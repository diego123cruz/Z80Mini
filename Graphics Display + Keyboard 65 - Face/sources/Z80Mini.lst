              	; --------------------------------------
              	; zasm: assemble "Z80Mini.asm"
              	; date: 2025-03-03 16:40:42
              	; --------------------------------------


              	;   Z80Mini Julho 2024
              	;   
              	;   ============== COMPILADOR ===================
              	;
              	;   Compilador (https://k1.spdns.de/Develop/Projects/zasm/Distributions/):
              	;
              	;       Win(CMD):           zasm.exe --z80 -w -u --bin  Z80Mini.asm
              	;       Win(Powershell):    ./zasm.exe --z80 -w -u --bin  Z80Mini.asm
              	;       Macos:              ./zasm --z80 -w -u --bin  Z80Mini.asm
              	;
              	;
              	;   =============== GRAVAÇÃO ====================
              	;
              	;     GRAVAÇÃO (32kb) (TL866 2 Plus - MacOS):
              	;	    minipro -p AT28C256 -w Z80Mini.rom -s	
              	;
              	;
              	;   =============== HARDWARE ====================
              	;         - CPU Z80@7.37280Mhz
              	;         - Lcd Grafico 128x64
              	;         - Keyboard 40 keys + Shift
              	;         - Rom 32k 0000h - 7FFFh
              	;         - Ram 32k 8000h - FFFFh
              	;         
              	;         - Ports:
              	;               - Keyboard: 40H
              	;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
              	;               - User IN/OUT: C0H
              	;               - Leds: 00H (Red B0-B3, Green B4-B7)
              	;
              	;
              	;   =============== LCD LIB ======================
              	;   ; Graphical LCD 128 x 64 Library
              	;   ------------------------------
              	;   By B. Chiha May-2023
              	;   https://github.com/bchiha/Z80_LCD_128x64_Graphics_Library/tree/
              	;
              	;
              	;
              	; -----------------------------------------------------------------------------
              	; PORTS
              	; -----------------------------------------------------------------------------
0070:         	LCDCTRL	    .EQU    70H
0071:         	LCDDATA     .EQU    71H
0040:         	KEY_IN      .EQU    40H
0040:         	KEY_OUT     .EQU    40H
0010:         	LEDS_ONBOARD .EQU   10H
              	
              	; -----------------------------------------------------------------------------
              	; KEYS MAP
              	; -----------------------------------------------------------------------------
00B4:         	KLEFT       .EQU    $B4             ; Key Left
00B7:         	KRIGHT      .EQU    $B7             ; Key Right
00B5:         	KUP         .EQU    $B5             ; Key Up
00B6:         	KDOWN       .EQU    $B6             ; Key Down
0080:         	KF1         .EQU    $80             ; Key F1
0081:         	KF2         .EQU    $81             ; Key F2
0082:         	KF3         .EQU    $82             ; Key F3
0083:         	KF4         .EQU    $83             ; Key F4
0084:         	KF5         .EQU    $84             ; Key F5
              	
              	; -----------------------------------------------------------------------------
              	; CONTROL KEYS
              	; -----------------------------------------------------------------------------
0003:         	CTRLC       .EQU    03H             ; Control "C"
0007:         	CTRLG       .EQU    07H             ; Control "G"
0008:         	BKSP        .EQU    08H             ; Back space
000A:         	LF          .EQU    0AH             ; Line feed
000B:         	VT          .equ    0BH             ; 
000C:         	CS          .EQU    0CH             ; Clear screen
000D:         	CR          .EQU    0DH             ; Carriage return [Enter]
000F:         	CTRLO       .EQU    0FH             ; Control "O"
0011:         	CTRLQ	    .EQU    11H		    ; Control "Q"
0012:         	CTRLR       .EQU    12H             ; Control "R"
0013:         	CTRLS       .EQU    13H             ; Control "S"
0015:         	CTRLU       .EQU    15H             ; Control "U"
001B:         	ESC         .EQU    1BH             ; Escape
007F:         	DEL         .EQU    7FH             ; Delete
              	
              	; -----------------------------------------------------------------------------
              	; H_Delay CONFIG
              	; -----------------------------------------------------------------------------
708000:         	kCPUClock:  .EQU 7372800       ;CPU clock speed in Hz
0024:         	kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
001A:         	kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
1CCC:         	kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
1CA8:         	kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
011A:         	kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop
              	
              	; -----------------------------------------------------------------------------
              	; SIO/2 - SERIAL
              	; -----------------------------------------------------------------------------
0000:         	SIOA_D		.EQU	$00
0002:         	SIOA_C		.EQU	$02
0001:         	SIOB_D		.EQU	$01 ; Não usado
0003:         	SIOB_C		.EQU	$03 ; Não usado
              	
              	; -----------------------------------------------------------------------------
              	; SYSTEM SETTINGS
              	; -----------------------------------------------------------------------------
FFF0:         	SYSTEM_SP:	.EQU 	$FFF0	;INITIAL STACK POINTER
              	
              	; -----------------------------------------------------------------------------
              	; I2C SETTINGS
              	; -----------------------------------------------------------------------------
00AE:         	I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
2710:         	TIMEOUT:    .EQU 10000          ;Timeout loop counter
              	
              	
0000:         	        .ORG 0
0000: F3      	RST00	DI
0001: C39001  	        JP  START_SYSTEM
              							
0004: FFFFFFFF	        .ORG     0008H
0008: C33502  	RST08   JP  LCD_PRINT_A
              	
000B: FFFFFFFF	        .ORG 0010H
000F: FF      	
0010: C3B710  	RST10   JP KEYREADINIT
              	
0013: FFFFFFFF	        .ORG 0018H ; check break
0017: FF      	
0018: C35E10  	RST18   JP CHKKEY
              	
001B: FFFFFFFF	RST20   .ORG 0020H
001F: FF      	
0020: C9      	        RET
              	
0021: FFFFFFFF	RST28   .ORG 0028H
0025: FFFFFF  	
0028: C9      	        RET
              	
0029: FFFFFFFF	        .ORG 0030H
002D: FFFFFF  	
0030: C9      	RST30   RET
              	
0031: FFFFFFFF	RST38   .ORG 0038H ; INT - MASKABLE INTERRUPT MODE-1
0035: FFFFFF  	
0038: ED4D    	        RETI
              	
003A: FFFFFFFF	RST66   .ORG 0066H ; NMI - Non­maskable Interrupt 
003E: FF...   	
0066: ED45    	        RETN
              	
              	
0068: 1B313233	line1 db ESC,"1234567890=",DEL
006C: 34353637	
0070: 3839303D	
0074: 7F      	
0075: 09717765	line2 db 09H,"qwertyuiop[]"
0079: 72747975	
007D: 696F705B	
0081: 5D      	
0082: 2D617364	line3 db "-asdfghjkl'",CR,CR
0086: 6667686A	
008A: 6B6C270D	
008E: 0D      	
008F: 002D7A78	line4 db 0,"-zxcvbnm,.",KUP,";"
0093: 6376626E	
0097: 6D2C2EB5	
009B: 3B      	
009C: 80818283	line5 db KF1,KF2,KF3,KF4,KF5,"  ",$5c,"-/",KLEFT,KDOWN,KRIGHT
00A0: 8420205C	
00A4: 2D2FB4B6	
00A8: B7      	
00A9: 1B214023	line1_shift db ESC,"!@#$%^&*()+",DEL
00AD: 24255E26	
00B1: 2A28292B	
00B5: 7F      	
00B6: 09515745	line2_shift db 09H,"QWERTYUIOP{}"
00BA: 52545955	
00BE: 494F507B	
00C2: 7D      	
00C3: 2D415344	line3_shift db "-ASDFGHJKL",$22,CR, CR
00C7: 4647484A	
00CB: 4B4C220D	
00CF: 0D      	
00D0: 002D5A58	line4_shift db 0,"-ZXCVBNM<>",KUP,":"
00D4: 4356424E	
00D8: 4D3C3EB5	
00DC: 3A      	
00DD: 80818283	line5_shift db KF1,KF2,KF3,KF4,KF5,"  |_?", KLEFT, KDOWN, KRIGHT
00E1: 8420207C	
00E5: 5F3FB4B6	
00E9: B7      	
              	
              	
00EA: FFFFFFFF	API     .ORG 0100H ; API POINTER
00EE: FF...   	
              	; **********************************************************************
              	; **  API - Public functions                                          **
              	; **********************************************************************
              	; LCD
0100: C38D02  	    JP INIT_LCD             ;Initalise the LCD
0103: C3A202  	    JP CLEAR_GBUF           ;Clear the Graphics Buffer
0106: C3B202  	    JP CLEAR_GR_LCD         ;Clear the Graphics LCD Screen
0109: C3D902  	    JP CLEAR_TXT_LCD        ;Clear the Text LCD Screen
010C: C3F002  	    JP SET_GR_MODE          ;Set Graphics Mode
010F: C3FA02  	    JP SET_TXT_MODE         ;Set Text Mode
0112: C3FF02  	    JP DRAW_BOX             ;Draw a rectangle between two points
0115: C33A03  	    JP DRAW_LINE            ;Draw a line between two points
0118: C3E503  	    JP DRAW_CIRCLE          ;Draw a circle from Mid X,Y to Radius
011B: C3BA04  	    JP DRAW_PIXEL           ;Draw one pixel at X,Y
011E: C32A03  	    JP FILL_BOX             ;Draw a filled rectangle between two points
0121: C3AC04  	    JP FILL_CIRCLE          ;Draw a filled circle from Mid X,Y to Radius
0124: C30D05  	    JP PLOT_TO_LCD          ;Display the Graphics Buffer to the LCD Screen
0127: C33F05  	    JP PRINT_STRING         ;Print Text on the screen in a given row
012A: C36105  	    JP PRINT_CHARS          ;Print Characters on the screen in a given row and column
012D: C38005  	    JP DELAY_US             ;Microsecond delay for LCD updates
0130: C38305  	    JP DELAY_MS             ;Millisecond delay for LCD updates
0133: C38905  	    JP SET_BUF_CLEAR        ;Clear the Graphics buffer on after Plotting to the screen
0136: C39105  	    JP SET_BUF_NO_CLEAR     ;Retain the Graphics buffer on after Plotting to the screen
0139: C3CB04  	    JP CLEAR_PIXEL          ;Remove a Pixel at X,Y
013C: C3DD04  	    JP FLIP_PIXEL           ;Flip a Pixel On/Off at X,Y
013F: C37907  	    JP LCD_INST             ;Send a parallel or serial instruction to LCD
0142: C37E07  	    JP LCD_DATA             ;Send a parallel or serial datum to LCD
0145: C39107  	    JP SER_SYNC             ;Send serial synchronise byte to LCD
0148: C31D07  	    JP DRAW_GRAPHIC         ;Draw an ASCII charcter or Sprite to the LCD
014B: C31507  	    JP INV_GRAPHIC          ;Inverse graphics printing
014E: C39605  	    JP INIT_TERMINAL        ;Initialize the LCD for terminal emulation
0151: C3AA05  	    JP SEND_CHAR_TO_GLCD    ;Send an ASCII Character to the LCD
0154: C31906  	    JP SEND_STRING_TO_GLCD  ;Send an ASCII String to the LCD
0157: C33206  	    JP SEND_A_TO_GLCD       ;Send register A to the LCD
015A: C34F06  	    JP SEND_HL_TO_GLCD      ;Send register HL to the LCD
015D: C35B06  	    JP SET_CURSOR           ;Set the graphics cursor
0160: C30C07  	    JP GET_CURSOR           ;Get the current cursor
0163: C31107  	    JP DISPLAY_CURSOR       ;Set Cursor on or off
              	; I2C Board
0166: C3B30D  	    JP I2C_Open              ;Start i2c (Device address in A)
0169: C3BA0D  	    JP I2C_Close             ;Close i2c 
016C: C3FA0D  	    JP I2C_Read              ;I2C Read
016F: C3BD0D  	    JP I2C_Write             ;I2C Write
              	; SERIAL Soft
0172: C36B0F  	    JP TXDATA               ; OUTPUT A CHARACTER TO THE TERMINAL, Char in A
0175: C37E0F  	    JP RXDATA               ; INPUT A CHARACTER FROM THE TERMINAL, Char in A
0178: C35D0F  	    JP SNDSTR               ; SEND AN ASCII STRING OUT THE SERIAL PORT (Max 128 chars), HL = POINTER TO 00H TERMINATED STRING
017B: C38A0F  	    JP INTELLOADER          ; Start load intel hex
              	; KEYBOARD
017E: C3B710  	    JP KEYREADINIT          ;Input character KeyboardOnboard (Char in A), loop until release key
0181: C37710  	    JP KEYREAD              ;Input character KeyboardOnboard (Char in A), WITHOUT loop until release key
0184: C35E10  	    JP CHKKEY               ;Check BK press
              	; UTIL
0187: C3AE11  	    JP H_Delay              ;Delay in milliseconds (DE in millis)
018A: C3D811  	    JP LED_RED              ;Half byte in A (4 bits)
018D: C3E711  	    JP LED_GREEN            ;Half byte in A (4 bits)
              	
              	
0190:         	START_SYSTEM:
              	    ; init RAM
0190: AF      	    XOR A
0191: 329DFB  	    LD (LED_ONBOARD), A
0194: 329EFB  	    LD (BDEL), A
0197:         	RESET_WARM:
              	    ; Set stack pointer
0197: 31F0FF  	    LD SP, SYSTEM_SP
              	
019A: 116400  	    LD DE, $0064 ; 100ms
019D: CDAE11  	    CALL H_Delay
              	
              	    ; Init serial
01A0: CD260F  	    CALL INIT_SERIAL
              	
              	    ; Init LCD
01A3: CD9605  	    CALL INIT_TERMINAL
01A6: CDF002  	    CALL SET_GR_MODE
01A9: CD9105  	    CALL SET_BUF_NO_CLEAR
              	
              	    ; Show init string
01AC: 010000  	    LD BC, $0000
01AF: CD5B06  	    CALL SET_CURSOR
01B2: 11E816  	    LD DE, WELLCOME_LCD
              	    ; set cursor ON
01B5: 3E00    	    LD A, 0
01B7: 3294FB  	    LD (CURSOR_ON), A
              	    ; send cursor
01BA: 3E00    	    LD A, 0
01BC: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
              	
01BF:         	LOOP_MONITOR:
01BF: CDB710  	    CALL KEYREADINIT
              	
01C2: FE48    	    CP 'H'
01C4: CC2112  	    CALL Z, SHOW_MENU
              	
01C7: FE80    	    CP KF1
01C9: CA0080  	    JP Z, $8000
              	
01CC: FE81    	    CP KF2
01CE: CA8A0F  	    JP Z, INTELLOADER
              	
01D1: FE42    	    CP 'B'
01D3: CABF12  	    JP Z, START_BASIC
              	
01D6: FE47    	    CP 'G'
01D8: CCDF12  	    CALL Z, GOJUMP
              	
01DB: FE4D    	    CP 'M'
01DD: CC0713  	    CALL Z, MODIFY
              	
01E0: FE44    	    CP 'D'
01E2: CC5F13  	    CALL Z, DSPLAY
              	
01E5: FE4F    	    CP 'O'
01E7: CCDD13  	    CALL Z, OUTPORT
              	
01EA: FE49    	    CP 'I'
01EC: CCF613  	    CALL Z, INPORT_MON
              	
01EF: FE31    	    CP '1'
01F1: CC730E  	    CALL Z, I2CLIST
              	
01F4: FE32    	    CP '2'
01F6: CC1A15  	    CALL Z, I2CCPUTOMEM
              	
01F9: FE33    	    CP '3'
01FB: CCBB15  	    CALL Z, I2CMEMTOCPU
              	
01FE: FE34    	    CP '4'
0200: CCF015  	    CALL Z, I2C_WR_DD
              	
0203: FE35    	    CP '5'
0205: CC1116  	    CALL Z, I2C_WR_RR_DD
              	
0208: FE36    	    CP '6'
020A: CC3B16  	    CALL Z, I2C_RD
              	
020D: FE37    	    CP '7'
020F: CC6A16  	    CALL Z, I2C_RD_RR
              	
0212: FE38    	    CP '8'
0214: CC1014  	    CALL Z, READ_MEM_FILES
              	
0217: CDAA05  	    CALL SEND_CHAR_TO_GLCD
              	
021A: C3BF01  	    JP  LOOP_MONITOR
              	
021D:         	BASIC:
021D: C30060  	    JP $6000
0220:         	BASIC_W:
0220: C30360  	    JP $6003
              	
              	
              	#include "LCD.asm"
              	; Graphical LCD 128 x 64 Library
              	; ------------------------------
              	; By B. Chiha May-2023
              	;
              	; This is a native Z80 Graphics library to be used with 128x64 Graphical LCD Screens
              	;
              	; There are a few variants of these LCD screens, but they must all must use the ST7920
              	; LCD Controller.  The LCD Screen that I used is the QC12864B.  This screen has two
              	; ST7921 Panels (128 x 32) stacked one above the other.  Other LCD boards might not do
              	; this.  If so the PLOT_TO_LCD function will need to be modified. (future work)
              	;
              	; These screens have DDRAM (Graphics) and CGRAM (Text) areas.  Both RAM areas can 
              	; be displayed at the same time.
              	;
              	; The Pinout for the QC12864B board is as follows:
              	;
              	; Pin	Name	Desc                    Serial  Parallel
              	; ---   ----    -------------           ------  -------------
              	; 1     VSS     Ground                  GND     GND
              	; 2     VDD     Power                   5v      5v
              	; 3     V0      Contrast                N/A     N/A
              	; 4     D/I     IR/DR (CS)              5v      A7
              	; 5     R/W     R/W (SID)               D0      RD (inverted)
              	; 6     E       Enable (SCLK)           D1      Port 7 (inverted)
              	; 7     DB0     Data                    N/A     D0
              	; 8     DB1     Data                    N/A     D1
              	; 9     DB2     Data                    N/A     D2
              	; 10    DB3     Data                    N/A     D3
              	; 11    DB4     Data                    N/A     D4
              	; 12    DB5     Data                    N/A     D5
              	; 13    DB6     Data                    N/A     D6
              	; 14    DB7     Data                    N/A     D7
              	; 15    PSB     Serial/Para             GND     5v
              	; 16    NC
              	; 17    RST     Reset                   RST     RST
              	; 18    VEE     LCD Drive               N/A     N/A
              	; 19    A       Backlight               5v/NC   5v/NC
              	; 20    K       Backlight               GND/NC  GND/NC
              	;
              	;
              	;        ORG 2000H               ;Start location
              	        
              	; Modifiable values.  Thse three values can be modified to suit your own set up
              	; LCD_IR and LCD_DR are the output ports to send an Instruction or Data value.
              	; V_DELAY_US is the minimum delay needed for a command to be processed by the
              	; LCD board.  If only some of the data is being sent, make this value larger
              	        
              	;Port 7 on TEC is connected to LCD Enable (Pin 6)
              	;A7 is connected to Register select (Pin 4).  (A7=0 for Instruction, A7=1 for Data)
0070:         	LCD_IR:	EQU 70H         ;Instruction Register
0071:         	LCD_DR:	EQU 71H         ;Data Register (A7)
0000:         	LCD_SER: EQU 00H        ;Serial Port if used
0010:         	V_DELAY_US: EQU $0010   ;Delay for 76us on your system $0004
              	
              	;Serial or Parallel communications to the LCD Screen.  Comment one of 
              	;the labels below based on the LCD connections. 00H = FALSE, 01H = TRUE
              	;COMMS_MODE: EQU 00H     ;Using PARALLEL Data connection
              	;COMMS_MODE: EQU 01H     ;Using SERIAL Data connection
              	
              	; Dont need to modify anything else below.
00F8:         	SER_BT: EQU 11111000B           ;Serial Synchronisation Byte
00B5:         	UP:     EQU $B5                 ; Up Arrow, change Z80 Mini
00B6:         	DN:     EQU $B6                 ; Down Arrow, change Z80Mini
0008:         	BKSP:   EQU 08H                 ; Back space 08H
0009:         	TAB:    EQU 09H                 ; Horizontal TAB
000A:         	LF:     EQU 0AH                 ; Line feed
000C:         	CS:     EQU 0CH                 ; Clear screen
000D:         	CR:     EQU 0DH                 ; Carriage return
0020:         	SPACE:  EQU 20H                 ; Space
008F:         	CURSOR: EQU 8FH                 ; Cursor
              	
              	
              	;-----------------
              	; NEW LINE
              	;-----------------
0223:         	LCD_CR:
0223: 3E0D    		LD A, CR
0225: CD3502  		CALL LCD_PRINT_A
0228: C9      		RET
              	
              	;-----------------
              	; SPACE
              	;-----------------
0229:         	LCD_SPACE:
0229: 3E20    		LD A, SPACE
022B: CD3502  		CALL LCD_PRINT_A
022E: C9      		RET
              	
              	;-----------------
              	; Claer screen - reset terminal
              	;-----------------
022F:         	LCD_CLEAR:
022F: 3E0C    	        LD A, CS
0231: CD3502  	        CALL LCD_PRINT_A
0234: C9      	        RET
              	
              	;-----------------
              	; LCD_PRINT_A
              	; Destroy only AF
              	;-----------------
0235:         	LCD_PRINT_A:
0235: F5      	        PUSH AF
0236: C5      		PUSH BC
0237: D5      	        PUSH DE
0238: E5      	        PUSH HL
              	        
              	        ; check delete (MSBasic)
0239: F5      	        PUSH AF
023A: 3A9EFB  	        LD A, (BDEL)
023D: B7      	        or a
023E: FEFF    	        CP $FF
0240: CC5902  	        call z, DELETE_CHAR
0243: F1      	        POP AF
0244: B7      	        or a
0245: FE00    	        CP $0
0247: 2008    	        jr nz, LCD_PRINT_A_OK
0249: 3EFF    	        LD A, $FF ; delete proximo char
024B: 329EFB  	        LD (BDEL), A
024E: C35402  	        jp LCD_PRINT_A_FIM
0251:         	LCD_PRINT_A_OK:
0251: CDAA05  		CALL SEND_CHAR_TO_GLCD
0254:         	LCD_PRINT_A_FIM:
0254: E1      	        POP HL
0255: D1      	        POP DE
0256: C1      	        POP BC 
0257: F1      	        POP AF
0258: C9      		RET
              	
0259:         	DELETE_CHAR:
0259: F1      	        POP AF ; AF
025A: E1      	        POP HL ; CALL
025B: AF      	        XOR A
025C: 329EFB  	        LD (BDEL), A
              	        
025F: 3E7F    	        LD A, DEL ; delete char
0261: C35102  	        JP LCD_PRINT_A_OK
              	
              	
              	;-----------------
              	; LCD_PRINT_STRING
              	; Entry: HL
              	; String terminada com 0
              	;-----------------
0264:         	LCD_PRINT_STRING:
0264: F5      	        PUSH AF
0265: C5      		PUSH BC
0266: D5      	        PUSH DE
0267: E5      	        PUSH HL
0268: 3E00    	        LD A, 0 ; terminador da string..
026A: 545D    	        LD DE, HL
026C: CD1906  		CALL SEND_STRING_TO_GLCD
026F: E1      	        POP HL
0270: D1      	        POP DE
0271: C1      	        POP BC 
0272: F1      	        POP AF
0273: C9      		RET
              	
              	
              	;-----------------
              	; LCD_IMAGE_128x64 - Print image 128x64, CURSOR 0,0
              	; Entry: HL
              	;-----------------
0274:         	LCD_IMAGE_128x64: 
0274: F5      	        PUSH AF
0275: C5      		PUSH BC
0276: D5      	        PUSH DE
0277: E5      	        PUSH HL
0278: 010000  	        LD BC, $0000
027B: CD5B06  	        CALL SET_CURSOR
027E: 0680    	        LD B, 128
0280: 0E40    	        LD C, 64
0282: CD3007  		CALL PLOT_GRAPHIC
0285: CD0D05  	        CALL PLOT_TO_LCD
0288: E1      	        POP HL
0289: D1      	        POP DE
028A: C1      	        POP BC 
028B: F1      	        POP AF
028C: C9      		RET
              	
              	
              	
              	; Initialise LCD
028D:         	INIT_LCD:
028D: 21A907  	        LD HL, INIT_BASIC       ;POINT HL TO LCD INITIALIZE TABLE
0290: 0606    	        LD B, 06H               ;B=4 BYTES
0292:         	NEXT_CMD:
0292: 7E      	        LD A, (HL)
0293: CD7907  	        CALL LCD_INST
0296: 23      	        INC HL
0297: 10F9    	        DJNZ NEXT_CMD
0299: 118002  	        LD DE, $0280            ;1.6 ms $0140@4Mhz
029C: CD8305  	        CALL DELAY_MS
              	        
029F: CDB202  	        CALL CLEAR_GR_LCD
              	        
              	; Clears the Graphics Memory Buffer
02A2:         	CLEAR_GBUF:
02A2: 2A80FB  	        LD HL, (VPORT)
02A5: ED5B80FB	        LD DE, (VPORT)
02A9: 13      	        INC DE
02AA: AF      	        XOR A
02AB: 77      	        LD (HL), A
02AC: 01FF03  	        LD BC, 03FFH
02AF: EDB0    	        LDIR
02B1: C9      	        RET
              	        
              	; Clears the Graphics LCD Buffer
02B2:         	CLEAR_GR_LCD:
02B2: CDF002  	        CALL SET_GR_MODE
02B5: 0E00    	        LD C, 00H
02B7:         	CLR_X:
02B7: 3E80    	        LD A, 80H
02B9: B1      	        OR C
02BA: CD7907  	        CALL LCD_INST
02BD: 3E80    	        LD A, 80H
02BF: CD7907  	        CALL LCD_INST
02C2: 3E02    	        LD A, 02H 
02C4: CD9107  	        CALL SER_SYNC           ;Data Block Sync
02C7: AF      	        XOR A                   ;Clear Byte
02C8: 0610    	        LD B, 10H
02CA:         	CLR_Y:
02CA: CD7E07  	        CALL LCD_DATA
02CD: CD7E07  	        CALL LCD_DATA
02D0: 10F8    	        DJNZ CLR_Y
02D2: 0C      	        INC C
02D3: 79      	        LD A, C
02D4: FE20    	        CP 20H
02D6: 20DF    	        JR NZ, CLR_X        
02D8: C9      	        RET
              	
              	; Clears the ASCII Text LCD
02D9:         	CLEAR_TXT_LCD:
02D9: CDFA02  	        CALL SET_TXT_MODE
02DC: 3E80    	        LD A, 80H
02DE: CD7907  	        CALL LCD_INST
02E1: 3E02    	        LD A, 02H 
02E3: CD9107  	        CALL SER_SYNC           ;Data Block Sync
02E6: 0640    	        LD B, 40H
02E8:         	CLR_ROWS:
02E8: 3E20    	        LD A,  " "
02EA: CD7E07  	        CALL LCD_DATA
02ED: 10F9    	        DJNZ CLR_ROWS
02EF: C9      	        RET
              	        
              	; Set Graphics Mode
02F0:         	SET_GR_MODE:
02F0: 3E34    	        LD A, 34H
02F2: CD7907  	        CALL LCD_INST
02F5: 3E36    	        LD A, 36H
02F7: C37907  	        JP LCD_INST
              	        
              	; Set Text Mode
02FA:         	SET_TXT_MODE:
02FA: 3E30    	        LD A, 30H
02FC: C37907  	        JP LCD_INST
              	        
              	;Draw Box
              	;Inputs: BC = X0,Y0
              	;        DE = X1,Y1
              	;Destroys: HL
02FF:         	DRAW_BOX:
02FF: C5      	        PUSH BC
0300:         	GTOP:
0300: CDBA04  	        CALL DRAW_PIXEL
0303: 7A      	        LD A, D
0304: 04      	        INC B
0305: B8      	        CP B
0306: 30F8    	        JR NC, GTOP
0308: C1      	        POP BC
              	        
0309: C5      	        PUSH BC
030A: 4B      	        LD C, E
030B:         	GBOTTOM:
030B: CDBA04  	        CALL DRAW_PIXEL
030E: 7A      	        LD A, D
030F: 04      	        INC B
0310: B8      	        CP B
0311: 30F8    	        JR NC, GBOTTOM
0313: C1      	        POP BC
              	        
0314: C5      	        PUSH BC
0315:         	GLEFT:
0315: CDBA04  	        CALL DRAW_PIXEL
0318: 7B      	        LD A, E
0319: 0C      	        INC C
031A: B9      	        CP C
031B: 30F8    	        JR NC, GLEFT
031D: C1      	        POP BC
              	        
031E: C5      	        PUSH BC
031F: 42      	        LD B, D
0320:         	GRIGHT:
0320: CDBA04  	        CALL DRAW_PIXEL
0323: 7B      	        LD A, E
0324: 0C      	        INC C
0325: B9      	        CP C
0326: 30F8    	        JR NC, GRIGHT
0328: C1      	        POP BC
0329: C9      	        RET
              	        
              	;Fill Box
              	;Draws vertical lines from X0,Y0 to X0,Y1 and increase X0 to X1 until X0=X1
              	;Inputs: BC = X0,Y0
              	;        DE = X1,Y1
              	;Destroys: HL
032A:         	FILL_BOX:
032A: C5      	        PUSH BC
032B:         	NEXT_PIXEL:
032B: CDBA04  	        CALL DRAW_PIXEL
032E: 7B      	        LD A, E
032F: 0C      	        INC C
0330: B9      	        CP C
0331: 30F8    	        JR NC, NEXT_PIXEL
0333: C1      	        POP BC
0334: 7A      	        LD A, D
0335: 04      	        INC B
0336: B8      	        CP B
0337: 30F1    	        JR NC, FILL_BOX
0339: C9      	        RET
              	        
              	;Draw a line between two points using Bresenham Line Algorithm
              	; void plotLine(int x0, int y0, int x1, int y1)
              	; {
              	;    int dx =  abs(x1-x0), sx = x0<x1 ? 1 : -1;
              	;    int dy = -abs(y1-y0), sy = y0<y1 ? 1 : -1;
              	;    int err = dx+dy, e2; /* error value e_xy */
              	        
              	;    for(;;){  /* loop */
              	;       setPixel(x0,y0);
              	;       if (x0==x1 && y0==y1) break;
              	;       e2 = 2*err;
              	;       if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
              	;       if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
              	;    }
              	; }
              	;Inputs: BC = X0,Y0
              	;        DE = X1,Y1
033A:         	DRAW_LINE:
              	;check that points are in range
033A: 79      	        LD A, C
033B: FE40    	        CP 40H
033D: D0      	        RET NC
033E: 78      	        LD A, B
033F: FE80    	        CP 80H
0341: D0      	        RET NC
0342: 7B      	        LD A, E
0343: FE40    	        CP 40H
0345: D0      	        RET NC
0346: 7A      	        LD A, D
0347: FE80    	        CP 80H
0349: D0      	        RET NC
              	        
              	;sx = x0<x1 ? 1 : -1
034A: 2601    	        LD H, 01H
034C: 78      	        LD A, B
034D: BA      	        CP D
034E: 3802    	        JR C, $ + 4
0350: 26FF    	        LD H, 0FFH
0352: 7C      	        LD A, H
0353: 3286FB  	        LD (SX), A
              	        
              	;sy = y0<y1 ? 1 : -1
0356: 2601    	        LD H, 01H
0358: 79      	        LD A, C
0359: BB      	        CP E
035A: 3802    	        JR C, $ + 4
035C: 26FF    	        LD H, 0FFH
035E: 7C      	        LD A, H
035F: 3287FB  	        LD (SY), A
              	        
0362: ED5384FB	        ld (ENDPT), DE
              	        
              	;dx =  abs(x1-x0)
0366: C5      	        PUSH BC
0367: 6A      	        LD L, D
0368: 2600    	        LD H, 0
036A: 48      	        LD C, B
036B: 0600    	        LD B, 0
036D: B7      	        OR A
036E: ED42    	        SBC HL, BC
0370: CDDB03  	        CALL ABSHL
0373: 2288FB  	        LD (DX), HL
0376: C1      	        POP BC
              	        
              	;dy = -abs(y1-y0)
0377: C5      	        PUSH BC
0378: 6B      	        LD L, E
0379: 2600    	        LD H, 0
037B: 0600    	        LD B, 0
037D: B7      	        OR A
037E: ED42    	        SBC HL, BC
0380: CDDB03  	        CALL ABSHL
0383: AF      	        XOR A
0384: 95      	        SUB L
0385: 6F      	        LD L, A
0386: 9F      	        SBC A, A
0387: 94      	        SUB H
0388: 67      	        LD H, A
0389: 228AFB  	        LD (DY), HL
038C: C1      	        POP BC
              	        
              	;err = dx+dy,
038D: ED5B88FB	        LD DE, (DX)
0391: 19      	        ADD HL, DE
0392: 228CFB  	        LD (ERR), HL
              	        
0395:         	LINE_LOOP:
              	;setPixel(x0,y0)
0395: CDBA04  	        CALL DRAW_PIXEL
              	        
              	;if (x0==x1 && y0==y1) break;
0398: 3A85FB  	        LD A, (ENDPT + 1)
039B: B8      	        CP B
039C: 2005    	        JR NZ, $ + 7
039E: 3A84FB  	        LD A, (ENDPT)
03A1: B9      	        CP C
03A2: C8      	        RET Z
              	        
              	;e2 = 2*err;
03A3: 2A8CFB  	        LD HL, (ERR)
03A6: 29      	        ADD HL, HL              ;E2
              	        
              	;if (e2 >= dy)  err += dy; x0 += sx;
03A7: ED5B8AFB	        LD DE, (DY)
03AB: B7      	        OR A
03AC: ED52    	        SBC HL, DE
03AE: 19      	        ADD HL, DE
03AF: FAC003  	        JP M, LL2
              	        
03B2: E5      	        PUSH HL
03B3: 2A8CFB  	        LD HL, (ERR)
03B6: 19      	        ADD HL, DE
03B7: 228CFB  	        LD (ERR), HL
03BA: 3A86FB  	        LD A, (SX)
03BD: 80      	        ADD A, B
03BE: 47      	        LD B, A
03BF: E1      	        POP HL
              	        
03C0:         	LL2:
              	;if (e2 <= dx)  err += dx; y0 += sy;
03C0: ED5B88FB	        LD DE, (DX)
03C4: B7      	        OR A
03C5: ED52    	        SBC HL, DE
03C7: 19      	        ADD HL, DE
03C8: 2803    	        JR Z, LL3
03CA: F29503  	        JP P, LINE_LOOP
03CD:         	LL3:
03CD: 2A8CFB  	        LD HL, (ERR)
03D0: 19      	        ADD HL, DE
03D1: 228CFB  	        LD (ERR), HL
03D4: 3A87FB  	        LD A, (SY)
03D7: 81      	        ADD A, C
03D8: 4F      	        LD C, A
              	        
03D9: 18BA    	        JR LINE_LOOP
              	        
03DB:         	ABSHL:
03DB: CB7C    	        BIT 7, H
03DD: C8      	        RET Z
03DE: AF      	        XOR A
03DF: 95      	        SUB L
03E0: 6F      	        LD L, A
03E1: 9F      	        SBC A, A
03E2: 94      	        SUB H
03E3: 67      	        LD H, A
03E4: C9      	        RET
              	        
              	;Draw a circle from a midpoint to a radius using Bresenham Line Algorithm
              	; void plotCircle(int xm, int ym, int r)
              	; {
              	;    int x = -r, y = 0, err = 2-2*r, i = 0; /* II. Quadrant */
              	;    printf("Midpoint = (%X,%X), Radius = %X\n", xm, ym, r);
              	;    do {
              	;       printf("(%X,%X) ", xm-x, ym+y); /*   I. Quadrant */
              	;       printf("(%X,%X) ", xm-y, ym-x); /*  II. Quadrant */
              	;       printf("(%X,%X) ", xm+x, ym-y); /* III. Quadrant */
              	;       printf("(%X,%X) ", xm+y, ym+x); /*  IV. Quadrant */
              	;       r = err;
              	;       if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
              	;       if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
              	;       printf("x = %d, r = %d, y = %d, err =%d\n", x, r, y, err);
              	;    } while (x < 0);
              	; }
              	;Inputs BC = xm,ym (Midpoint)
              	;       E = radius
03E5:         	DRAW_CIRCLE:
              	;   int x = -r, err = 2-2*r; /* II. Quadrant */
03E5: AF      	        XOR A
03E6: 93      	        SUB E
03E7: 3286FB  	        LD (SX), A              ;x
              	;   y = 0
03EA: AF      	        XOR A
03EB: 3287FB  	        LD (SY), A              ;y
              	;   RAD = r
03EE: 1600    	        LD D, 00H
03F0: 7B      	        LD A, E
03F1: ED538EFB	        LD (RAD), DE            ;r
              	;   err = 2-2*r
03F5: EB      	        EX DE, HL
03F6: 29      	        ADD HL, HL
03F7: EB      	        EX DE, HL
03F8: 210200  	        LD HL, 0002H
03FB: B7      	        OR A
03FC: ED52    	        SBC HL, DE              ;err
03FE: 228CFB  	        LD (ERR), HL
              	        
0401:         	CIRCLE_LOOP:
              	;       setPixel(xm-x, ym+y); /*   I. Quadrant */
0401: C5      	        PUSH BC
0402: 3A86FB  	        LD A, (SX)
0405: ED44    	        NEG
0407: 80      	        ADD A, B
0408: 47      	        LD B, A
0409: 3A87FB  	        LD A, (SY)
040C: 81      	        ADD A, C
040D: 4F      	        LD C, A
040E: CDBA04  	        CALL DRAW_PIXEL
0411: C1      	        POP BC
              	;       setPixel(xm+x, ym-y); /* III. Quadrant */
0412: C5      	        PUSH BC
0413: 3A86FB  	        LD A, (SX)
0416: 80      	        ADD A, B
0417: 47      	        LD B, A
0418: 3A87FB  	        LD A, (SY)
041B: ED44    	        NEG
041D: 81      	        ADD A, C
041E: 4F      	        LD C, A
041F: CDBA04  	        CALL DRAW_PIXEL
0422: C1      	        POP BC
              	;       setPixel(xm-y, ym-x); /*  II. Quadrant */
0423: C5      	        PUSH BC
0424: 3A87FB  	        LD A, (SY)
0427: ED44    	        NEG
0429: 80      	        ADD A, B
042A: 47      	        LD B, A
042B: 3A86FB  	        LD A, (SX)
042E: ED44    	        NEG
0430: 81      	        ADD A, C
0431: 4F      	        LD C, A
0432: CDBA04  	        CALL DRAW_PIXEL
0435: C1      	        POP BC
              	;       setPixel(xm+y, ym+x); /*  IV. Quadrant */
0436: C5      	        PUSH BC
0437: 3A87FB  	        LD A, (SY)
043A: 80      	        ADD A, B
043B: 47      	        LD B, A
043C: 3A86FB  	        LD A, (SX)
043F: 81      	        ADD A, C
0440: 4F      	        LD C, A
0441: CDBA04  	        CALL DRAW_PIXEL
0444: C1      	        POP BC
              	;       r = err;
0445: 2A8CFB  	        LD HL, (ERR)
0448: 228EFB  	        LD (RAD), HL
              	;       if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
044B: 3A87FB  	        LD A, (SY)
044E: 5F      	        LD E, A
044F: 1600    	        LD D, 0
0451: B7      	        OR A
0452: ED52    	        SBC HL, DE
0454: 19      	        ADD HL, DE
0455: 2803    	        JR Z, $ + 5
0457: F26D04  	        JP P, DS1
045A: 3A87FB  	        LD A, (SY)
045D: 3C      	        INC A
045E: 3287FB  	        LD (SY), A
0461: 87      	        ADD A, A
0462: 3C      	        INC A
0463: 5F      	        LD E, A
0464: 1600    	        LD D, 0
0466: 2A8CFB  	        LD HL, (ERR)
0469: 19      	        ADD HL, DE
046A: 228CFB  	        LD (ERR), HL
              	;       if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
046D:         	DS1:
046D: 2A8EFB  	        LD HL, (RAD)
0470: 3A86FB  	        LD A, (SX)
0473: 16FF    	        LD D, 0FFH
0475: 5F      	        LD E, A
0476: B7      	        OR A
0477: ED52    	        SBC HL, DE
0479: 19      	        ADD HL, DE
047A: 2803    	        JR Z, $ + 5
047C: F29104  	        JP P, DS2
047F: 2A8CFB  	        LD HL, (ERR)
0482: 3A87FB  	        LD A, (SY)
0485: 1600    	        LD D, 0
0487: 5F      	        LD E, A
0488: B7      	        OR A
0489: ED52    	        SBC HL, DE
048B: 19      	        ADD HL, DE
048C: 2816    	        JR Z, DS3
048E: FAA404  	        JP M, DS3
0491:         	DS2:
0491: 3A86FB  	        LD A, (SX)
0494: 3C      	        INC A
0495: 3286FB  	        LD (SX), A
0498: 87      	        ADD A, A
0499: 3C      	        INC A
049A: 5F      	        LD E, A
049B: 16FF    	        LD D, 0FFH
049D: 2A8CFB  	        LD HL, (ERR)
04A0: 19      	        ADD HL, DE
04A1: 228CFB  	        LD (ERR), HL
              	;   } while (x < 0);
04A4:         	DS3:
04A4: 3A86FB  	        LD A, (SX)
04A7: B7      	        OR A
04A8: C20104  	        JP NZ, CIRCLE_LOOP
04AB: C9      	        RET
              	        
              	;Fill Circle
              	;Fills a circle by increasing radius until Radius = Original Radius E
              	;Inputs BC = xm,ym (Midpoint)
              	;       E = radius
04AC:         	FILL_CIRCLE:
04AC: 1601    	        LD D, 01H               ;Start radius
04AE:         	NEXT_CIRCLE:
04AE: D5      	        PUSH DE                 ;Save end Radius
04AF: 5A      	        LD E, D
04B0: CDE503  	        CALL DRAW_CIRCLE
04B3: D1      	        POP DE                  ;Restore Radius
04B4: 7B      	        LD A, E
04B5: 14      	        INC D
04B6: BA      	        CP D
04B7: 30F5    	        JR NC, NEXT_CIRCLE
04B9: C9      	        RET
              	        
              	;Draw Pixel in position X Y
              	;Input B = column/X (0-127), C = row/Y (0-63)
              	;destroys HL
04BA:         	DRAW_PIXEL:
04BA: 79      	        LD A, C
04BB: FE40    	        CP 40H
04BD: D0      	        RET NC
04BE: 78      	        LD A, B
04BF: FE80    	        CP 80H
04C1: D0      	        RET NC
              	        
04C2: D5      	        PUSH DE
04C3: CDEE04  	        CALL SET_GBUF
              	
04C6: 7A      	        LD A, D
04C7: B6      	        OR (HL)
04C8: 77      	        LD (HL), A
04C9: D1      	        POP DE
04CA: C9      	        RET
              	
              	;Clear Pixel in position X Y
              	;Input B = column/X (0-127), C = row/Y (0-63)
              	;destroys HL
04CB:         	CLEAR_PIXEL:
04CB: 79      	        LD A, C
04CC: FE40    	        CP 40H
04CE: D0      	        RET NC
04CF: 78      	        LD A, B
04D0: FE80    	        CP 80H
04D2: D0      	        RET NC
              	        
04D3: D5      	        PUSH DE
04D4: CDEE04  	        CALL SET_GBUF
              	
04D7: 7A      	        LD A, D
04D8: 2F      	        CPL
04D9: A6      	        AND (HL)
04DA: 77      	        LD (HL), A
04DB: D1      	        POP DE
04DC: C9      	        RET
              	
              	;Flip Pixel in position X Y
              	;Input B = column/X (0-127), C = row/Y (0-63)
              	;destroys HL
04DD:         	FLIP_PIXEL:
04DD: 79      	        LD A, C
04DE: FE40    	        CP 40H
04E0: D0      	        RET NC
04E1: 78      	        LD A, B
04E2: FE80    	        CP 80H
04E4: D0      	        RET NC
              	        
04E5: D5      	        PUSH DE
04E6: CDEE04  	        CALL SET_GBUF
              	
04E9: 7A      	        LD A, D
04EA: AE      	        XOR (HL)
04EB: 77      	        LD (HL), A
04EC: D1      	        POP DE
04ED: C9      	        RET
              	
              	;Helper routine to set HL to the correct GBUF address given X and Y
              	;Input B = column/X (0-127), C = row/Y (0-63)
              	;Output HL = address of GBUF X,Y byte, D = Byte with Pixel Bit Set
              	;Destroys E
04EE:         	SET_GBUF:
04EE: 69      	        LD L, C
04EF: 2600    	        LD H, 00H
04F1: 29      	        ADD HL, HL
04F2: 29      	        ADD HL, HL
04F3: 29      	        ADD HL, HL
04F4: 29      	        ADD HL, HL
04F5: ED5B80FB	        LD DE, (VPORT)
04F9: 1B      	        DEC DE
04FA: 19      	        ADD HL, DE
              	        
04FB: 78      	        LD A, B
04FC: 1608    	        LD D, 08H
04FE:         	BASE_COL:
04FE: 23      	        INC HL
04FF: 92      	        SUB D
0500: 30FC    	        JR NC, BASE_COL
              	        
0502: 2F      	        CPL
0503: 1601    	        LD D, 01H
0505: B7      	        OR A
0506: C8      	        RET Z
0507:         	SHIFT_BIT:
0507: CB22    	        SLA D
0509: 3D      	        DEC A
050A: 20FB    	        JR NZ, SHIFT_BIT
050C: C9      	        RET
              	
              	;Main draw routine.  Moves GBUF to LCD and clears buffer
              	;Destroys all
050D:         	PLOT_TO_LCD:
050D: 2A80FB  	        LD HL, (VPORT)
0510: 0E80    	        LD C, 80H
0512:         	PLOT_ROW:
0512: 79      	        LD A, C
0513: E69F    	        AND 9FH
0515: CD7907  	        CALL LCD_INST           ;Vertical
0518: 3E80    	        LD A, 80H
051A: CB69    	        BIT 5, C
051C: 2802    	        JR Z, $ + 4
051E: F608    	        OR 08H
0520: CD7907  	        CALL LCD_INST           ;Horizontal
0523: 3E02    	        LD A, 02H 
0525: CD9107  	        CALL SER_SYNC           ;Data Block Sync
0528: 0610    	        LD B, 10H               ;send eight double bytes (16 bytes)
052A:         	PLOT_COLUMN:
052A: 7E      	        LD A, (HL)
052B: CD7E07  	        CALL LCD_DATA
052E: 3A90FB  	        LD A, (CLRBUF)
0531: B7      	        OR A
0532: 2802    	        JR Z, $ + 4
0534: 3600    	        LD (HL), 00H            ;Clear Buffer if CLRBUF is non zero
0536: 23      	        INC HL
0537: 10F1    	        DJNZ PLOT_COLUMN
0539: 0C      	        INC C
053A: CB71    	        BIT 6, C                ;Is Row = 64?
053C: 28D4    	        JR Z, PLOT_ROW
053E: C9      	        RET
              	        
              	; Print ASCII text on a given row
              	; Inputs: A = 0 to 3 Row Number
              	;         DB "String" on next line, terminate with 0
              	; EG:
              	;   LD A,2
              	;   CALL PRINT_STRING
              	;   DB "This Text",0
              	;
053F:         	PRINT_STRING:
053F: 47      	        LD B, A
0540: CDFA02  	        CALL SET_TXT_MODE
0543: 21A507  	        LD HL, ROWS
0546: 78      	        LD A, B
0547: 85      	        ADD A, L
0548: 3001    	        JR NC, $ + 3
054A: 24      	        INC H
054B: 6F      	        LD L, A
054C: 7E      	        LD A, (HL)
054D: CD7907  	        CALL LCD_INST
0550: 3E02    	        LD A, 02H 
0552: CD9107  	        CALL SER_SYNC           ;Data Block Sync
0555: E1      	        POP HL
0556:         	DS_LOOP:
0556: 7E      	        LD A, (HL)
0557: 23      	        INC HL
0558: B7      	        OR A
0559: 2805    	        JR Z, DS_EXIT
055B: CD7E07  	        CALL LCD_DATA
055E: 18F6    	        JR DS_LOOP
0560:         	DS_EXIT:
0560: E9      	        JP (HL)
              	        
              	;Print Characters at a position X,Y
              	;Eventhough there are 16 columns, only every second column can be written
              	;to and two characters are to be printed.  IE: if you want to print one
              	;character in column 2, then you must set B=0 and print " x", putting
              	;a space before the chracter.
              	;Input B = column/X (0-7), C = row/Y (0-3)
              	;      HL = Start address of text to display, terminate with 0
0561:         	PRINT_CHARS:
0561: CDFA02  	        CALL SET_TXT_MODE
0564: 11A507  	        LD DE, ROWS
0567: 79      	        LD A, C
0568: 83      	        ADD A, E
0569: 3001    	        JR NC, $ + 3
056B: 14      	        INC D
056C: 5F      	        LD E, A
056D: 1A      	        LD A, (DE)
056E: 80      	        ADD A, B
056F: CD7907  	        CALL LCD_INST
0572: 3E02    	        LD A, 02H 
0574: CD9107  	        CALL SER_SYNC           ;Data Block Sync
0577:         	PC_LOOP:
0577: 7E      	        LD A, (HL)
0578: 23      	        INC HL
0579: B7      	        OR A
057A: C8      	        RET Z
057B: CD7E07  	        CALL LCD_DATA
057E: 18F7    	        JR PC_LOOP
              	        
              	; Delay for LCD write
0580:         	DELAY_US:
0580: 111000  	        LD DE, V_DELAY_US       ;DELAY BETWEEN, was 0010H
0583:         	DELAY_MS:
0583: 1B      	        DEC DE                  ;EACH BYTE
0584: 7A      	        LD A, D                 ;AS PER
0585: B3      	        OR E                    ;LCD MANUFACTER'S
0586: 20FB    	        JR NZ, DELAY_MS         ;INSTRUCTIONS
0588: C9      	        RET
              	        
              	; Set Buffer Clearing after outputting to LCD
              	; Input: A = 0 Buffer to be cleared, A <> 0 Buffer kept
0589:         	SET_BUF_CLEAR:
0589: 3EFF    	        LD A, 0FFH
058B: 3290FB  	        LD (CLRBUF), A
058E: C3A202  	        JP CLEAR_GBUF
              	        
0591:         	SET_BUF_NO_CLEAR:
0591: AF      	        XOR A
0592: 3290FB  	        LD (CLRBUF), A
0595: C9      	        RET
              	
              	;Initialise the GLCD Terminal
              	;Clears the GBUF, sets cursor to top left and displays cursor.
              	;This must be called prior to any Terminal routine.  This routine
              	;will as call INIT_LCD.
0596:         	INIT_TERMINAL:
0596: 2180F7  	        LD HL,TGBUF              ;Reset VPORT and BUFF_TOP to TGBUF
0599: 2280FB  	        LD (VPORT),HL           ;to GBUF
059C: 2282FB  	        LD (TBUF),HL
059F: CD8D02  	        CALL INIT_LCD           ;Clear LCD GBUF
05A2: 010000  	        LD BC,0000H
05A5: CD5B06  	        CALL SET_CURSOR         ;Move cursor to top left
05A8: 185F    	        JR DRAW_CURSOR          ;Draw Cursor and exit
              	
              	;Send or handle ASCII characters to the GLCD screen.  This routines displays
              	;ASCII charcters to the GLCD screen and handles some special control characters
              	;It also handles srolling history of 10 lines.  Characters are drawn at the 
              	;current cursor position.  Cursor increments if characger is drawn.
              	;       CR / 0DH = will move the cursor down and reset it column
              	;       LF / 0AH = is ignored
              	;       FF / 0CH = clears the terminal (restarts)
              	;       BS / 08H = will delete the character at the cursor and move cursor back one
              	;       HT / 09H = will TAB 4 spaces
              	;       UP / 05H = will scroll up one line if any
              	;       DN / 06H = will scroll down one line if any
              	;Input: A = ASCII charcter to send to the GLCD screen.
              	;       A = 0  cursor drawn only
05AA:         	SEND_CHAR_TO_GLCD:
              	        ;Check for special characters
05AA: B7      	        OR A                    ;Zero?
05AB: 285C    	        JR Z,DRAW_CURSOR
05AD:         	DO_SCRL_UP:
05AD: FEB5    	        CP UP                   ;Up Arrow
05AF: 2007    	        JR NZ,DO_SCRL_DN
05B1: AF      	        XOR A
05B2: CDC706  	        CALL MOVE_VPORT
05B5: C30D05  	        JP PLOT_TO_LCD
05B8:         	DO_SCRL_DN:
05B8: FEB6    	        CP DN                   ;Down Arrow
05BA: 2004    	        JR NZ,DO_CR
05BC: 3E01    	        LD A,1
05BE: 18F2    	        JR $-12                 ;Move VPORT above
05C0:         	DO_CR:
              	        ;Key is now a drawing character, reset VPORT first
05C0: 2180F7  	        LD HL,TGBUF
05C3: 2280FB  	        LD (VPORT),HL
05C6: FE0A    	        CP LF      ;LF
05C8: C8      	        RET Z
05C9: FE0D    	        CP CR      ;CR
05CB: 200D    	        JR NZ,DO_FF
05CD: 3E20    	        LD A,SPACE              ;Clear Cursor
05CF: CD1D07  	        CALL DRAW_GRAPHIC
05D2: CD7906  	        CALL INC_ROW
05D5: 3293FB  	        LD (CURSOR_YS),A        ;Save start row
05D8: 182F    	        JR DRAW_CURSOR
05DA:         	DO_FF:
05DA: FE0C    	        CP CS                   ;Form Feed / Clear Screen
05DC: 28B8    	        JR Z,INIT_TERMINAL      ;Reset All.
05DE:         	DO_BS:
05DE: FE7F    	        CP DEL                 ;Backspace BKSP
05E0: 200A    	        JR NZ,DO_TAB
05E2: 3E20    	        LD A,SPACE              ;Space
05E4: CD1D07  	        CALL DRAW_GRAPHIC
05E7: CDE706  	        CALL DEC_CURSOR
05EA: 181D    	        JR DRAW_CURSOR
05EC:         	DO_TAB:
05EC: FE09    	        CP TAB                  ;Horizontal Tab
05EE: 2013    	        JR NZ,DO_CHAR
05F0: 3E20    	        LD A,SPACE              ;Space
05F2: CD1D07  	        CALL DRAW_GRAPHIC
05F5: CD6C06  	        CALL INC_CURSOR
05F8: CD6C06  	        CALL INC_CURSOR
05FB: CD6C06  	        CALL INC_CURSOR
05FE: CD6C06  	        CALL INC_CURSOR
0601: 1806    	        JR DRAW_CURSOR
0603:         	DO_CHAR:
0603: CD1D07  	        CALL DRAW_GRAPHIC
0606: CD6C06  	        CALL INC_CURSOR
0609:         	DRAW_CURSOR:
0609: 3A94FB  	        LD A,(CURSOR_ON)
060C: B7      	        OR A
060D: 3E20    	        LD A,SPACE              ;Space
060F: 2002    	        JR NZ,$+4               ;Skip cursor draw
0611: 3E8F    	        LD A,CURSOR             ;Cursor
0613: CD1D07  	        CALL DRAW_GRAPHIC
0616: C30D05  	        JP PLOT_TO_LCD          ;Plot screen and exit
              	
              	
              	
              	;Send a string of characters to the GLCD.  Prints a string pointed 
              	;by DE.  It stops printing and returns when either a CR is printed or
              	;when the next byte is the same as what is in register A
              	;Inputs: DE = address of string to print
              	;        A = character to stop printing.
              	;Destroy: All
0619:         	SEND_STRING_TO_GLCD:
0619: 47      	        LD B,A                  ;Save cp in B
061A:         	PS1:
061A: 1A      	        LD A,(DE)               ;Get character
061B: 13      	        INC DE                  ;Move pointer
061C: B8      	        CP B                    ;Same as B?
061D: 28EA    	        JR Z,DRAW_CURSOR        ;Yes exit and plot LCD screen
061F: FE0D    	        CP CR                   ;Is it a CR?
0621: 289D    	        JR Z,DO_CR              ;Yes do a CR and plot LCD screen and exit
0623: FE0C    	        CP CS                   ;Is it a FF?
0625: 28B3    	        JR Z,DO_FF              ;Yes do a Form Feed and plot LCD screen and exit
0627: D9      	        EXX                     ;Save bulk registers
0628: CD1D07  	        CALL DRAW_GRAPHIC       ;Draw the character
062B: CD6C06  	        CALL INC_CURSOR         ;Move cursor by one
062E: D9      	        EXX                     ;Restore bulk registers
062F: 18E9    	        JR PS1                  ;Repeat for next character
0631: C9      	        RET     
              	
              	;Display the register A in ASCII on the GLCD
              	;Input: A = value to convert and display
0632:         	SEND_A_TO_GLCD:
0632: CD3706  	        CALL DRAW_A             ;Do the conversion
0635: 18D2    	        JR DRAW_CURSOR          ;exit and plot LCD screen
0637:         	DRAW_A:
0637: F5      	        PUSH AF                 ;Save AF
0638: 0F      	        RRCA                    ;move high
0639: 0F      	        RRCA                    ;nibble to low nibble
063A: 0F      	        RRCA
063B: 0F      	        RRCA
063C: CD4006  	        CALL NIBBLE_TO_GLCD     ;Convert and display
063F: F1      	        POP AF                  ;Restore AF
0640:         	NIBBLE_TO_GLCD:
0640: E60F    	        AND 0FH                 ;mask out high nibble
0642: C690    	        ADD A,90H               ;convert to 
0644: 27      	        DAA                     ;ASCII
0645: CE40    	        ADC A,40H               ;using this
0647: 27      	        DAA                     ;amazing routine
0648: CD1D07  	        CALL DRAW_GRAPHIC       ;Draw the character
064B: CD6C06  	        CALL INC_CURSOR         ;Move cursor by one
064E: C9      	        RET
              	
              	;Display the register HL in ASCII on the GLCD
              	;Input: HL = value to convert and display
064F:         	SEND_HL_TO_GLCD:
064F: E5      	        PUSH HL                 ;Save HL
0650: 7C      	        LD A,H                  ;get H
0651: CD3706  	        CALL DRAW_A             ;Do the conversion
0654: E1      	        POP HL
0655: 7D      	        LD A,L                  ;get L
0656: CD3706  	        CALL DRAW_A             ;Do the conversion
0659: 18AE    	        JR DRAW_CURSOR          ;exit and plot LCD screen
              	
              	;Set the Graphic cursor position
              	;Inputs: BC = X,Y where X = 0..127, Y = 0..63
              	;Ignores update if one of the X,Y values are out of range
              	;Destroys: A
065B:         	SET_CURSOR:
              	        ;Check range. Exit if X,Y out of range
065B: 79      	        LD A, C
065C: FE40    	        CP 40H
065E: D0      	        RET NC
065F: 78      	        LD A, B
0660: FE80    	        CP 80H
0662: D0      	        RET NC
              	        ;Set Cursor and initial start row
0663: ED4391FB	        LD (CURSOR_XY),BC       ;Save cursor
0667: 79      	        LD A,C
0668: 3293FB  	        LD (CURSOR_YS),A        ;And initial Y Start
066B: C9      	        RET
              	
              	;Increment the cursor by one font character
              	;A Font Character is 6x6 Pixels.  Move column 6 across until it can't then reset
              	;column back to 0 and move 6 down.
              	;If can't go down any further then keep on last row but move column back to 0
              	;Font Characters maximum 20 across and 10 down
              	;Output: Carry Set = No screen overflow
              	;Destroys: A
066C:         	INC_CURSOR:
066C: 3A92FB  	        LD A,(CURSOR_X)         ;Get X
066F: C606    	        ADD A,6                 ;Add 6
0671: FE7E    	        CP 126                  ;Is it >= 126?
0673: 3004    	        JR NC,INC_ROW           ;Yes, reset column and increment row
0675: 3292FB  	        LD (CURSOR_X),A         ;Save new column
0678: C9      	        RET
0679:         	INC_ROW:
0679: AF      	        XOR A
067A: 3292FB  	        LD (CURSOR_X),A         ;reset column to 0
067D: 3A91FB  	        LD A,(CURSOR_Y)         ;get row
0680: C606    	        ADD A,6                 ;Add 6
0682: FE3C    	        CP 60                   ;Is it >= 60
0684: 3807    	        JR C,SAVE_ROW           ;No, save new row
0686: F5      	        PUSH AF
0687: CD9106  	        CALL SHIFT_BUFFER       ;Shift buffer up one row
068A: F1      	        POP AF
068B: D606    	        SUB 6                   ;overflow, just leave the same
068D:         	SAVE_ROW:
068D: 3291FB  	        LD (CURSOR_Y),A         ;Save new row
0690: C9      	        RET
              	
              	;Shift the graphics buffer (GBUF) into the scroll buffer (SBUF) by
              	;one row (6 lines).  Move the top buffer address to the new top of 
              	;the scroll buffer
0691:         	SHIFT_BUFFER:
              	        ;Check if anymore buffer left
0691: 2A82FB  	        LD HL,(TBUF)        ;Get top buffer address
0694: 1100F0  	        LD DE,TGBUF-SBUF    ;Get scroll buffer address
0697: B7      	        OR A                ;Clear carry
0698: ED52    	        SBC HL,DE           ;TBUF-SBUF
069A: 2809    	        JR Z,SKIP_TBUF
069C: 19      	        ADD HL,DE           ;restore HL
069D: 116000  	        LD DE,16*6          ;Six pixel rows
06A0: ED52    	        SBC HL,DE           ;Move TBUF down by 6 rows
06A2: 2282FB  	        LD (TBUF),HL        ;Save new TBUF
06A5:         	SKIP_TBUF:
06A5: 2160F0  	        LD HL,TGBUF-SBUF+(16*6) ;Top of scroll buffer less one row
06A8: 1100F0  	        LD DE,TGBUF-SBUF    ;Top of scroll buffer
06AB: 01E00A  	        LD BC,16*6*29       ;19 rows (change to 20 lines 19 to 29 (+10)) Z80 Mini
06AE: EDB0    	        LDIR
06B0: 21E0FA  	        LD HL,TGBUF+0360H   ;clear last row (9*16)
06B3: 11E1FA  	        LD DE,TGBUF+0361H
06B6: 015F00  	        LD BC,5FH
06B9: AF      	        XOR A
06BA: 77      	        LD (HL),A
06BB: EDB0    	        LDIR
              	        ;Move Y Start up one row
06BD: 3A93FB  	        LD A,(CURSOR_YS)    ;Get Y Start row
06C0: D606    	        SUB 6
06C2: D8      	        RET C               ;Ignore if less than zero
06C3: 3293FB  	        LD (CURSOR_YS),A    
06C6: C9      	        RET
              	
              	;Move the VPORT vertically between TBUF and end of GBUB.  VPORT will be 
              	;shifted by a standard termial row of 6 lines.
              	;input: A = 0 shift up else shift down
06C7:         	MOVE_VPORT:
06C7: 2A80FB  	        LD HL,(VPORT)       ;get viewport
06CA: EB      	        EX DE,HL
06CB: B7      	        OR A                ;check move
06CC: 200E    	        JR NZ,MOVE_DOWN     ;shift down
06CE:         	MOVE_UP:
06CE: 2A82FB  	        LD HL,(TBUF)        ;get top of buffer
06D1: ED52    	        SBC HL,DE           ;
06D3: C8      	        RET Z               ;if the same, then at top already
06D4: 21A0FF  	        LD HL,0-60H         ;one row up 60
06D7:         	SAVE_VPORT:
06D7: 19      	        ADD HL,DE           ;get new VPORT value
06D8: 2280FB  	        LD (VPORT),HL
06DB: C9      	        RET
06DC:         	MOVE_DOWN:
06DC: 2180F7  	        LD HL,TGBUF         ;get top of graphics buffer
06DF: ED52    	        SBC HL,DE           ;
06E1: C8      	        RET Z               ;if the same, then at top already
06E2: 216000  	        LD HL,60H           ;one row down 60
06E5: 18F0    	        JR SAVE_VPORT
              	
              	;Decrement the cursor by one font character up to the current row start
              	;Used to help with Backspace character or left arrow?
              	;Destroys: A
06E7:         	DEC_CURSOR:
06E7: 3A92FB  	        LD A,(CURSOR_X)         ;Get X
06EA: D606    	        SUB 6                   ;subract 6
06EC:         	SAVE_COL:
06EC: 3292FB  	        LD (CURSOR_X),A         ;Save new column
              	        ;if < 0 then just make 0 or 20 depending on Y Start
06EF: D0      	        RET NC
06F0: C5      	        PUSH BC
06F1: 3A93FB  	        LD A,(CURSOR_YS)        ;Get Y Start
06F4: 47      	        LD B,A
06F5: 3A91FB  	        LD A,(CURSOR_Y)         ;Get Y
06F8: 90      	        SUB B
06F9: C1      	        POP BC
06FA: 3E00    	        LD A,0                  ;reset to 0
06FC: 28EE    	        JR Z,SAVE_COL
06FE: 3E78    	        LD A,6*20               ;last column 20
0700: 3292FB  	        LD (CURSOR_X),A         ;Save new column
0703: 3A91FB  	        LD A,(CURSOR_Y)
0706: D606    	        SUB 6                   ;move row one line up
0708: 3291FB  	        LD (CURSOR_Y),A         ;Save new row
070B: C9      	        RET
              	
              	;Get cursor position
              	;Outputs: BC = X,Y where X = 0..127, Y = 0..63
070C:         	GET_CURSOR:
070C: ED4B91FB	        LD BC,(CURSOR_XY)
0710: C9      	        RET
              	
              	;Display Cursor
              	;Input: A = 0, Turn cursor on, A = non zero, Turn cursor off
              	;Default is Cursor ON
0711:         	DISPLAY_CURSOR:
0711: 3294FB  	        LD (CURSOR_ON),A
0714: C9      	        RET
              	
              	;Inverse Graphic Drawing
              	;Initial state is normal.  Calling this routine will TOGGLE the inverse drawing flag
              	;Destroys: A
0715:         	INV_GRAPHIC:
0715: 3A95FB  	        LD A,(INVERSE)
0718: 2F      	        CPL                 ;flip bits
0719: 3295FB  	        LD (INVERSE),A
071C: C9      	        RET
              	
              	;Draw Graphic at the current cursor.  Draw either an ASCII character or
              	;a custom sprite/picture
              	;Input: A = ASCII number or 
              	;    if A=0 Then 
              	;       HL = Address of graphic data
              	;       B = width of graphic in pixels (1-128)
              	;       C = height of graphic in pixels (1-64)
              	;Destroys: All
071D:         	DRAW_GRAPHIC:
071D: B7      	        OR A                ;is A=0
071E: 2810    	        JR Z,PLOT_GRAPHIC   ;yes, use data pointing to HL
              	        ;Use internal font table and index it to value in A
0720: 3D      	        DEC A               ;fix for A = 0..255
0721: 2600    	        LD H,0
0723: 6F      	        LD L,A
0724: 29      	        ADD HL,HL           ;Multipy A by 2
0725: 54      	        LD D,H
0726: 5D      	        LD E,L              ;Save in DE
0727: 29      	        ADD HL,HL           ;Multipy A by 4
0728: 19      	        ADD HL,DE           ;Multiply by 6
0729: 11B307  	        LD DE,FONT_DATA     ;Font Table
072C: 19      	        ADD HL,DE           ;Add index (A*8) to HL
072D: 010606  	        LD BC,0606H         ;Six pixels across, Six pixels down
0730:         	PLOT_GRAPHIC:
0730: 50      	        LD D,B              ;D=Column pixel count
0731: 7A      	        LD A,D
0732: 3296FB  	        LD (PIXEL_X),A      ;Save original pixel length
0735: 59      	        LD E,C              ;E=Row pixel count
0736: ED4B91FB	        LD BC,(CURSOR_XY)   ;Get graphics cursor position
073A:         	PLOT_BYTE:
073A: 7A      	        LD A,D              ;Get column bit count
073B: D608    	        SUB 8
073D: 57      	        LD D,A
073E: D5      	        PUSH DE        
073F: 1608    	        LD D,8
0741: 5E      	        LD E,(HL)           ;get pixel data
0742: 3009    	        JR NC,INV_BIT
0744: 82      	        ADD A,D             ;Restore column bit count
0745: 57      	        LD D,A
0746: 7A      	        LD A,D
              	        ;D = Rotate adjust count
0747: CB0B    	        RRC E               ;rotate it to get first bit in bit 7
0749: 15      	        DEC D
074A: 20FB    	        JR NZ,$-3
074C: 57      	        LD D,A              ;reset D to actual bit count
074D:         	INV_BIT:
074D: 3E00    	        LD A, 0      ;check inverse flag
074F: AB      	        XOR E               ;flip bits
0750: 5F      	        LD E,A              ;save new data
0751:         	PLOT_BIT:
0751: CB03    	        RLC E
0753: E5      	        PUSH HL
0754: 3005    	        JR NC,REMOVE_PIXEL
0756: CDBA04  	        CALL DRAW_PIXEL
0759: 1803    	        JR $+5
075B:         	REMOVE_PIXEL:
075B: CDCB04  	        CALL CLEAR_PIXEL
075E: E1      	        POP HL
075F: 04      	        INC B               ;move X to the right by one
0760: 15      	        DEC D
0761: 20EE    	        JR NZ,PLOT_BIT
              	        ;All bits are plotted check if D <= 0
0763: 23      	        INC HL              ;move to next pixel byte
0764: D1      	        POP DE              ;restore Column/Row bit count
0765: 7A      	        LD A,D
0766: B7      	        OR A                ;check for zero or lessor
0767: 2803    	        JR Z,$+5
0769: F23A07  	        JP P,PLOT_BYTE      ;its greater or zero, do next byte
              	        ;Move down a row and set column to the start
076C: 1D      	        DEC E               ;move column pixel count down by one
076D: C8      	        RET Z               ;if its zero no more to do, just exit
076E: 0C      	        INC C               ;move down a row
076F: 3A92FB  	        LD A,(CURSOR_X)
0772: 47      	        LD B,A              ;reset column
0773: 3A96FB  	        LD A,(PIXEL_X)
0776: 57      	        LD D,A              ;reset pixel length per row
0777: 18C1    	        JR PLOT_BYTE
              	
              	;Serial/Paralled Communication routines
              	;Send information to the LCD screen via SERIAL or PARALLEL connection.  Parallel is straight
              	;forward.  Just send the Byte in the Accumilator to the relevante Instruction or Data port.
              	;Then call a delay for that byte to be processed by the LCD.
              	;For Serial communication, three Bytes are to be sent using the SPI protocol.
              	;The first byte is a synchronise/configuration byte.  This sets
              	;the Data/Instruction register bit.  The second and third bytes is the actual data to send.
              	;It is split into two bytes with 4 bits of data set at the upper nibble and zeros for the rest.
              	;A maximum of 256 Bytes of Data information can be send with only one Synchronise Byte.  The
              	;LCD Data routine doesn't send the sync byte.  It needs to be done prior by calling SER_SYNC first.
              	;
              	;The two routines to use are:
              	;LCD_DATA, Sends Data information.  Along with SER_SYNC called prior and
              	;LCD_INST, Sends Instruction information
              	
              	;Send to LCD Instruction register
              	;If serial connection it will send the byte with a synchronise byte.
              	;If parallel byte is sent to the Instruction register port and a delay is triggered
              	;Input: A = Byte to send
0779:         	LCD_INST:
              	;IF COMMS_MODE
              	;        PUSH AF
              	;        XOR A
              	;        CALL SER_SYNC
              	;        POP AF
              	;        JP SER_BYTE
              	;ELSE
0779: D370    	        OUT (LCD_IR), A
077B: C38005  	        JP DELAY_US
              	;ENDIF
              	
              	;Send to LCD Data register
              	;If serial connection it will send the byte with no synchronise byte.  The
              	;synchronise byte is to be sent separately.
              	;If parallel byte is sent to the Data register port and a delay is triggered
              	;Input: A = Byte to send
077E:         	LCD_DATA:
              	;IF COMMS_MODE
              	;        JP SER_BYTE
              	;ELSE
077E: D371    	        OUT (LCD_DR), A
0780: C38005  	        JP DELAY_US
              	;ENDIF
              	
              	;Serial Byte Send
              	;Send a Byte in two halfs,  First half is the upper nibble with 4 zeros and second
              	;byte is the lower nibble shifted to the upper nibble with 4 zeros.
              	;   EG: if Byte to send is 10010110B, then
              	;   BYTE 1 = 10010000b and
              	;   BYTE 2 = 01100000b
              	;Input: A = byte to send
0783:         	SER_BYTE:
0783: F5      	        PUSH AF
0784: CD8C07  	        CALL SEND_PART
0787: F1      	        POP AF
0788: 07      	        RLCA
0789: 07      	        RLCA
078A: 07      	        RLCA
078B: 07      	        RLCA
078C:         	SEND_PART:
078C: E6F0    	        AND 0F0H                ;Mask out lower nibble
078E: C39207  	        JP SPI_WR               ;Send First Half of Command/Data byte
              	
              	;Serial Synchronise Byte
              	;Send 5 consecutive '1's then '000's for instruction or '010' for data.
              	;Input: A = 0x00 for instruction register and 0x02 if data register
0791:         	SER_SYNC:
              	;IF COMMS_MODE
              	;        OR SER_BT
              	;ELSE
0791: C9      	        RET
              	;ENDIF
              	
              	;SPI Write Routine.
              	;Send a byte to the LCD using the SPI protocol
              	;Inputs: A = Byte to be sent
0792:         	SPI_WR:
0792: C5      	        PUSH BC
0793: 0608    	        LD B, 08H       ;Eight Bits to send
0795: 4F      	        LD C, A         ;SPI Byte
0796: AF      	        XOR A           ;Clear A
0797:         	CLK_LOOP:
0797: CB01    	        RLC C           ;Put Bit 7 in Carry Flag
0799: 8F      	        ADC A,A         ;Set Bit 0 with Carry Flag
079A: F602    	        OR 02H          ;Set SCLK high (pulse clock)
079C: D300    	        OUT (LCD_SER),A ;Output to LCD
079E: AF      	        XOR A           ;Set SCLK low (and SID)
079F: D300    	        OUT (LCD_SER),A ;Output to LCD
07A1: 10F4    	        DJNZ CLK_LOOP   ;Get next Bit
07A3: C1      	        POP BC
07A4: C9      	        RET
              	
              	; Contstants
07A5: 80908898	ROWS:   DB      80H,90H,88H,98H ;Text Row start position
              	        
07A9:         	INIT_BASIC:
07A9: 30      	        DB  30H
07AA: 20      	        DB  20H
07AB: 30      	        DB  30H
07AC: 0C      	        DB  0CH
07AD: 01      	        DB  01H
07AE: 02      	        DB  02H
              	        ;fim
              	
              	
              	
              	
07AF: 30      	        DB      30H             ;8 Bit interface, basic instruction
07B0: 0C      	        DB      0CH             ;display on, cursor & blink off
07B1: 06      	        DB      06H             ;cursor move to right ,no shift
07B2: 01      	        DB      01H             ;clear RAM
              	
              	;General Graphic Data
              	;Byte 1 = X pixel length, Byte 2 = Y pixel length
              	;Byte n = Pixel data where bits represent pixels.  Read from LSB
07B3:         	FONT_DATA:
              	        ;001
07B3: 1E      	        DB 00011110b   ;  ####
07B4: 21      	        DB 00100001b   ; #    #
07B5: 21      	        DB 00100001b   ; #    #
07B6: 21      	        DB 00100001b   ; #    #
07B7: 21      	        DB 00100001b   ; #    #
07B8: 1E      	        DB 00011110b   ;  ####
              	        ;002
07B9: 1E      	        DB 00011110b   ;  ####
07BA: 3F      	        DB 00111111b   ; ######
07BB: 3F      	        DB 00111111b   ; ######
07BC: 3F      	        DB 00111111b   ; ######
07BD: 3F      	        DB 00111111b   ; ######
07BE: 1E      	        DB 00011110b   ;  ####
              	        ;003 Up Arrow
07BF: 0C      	        DB 00001100b   ;   ##
07C0: 1E      	        DB 00011110b   ;  ####
07C1: 3F      	        DB 00111111b   ; ######
07C2: 0C      	        DB 00001100b   ;   ##
07C3: 0C      	        DB 00001100b   ;   ##
07C4: 0C      	        DB 00001100b   ;   ##
              	        ;004 Down Arrow
07C5: 0C      	        DB 00001100b   ;   ##
07C6: 0C      	        DB 00001100b   ;   ##
07C7: 0C      	        DB 00001100b   ;   ##
07C8: 3F      	        DB 00111111b   ; ######
07C9: 1E      	        DB 00011110b   ;  ####
07CA: 0C      	        DB 00001100b   ;   ##
              	        ;005 Left Arrow
07CB: 08      	        DB 00001000b   ;   #
07CC: 18      	        DB 00011000b   ;  ##
07CD: 3F      	        DB 00111111b   ; ######
07CE: 3F      	        DB 00111111b   ; ######
07CF: 18      	        DB 00011000b   ;  ##
07D0: 08      	        DB 00001000b   ;   #
              	        ;006 Right Arrow
07D1: 04      	        DB 00000100b   ;    #
07D2: 06      	        DB 00000110b   ;    ##
07D3: 3F      	        DB 00111111b   ; ######
07D4: 3F      	        DB 00111111b   ; ######
07D5: 06      	        DB 00000110b   ;    ##
07D6: 04      	        DB 00000100b   ;    #
              	        ;007 Up Hat
07D7: 0C      	        DB 00001100b   ;   ##
07D8: 1E      	        DB 00011110b   ;  ####
07D9: 3F      	        DB 00111111b   ; ######
07DA: 00      	        DB 00000000b   ;
07DB: 00      	        DB 00000000b   ;
07DC: 00      	        DB 00000000b   ;
              	        ;008 Down Hat
07DD: 00      	        DB 00000000b   ;
07DE: 00      	        DB 00000000b   ;
07DF: 00      	        DB 00000000b   ;
07E0: 3F      	        DB 00111111b   ; ######
07E1: 1E      	        DB 00011110b   ;  ####
07E2: 0C      	        DB 00001100b   ;   ##
              	        ;009 Left Hat
07E3: 08      	        DB 00001000b   ;   #
07E4: 18      	        DB 00011000b   ;  ##
07E5: 38      	        DB 00111000b   ; ###
07E6: 38      	        DB 00111000b   ; ###
07E7: 18      	        DB 00011000b   ;  ##
07E8: 08      	        DB 00001000b   ;   #
              	        ;010 Right Hat
07E9: 04      	        DB 00000100b   ;    #
07EA: 06      	        DB 00000110b   ;    ##
07EB: 07      	        DB 00000111b   ;    ###
07EC: 07      	        DB 00000111b   ;    ###
07ED: 06      	        DB 00000110b   ;    ##
07EE: 04      	        DB 00000100b   ;    #
              	        ;011 Note 1
07EF: 04      	        DB 00000100b   ;    #
07F0: 04      	        DB 00000100b   ;    # 
07F1: 04      	        DB 00000100b   ;    # 
07F2: 1C      	        DB 00011100b   ;  ###
07F3: 3C      	        DB 00111100b   ; ####
07F4: 18      	        DB 00011000b   ;  ##
              	        ;012 Note 2
07F5: 04      	        DB 00000100b   ;    #
07F6: 06      	        DB 00000110b   ;    ## 
07F7: 05      	        DB 00000101b   ;    # #
07F8: 1C      	        DB 00011100b   ;  ###
07F9: 3C      	        DB 00111100b   ; ####
07FA: 18      	        DB 00011000b   ;  ##
              	        ;013 Rocket
07FB: 0C      	        DB 00001100b   ;   ##
07FC: 0C      	        DB 00001100b   ;   ##
07FD: 0C      	        DB 00001100b   ;   ##
07FE: 0C      	        DB 00001100b   ;   ##
07FF: 1E      	        DB 00011110b   ;  ####
0800: 33      	        DB 00110011b   ; ##  ##
              	        ;014 Bomb
0801: 1E      	        DB 00011110b   ;  ####
0802: 0C      	        DB 00001100b   ;   ##
0803: 1E      	        DB 00011110b   ;  ####
0804: 1E      	        DB 00011110b   ;  ####
0805: 1E      	        DB 00011110b   ;  ####
0806: 0C      	        DB 00001100b   ;   ##
              	        ;015 Explosion
0807: 0C      	        DB 00001100b   ;   ##
0808: 3F      	        DB 00111111b   ; ######
0809: 06      	        DB 00000110b   ;    ##
080A: 0C      	        DB 00001100b   ;   ##
080B: 18      	        DB 00011000b   ;  ##
080C: 0C      	        DB 00001100b   ;   ##
              	        ;016
080D: 36      	        DB 00110110b   ; ## ##
080E: 24      	        DB 00100100b   ; #  #
080F: 00      	        DB 00000000b   ;
0810: 00      	        DB 00000000b   ;
0811: 00      	        DB 00000000b   ;
0812: 00      	        DB 00000000b   ;
              	        ;017
0813: 36      	        DB 00110110b   ; ## ##
0814: 12      	        DB 00010010b   ;  #  #
0815: 00      	        DB 00000000b   ;
0816: 00      	        DB 00000000b   ;
0817: 00      	        DB 00000000b   ;
0818: 00      	        DB 00000000b   ;
              	        ;018
0819: 0E      	        DB 00001110b   ;   ###
081A: 12      	        DB 00010010b   ;  #  #
081B: 38      	        DB 00111000b   ; ###
081C: 12      	        DB 00010010b   ;  #  #
081D: 3E      	        DB 00111110b   ; #####
081E: 00      	        DB 00000000b   ;
              	        ;019
081F: 1C      	        DB 00011100b   ;  ###
0820: 22      	        DB 00100010b   ; #   #
0821: 2A      	        DB 00101010b   ; # # #
0822: 22      	        DB 00100010b   ; #   #
0823: 1C      	        DB 00011100b   ;  ###
0824: 00      	        DB 00000000b   ;
              	        ;020
0825: 3E      	        DB 00111110b   ; #####
0826: 34      	        DB 00110100b   ; ## #
0827: 34      	        DB 00110100b   ; ## #
0828: 14      	        DB 00010100b   ;  # #
0829: 14      	        DB 00010100b   ;  # #
082A: 00      	        DB 00000000b   ;
              	        ;021
082B: 1C      	        DB 00011100b   ;  ###
082C: 18      	        DB 00011000b   ;  ##
082D: 24      	        DB 00100100b   ; #  #
082E: 18      	        DB 00011000b   ;  ##
082F: 38      	        DB 00111000b   ; ###
0830: 00      	        DB 00000000b   ;
              	        ;022
0831: 0C      	        DB 00001100b   ;   ##
0832: 0C      	        DB 00001100b   ;   ##
0833: 02      	        DB 00000010b   ;     #
0834: 00      	        DB 00000000b   ;
0835: 00      	        DB 00000000b   ;
0836: 00      	        DB 00000000b   ;
              	        ;023
0837: 14      	        DB 00010100b   ;  # #
0838: 00      	        DB 00000000b   ;
0839: 08      	        DB 00001000b   ;   #
083A: 22      	        DB 00100010b   ; #   # 
083B: 1C      	        DB 00011100b   ;  ###
083C: 00      	        DB 00000000b   ;
              	        ;024
083D: 14      	        DB 00010100b   ;  # #
083E: 00      	        DB 00000000b   ;
083F: 00      	        DB 00000000b   ;
0840: 1C      	        DB 00011100b   ;  ###
0841: 22      	        DB 00100010b   ; #   # 
0842: 00      	        DB 00000000b   ;
              	        ;025
0843: 08      	        DB 00001000b   ;   #
0844: 00      	        DB 00000000b   ;
0845: 18      	        DB 00011000b   ;  ##
0846: 22      	        DB 00100010b   ; #   #
0847: 1C      	        DB 00011100b   ;  ###
0848: 00      	        DB 00000000b   ;
              	        ;026
0849: 08      	        DB 00001000b   ;   #
084A: 00      	        DB 00000000b   ;
084B: 08      	        DB 00001000b   ;   #
084C: 08      	        DB 00001000b   ;   #
084D: 08      	        DB 00001000b   ;   #
084E: 00      	        DB 00000000b   ;
              	        ;027
084F: 00      	        DB 00000000b   ;
0850: 00      	        DB 00000000b   ;
0851: 3E      	        DB 00111110b   ; #####
0852: 06      	        DB 00000110b   ;    ##
0853: 06      	        DB 00000110b   ;    ##
0854: 00      	        DB 00000000b   ;
              	        ;028
0855: 1C      	        DB 00011100b   ;  ###
0856: 1C      	        DB 00011100b   ;  ###
0857: 3E      	        DB 00111110b   ; #####
0858: 08      	        DB 00001000b   ;   #
0859: 1C      	        DB 00011100b   ;  ###
085A: 00      	        DB 00000000b   ;
              	        ;029
085B: 08      	        DB 00001000b   ;   #
085C: 1C      	        DB 00011100b   ;  ###
085D: 3E      	        DB 00111110b   ; #####
085E: 1C      	        DB 00011100b   ;  ###
085F: 08      	        DB 00001000b   ;   #
0860: 00      	        DB 00000000b   ;
              	        ;030
0861: 14      	        DB 00010100b   ;  # #
0862: 3E      	        DB 00111110b   ; #####
0863: 3E      	        DB 00111110b   ; #####
0864: 1C      	        DB 00011100b   ;  ###
0865: 08      	        DB 00001000b   ;   #
0866: 00      	        DB 00000000b   ;
              	        ;031
0867: 08      	        DB 00001000b   ;   #
0868: 1C      	        DB 00011100b   ;  ###
0869: 3E      	        DB 00111110b   ; #####
086A: 08      	        DB 00001000b   ;   #
086B: 1C      	        DB 00011100b   ;  ###
086C: 00      	        DB 00000000b   ;
              	        ;032 Space
086D: 00      	        DB 00000000b   ;
086E: 00      	        DB 00000000b   ;
086F: 00      	        DB 00000000b   ;
0870: 00      	        DB 00000000b   ;
0871: 00      	        DB 00000000b   ;
0872: 00      	        DB 00000000b   ;
              	        ;033 !
0873: 08      	        DB 00001000b   ;   #
0874: 08      	        DB 00001000b   ;   #
0875: 08      	        DB 00001000b   ;   #
0876: 00      	        DB 00000000b   ;
0877: 08      	        DB 00001000b   ;   #
0878: 00      	        DB 00000000b   ;
              	        ;034 "
0879: 14      	        DB 00010100b   ;  # #
087A: 14      	        DB 00010100b   ;  # #
087B: 00      	        DB 00000000b   ;
087C: 00      	        DB 00000000b   ;
087D: 00      	        DB 00000000b   ;
087E: 00      	        DB 00000000b   ;
              	        ;035 #
087F: 14      	        DB 00010100b   ;  # #
0880: 3E      	        DB 00111110b   ; #####
0881: 14      	        DB 00010100b   ;  # #
0882: 3E      	        DB 00111110b   ; #####
0883: 14      	        DB 00010100b   ;  # #
0884: 00      	        DB 00000000b   ;
              	        ;036 $
0885: 1E      	        DB 00011110b   ;  ####
0886: 28      	        DB 00101000b   ; # #
0887: 1C      	        DB 00011100b   ;  ###
0888: 0A      	        DB 00001010b   ;   # #
0889: 3C      	        DB 00111100b   ; ####
088A: 00      	        DB 00000000b   ;
              	        ;037 %
088B: 32      	        DB 00110010b   ; ##  #
088C: 34      	        DB 00110100b   ; ## #
088D: 08      	        DB 00001000b   ;   #
088E: 16      	        DB 00010110b   ;  # ##
088F: 26      	        DB 00100110b   ; #  ##
0890: 00      	        DB 00000000b   ;
              	        ;038 &
0891: 18      	        DB 00011000b   ;  ##
0892: 24      	        DB 00100100b   ; #  #
0893: 1A      	        DB 00011010b   ;  ## #
0894: 24      	        DB 00100100b   ; #  #
0895: 1A      	        DB 00011010b   ;  ## #
0896: 00      	        DB 00000000b   ;
              	        ;039 '
0897: 04      	        DB 00000100b   ;    #
0898: 08      	        DB 00001000b   ;   #
0899: 00      	        DB 00000000b   ;
089A: 00      	        DB 00000000b   ;
089B: 00      	        DB 00000000b   ;
089C: 00      	        DB 00000000b   ;
              	        ;040 (
089D: 04      	        DB 00000100b   ;    #
089E: 08      	        DB 00001000b   ;   #
089F: 08      	        DB 00001000b   ;   #
08A0: 08      	        DB 00001000b   ;   #
08A1: 04      	        DB 00000100b   ;    #
08A2: 00      	        DB 00000000b   ;
              	        ;041 )
08A3: 10      	        DB 00010000b   ;  #
08A4: 08      	        DB 00001000b   ;   #
08A5: 08      	        DB 00001000b   ;   #
08A6: 08      	        DB 00001000b   ;   #
08A7: 10      	        DB 00010000b   ;  #
08A8: 00      	        DB 00000000b   ;
              	        ;042 *
08A9: 2A      	        DB 00101010b   ; # # #
08AA: 1C      	        DB 00011100b   ;  ###
08AB: 3E      	        DB 00111110b   ; #####
08AC: 1C      	        DB 00011100b   ;  ###
08AD: 2A      	        DB 00101010b   ; # # #
08AE: 00      	        DB 00000000b   ;
              	        ;043 +
08AF: 00      	        DB 00000000b   ;
08B0: 08      	        DB 00001000b   ;   #
08B1: 1C      	        DB 00011100b   ;  ###
08B2: 08      	        DB 00001000b   ;   #
08B3: 00      	        DB 00000000b   ;
08B4: 00      	        DB 00000000b   ;
              	        ;044 ,
08B5: 00      	        DB 00000000b   ;
08B6: 00      	        DB 00000000b   ;
08B7: 00      	        DB 00000000b   ;
08B8: 08      	        DB 00001000b   ;   #
08B9: 10      	        DB 00010000b   ;  #
08BA: 00      	        DB 00000000b   ;
              	        ;045 -
08BB: 00      	        DB 00000000b   ;
08BC: 00      	        DB 00000000b   ;
08BD: 1C      	        DB 00011100b   ;  ###
08BE: 00      	        DB 00000000b   ;
08BF: 00      	        DB 00000000b   ;
08C0: 00      	        DB 00000000b   ;
              	        ;046 .
08C1: 00      	        DB 00000000b   ;
08C2: 00      	        DB 00000000b   ;
08C3: 00      	        DB 00000000b   ;
08C4: 00      	        DB 00000000b   ;
08C5: 10      	        DB 00010000b   ;  #
08C6: 00      	        DB 00000000b   ;
              	        ;047 /
08C7: 04      	        DB 00000100b   ;    #
08C8: 08      	        DB 00001000b   ;   #
08C9: 08      	        DB 00001000b   ;   #
08CA: 08      	        DB 00001000b   ;   #
08CB: 10      	        DB 00010000b   ;  #
08CC: 00      	        DB 00000000b   ;
              	        ;048 0
08CD: 1C      	        DB 00011100b   ;  ###
08CE: 14      	        DB 00010100b   ;  # #
08CF: 14      	        DB 00010100b   ;  # #
08D0: 14      	        DB 00010100b   ;  # #
08D1: 1C      	        DB 00011100b   ;  ###
08D2: 00      	        DB 00000000b   ;
              	        ;049 1
08D3: 08      	        DB 00001000b   ;   #
08D4: 18      	        DB 00011000b   ;  ##
08D5: 08      	        DB 00001000b   ;   #
08D6: 08      	        DB 00001000b   ;   #
08D7: 1C      	        DB 00011100b   ;  ###
08D8: 00      	        DB 00000000b   ;
              	        ;050 2
08D9: 1C      	        DB 00011100b   ;  ###
08DA: 04      	        DB 00000100b   ;    #
08DB: 1C      	        DB 00011100b   ;  ###
08DC: 10      	        DB 00010000b   ;  #
08DD: 1C      	        DB 00011100b   ;  ###
08DE: 00      	        DB 00000000b   ;
              	        ;051 3
08DF: 1C      	        DB 00011100b   ;  ###
08E0: 04      	        DB 00000100b   ;    #
08E1: 0C      	        DB 00001100b   ;   ##
08E2: 04      	        DB 00000100b   ;    #
08E3: 1C      	        DB 00011100b   ;  ###
08E4: 00      	        DB 00000000b   ;
              	        ;052 4
08E5: 10      	        DB 00010000b   ;  #
08E6: 10      	        DB 00010000b   ;  #
08E7: 14      	        DB 00010100b   ;  # #
08E8: 1C      	        DB 00011100b   ;  ###
08E9: 04      	        DB 00000100b   ;    #
08EA: 00      	        DB 00000000b   ;
              	        ;053 5
08EB: 1C      	        DB 00011100b   ;  ###
08EC: 10      	        DB 00010000b   ;  #
08ED: 1C      	        DB 00011100b   ;  ###
08EE: 04      	        DB 00000100b   ;    #
08EF: 1C      	        DB 00011100b   ;  ###
08F0: 00      	        DB 00000000b   ;
              	        ;054 6
08F1: 18      	        DB 00011000b   ;  ##
08F2: 10      	        DB 00010000b   ;  #
08F3: 1C      	        DB 00011100b   ;  ###
08F4: 14      	        DB 00010100b   ;  # #
08F5: 1C      	        DB 00011100b   ;  ###
08F6: 00      	        DB 00000000b   ;
              	        ;055 7
08F7: 1C      	        DB 00011100b   ;  ###
08F8: 04      	        DB 00000100b   ;    #
08F9: 08      	        DB 00001000b   ;   #
08FA: 10      	        DB 00010000b   ;  #
08FB: 10      	        DB 00010000b   ;  #
08FC: 00      	        DB 00000000b   ;
              	        ;056 8
08FD: 1C      	        DB 00011100b   ;  ###
08FE: 14      	        DB 00010100b   ;  # #
08FF: 1C      	        DB 00011100b   ;  ###
0900: 14      	        DB 00010100b   ;  # #
0901: 1C      	        DB 00011100b   ;  ###
0902: 00      	        DB 00000000b   ;
              	        ;057 9
0903: 1C      	        DB 00011100b   ;  ###
0904: 14      	        DB 00010100b   ;  # #
0905: 1C      	        DB 00011100b   ;  ###
0906: 04      	        DB 00000100b   ;    #
0907: 1C      	        DB 00011100b   ;  ###
0908: 00      	        DB 00000000b   ;
              	        ;058 :
0909: 00      	        DB 00000000b   ;
090A: 08      	        DB 00001000b   ;   #
090B: 00      	        DB 00000000b   ;
090C: 08      	        DB 00001000b   ;   #
090D: 00      	        DB 00000000b   ;
090E: 00      	        DB 00000000b   ;
              	        ;059 ;
090F: 00      	        DB 00000000b   ;
0910: 08      	        DB 00001000b   ;   #
0911: 00      	        DB 00000000b   ;
0912: 08      	        DB 00001000b   ;   #
0913: 10      	        DB 00010000b   ;  #
0914: 00      	        DB 00000000b   ;
              	        ;060 <
0915: 04      	        DB 00000100b   ;    #
0916: 08      	        DB 00001000b   ;   #
0917: 10      	        DB 00010000b   ;  #
0918: 08      	        DB 00001000b   ;   #
0919: 04      	        DB 00000100b   ;    #
091A: 00      	        DB 00000000b   ;
              	        ;061 =
091B: 00      	        DB 00000000b   ;
091C: 1C      	        DB 00011100b   ;  ###
091D: 00      	        DB 00000000b   ;
091E: 1C      	        DB 00011100b   ;  ###
091F: 00      	        DB 00000000b   ;
0920: 00      	        DB 00000000b   ;
              	        ;062 >
0921: 10      	        DB 00010000b   ;  #
0922: 08      	        DB 00001000b   ;   #
0923: 04      	        DB 00000100b   ;    #
0924: 08      	        DB 00001000b   ;   #
0925: 10      	        DB 00010000b   ;  #
0926: 00      	        DB 00000000b   ;
              	        ;063 ?
0927: 1C      	        DB 00011100b   ;  ###
0928: 22      	        DB 00100010b   ; #   # 
0929: 0C      	        DB 00001100b   ;   ##
092A: 00      	        DB 00000000b   ;
092B: 08      	        DB 00001000b   ;   #
092C: 00      	        DB 00000000b   ;
              	        ;064 @
092D: 1C      	        DB 00011100b   ;  ###
092E: 22      	        DB 00100010b   ; #   #
092F: 26      	        DB 00100110b   ; #  ##
0930: 2A      	        DB 00101010b   ; # # # 
0931: 0C      	        DB 00001100b   ;   ##
0932: 00      	        DB 00000000b   ;
              	        ;065 A
0933: 18      	        DB 00011000b   ;  ##
0934: 24      	        DB 00100100b   ; #  #
0935: 22      	        DB 00100010b   ; #   #
0936: 3E      	        DB 00111110b   ; #####
0937: 22      	        DB 00100010b   ; #   #
0938: 00      	        DB 00000000b   ; 
              	        ;066 B
0939: 38      	        DB 00111000b   ; ###
093A: 24      	        DB 00100100b   ; #  #
093B: 3C      	        DB 00111100b   ; ####
093C: 22      	        DB 00100010b   ; #   #
093D: 3C      	        DB 00111100b   ; ####
093E: 00      	        DB 00000000b   ; 
              	        ;067 C
093F: 1C      	        DB 00011100b   ;  ###
0940: 22      	        DB 00100010b   ; #   # 
0941: 20      	        DB 00100000b   ; #
0942: 22      	        DB 00100010b   ; #   # 
0943: 1C      	        DB 00011100b   ;  ###
0944: 00      	        DB 00000000b   ;
              	        ;068 D
0945: 3C      	        DB 00111100b   ; ####
0946: 26      	        DB 00100110b   ; #  ##
0947: 22      	        DB 00100010b   ; #   #
0948: 22      	        DB 00100010b   ; #   #
0949: 3C      	        DB 00111100b   ; ####
094A: 00      	        DB 00000000b   ;
              	        ;069 E
094B: 3E      	        DB 00111110b   ; #####
094C: 20      	        DB 00100000b   ; #
094D: 3C      	        DB 00111100b   ; ####
094E: 20      	        DB 00100000b   ; #
094F: 3E      	        DB 00111110b   ; #####
0950: 00      	        DB 00000000b   ;
              	        ;070 F
0951: 3E      	        DB 00111110b   ; #####
0952: 20      	        DB 00100000b   ; #
0953: 3C      	        DB 00111100b   ; ####
0954: 20      	        DB 00100000b   ; #
0955: 20      	        DB 00100000b   ; #
0956: 00      	        DB 00000000b   ;
              	        ;071 G
0957: 1C      	        DB 00011100b   ;  ###
0958: 20      	        DB 00100000b   ; #    
0959: 26      	        DB 00100110b   ; #  ##
095A: 22      	        DB 00100010b   ; #   # 
095B: 1C      	        DB 00011100b   ;  ###
095C: 00      	        DB 00000000b   ;
              	        ;072 H
095D: 24      	        DB 00100100b   ; #  #
095E: 22      	        DB 00100010b   ; #   #
095F: 3E      	        DB 00111110b   ; #####
0960: 22      	        DB 00100010b   ; #   #
0961: 22      	        DB 00100010b   ; #   #
0962: 00      	        DB 00000000b   ;
              	        ;073 I
0963: 1C      	        DB 00011100b   ;  ###
0964: 08      	        DB 00001000b   ;   #
0965: 08      	        DB 00001000b   ;   #
0966: 08      	        DB 00001000b   ;   #
0967: 1C      	        DB 00011100b   ;  ###
0968: 00      	        DB 00000000b   ;
              	        ;074 J
0969: 0C      	        DB 00001100b   ;   ##
096A: 04      	        DB 00000100b   ;    #
096B: 04      	        DB 00000100b   ;    #
096C: 14      	        DB 00010100b   ;  # #
096D: 1C      	        DB 00011100b   ;  ###
096E: 00      	        DB 00000000b   ;
              	        ;075 K
096F: 24      	        DB 00100100b   ; #  #
0970: 28      	        DB 00101000b   ; # #
0971: 30      	        DB 00110000b   ; ##
0972: 28      	        DB 00101000b   ; # #
0973: 24      	        DB 00100100b   ; #  #
0974: 00      	        DB 00000000b   ;
              	        ;076 L
0975: 20      	        DB 00100000b   ; #
0976: 20      	        DB 00100000b   ; #
0977: 20      	        DB 00100000b   ; #
0978: 20      	        DB 00100000b   ; #
0979: 3C      	        DB 00111100b   ; ####
097A: 00      	        DB 00000000b   ; 
              	        ;077 M
097B: 22      	        DB 00100010b   ; #   #
097C: 36      	        DB 00110110b   ; ## ##
097D: 2A      	        DB 00101010b   ; # # #
097E: 22      	        DB 00100010b   ; #   #
097F: 22      	        DB 00100010b   ; #   #
0980: 00      	        DB 00000000b   ; 
              	        ;078 N
0981: 22      	        DB 00100010b   ; #   #
0982: 32      	        DB 00110010b   ; ##  #
0983: 2A      	        DB 00101010b   ; # # #
0984: 26      	        DB 00100110b   ; #  ##
0985: 22      	        DB 00100010b   ; #   #
0986: 00      	        DB 00000000b   ; 
              	        ;079 O
0987: 1C      	        DB 00011100b   ;  ###
0988: 26      	        DB 00100110b   ; #  ## 
0989: 22      	        DB 00100010b   ; #   #
098A: 22      	        DB 00100010b   ; #   # 
098B: 1C      	        DB 00011100b   ;  ###
098C: 00      	        DB 00000000b   ; 
              	        ;080 P
098D: 38      	        DB 00111000b   ; ###
098E: 24      	        DB 00100100b   ; #  #
098F: 38      	        DB 00111000b   ; ###
0990: 20      	        DB 00100000b   ; #
0991: 20      	        DB 00100000b   ; #
0992: 00      	        DB 00000000b   ; 
              	        ;081 Q
0993: 1C      	        DB 00011100b   ;  ###
0994: 22      	        DB 00100010b   ; #   # 
0995: 22      	        DB 00100010b   ; #   #
0996: 26      	        DB 00100110b   ; #  ## 
0997: 1E      	        DB 00011110b   ;  ####
0998: 00      	        DB 00000000b   ; 
              	        ;082 R
0999: 38      	        DB 00111000b   ; ###
099A: 24      	        DB 00100100b   ; #  #
099B: 38      	        DB 00111000b   ; ###
099C: 28      	        DB 00101000b   ; # #
099D: 24      	        DB 00100100b   ; #  #
099E: 00      	        DB 00000000b   ; 
              	        ;083 S
099F: 1E      	        DB 00011110b   ;  ####
09A0: 20      	        DB 00100000b   ; #
09A1: 1C      	        DB 00011100b   ;  ###
09A2: 02      	        DB 00000010b   ;     #
09A3: 3C      	        DB 00111100b   ; ####
09A4: 00      	        DB 00000000b   ; 
              	        ;084 T
09A5: 3E      	        DB 00111110b   ; #####
09A6: 08      	        DB 00001000b   ;   #
09A7: 08      	        DB 00001000b   ;   #
09A8: 08      	        DB 00001000b   ;   #
09A9: 08      	        DB 00001000b   ;   #
09AA: 00      	        DB 00000000b   ; 
              	        ;085 U
09AB: 24      	        DB 00100100b   ; #  #
09AC: 22      	        DB 00100010b   ; #   #
09AD: 22      	        DB 00100010b   ; #   #
09AE: 22      	        DB 00100010b   ; #   #
09AF: 1C      	        DB 00011100b   ;  ###
09B0: 00      	        DB 00000000b   ; 
              	        ;086 V
09B1: 22      	        DB 00100010b   ; #   #
09B2: 22      	        DB 00100010b   ; #   #
09B3: 14      	        DB 00010100b   ;  # #
09B4: 14      	        DB 00010100b   ;  # #
09B5: 08      	        DB 00001000b   ;   #
09B6: 00      	        DB 00000000b   ; 
              	        ;087 W
09B7: 24      	        DB 00100100b   ; #  #
09B8: 22      	        DB 00100010b   ; #   #
09B9: 2A      	        DB 00101010b   ; # # #
09BA: 2A      	        DB 00101010b   ; # # #
09BB: 14      	        DB 00010100b   ;  # #
09BC: 00      	        DB 00000000b   ; 
              	        ;088 X
09BD: 22      	        DB 00100010b   ; #   #
09BE: 14      	        DB 00010100b   ;  # #
09BF: 08      	        DB 00001000b   ;   #
09C0: 14      	        DB 00010100b   ;  # #
09C1: 22      	        DB 00100010b   ; #   #
09C2: 00      	        DB 00000000b   ; 
              	        ;089 Y
09C3: 22      	        DB 00100010b   ; #   #
09C4: 14      	        DB 00010100b   ;  # #
09C5: 08      	        DB 00001000b   ;   #
09C6: 08      	        DB 00001000b   ;   #
09C7: 08      	        DB 00001000b   ;   #
09C8: 00      	        DB 00000000b   ; 
              	        ;090 Z
09C9: 3E      	        DB 00111110b   ; #####
09CA: 04      	        DB 00000100b   ;    #
09CB: 08      	        DB 00001000b   ;   #
09CC: 10      	        DB 00010000b   ;  #
09CD: 3E      	        DB 00111110b   ; #####
09CE: 00      	        DB 00000000b   ; 
              	        ;091 [
09CF: 0C      	        DB 00001100b   ;   ##
09D0: 08      	        DB 00001000b   ;   #
09D1: 08      	        DB 00001000b   ;   #
09D2: 08      	        DB 00001000b   ;   #
09D3: 0C      	        DB 00001100b   ;   ##
09D4: 00      	        DB 00000000b   ; 
              	        ;092 \
09D5: 10      	        DB 00010000b   ;  #
09D6: 08      	        DB 00001000b   ;   #
09D7: 08      	        DB 00001000b   ;   #
09D8: 08      	        DB 00001000b   ;   #
09D9: 04      	        DB 00000100b   ;    #
09DA: 00      	        DB 00000000b   ; 
              	        ;093 ]
09DB: 18      	        DB 00011000b   ;  ##
09DC: 08      	        DB 00001000b   ;   #
09DD: 08      	        DB 00001000b   ;   #
09DE: 08      	        DB 00001000b   ;   #
09DF: 18      	        DB 00011000b   ;  ##
09E0: 00      	        DB 00000000b   ; 
              	        ;094 ^
09E1: 08      	        DB 00001000b   ;   #
09E2: 14      	        DB 00010100b   ;  # #
09E3: 00      	        DB 00000000b   ; 
09E4: 00      	        DB 00000000b   ; 
09E5: 00      	        DB 00000000b   ; 
09E6: 00      	        DB 00000000b   ; 
              	        ;095 _
09E7: 00      	        DB 00000000b   ; 
09E8: 00      	        DB 00000000b   ; 
09E9: 00      	        DB 00000000b   ; 
09EA: 00      	        DB 00000000b   ; 
09EB: 3E      	        DB 00111110b   ; #####
09EC: 00      	        DB 00000000b   ; 
              	        ;096 `
09ED: 08      	        DB 00001000b   ;   #
09EE: 04      	        DB 00000100b   ;    #
09EF: 00      	        DB 00000000b   ;
09F0: 00      	        DB 00000000b   ;
09F1: 00      	        DB 00000000b   ;
09F2: 00      	        DB 00000000b   ;
              	        ;097 a
09F3: 00      	        DB 00000000b   ; 
09F4: 1C      	        DB 00011100b   ;  ###
09F5: 22      	        DB 00100010b   ; #   #
09F6: 26      	        DB 00100110b   ; #  ##
09F7: 1A      	        DB 00011010b   ;  ## #
09F8: 00      	        DB 00000000b   ; 
              	        ;098 b
09F9: 20      	        DB 00100000b   ; #
09FA: 3C      	        DB 00111100b   ; ####
09FB: 22      	        DB 00100010b   ; #   #
09FC: 22      	        DB 00100010b   ; #   #
09FD: 3C      	        DB 00111100b   ; ####
09FE: 00      	        DB 00000000b   ; 
              	        ;099 c
09FF: 00      	        DB 00000000b   ; 
0A00: 1C      	        DB 00011100b   ;  ###
0A01: 20      	        DB 00100000b   ; #   
0A02: 20      	        DB 00100000b   ; #   
0A03: 1C      	        DB 00011100b   ;  ###
0A04: 00      	        DB 00000000b   ; 
              	        ;100 d
0A05: 02      	        DB 00000010b   ;     #
0A06: 1E      	        DB 00011110b   ;  ####
0A07: 22      	        DB 00100010b   ; #   #
0A08: 22      	        DB 00100010b   ; #   #
0A09: 1E      	        DB 00011110b   ;  ####
0A0A: 00      	        DB 00000000b   ; 
              	        ;101 e
0A0B: 1C      	        DB 00011100b   ;  ###
0A0C: 22      	        DB 00100010b   ; #   #
0A0D: 3C      	        DB 00111100b   ; ####
0A0E: 20      	        DB 00100000b   ; #
0A0F: 1E      	        DB 00011110b   ;  ####
0A10: 00      	        DB 00000000b   ; 
              	        ;102 f
0A11: 0E      	        DB 00001110b   ;   ###
0A12: 10      	        DB 00010000b   ;  # 
0A13: 3C      	        DB 00111100b   ; ####
0A14: 10      	        DB 00010000b   ;  # 
0A15: 10      	        DB 00010000b   ;  # 
0A16: 00      	        DB 00000000b   ; 
              	        ;103 g
0A17: 1E      	        DB 00011110b   ;  ####
0A18: 22      	        DB 00100010b   ; #   #
0A19: 1E      	        DB 00011110b   ;  ####
0A1A: 02      	        DB 00000010b   ;     #
0A1B: 3C      	        DB 00111100b   ; ####
0A1C: 00      	        DB 00000000b   ; 
              	        ;104 h
0A1D: 20      	        DB 00100000b   ; #
0A1E: 20      	        DB 00100000b   ; #
0A1F: 3C      	        DB 00111100b   ; ####
0A20: 22      	        DB 00100010b   ; #   #
0A21: 22      	        DB 00100010b   ; #   #
0A22: 00      	        DB 00000000b   ; 
              	        ;105 i
0A23: 08      	        DB 00001000b   ;   #
0A24: 00      	        DB 00000000b   ; 
0A25: 08      	        DB 00001000b   ;   #
0A26: 08      	        DB 00001000b   ;   #
0A27: 08      	        DB 00001000b   ;   #
0A28: 00      	        DB 00000000b   ; 
              	        ;106 j
0A29: 04      	        DB 00000100b   ;    # 
0A2A: 00      	        DB 00000000b   ; 
0A2B: 04      	        DB 00000100b   ;    # 
0A2C: 04      	        DB 00000100b   ;    # 
0A2D: 18      	        DB 00011000b   ;  ##
0A2E: 00      	        DB 00000000b   ; 
              	        ;107 k
0A2F: 20      	        DB 00100000b   ; #
0A30: 24      	        DB 00100100b   ; #  #
0A31: 28      	        DB 00101000b   ; # #
0A32: 34      	        DB 00110100b   ; ## #
0A33: 22      	        DB 00100010b   ; #   #
0A34: 00      	        DB 00000000b   ; 
              	        ;108 l
0A35: 08      	        DB 00001000b   ;   #
0A36: 08      	        DB 00001000b   ;   #
0A37: 08      	        DB 00001000b   ;   #
0A38: 08      	        DB 00001000b   ;   #
0A39: 0C      	        DB 00001100b   ;   ##
0A3A: 00      	        DB 00000000b   ; 
              	        ;109 m
0A3B: 00      	        DB 00000000b   ; 
0A3C: 14      	        DB 00010100b   ;  # #
0A3D: 2A      	        DB 00101010b   ; # # #
0A3E: 2A      	        DB 00101010b   ; # # #
0A3F: 2A      	        DB 00101010b   ; # # #
0A40: 00      	        DB 00000000b   ; 
              	        ;110 n
0A41: 00      	        DB 00000000b   ; 
0A42: 1C      	        DB 00011100b   ;  ###
0A43: 22      	        DB 00100010b   ; #   #
0A44: 22      	        DB 00100010b   ; #   #
0A45: 22      	        DB 00100010b   ; #   #
0A46: 00      	        DB 00000000b   ; 
              	        ;111 o
0A47: 00      	        DB 00000000b   ; 
0A48: 1C      	        DB 00011100b   ;  ###
0A49: 22      	        DB 00100010b   ; #   #
0A4A: 22      	        DB 00100010b   ; #   #
0A4B: 1C      	        DB 00011100b   ;  ###
0A4C: 00      	        DB 00000000b   ; 
              	        ;112 p
0A4D: 1C      	        DB 00011100b   ;  ###
0A4E: 22      	        DB 00100010b   ; #   #
0A4F: 22      	        DB 00100010b   ; #   #
0A50: 3C      	        DB 00111100b   ; ####
0A51: 20      	        DB 00100000b   ; #
0A52: 00      	        DB 00000000b   ; 
              	        ;113 q
0A53: 1C      	        DB 00011100b   ;  ###
0A54: 22      	        DB 00100010b   ; #   #
0A55: 22      	        DB 00100010b   ; #   #
0A56: 1E      	        DB 00011110b   ;  ####
0A57: 02      	        DB 00000010b   ;     #
0A58: 00      	        DB 00000000b   ; 
              	        ;114 r
0A59: 00      	        DB 00000000b   ; 
0A5A: 2C      	        DB 00101100b   ; # ##
0A5B: 30      	        DB 00110000b   ; ##
0A5C: 20      	        DB 00100000b   ; #
0A5D: 20      	        DB 00100000b   ; #
0A5E: 00      	        DB 00000000b   ; 
              	        ;115 s
0A5F: 1C      	        DB 00011100b   ;  ###
0A60: 20      	        DB 00100000b   ; #
0A61: 1C      	        DB 00011100b   ;  ###
0A62: 02      	        DB 00000010b   ;     #
0A63: 3C      	        DB 00111100b   ; ####
0A64: 00      	        DB 00000000b   ; 
              	        ;116 t
0A65: 08      	        DB 00001000b   ;   #
0A66: 1C      	        DB 00011100b   ;  ###
0A67: 08      	        DB 00001000b   ;   #
0A68: 08      	        DB 00001000b   ;   #
0A69: 04      	        DB 00000100b   ;    #
0A6A: 00      	        DB 00000000b   ; 
              	        ;117 u
0A6B: 00      	        DB 00000000b   ; 
0A6C: 22      	        DB 00100010b   ; #   # 
0A6D: 22      	        DB 00100010b   ; #   # 
0A6E: 22      	        DB 00100010b   ; #   # 
0A6F: 1C      	        DB 00011100b   ;  ###
0A70: 00      	        DB 00000000b   ; 
              	        ;118 v
0A71: 00      	        DB 00000000b   ; 
0A72: 22      	        DB 00100010b   ; #   # 
0A73: 22      	        DB 00100010b   ; #   # 
0A74: 14      	        DB 00010100b   ;  # # 
0A75: 08      	        DB 00001000b   ;   #
0A76: 00      	        DB 00000000b   ; 
              	        ;119 w
0A77: 00      	        DB 00000000b   ; 
0A78: 22      	        DB 00100010b   ; #   # 
0A79: 22      	        DB 00100010b   ; #   # 
0A7A: 2A      	        DB 00101010b   ; # # # 
0A7B: 36      	        DB 00110110b   ; ## ##
0A7C: 00      	        DB 00000000b   ; 
              	        ;120 x
0A7D: 00      	        DB 00000000b   ; 
0A7E: 22      	        DB 00100010b   ; #   # 
0A7F: 1C      	        DB 00011100b   ;  ###
0A80: 1C      	        DB 00011100b   ;  ###
0A81: 22      	        DB 00100010b   ; #   # 
0A82: 00      	        DB 00000000b   ; 
              	        ;121 y
0A83: 22      	        DB 00100010b   ; #   # 
0A84: 22      	        DB 00100010b   ; #   # 
0A85: 1E      	        DB 00011110b   ;  ####
0A86: 02      	        DB 00000010b   ;     #
0A87: 3C      	        DB 00111100b   ; ####
0A88: 00      	        DB 00000000b   ; 
              	        ;122 z
0A89: 00      	        DB 00000000b   ; 
0A8A: 3C      	        DB 00111100b   ; #### 
0A8B: 08      	        DB 00001000b   ;   #
0A8C: 10      	        DB 00010000b   ;  #
0A8D: 3C      	        DB 00111100b   ; #### 
0A8E: 00      	        DB 00000000b   ; 
              	        ;123 {
0A8F: 0C      	        DB 00001100b   ;   ##
0A90: 08      	        DB 00001000b   ;   #
0A91: 10      	        DB 00010000b   ;  #
0A92: 08      	        DB 00001000b   ;   #
0A93: 0C      	        DB 00001100b   ;   ##
0A94: 00      	        DB 00000000b   ; 
              	        ;124 |
0A95: 08      	        DB 00001000b   ;   # 
0A96: 08      	        DB 00001000b   ;   # 
0A97: 08      	        DB 00001000b   ;   # 
0A98: 08      	        DB 00001000b   ;   # 
0A99: 08      	        DB 00001000b   ;   # 
0A9A: 00      	        DB 00000000b   ; 
              	        ;125 }
0A9B: 18      	        DB 00011000b   ;  ##
0A9C: 08      	        DB 00001000b   ;   #
0A9D: 04      	        DB 00000100b   ;    #
0A9E: 08      	        DB 00001000b   ;   #
0A9F: 18      	        DB 00011000b   ;  ##
0AA0: 00      	        DB 00000000b   ; 
              	        ;126 ~
0AA1: 14      	        DB 00010100b   ;  # #
0AA2: 28      	        DB 00101000b   ; # #
0AA3: 00      	        DB 00000000b   ; 
0AA4: 00      	        DB 00000000b   ; 
0AA5: 00      	        DB 00000000b   ; 
0AA6: 00      	        DB 00000000b   ; 
              	        ;127 
0AA7: 2A      	        DB 00101010b   ; # # #
0AA8: 15      	        DB 00010101b   ;  # # #
0AA9: 2A      	        DB 00101010b   ; # # #
0AAA: 15      	        DB 00010101b   ;  # # #
0AAB: 2A      	        DB 00101010b   ; # # #
0AAC: 15      	        DB 00010101b   ;  # # #
              	        ;128
0AAD: 00      	        DB 00000000b   ; 
0AAE: 00      	        DB 00000000b   ; 
0AAF: 00      	        DB 00000000b   ; 
0AB0: 00      	        DB 00000000b   ; 
0AB1: 00      	        DB 00000000b   ; 
0AB2: 00      	        DB 00000000b   ; 
              	        ;129
0AB3: 38      	        DB 00111000b   ; ###
0AB4: 38      	        DB 00111000b   ; ###
0AB5: 38      	        DB 00111000b   ; ###
0AB6: 00      	        DB 00000000b   ; 
0AB7: 00      	        DB 00000000b   ; 
0AB8: 00      	        DB 00000000b   ; 
              	        ;130
0AB9: 07      	        DB 00000111b   ;    ###
0ABA: 07      	        DB 00000111b   ;    ###
0ABB: 07      	        DB 00000111b   ;    ###
0ABC: 00      	        DB 00000000b   ; 
0ABD: 00      	        DB 00000000b   ; 
0ABE: 00      	        DB 00000000b   ; 
              	        ;131
0ABF: 3F      	        DB 00111111b   ; ######
0AC0: 3F      	        DB 00111111b   ; ######
0AC1: 3F      	        DB 00111111b   ; ######
0AC2: 00      	        DB 00000000b   ; 
0AC3: 00      	        DB 00000000b   ; 
0AC4: 00      	        DB 00000000b   ; 
              	        ;132
0AC5: 00      	        DB 00000000b   ; 
0AC6: 00      	        DB 00000000b   ; 
0AC7: 00      	        DB 00000000b   ; 
0AC8: 38      	        DB 00111000b   ; ###
0AC9: 38      	        DB 00111000b   ; ###
0ACA: 38      	        DB 00111000b   ; ###
              	        ;133
0ACB: 38      	        DB 00111000b   ; ###
0ACC: 38      	        DB 00111000b   ; ###
0ACD: 38      	        DB 00111000b   ; ###
0ACE: 38      	        DB 00111000b   ; ###
0ACF: 38      	        DB 00111000b   ; ###
0AD0: 38      	        DB 00111000b   ; ###
              	        ;134
0AD1: 07      	        DB 00000111b   ;    ###
0AD2: 07      	        DB 00000111b   ;    ###
0AD3: 07      	        DB 00000111b   ;    ###
0AD4: 38      	        DB 00111000b   ; ###
0AD5: 38      	        DB 00111000b   ; ###
0AD6: 38      	        DB 00111000b   ; ###
              	        ;135
0AD7: 3F      	        DB 00111111b   ; ######
0AD8: 3F      	        DB 00111111b   ; ######
0AD9: 3F      	        DB 00111111b   ; ######
0ADA: 38      	        DB 00111000b   ; ###
0ADB: 38      	        DB 00111000b   ; ###
0ADC: 38      	        DB 00111000b   ; ###
              	        ;136
0ADD: 00      	        DB 00000000b   ; 
0ADE: 00      	        DB 00000000b   ; 
0ADF: 00      	        DB 00000000b   ; 
0AE0: 07      	        DB 00000111b   ;    ###
0AE1: 07      	        DB 00000111b   ;    ###
0AE2: 07      	        DB 00000111b   ;    ###
              	        ;137
0AE3: 38      	        DB 00111000b   ; ###
0AE4: 38      	        DB 00111000b   ; ###
0AE5: 38      	        DB 00111000b   ; ###
0AE6: 07      	        DB 00000111b   ;    ###
0AE7: 07      	        DB 00000111b   ;    ###
0AE8: 07      	        DB 00000111b   ;    ###
              	        ;138
0AE9: 07      	        DB 00000111b   ;    ###
0AEA: 07      	        DB 00000111b   ;    ###
0AEB: 07      	        DB 00000111b   ;    ###
0AEC: 07      	        DB 00000111b   ;    ###
0AED: 07      	        DB 00000111b   ;    ###
0AEE: 07      	        DB 00000111b   ;    ###
              	        ;139
0AEF: 3F      	        DB 00111111b   ; ######
0AF0: 3F      	        DB 00111111b   ; ######
0AF1: 3F      	        DB 00111111b   ; ######
0AF2: 07      	        DB 00000111b   ;    ###
0AF3: 07      	        DB 00000111b   ;    ###
0AF4: 07      	        DB 00000111b   ;    ###
              	        ;140
0AF5: 00      	        DB 00000000b   ; 
0AF6: 00      	        DB 00000000b   ; 
0AF7: 00      	        DB 00000000b   ; 
0AF8: 3F      	        DB 00111111b   ; ######
0AF9: 3F      	        DB 00111111b   ; ######
0AFA: 3F      	        DB 00111111b   ; ######
              	        ;141
0AFB: 38      	        DB 00111000b   ; ###
0AFC: 38      	        DB 00111000b   ; ###
0AFD: 38      	        DB 00111000b   ; ###
0AFE: 3F      	        DB 00111111b   ; ######
0AFF: 3F      	        DB 00111111b   ; ######
0B00: 3F      	        DB 00111111b   ; ######
              	        ;142
0B01: 07      	        DB 00000111b   ;    ###
0B02: 07      	        DB 00000111b   ;    ###
0B03: 07      	        DB 00000111b   ;    ###
0B04: 3F      	        DB 00111111b   ; ######
0B05: 3F      	        DB 00111111b   ; ######
0B06: 3F      	        DB 00111111b   ; ######
              	        ;143
0B07: 3F      	        DB 00111111b   ; ######
0B08: 3F      	        DB 00111111b   ; ######
0B09: 3F      	        DB 00111111b   ; ######
0B0A: 3F      	        DB 00111111b   ; ######
0B0B: 3F      	        DB 00111111b   ; ######
0B0C: 3F      	        DB 00111111b   ; ######
              	        ;144
0B0D: 00      	        DB 00000000b   ; 
0B0E: 00      	        DB 00000000b   ; 
0B0F: 0C      	        DB 00001100b   ;   ##
0B10: 0C      	        DB 00001100b   ;   ##
0B11: 00      	        DB 00000000b   ; 
0B12: 00      	        DB 00000000b   ; 
              	        ;145
0B13: 0C      	        DB 00001100b   ;   ##
0B14: 0C      	        DB 00001100b   ;   ##
0B15: 0C      	        DB 00001100b   ;   ##
0B16: 0C      	        DB 00001100b   ;   ##
0B17: 00      	        DB 00000000b   ; 
0B18: 00      	        DB 00000000b   ; 
              	        ;146
0B19: 00      	        DB 00000000b   ; 
0B1A: 00      	        DB 00000000b   ; 
0B1B: 0F      	        DB 00001111b   ;   ####
0B1C: 0F      	        DB 00001111b   ;   ####
0B1D: 00      	        DB 00000000b   ; 
0B1E: 00      	        DB 00000000b   ; 
              	        ;147
0B1F: 0C      	        DB 00001100b   ;   ##
0B20: 0C      	        DB 00001100b   ;   ##
0B21: 0F      	        DB 00001111b   ;   ####
0B22: 07      	        DB 00000111b   ;    ###
0B23: 00      	        DB 00000000b   ; 
0B24: 00      	        DB 00000000b   ; 
              	        ;148
0B25: 00      	        DB 00000000b   ; 
0B26: 00      	        DB 00000000b   ; 
0B27: 0C      	        DB 00001100b   ;   ##
0B28: 0C      	        DB 00001100b   ;   ##
0B29: 0C      	        DB 00001100b   ;   ##
0B2A: 0C      	        DB 00001100b   ;   ##
              	        ;149
0B2B: 0C      	        DB 00001100b   ;   ##
0B2C: 0C      	        DB 00001100b   ;   ##
0B2D: 0C      	        DB 00001100b   ;   ##
0B2E: 0C      	        DB 00001100b   ;   ##
0B2F: 0C      	        DB 00001100b   ;   ##
0B30: 0C      	        DB 00001100b   ;   ##
              	        ;150
0B31: 00      	        DB 00000000b   ; 
0B32: 00      	        DB 00000000b   ; 
0B33: 07      	        DB 00000111b   ;    ###
0B34: 0F      	        DB 00001111b   ;   ####
0B35: 0C      	        DB 00001100b   ;   ##
0B36: 0C      	        DB 00001100b   ;   ##
              	        ;151
0B37: 0C      	        DB 00001100b   ;   ##
0B38: 0C      	        DB 00001100b   ;   ##
0B39: 0F      	        DB 00001111b   ;   ####
0B3A: 0F      	        DB 00001111b   ;   ####
0B3B: 0C      	        DB 00001100b   ;   ##
0B3C: 0C      	        DB 00001100b   ;   ##
              	        ;152
0B3D: 00      	        DB 00000000b   ; 
0B3E: 00      	        DB 00000000b   ; 
0B3F: 3C      	        DB 00111100b   ; ####
0B40: 3C      	        DB 00111100b   ; ####
0B41: 00      	        DB 00000000b   ; 
0B42: 00      	        DB 00000000b   ; 
              	        ;153
0B43: 0C      	        DB 00001100b   ;   ##
0B44: 0C      	        DB 00001100b   ;   ##
0B45: 3C      	        DB 00111100b   ; ####
0B46: 38      	        DB 00111000b   ; ###
0B47: 00      	        DB 00000000b   ; 
0B48: 00      	        DB 00000000b   ; 
              	        ;154
0B49: 00      	        DB 00000000b   ; 
0B4A: 00      	        DB 00000000b   ; 
0B4B: 3F      	        DB 00111111b   ; ######
0B4C: 3F      	        DB 00111111b   ; ######
0B4D: 00      	        DB 00000000b   ; 
0B4E: 00      	        DB 00000000b   ; 
              	        ;155
0B4F: 0C      	        DB 00001100b   ;   ##
0B50: 0C      	        DB 00001100b   ;   ##
0B51: 3F      	        DB 00111111b   ; ######
0B52: 3F      	        DB 00111111b   ; ######
0B53: 00      	        DB 00000000b   ; 
0B54: 00      	        DB 00000000b   ; 
              	        ;156
0B55: 00      	        DB 00000000b   ; 
0B56: 00      	        DB 00000000b   ; 
0B57: 38      	        DB 00111000b   ; ###
0B58: 3C      	        DB 00111100b   ; ####
0B59: 0C      	        DB 00001100b   ;   ##
0B5A: 0C      	        DB 00001100b   ;   ##
              	        ;157
0B5B: 0C      	        DB 00001100b   ;   ##
0B5C: 0C      	        DB 00001100b   ;   ##
0B5D: 3C      	        DB 00111100b   ; ####
0B5E: 3C      	        DB 00111100b   ; ####
0B5F: 0C      	        DB 00001100b   ;   ##
0B60: 0C      	        DB 00001100b   ;   ##
              	        ;158
0B61: 00      	        DB 00000000b   ; 
0B62: 00      	        DB 00000000b   ; 
0B63: 3F      	        DB 00111111b   ; ######
0B64: 3F      	        DB 00111111b   ; ######
0B65: 0C      	        DB 00001100b   ;   ##
0B66: 0C      	        DB 00001100b   ;   ##
              	        ;159
0B67: 0C      	        DB 00001100b   ;   ##
0B68: 0C      	        DB 00001100b   ;   ##
0B69: 3F      	        DB 00111111b   ; ######
0B6A: 3F      	        DB 00111111b   ; ######
0B6B: 0C      	        DB 00001100b   ;   ##
0B6C: 0C      	        DB 00001100b   ;   ##
              	        ;160
0B6D: 00      	        DB 00000000b   ; 
0B6E: 12      	        DB 00010010b   ;  #  #
0B6F: 00      	        DB 00000000b   ; 
0B70: 00      	        DB 00000000b   ; 
0B71: 12      	        DB 00010010b   ;  #  #
0B72: 00      	        DB 00000000b   ; 
              	        ;161
0B73: 12      	        DB 00010010b   ;  #  #
0B74: 12      	        DB 00010010b   ;  #  #
0B75: 12      	        DB 00010010b   ;  #  #
0B76: 12      	        DB 00010010b   ;  #  #
0B77: 00      	        DB 00000000b   ; 
0B78: 00      	        DB 00000000b   ; 
              	        ;162
0B79: 00      	        DB 00000000b   ; 
0B7A: 0F      	        DB 00001111b   ;   ####
0B7B: 00      	        DB 00000000b   ; 
0B7C: 00      	        DB 00000000b   ; 
0B7D: 0F      	        DB 00001111b   ;   ####
0B7E: 00      	        DB 00000000b   ; 
              	        ;163
0B7F: 12      	        DB 00010010b   ;  #  #
0B80: 13      	        DB 00010011b   ;  #  ##
0B81: 10      	        DB 00010000b   ;  #
0B82: 10      	        DB 00010000b   ;  #
0B83: 0F      	        DB 00001111b   ;   ####
0B84: 00      	        DB 00000000b   ; 
              	        ;164
0B85: 00      	        DB 00000000b   ; 
0B86: 00      	        DB 00000000b   ; 
0B87: 12      	        DB 00010010b   ;  #  #
0B88: 12      	        DB 00010010b   ;  #  #
0B89: 12      	        DB 00010010b   ;  #  #
0B8A: 12      	        DB 00010010b   ;  #  #
              	        ;165
0B8B: 12      	        DB 00010010b   ;  #  #
0B8C: 12      	        DB 00010010b   ;  #  #
0B8D: 12      	        DB 00010010b   ;  #  #
0B8E: 12      	        DB 00010010b   ;  #  #
0B8F: 12      	        DB 00010010b   ;  #  #
0B90: 12      	        DB 00010010b   ;  #  #
              	        ;166
0B91: 00      	        DB 00000000b   ; 
0B92: 0F      	        DB 00001111b   ;   ####
0B93: 10      	        DB 00010000b   ;  #
0B94: 10      	        DB 00010000b   ;  #
0B95: 13      	        DB 00010011b   ;  #  ##
0B96: 12      	        DB 00010010b   ;  #  #
              	        ;167
0B97: 12      	        DB 00010010b   ;  #  #
0B98: 13      	        DB 00010011b   ;  #  ##
0B99: 10      	        DB 00010000b   ;  #
0B9A: 10      	        DB 00010000b   ;  #
0B9B: 13      	        DB 00010011b   ;  #  ##
0B9C: 12      	        DB 00010010b   ;  #  #
              	        ;168
0B9D: 00      	        DB 00000000b   ; 
0B9E: 3C      	        DB 00111100b   ; ####
0B9F: 00      	        DB 00000000b   ; 
0BA0: 00      	        DB 00000000b   ; 
0BA1: 3C      	        DB 00111100b   ; ####
0BA2: 00      	        DB 00000000b   ; 
              	        ;169
0BA3: 12      	        DB 00010010b   ;  #  #
0BA4: 32      	        DB 00110010b   ; ##  #
0BA5: 02      	        DB 00000010b   ;     #
0BA6: 02      	        DB 00000010b   ;     #
0BA7: 3C      	        DB 00111100b   ; ####
0BA8: 00      	        DB 00000000b   ; 
              	        ;170
0BA9: 00      	        DB 00000000b   ; 
0BAA: 3F      	        DB 00111111b   ; ######
0BAB: 00      	        DB 00000000b   ; 
0BAC: 00      	        DB 00000000b   ; 
0BAD: 3F      	        DB 00111111b   ; ######
0BAE: 00      	        DB 00000000b   ; 
              	        ;171
0BAF: 12      	        DB 00010010b   ;  #  #
0BB0: 33      	        DB 00110011b   ; ##  ##
0BB1: 00      	        DB 00000000b   ; 
0BB2: 00      	        DB 00000000b   ; 
0BB3: 3F      	        DB 00111111b   ; ######
0BB4: 00      	        DB 00000000b   ; 
              	        ;172
0BB5: 00      	        DB 00000000b   ; 
0BB6: 3C      	        DB 00111100b   ; ####
0BB7: 02      	        DB 00000010b   ;     #
0BB8: 02      	        DB 00000010b   ;     #
0BB9: 32      	        DB 00110010b   ; ##  #
0BBA: 12      	        DB 00010010b   ;  #  #
              	        ;173
0BBB: 12      	        DB 00010010b   ;  #  #
0BBC: 32      	        DB 00110010b   ; ##  #
0BBD: 02      	        DB 00000010b   ;     #
0BBE: 02      	        DB 00000010b   ;     #
0BBF: 32      	        DB 00110010b   ; ##  #
0BC0: 12      	        DB 00010010b   ;  #  #
              	        ;174
0BC1: 00      	        DB 00000000b   ; 
0BC2: 3F      	        DB 00111111b   ; ######
0BC3: 00      	        DB 00000000b   ; 
0BC4: 00      	        DB 00000000b   ; 
0BC5: 33      	        DB 00110011b   ; ##  ##
0BC6: 12      	        DB 00010010b   ;  #  #
              	        ;175
0BC7: 12      	        DB 00010010b   ;  #  #
0BC8: 33      	        DB 00110011b   ; ##  ##
0BC9: 00      	        DB 00000000b   ; 
0BCA: 00      	        DB 00000000b   ; 
0BCB: 33      	        DB 00110011b   ; ##  ##
0BCC: 12      	        DB 00010010b   ;  #  #
              	        ;176
0BCD: 0C      	        DB 00001100b   ;   ##
0BCE: 18      	        DB 00011000b   ;  ##
0BCF: 30      	        DB 00110000b   ; ##
0BD0: 20      	        DB 00100000b   ; #
0BD1: 00      	        DB 00000000b   ; 
0BD2: 00      	        DB 00000000b   ; 
              	        ;177
0BD3: 0C      	        DB 00001100b   ;   ##
0BD4: 06      	        DB 00000110b   ;    ##
0BD5: 03      	        DB 00000011b   ;     ##
0BD6: 01      	        DB 00000001b   ;      #
0BD7: 00      	        DB 00000000b   ; 
0BD8: 00      	        DB 00000000b   ; 
              	        ;178
0BD9: 00      	        DB 00000000b   ; 
0BDA: 00      	        DB 00000000b   ; 
0BDB: 01      	        DB 00000001b   ;      #
0BDC: 03      	        DB 00000011b   ;     ##
0BDD: 06      	        DB 00000110b   ;    ##
0BDE: 0C      	        DB 00001100b   ;   ##
              	        ;179
0BDF: 00      	        DB 00000000b   ; 
0BE0: 00      	        DB 00000000b   ; 
0BE1: 20      	        DB 00100000b   ; #
0BE2: 30      	        DB 00110000b   ; ##
0BE3: 18      	        DB 00011000b   ;  ##
0BE4: 0C      	        DB 00001100b   ;   ##
              	        ;180
0BE5: 0C      	        DB 00001100b   ;   ##
0BE6: 1E      	        DB 00011110b   ;  ####
0BE7: 33      	        DB 00110011b   ; ##  ##
0BE8: 21      	        DB 00100001b   ; #    # 
0BE9: 00      	        DB 00000000b   ; 
0BEA: 00      	        DB 00000000b   ; 
              	        ;181
0BEB: 0C      	        DB 00001100b   ;   ##
0BEC: 06      	        DB 00000110b   ;    ##
0BED: 03      	        DB 00000011b   ;     ##
0BEE: 03      	        DB 00000011b   ;     ##
0BEF: 06      	        DB 00000110b   ;    ##
0BF0: 0C      	        DB 00001100b   ;   ##
              	        ;182
0BF1: 00      	        DB 00000000b   ; 
0BF2: 00      	        DB 00000000b   ; 
0BF3: 21      	        DB 00100001b   ; #    # 
0BF4: 33      	        DB 00110011b   ; ##  ##
0BF5: 1E      	        DB 00011110b   ;  ####
0BF6: 0C      	        DB 00001100b   ;   ##
              	        ;183
0BF7: 0C      	        DB 00001100b   ;   ##
0BF8: 18      	        DB 00011000b   ;  ##
0BF9: 30      	        DB 00110000b   ; ##
0BFA: 30      	        DB 00110000b   ; ##
0BFB: 18      	        DB 00011000b   ;  ##
0BFC: 0C      	        DB 00001100b   ;   ##
              	        ;184
0BFD: 0C      	        DB 00001100b   ;   ##
0BFE: 18      	        DB 00011000b   ;  ##
0BFF: 31      	        DB 00110001b   ; ##   #
0C00: 23      	        DB 00100011b   ; #   ##
0C01: 06      	        DB 00000110b   ;    ##
0C02: 0C      	        DB 00001100b   ;   ##
              	        ;185
0C03: 0C      	        DB 00001100b   ;   ##
0C04: 06      	        DB 00000110b   ;    ##
0C05: 23      	        DB 00100011b   ; #   ##
0C06: 31      	        DB 00110001b   ; ##   #
0C07: 18      	        DB 00011000b   ;  ##
0C08: 0C      	        DB 00001100b   ;   ##
              	        ;186
0C09: 0C      	        DB 00001100b   ;   ##
0C0A: 1E      	        DB 00011110b   ;  ####
0C0B: 33      	        DB 00110011b   ; ##  ##
0C0C: 33      	        DB 00110011b   ; ##  ##
0C0D: 1E      	        DB 00011110b   ;  ####
0C0E: 0C      	        DB 00001100b   ;   ##
              	        ;187
0C0F: 33      	        DB 00110011b   ; ##  ##
0C10: 33      	        DB 00110011b   ; ##  ##
0C11: 0C      	        DB 00001100b   ;   ##
0C12: 0C      	        DB 00001100b   ;   ##
0C13: 33      	        DB 00110011b   ; ##  ##
0C14: 33      	        DB 00110011b   ; ##  ##
              	        ;188
0C15: 03      	        DB 00000011b   ;     ##
0C16: 03      	        DB 00000011b   ;     ##
0C17: 0C      	        DB 00001100b   ;   ##
0C18: 0C      	        DB 00001100b   ;   ##
0C19: 30      	        DB 00110000b   ; ##
0C1A: 30      	        DB 00110000b   ; ##
              	        ;189
0C1B: 30      	        DB 00110000b   ; ##
0C1C: 30      	        DB 00110000b   ; ##
0C1D: 0C      	        DB 00001100b   ;   ##
0C1E: 0C      	        DB 00001100b   ;   ##
0C1F: 03      	        DB 00000011b   ;     ##
0C20: 03      	        DB 00000011b   ;     ##
              	        ;190
0C21: 2A      	        DB 00101010b   ; # # #
0C22: 14      	        DB 00010100b   ;  # #
0C23: 2A      	        DB 00101010b   ; # # #
0C24: 14      	        DB 00010100b   ;  # #
0C25: 2A      	        DB 00101010b   ; # # #
0C26: 00      	        DB 00000000b   ; 
              	        ;191
0C27: 14      	        DB 00010100b   ;  # #
0C28: 2A      	        DB 00101010b   ; # # #
0C29: 14      	        DB 00010100b   ;  # #
0C2A: 2A      	        DB 00101010b   ; # # #
0C2B: 14      	        DB 00010100b   ;  # #
0C2C: 00      	        DB 00000000b   ; 
              	        ;192
0C2D: 00      	        DB 00000000b   ; 
0C2E: 1A      	        DB 00011010b   ;  ## #
0C2F: 24      	        DB 00100100b   ; #  #
0C30: 24      	        DB 00100100b   ; #  #
0C31: 1A      	        DB 00011010b   ;  ## #
0C32: 00      	        DB 00000000b   ; 
              	        ;193
0C33: 18      	        DB 00011000b   ;  ##
0C34: 24      	        DB 00100100b   ; #  #
0C35: 2C      	        DB 00101100b   ; # ##
0C36: 22      	        DB 00100010b   ; #   #
0C37: 2C      	        DB 00101100b   ; # ##
0C38: 00      	        DB 00000000b   ; 
              	        ;194
0C39: 00      	        DB 00000000b   ; 
0C3A: 22      	        DB 00100010b   ; #   #
0C3B: 1C      	        DB 00011100b   ;  ###
0C3C: 22      	        DB 00100010b   ; #   #
0C3D: 1C      	        DB 00011100b   ;  ###
0C3E: 00      	        DB 00000000b   ; 
              	        ;195
0C3F: 1C      	        DB 00011100b   ;  ###
0C40: 30      	        DB 00110000b   ; ##
0C41: 1C      	        DB 00011100b   ;  ###
0C42: 22      	        DB 00100010b   ; #   #
0C43: 1C      	        DB 00011100b   ;  ### 
0C44: 00      	        DB 00000000b   ; 
              	        ;196
0C45: 0E      	        DB 00001110b   ;   ### 
0C46: 30      	        DB 00110000b   ; ##
0C47: 3C      	        DB 00111100b   ; ####
0C48: 30      	        DB 00110000b   ; ##
0C49: 0E      	        DB 00001110b   ;   ###
0C4A: 00      	        DB 00000000b   ; 
              	        ;197
0C4B: 1C      	        DB 00011100b   ;  ###
0C4C: 22      	        DB 00100010b   ; #   #
0C4D: 3E      	        DB 00111110b   ; #####
0C4E: 22      	        DB 00100010b   ; #   #
0C4F: 1C      	        DB 00011100b   ;  ###
0C50: 00      	        DB 00000000b   ; 
              	        ;198
0C51: 20      	        DB 00100000b   ; #
0C52: 10      	        DB 00010000b   ;  #
0C53: 08      	        DB 00001000b   ;   #
0C54: 14      	        DB 00010100b   ;  # #
0C55: 22      	        DB 00100010b   ; #   # 
0C56: 00      	        DB 00000000b   ; 
              	        ;199
0C57: 24      	        DB 00100100b   ; #  #
0C58: 24      	        DB 00100100b   ; #  #
0C59: 38      	        DB 00111000b   ; ###
0C5A: 20      	        DB 00100000b   ; #
0C5B: 20      	        DB 00100000b   ; # 
0C5C: 00      	        DB 00000000b   ; 
              	        ;200
0C5D: 00      	        DB 00000000b   ; 
0C5E: 3E      	        DB 00111110b   ; #####
0C5F: 14      	        DB 00010100b   ;  # #
0C60: 14      	        DB 00010100b   ;  # #
0C61: 24      	        DB 00100100b   ; #  #
0C62: 00      	        DB 00000000b   ; 
              	        ;201
0C63: 00      	        DB 00000000b   ; 
0C64: 1E      	        DB 00011110b   ;  ####
0C65: 34      	        DB 00110100b   ; ## #
0C66: 34      	        DB 00110100b   ; ## #
0C67: 18      	        DB 00011000b   ;  ##
0C68: 00      	        DB 00000000b   ; 
              	        ;202
0C69: 06      	        DB 00000110b   ;    ##
0C6A: 1C      	        DB 00011100b   ;  ###
0C6B: 36      	        DB 00110110b   ; ## ##
0C6C: 1C      	        DB 00011100b   ;  ###
0C6D: 30      	        DB 00110000b   ; ##
0C6E: 00      	        DB 00000000b   ; 
              	        ;203
0C6F: 06      	        DB 00000110b   ;    ##
0C70: 04      	        DB 00000100b   ;    #
0C71: 36      	        DB 00110110b   ; ## ##
0C72: 1C      	        DB 00011100b   ;  ###
0C73: 30      	        DB 00110000b   ; ##
0C74: 00      	        DB 00000000b   ; 
              	        ;204
0C75: 32      	        DB 00110010b   ; ##  #
0C76: 1C      	        DB 00011100b   ;  ###
0C77: 0C      	        DB 00001100b   ;   ##
0C78: 16      	        DB 00010110b   ;  # ##
0C79: 22      	        DB 00100010b   ; #   #
0C7A: 00      	        DB 00000000b   ; 
              	        ;205
0C7B: 00      	        DB 00000000b   ; 
0C7C: 14      	        DB 00010100b   ;  # #
0C7D: 22      	        DB 00100010b   ; #   #
0C7E: 2A      	        DB 00101010b   ; # # #
0C7F: 1C      	        DB 00011100b   ;  ###
0C80: 00      	        DB 00000000b   ; 
              	        ;206
0C81: 3E      	        DB 00111110b   ; #####
0C82: 12      	        DB 00010010b   ;  #  #
0C83: 08      	        DB 00001000b   ;   #
0C84: 12      	        DB 00010010b   ;  #  #
0C85: 3E      	        DB 00111110b   ; #####
0C86: 00      	        DB 00000000b   ; 
              	        ;207
0C87: 1C      	        DB 00011100b   ;  ###
0C88: 22      	        DB 00100010b   ; #   #
0C89: 22      	        DB 00100010b   ; #   #
0C8A: 14      	        DB 00010100b   ;  # #
0C8B: 36      	        DB 00110110b   ; ## ##
0C8C: 00      	        DB 00000000b   ; 
              	        ;208
0C8D: 1C      	        DB 00011100b   ;  ###
0C8E: 1C      	        DB 00011100b   ;  ###
0C8F: 0A      	        DB 00001010b   ;   # #
0C90: 1C      	        DB 00011100b   ;  ###
0C91: 28      	        DB 00101000b   ; # #
0C92: 08      	        DB 00001000b   ;   #
              	        ;209
0C93: 1C      	        DB 00011100b   ;  ###
0C94: 1C      	        DB 00011100b   ;  ###
0C95: 28      	        DB 00101000b   ; # #
0C96: 1C      	        DB 00011100b   ;  ###
0C97: 0A      	        DB 00001010b   ;   # #
0C98: 08      	        DB 00001000b   ;   #
              	        ;210
0C99: 1C      	        DB 00011100b   ;  ###
0C9A: 1C      	        DB 00011100b   ;  ###
0C9B: 2A      	        DB 00101010b   ; # # #
0C9C: 1C      	        DB 00011100b   ;  ###
0C9D: 08      	        DB 00001000b   ;   # 
0C9E: 08      	        DB 00001000b   ;   #
              	        ;211
0C9F: 1C      	        DB 00011100b   ;  ###
0CA0: 1C      	        DB 00011100b   ;  ###
0CA1: 08      	        DB 00001000b   ;   # 
0CA2: 1C      	        DB 00011100b   ;  ###
0CA3: 2A      	        DB 00101010b   ; # # #
0CA4: 08      	        DB 00001000b   ;   #
              	        ;212
0CA5: 14      	        DB 00010100b   ;  # # 
0CA6: 00      	        DB 00000000b   ; 
0CA7: 14      	        DB 00010100b   ;  # # 
0CA8: 14      	        DB 00010100b   ;  # # 
0CA9: 1C      	        DB 00011100b   ;  ###
0CAA: 00      	        DB 00000000b   ; 
              	        ;213
0CAB: 14      	        DB 00010100b   ;  # # 
0CAC: 00      	        DB 00000000b   ; 
0CAD: 1C      	        DB 00011100b   ;  ###
0CAE: 14      	        DB 00010100b   ;  # # 
0CAF: 1C      	        DB 00011100b   ;  ###
0CB0: 00      	        DB 00000000b   ; 
              	        ;214
0CB1: 14      	        DB 00010100b   ;  # # 
0CB2: 00      	        DB 00000000b   ; 
0CB3: 1C      	        DB 00011100b   ;  ###
0CB4: 14      	        DB 00010100b   ;  # # 
0CB5: 1E      	        DB 00011110b   ;  ####
0CB6: 00      	        DB 00000000b   ; 
              	        ;215
0CB7: 14      	        DB 00010100b   ;  # # 
0CB8: 00      	        DB 00000000b   ; 
0CB9: 1C      	        DB 00011100b   ;  ###
0CBA: 14      	        DB 00010100b   ;  # # 
0CBB: 14      	        DB 00010100b   ;  # # 
0CBC: 00      	        DB 00000000b   ; 
              	        ;216
0CBD: 28      	        DB 00101000b   ; # #
0CBE: 2C      	        DB 00101100b   ; # ## 
0CBF: 3E      	        DB 00111110b   ; ##### 
0CC0: 0C      	        DB 00001100b   ;   ## 
0CC1: 08      	        DB 00001000b   ;   #
0CC2: 00      	        DB 00000000b   ; 
              	        ;217
0CC3: 0A      	        DB 00001010b   ;   # #
0CC4: 1A      	        DB 00011010b   ;  ## #
0CC5: 3E      	        DB 00111110b   ; #####
0CC6: 18      	        DB 00011000b   ;  ## 
0CC7: 08      	        DB 00001000b   ;   #
0CC8: 00      	        DB 00000000b   ; 
              	        ;218
0CC9: 08      	        DB 00001000b   ;   #
0CCA: 1C      	        DB 00011100b   ;  ###
0CCB: 08      	        DB 00001000b   ;   #
0CCC: 00      	        DB 00000000b   ;  
0CCD: 1C      	        DB 00011100b   ;  ###
0CCE: 00      	        DB 00000000b   ;
              	        ;219
0CCF: 08      	        DB 00001000b   ;   #
0CD0: 00      	        DB 00000000b   ; 
0CD1: 3E      	        DB 00111110b   ; #####
0CD2: 00      	        DB 00000000b   ;
0CD3: 08      	        DB 00001000b   ;   #
0CD4: 00      	        DB 00000000b   ;
              	        ;220
0CD5: 04      	        DB 00000100b   ;    #
0CD6: 08      	        DB 00001000b   ;   # 
0CD7: 10      	        DB 00010000b   ;  #
0CD8: 08      	        DB 00001000b   ;   # 
0CD9: 1C      	        DB 00011100b   ;  ###
0CDA: 00      	        DB 00000000b   ; 
              	        ;221
0CDB: 10      	        DB 00010000b   ;  #
0CDC: 08      	        DB 00001000b   ;   # 
0CDD: 04      	        DB 00000100b   ;    #
0CDE: 08      	        DB 00001000b   ;   # 
0CDF: 1C      	        DB 00011100b   ;  ###
0CE0: 00      	        DB 00000000b   ; 
              	        ;222
0CE1: 1C      	        DB 00011100b   ;  ###
0CE2: 00      	        DB 00000000b   ; 
0CE3: 1C      	        DB 00011100b   ;  ###
0CE4: 00      	        DB 00000000b   ; 
0CE5: 1C      	        DB 00011100b   ;  ###
0CE6: 00      	        DB 00000000b   ; 
              	        ;223
0CE7: 06      	        DB 00000110b   ;    ## 
0CE8: 04      	        DB 00000100b   ;    # 
0CE9: 34      	        DB 00110100b   ; ## #
0CEA: 14      	        DB 00010100b   ;  # # 
0CEB: 08      	        DB 00001000b   ;   # 
0CEC: 00      	        DB 00000000b   ; 
              	        ;224
0CED: 1E      	        DB 00011110b   ;  #### 
0CEE: 0E      	        DB 00001110b   ;   ### 
0CEF: 0E      	        DB 00001110b   ;   ### 
0CF0: 12      	        DB 00010010b   ;  #  #
0CF1: 20      	        DB 00100000b   ; # 
0CF2: 00      	        DB 00000000b   ; 
              	        ;225
0CF3: 20      	        DB 00100000b   ; #
0CF4: 12      	        DB 00010010b   ;  #  #
0CF5: 0E      	        DB 00001110b   ;   ###
0CF6: 0E      	        DB 00001110b   ;   ###
0CF7: 1E      	        DB 00011110b   ;  ####
0CF8: 00      	        DB 00000000b   ; 
              	        ;226
0CF9: 02      	        DB 00000010b   ;      #
0CFA: 24      	        DB 00100100b   ;  #  #
0CFB: 38      	        DB 00111000b   ;  ###
0CFC: 38      	        DB 00111000b   ;  ###
0CFD: 3C      	        DB 00111100b   ;  #### 
0CFE: 00      	        DB 00000000b   ; 
              	        ;227
0CFF: 3C      	        DB 00111100b   ; ####
0D00: 38      	        DB 00111000b   ; ###
0D01: 38      	        DB 00111000b   ; ###
0D02: 24      	        DB 00100100b   ; #  # 
0D03: 02      	        DB 00000010b   ;     #
0D04: 00      	        DB 00000000b   ; 
              	        ;228
0D05: 3E      	        DB 00111110b   ; #####
0D06: 22      	        DB 00100010b   ; #   #
0D07: 22      	        DB 00100010b   ; #   #
0D08: 22      	        DB 00100010b   ; #   #
0D09: 3E      	        DB 00111110b   ; #####
0D0A: 00      	        DB 00000000b   ; 
              	        ;229
0D0B: 3E      	        DB 00111110b   ; #####
0D0C: 26      	        DB 00100110b   ; #  ##
0D0D: 2A      	        DB 00101010b   ; # # #
0D0E: 32      	        DB 00110010b   ; ##  #
0D0F: 3E      	        DB 00111110b   ; #####
0D10: 00      	        DB 00000000b   ; 
              	        ;230
0D11: 08      	        DB 00001000b   ;   # 
0D12: 12      	        DB 00010010b   ;  #  #
0D13: 24      	        DB 00100100b   ; #  #
0D14: 12      	        DB 00010010b   ;  #  #
0D15: 08      	        DB 00001000b   ;   # 
0D16: 00      	        DB 00000000b   ; 
              	        ;231
0D17: 08      	        DB 00001000b   ;   # 
0D18: 24      	        DB 00100100b   ; #  #
0D19: 12      	        DB 00010010b   ;  #  #
0D1A: 24      	        DB 00100100b   ; #  #
0D1B: 08      	        DB 00001000b   ;   # 
0D1C: 00      	        DB 00000000b   ; 
              	        ;232 TEC-1G
0D1D: 1D      	        DB 00011101b   ;  ### #
0D1E: 08      	        DB 00001000b   ;   #
0D1F: 09      	        DB 00001001b   ;   #  #
0D20: 08      	        DB 00001000b   ;   #
0D21: 09      	        DB 00001001b   ;   #  #
0D22: 00      	        DB 00000000b   ; 
              	        ;233 TEC-1G
0D23: 37      	        DB 00110111b   ; ## ###
0D24: 04      	        DB 00000100b   ;    #
0D25: 34      	        DB 00110100b   ; ## #
0D26: 04      	        DB 00000100b   ;    #
0D27: 37      	        DB 00110111b   ; ## ###
0D28: 00      	        DB 00000000b   ; 
              	        ;234 TEC-1G
0D29: 00      	        DB 00000000b   ; 
0D2A: 01      	        DB 00000001b   ;      #
0D2B: 1C      	        DB 00011100b   ;  ###
0D2C: 00      	        DB 00000000b   ; 
0D2D: 00      	        DB 00000000b   ; 
0D2E: 00      	        DB 00000000b   ; 
              	        ;235 TEC-1G
0D2F: 2E      	        DB 00101110b   ; # ###
0D30: 28      	        DB 00101000b   ; # #
0D31: 2A      	        DB 00101010b   ; # # #
0D32: 2A      	        DB 00101010b   ; # # #
0D33: 2E      	        DB 00101110b   ; # ###
0D34: 00      	        DB 00000000b   ; 
              	        ;236 Z80
0D35: 1D      	        DB 00011101b   ;  ### #
0D36: 05      	        DB 00000101b   ;    # #
0D37: 09      	        DB 00001001b   ;   #  #
0D38: 11      	        DB 00010001b   ;  #   #
0D39: 1D      	        DB 00011101b   ;  ### #
0D3A: 00      	        DB 00000000b   ; 
              	        ;237 Z80
0D3B: 37      	        DB 00110111b   ; ## ###
0D3C: 15      	        DB 00010101b   ;  # # #
0D3D: 35      	        DB 00110101b   ; ## # #
0D3E: 15      	        DB 00010101b   ;  # # #
0D3F: 37      	        DB 00110111b   ; ## ###
0D40: 00      	        DB 00000000b   ; 
              	        ;238 CPU
0D41: 1D      	        DB 00011101b   ;  ### #
0D42: 11      	        DB 00010001b   ;  #   #
0D43: 11      	        DB 00010001b   ;  #   #
0D44: 11      	        DB 00010001b   ;  #   #
0D45: 1D      	        DB 00011101b   ;  ### #
0D46: 00      	        DB 00000000b   ; 
              	        ;239 CPU
0D47: 35      	        DB 00110101b   ; ## # #
0D48: 15      	        DB 00010101b   ;  # # #
0D49: 35      	        DB 00110101b   ; ## # #
0D4A: 05      	        DB 00000101b   ;    # #
0D4B: 07      	        DB 00000111b   ;    ###
0D4C: 00      	        DB 00000000b   ; 
              	        ;240
0D4D: 00      	        DB 00000000b   ; 
0D4E: 00      	        DB 00000000b   ; 
0D4F: 00      	        DB 00000000b   ; 
0D50: 00      	        DB 00000000b   ; 
0D51: 00      	        DB 00000000b   ; 
0D52: 00      	        DB 00000000b   ; 
              	        ;241
0D53: 00      	        DB 00000000b   ; 
0D54: 00      	        DB 00000000b   ; 
0D55: 00      	        DB 00000000b   ; 
0D56: 00      	        DB 00000000b   ; 
0D57: 00      	        DB 00000000b   ; 
0D58: 00      	        DB 00000000b   ; 
              	        ;242
0D59: 00      	        DB 00000000b   ; 
0D5A: 00      	        DB 00000000b   ; 
0D5B: 00      	        DB 00000000b   ; 
0D5C: 00      	        DB 00000000b   ; 
0D5D: 00      	        DB 00000000b   ; 
0D5E: 00      	        DB 00000000b   ; 
              	        ;243
0D5F: 00      	        DB 00000000b   ; 
0D60: 00      	        DB 00000000b   ; 
0D61: 00      	        DB 00000000b   ; 
0D62: 00      	        DB 00000000b   ; 
0D63: 00      	        DB 00000000b   ; 
0D64: 00      	        DB 00000000b   ; 
              	        ;244
0D65: 00      	        DB 00000000b   ; 
0D66: 00      	        DB 00000000b   ; 
0D67: 00      	        DB 00000000b   ; 
0D68: 00      	        DB 00000000b   ; 
0D69: 00      	        DB 00000000b   ; 
0D6A: 00      	        DB 00000000b   ; 
              	        ;245
0D6B: 00      	        DB 00000000b   ; 
0D6C: 00      	        DB 00000000b   ; 
0D6D: 00      	        DB 00000000b   ; 
0D6E: 00      	        DB 00000000b   ; 
0D6F: 00      	        DB 00000000b   ; 
0D70: 00      	        DB 00000000b   ; 
              	        ;246
0D71: 00      	        DB 00000000b   ; 
0D72: 00      	        DB 00000000b   ; 
0D73: 00      	        DB 00000000b   ; 
0D74: 00      	        DB 00000000b   ; 
0D75: 00      	        DB 00000000b   ; 
0D76: 00      	        DB 00000000b   ; 
              	        ;247
0D77: 00      	        DB 00000000b   ; 
0D78: 00      	        DB 00000000b   ; 
0D79: 00      	        DB 00000000b   ; 
0D7A: 00      	        DB 00000000b   ; 
0D7B: 00      	        DB 00000000b   ; 
0D7C: 00      	        DB 00000000b   ; 
              	        ;248
0D7D: 00      	        DB 00000000b   ; 
0D7E: 00      	        DB 00000000b   ; 
0D7F: 00      	        DB 00000000b   ; 
0D80: 00      	        DB 00000000b   ; 
0D81: 00      	        DB 00000000b   ; 
0D82: 00      	        DB 00000000b   ; 
              	        ;249
0D83: 00      	        DB 00000000b   ; 
0D84: 00      	        DB 00000000b   ; 
0D85: 00      	        DB 00000000b   ; 
0D86: 00      	        DB 00000000b   ; 
0D87: 00      	        DB 00000000b   ; 
0D88: 00      	        DB 00000000b   ; 
              	        ;250
0D89: 00      	        DB 00000000b   ; 
0D8A: 00      	        DB 00000000b   ; 
0D8B: 00      	        DB 00000000b   ; 
0D8C: 00      	        DB 00000000b   ; 
0D8D: 00      	        DB 00000000b   ; 
0D8E: 00      	        DB 00000000b   ; 
              	        ;251
0D8F: 00      	        DB 00000000b   ; 
0D90: 00      	        DB 00000000b   ; 
0D91: 00      	        DB 00000000b   ; 
0D92: 00      	        DB 00000000b   ; 
0D93: 00      	        DB 00000000b   ; 
0D94: 00      	        DB 00000000b   ; 
              	        ;252
0D95: 00      	        DB 00000000b   ; 
0D96: 00      	        DB 00000000b   ; 
0D97: 00      	        DB 00000000b   ; 
0D98: 00      	        DB 00000000b   ; 
0D99: 00      	        DB 00000000b   ; 
0D9A: 00      	        DB 00000000b   ; 
              	        ;253
0D9B: 00      	        DB 00000000b   ; 
0D9C: 00      	        DB 00000000b   ; 
0D9D: 00      	        DB 00000000b   ; 
0D9E: 00      	        DB 00000000b   ; 
0D9F: 00      	        DB 00000000b   ; 
0DA0: 00      	        DB 00000000b   ; 
              	        ;254
0DA1: 00      	        DB 00000000b   ; 
0DA2: 00      	        DB 00000000b   ; 
0DA3: 00      	        DB 00000000b   ; 
0DA4: 00      	        DB 00000000b   ; 
0DA5: 00      	        DB 00000000b   ; 
0DA6: 00      	        DB 00000000b   ; 
              	        ;255
0DA7: 00      	        DB 00000000b   ; 
0DA8: 00      	        DB 00000000b   ; 
0DA9: 00      	        DB 00000000b   ; 
0DAA: 00      	        DB 00000000b   ; 
0DAB: 00      	        DB 00000000b   ; 
0DAC: 00      	        DB 00000000b   ; 
              	        ;256
0DAD: 00      	        DB 00000000b   ; 
0DAE: 00      	        DB 00000000b   ; 
0DAF: 00      	        DB 00000000b   ; 
0DB0: 00      	        DB 00000000b   ; 
0DB1: 00      	        DB 00000000b   ; 
0DB2: 01      	        DB 00000001b   ;      #
              	        
              	
              	;    JP INIT_LCD             ;Initalise the LCD
              	;    JP CLEAR_GBUF           ;Clear the Graphics Buffer
              	;    JP CLEAR_GR_LCD         ;Clear the Graphics LCD Screen
              	;    JP CLEAR_TXT_LCD        ;Clear the Text LCD Screen
              	;    JP SET_GR_MODE          ;Set Graphics Mode
              	;    JP SET_TXT_MODE         ;Set Text Mode
              	;    JP DRAW_BOX             ;Draw a rectangle between two points
              	;    JP DRAW_LINE            ;Draw a line between two points
              	;    JP DRAW_CIRCLE          ;Draw a circle from Mid X,Y to Radius
              	;    JP DRAW_PIXEL           ;Draw one pixel at X,Y
              	;    JP FILL_BOX             ;Draw a filled rectangle between two points
              	;    JP FILL_CIRCLE          ;Draw a filled circle from Mid X,Y to Radius
              	;    JP PLOT_TO_LCD          ;Display the Graphics Buffer to the LCD Screen
              	;    JP PRINT_STRING         ;Print Text on the screen in a given row
              	;    JP PRINT_CHARS          ;Print Characters on the screen in a given row and column
              	;    JP DELAY_US             ;Microsecond delay for LCD updates
              	;    JP DELAY_MS             ;Millisecond delay for LCD updates
              	;    JP SET_BUF_CLEAR        ;Clear the Graphics buffer on after Plotting to the screen
              	;    JP SET_BUF_NO_CLEAR     ;Retain the Graphics buffer on after Plotting to the screen
              	;    JP CLEAR_PIXEL          ;Remove a Pixel at X,Y
              	;    JP FLIP_PIXEL           ;Flip a Pixel On/Off at X,Y
              	;    JP LCD_INST             ;Send a parallel or serial instruction to LCD
              	;    JP LCD_DATA             ;Send a parallel or serial datum to LCD
              	;    JP SER_SYNC             ;Send serial synchronise byte to LCD
              	;    JP DRAW_GRAPHIC         ;Draw an ASCII charcter or Sprite to the LCD
              	;    JP INV_GRAPHIC          ;Inverse graphics printing
              	;    JP INIT_TERMINAL        ;Initialize the LCD for terminal emulation
              	;    JP SEND_CHAR_TO_GLCD    ;Send an ASCII Character to the LCD
              	;    JP SEND_STRING_TO_GLCD  ;Send an ASCII String to the LCD
              	;    JP SEND_A_TO_GLCD       ;Send register A to the LCD
              	;    JP SEND_HL_TO_GLCD      ;Send register HL to the LCD
              	;    JP SET_CURSOR           ;Set the graphics cursor
              	;    JP GET_CURSOR           ;Get the current cursor
              	;    JP DISPLAY_CURSOR       ;Set Cursor on or off
              	#include "I2C.asm"
              	; **********************************************************************
              	; I2C support functions
              	
              	; I2C bus open device
              	;   On entry: A = Device address (bit zero is read flag)
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             BC DE HL IX IY preserved
0DB3: F5      	I2C_Open:   PUSH AF
0DB4: CD270E  	            CALL I2C_Start      ;Output start condition
0DB7: F1      	            POP  AF
0DB8: 1803    	            JR   I2C_Write      ;Write data byte
              	
              	
              	; I2C bus close device
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A=0 and Z flagged
              	;             If unsuccessfully A=Error and NZ flagged
              	;             SCL = hi, SDA = hi
              	;             BC DE HL IX IY preserved
0DBA: C3320E  	I2C_Close:  JP   I2C_Stop       ;Output stop condition
              	
              	
              	; **********************************************************************
              	; **********************************************************************
              	; I2C bus master driver
              	; **********************************************************************
              	; **********************************************************************
              	
              	; Functions provided are:
              	;     I2C_Start
              	;     I2C_Stop
              	;     I2C_Read
              	;     I2C_Write
              	;
              	; This code has delays between all I/O operations to ensure it works
              	; with the slowest I2C devices
              	;
              	; I2C transfer sequence
              	;   +-------+  +---------+  +---------+     +---------+  +-------+
              	;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
              	;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
              	;   +-------+  +---------+  +---------+     +---------+  +-------+
              	;
              	;
              	; Start condition                     Stop condition
              	; Output by master device             Output by master device
              	;       ----+                                      +----
              	; SDA       |                         SDA          |
              	;           +-------                        -------+
              	;       -------+                                +-------
              	; SCL          |                      SCL       |
              	;              +----                        ----+
              	;
              	;
              	; Address frame
              	; Clock and data output from master device
              	; Receiving device outputs acknowledge 
              	;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
              	; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
              	;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
              	;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
              	; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
              	;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
              	;
              	;
              	; Data frame 
              	; Clock output by master device
              	; Data output by transmitting device
              	; Receiving device outputs acknowledge 
              	;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
              	; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
              	;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
              	;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
              	; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
              	;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
              	;
              	
              	
              	; **********************************************************************
              	; I2C constants
              	
              	
              	; I2C bus master interface
              	; The default device option is for SC126 or compatible
              	
0021:         	I2C_PORT:   .EQU $21           ;Host I2C port address
0007:         	I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
0007:         	I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
0000:         	I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
0000:         	I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
0081:         	I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
              	
              	
              	; I2C support constants
0000:         	ERR_NONE:   .EQU 0              ;Error = None
0001:         	ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
0002:         	ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
0003:         	ERR_TOUT:   .EQU 3              ;Error = Timeout
              	
              	
              	; **********************************************************************
              	; Hardware dependent I2C bus functions
              	
              	
              	; I2C bus transmit frame (address or data)
              	;   On entry: A = Data byte, or
              	;                 Address byte (bit zero is read flag)
              	;             SCL = low, SDA = low
              	;   On exit:  If successful A=0 and Z flagged
              	;                SCL = lo, SDA = lo
              	;             If unsuccessful A=Error and NZ flagged
              	;                SCL = high, SDA = high, I2C closed
              	;             BC DE HL IX IY preserved
0DBD: C5      	I2C_Write:  PUSH BC             ;Preserve registers
0DBE: D5      	            PUSH DE
0DBF: 57      	            LD   D,A            ;Store byte to be written
0DC0: 0608    	            LD   B,8            ;8 data bits, bit 7 first
0DC2: CB12    	I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
0DC4: 3805    	            JR   C,I2C_WriteBit_Hi      ;High, so skip
0DC6: CD590E  	            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
0DC9: 1803    	            JR   I2C_WriteBit_Clk
0DCB: CD520E  	I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
0DCE: CD440E  	I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
0DD1: CD4B0E  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
0DD4: 10EC    	            DJNZ I2C_WriteWr_Loop
              	; Test for acknowledge from slave (receiver)
              	; On arriving here, SCL = lo, SDA = data bit
0DD6: CD520E  	            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
0DD9: CD440E  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
0DDC: CD6A0E  	            CALL I2C_RdPort     ;Read SDA input
0DDF: 47      	            LD   B,A
0DE0: CD4B0E  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
0DE3: CB78    	            BIT  I2C_SDA_RD,B
0DE5: 2004    	            JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
0DE7: D1      	            POP  DE             ;Restore registers
0DE8: C1      	            POP  BC
0DE9: AF      	            XOR  A              ;Return success A=0 and Z flagged
0DEA: C9      	            RET
              	; I2C STOP required as no acknowledge
              	; On arriving here, SCL = lo, SDA = hi
0DEB: CD590E  	I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
0DEE: CD440E  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
0DF1: CD520E  	            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
0DF4: D1      	            POP  DE             ;Restore registers
0DF5: C1      	            POP  BC
0DF6: 3E02    	            LD   A,ERR_NOACK    ;Return error = No Acknowledge
0DF8: B7      	            OR   A              ;  and NZ flagged
0DF9: C9      	            RET
              	
              	
              	; I2C bus receive frame (data)
              	;   On entry: A = Acknowledge flag
              	;               If A != 0 the read is acknowledged
              	;             SCL low, SDA low
              	;   On exit:  If successful A = data byte and Z flagged
              	;               SCL = low, SDA = low
              	;             If unsuccessul* A = Error and NZ flagged
              	;               SCL = low, SDA = low
              	;             BC DE HL IX IY preserved
              	; *This function always returns successful
0DFA: C5      	I2C_Read:   PUSH BC             ;Preserve registers
0DFB: D5      	            PUSH DE
0DFC: 5F      	            LD   E,A            ;Store acknowledge flag
0DFD: 0608    	            LD   B,8            ;8 data bits, 7 first
0DFF: CD520E  	            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
0E02: CD440E  	I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
0E05: CD6A0E  	            CALL I2C_RdPort     ;Read SDA input bit
0E08: 37      	            SCF                 ;Set carry flag
0E09: CB7F    	            BIT  I2C_SDA_RD,A   ;SDA input high?
0E0B: 2001    	            JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
0E0D: 3F      	            CCF                 ;Clear carry flag
0E0E: CB12    	I2C_ReadRotate:    RL   D              ;Rotate result into D
0E10: CD4B0E  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
0E13: 10ED    	            DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
              	; Acknowledge input byte
              	; On arriving here, SCL = lo, SDA = hi/input
0E15: 7B      	            LD   A,E            ;Get acknowledge flag
0E16: B7      	            OR   A              ;A = 0? (indicates no acknowledge)
0E17: 2803    	            JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
0E19: CD590E  	            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
0E1C: CD440E  	I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
0E1F: CD4B0E  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
0E22: 7A      	            LD   A,D            ;Get data byte received
0E23: D1      	            POP  DE             ;Restore registers
0E24: C1      	            POP  BC
0E25: BF      	            CP   A              ;Return success Z flagged
0E26: C9      	            RET
              	
              	
              	; I2C bus start
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  SCL = low, SDA = low
              	;             A = 0 and Z flagged as we always succeed
              	;             BC DE HL IX IY preserved
              	; First ensure SDA and SCL are high
0E27: CD400E  	I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
              	;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
              	;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
              	; Generate I2C start condition
0E2A: CD590E  	            CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
0E2D: CD4B0E  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
0E30: AF      	            XOR  A              ;Return success A=0 and Z flagged
0E31: C9      	            RET
              	
              	
              	; I2C bus stop 
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  SCL = high, SDA = high
              	;             A = 0 and Z flagged as we always succeed
              	;             BC DE HL IX IY preserved
              	; First ensure SDA and SCL are low
0E32: CD590E  	I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
0E35: CD4B0E  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
              	; Generate stop condition
0E38: CD440E  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
0E3B: CD520E  	            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
0E3E: AF      	            XOR  A              ;Return success A=0 and Z flagged
0E3F: C9      	            RET
              	
              	
              	; **********************************************************************
              	; I2C bus simple I/O functions
              	;   On entry: No parameters required
              	;   On exit:  BC DE HL IX IY preserved
              	
0E40: 3E81    	I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
0E42: 181A    	            JR   I2C_WrPort
              	
0E44: 3A9FFB  	I2C_SCL_HI: LD   A,(I2C_RAMCPY)
0E47: CBC7    	            SET  I2C_SCL_WR,A
0E49: 1813    	            JR   I2C_WrPort
              	
0E4B: 3A9FFB  	I2C_SCL_LO: LD   A,(I2C_RAMCPY)
0E4E: CB87    	            RES  I2C_SCL_WR,A
0E50: 180C    	            JR   I2C_WrPort
              	
0E52: 3A9FFB  	I2C_SDA_HI: LD   A,(I2C_RAMCPY)
0E55: CBFF    	            SET  I2C_SDA_WR,A
0E57: 1805    	            JR   I2C_WrPort
              	
0E59: 3A9FFB  	I2C_SDA_LO: LD   A,(I2C_RAMCPY)
0E5C: CBBF    	            RES  I2C_SDA_WR,A
              	
0E5E: C5      	I2C_WrPort: PUSH BC             ;Preserve registers
0E5F: 0600    	            LD   B,0            ;Set up BC for 16-bit
0E61: 0E21    	            LD   C,I2C_PORT     ;  I/O address of I2C port
0E63: ED79    	            OUT  (C),A          ;Write A to I2C I/O port
0E65: 329FFB  	            LD   (I2C_RAMCPY),A ;Write A to RAM copy
0E68: C1      	            POP  BC             ;Restore registers
0E69: C9      	            RET
              	
0E6A: C5      	I2C_RdPort: PUSH BC             ;Preserve registers
0E6B: 0600    	            LD   B,0            ;Set up BC for 16-bit
0E6D: 0E21    	            LD   C,I2C_PORT     ;  I/O address of I2C port
0E6F: ED78    	            IN   A,(C)          ;Read A from I/O port
0E71: C1      	            POP  BC             ;Restore registers
0E72: C9      	            RET
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	
              	;==============================================================================
              	;==============================================================================
              	;==============================================================================
              	;===================       FUNCTIONS    =======================================
              	;==============================================================================
              	;==============================================================================
              	
              	
              	
              	
              	; **********************************************************************
              	; List devices found on the I2C bus
              	;
              	; Test each I2C device address and reports any that acknowledge
              	
0E73: 211E18  	I2CLIST:    LD   HL, I2C_LIST_MSG        ;Address of message string
0E76: AF      	            XOR A ; A = character to stop printing.
0E77: CD6402  	            CALL LCD_PRINT_STRING         ;Output string
0E7A: 1600    	            LD   D,0            ;First I2C device address to test
0E7C: D5      	LISTLOOP:      PUSH DE             ;Preserve DE
0E7D: 7A      	            LD   A,D            ;Get device address to be tested
0E7E: CD990E  	            CALL LISTTEST          ;Test if device is present
0E81: D1      	            POP  DE             ;Restore DE
0E82: 2009    	            JR   NZ,LISTNEXT       ;Skip if no acknowledge
0E84: 7A      	            LD   A,D            ;Get address of device tested
0E85: CD0D0F  	            CALL HexOut         ;Output as two character hex 
0E88: 3E20    	            LD A, ' '; space
0E8A: CD3502  	            CALL LCD_PRINT_A       ;Output space character
0E8D: 14      	LISTNEXT:      INC  D              ;Get next write address
0E8E: 14      	            INC  D
0E8F: 7A      	            LD   A,D            ;Address of next device to test
0E90: B7      	            OR   A              ;Have we tested all addresses?
0E91: 20E9    	            JR   NZ,LISTLOOP       ;No, so loop again
0E93: 3E0D    	            LD A, CR; enter
0E95: CD3502  	            CALL LCD_PRINT_A       ;Output space character
0E98: C9      	            RET
              	
              	; Test if device at I2C address A acknowledges
              	;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
              	;   On exit:  Z flagged if device acknowledges
              	;             NZ flagged if devices does not acknowledge
0E99: CDB30D  	LISTTEST:      CALL I2C_Open       ;Open I2C device for write
0E9C: C0      	            RET  NZ             ;Abort if failed to open
0E9D: CDBA0D  	            CALL I2C_Close      ;Close I2C device 
0EA0: AF      	            XOR  A              ;Return with Z flagged
0EA1: C9      	            RET
              	
              	
              	
              	
              	; Copy a block from I2C memory to CPU memory
              	;   On entry: DE = First address in I2C memory
              	;             HL = First address in CPU memory
              	;             BC = Number of bytes to be copied
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             IX IY preserved
0EA2: C5      	I2C_MemRd:  PUSH BC
0EA3: 011027  	            LD   BC,TIMEOUT     ;Timeout loop counter
0EA6: 3EAE    	I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
0EA8: CDB30D  	            CALL I2C_Open       ;Open for write
0EAB: 280A    	            JR   Z,I2C_MemRdReady       ;If open okay then skip on
0EAD: 0B      	            DEC  BC
0EAE: 78      	            LD   A,B
0EAF: B1      	            OR   C              ;Timeout?
0EB0: 20F4    	            JR   NZ,I2C_MemRdRepeat     ;No, so go try again
0EB2: C1      	            POP  BC
0EB3: 3E03    	            LD   A,ERR_TOUT     ;Error code
0EB5: B7      	            OR   A              ;Error, so NZ flagged
0EB6: C9      	            RET                 ;Return with error
              	; Device opened okay
0EB7: C1      	I2C_MemRdReady:     POP  BC             ;Restore byte counter
0EB8: 7A      	            LD   A,D            ;Address (hi) in I2C memory
0EB9: CDBD0D  	            CALL I2C_Write      ;Write address
0EBC: 7B      	            LD   A,E            ;Address (lo) in I2C memory
0EBD: CDBD0D  	            CALL I2C_Write      ;Write address
0EC0: 3EAF    	            LD   A,I2CA_BLOCK+1 ;I2C device to be read from
0EC2: CDB30D  	            CALL I2C_Open       ;Open for read
0EC5: C0      	            RET  NZ             ;Abort if error
0EC6: 0B      	I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
0EC7: 78      	            LD   A,B
0EC8: B1      	            OR   C              ;Last byte to be read?
0EC9: CDFA0D  	            CALL I2C_Read       ;Read byte with no ack on last byte
0ECC: 77      	            LD   (HL),A         ;Write byte in CPU memory
0ECD: 23      	            INC  HL             ;Increment CPU memory pointer
0ECE: 78      	            LD   A,B
0ECF: B1      	            OR   C              ;Finished?
0ED0: 20F4    	            JR   NZ,I2C_MemRdRead       ;No, so go read next byte
0ED2: CD320E  	            CALL I2C_Stop       ;Generate I2C stop
0ED5: AF      	            XOR  A              ;Return with success (Z flagged)
0ED6: C9      	            RET
              	
              	
              	; Copy a block from CPU memory to I2C memory
              	;   On entry: DE = First address in I2C memory
              	;             HL = First address in CPU memory
              	;             BC = Number of bytes to be copied
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             IX IY preserved
              	; The 24LC64 requires blocks of data to be written in 64 byte (or less)
              	; pages.
0ED7: C5      	I2C_MemWr:  PUSH BC
0ED8: 011027  	            LD   BC,TIMEOUT     ;Timeout loop counter
0EDB: 3EAE    	I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
0EDD: CDB30D  	            CALL I2C_Open       ;Open for write
0EE0: 280A    	            JR   Z,I2C_MemWrReady       ;If open okay then skip on
0EE2: 0B      	            DEC  BC
0EE3: 78      	            LD   A,B
0EE4: B1      	            OR   C              ;Timeout?
0EE5: 20F4    	            JR   NZ,I2C_MemWrRepeat     ;No, so go try again
0EE7: C1      	            POP  BC
0EE8: 3E03    	            LD   A,ERR_TOUT     ;Error code
0EEA: B7      	            OR   A              ;Error, so NZ flagged
0EEB: C9      	            RET                 ;Return with error
              	; Device opened okay
0EEC: C1      	I2C_MemWrReady:     POP  BC             ;Restore byte counter
0EED: 7A      	I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
0EEE: CDBD0D  	            CALL I2C_Write      ;Write address
0EF1: 7B      	            LD   A,E            ;Address (lo) in I2C memory
0EF2: CDBD0D  	            CALL I2C_Write      ;Write address
0EF5: 7E      	I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
0EF6: CDBD0D  	            CALL I2C_Write      ;Read byte from I2C memory
0EF9: 23      	            INC  HL             ;Increment CPU memory pointer
0EFA: 13      	            INC  DE             ;Increment I2C memory pointer
0EFB: 0B      	            DEC  BC             ;Decrement byte counter
0EFC: 78      	            LD   A,B
0EFD: B1      	            OR   C              ;Finished?
0EFE: 2805    	            JR   Z,I2C_MemWrStore       ;Yes, so go store this page
0F00: 7B      	            LD   A,E            ;Get address in I2C memory (lo byte)
0F01: E63F    	            AND  63             ;64 byte page boundary?
0F03: 20F0    	            JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
0F05: CD320E  	I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
0F08: 78      	            LD   A,B
0F09: B1      	            OR   C              ;Finished?
0F0A: 20CB    	            JR   NZ,I2C_MemWr   ;No, so go write some more
0F0C: C9      	            RET   
              	
              	
              	; Hex byte output to console
              	;   On entry: A = Byte to be output in hex
              	;   On exit:  BC DE HL IX IY preserved
0F0D: F5      	HexOut:     PUSH AF             ;Preserve byte to be output
0F0E: 1F      	            RRA                 ;Shift top nibble to
0F0F: 1F      	            RRA                 ;  botom four bits..
0F10: 1F      	            RRA
0F11: 1F      	            RRA
0F12: E60F    	            AND  $0F           ;Mask off unwanted bits
0F14: CD1A0F  	            CALL HexOutHex           ;Output hi nibble
0F17: F1      	            POP  AF             ;Restore byte to be output
0F18: E60F    	            AND  $0F           ;Mask off unwanted bits
              	; Output nibble as ascii character
0F1A: FE0A    	HexOutHex:       CP   $0A           ;Nibble > 10 ?
0F1C: 3802    	            JR   C,HexOutSkip        ;No, so skip
0F1E: C607    	            ADD  A,7            ;Yes, so add 7
0F20: C630    	HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
0F22: CD0800  	            CALL $0008       ;Write character
0F25: C9      	            RET
              	
              	#include "Serial.asm"
0F26:         	INIT_SERIAL:
              		; Init Serial
0F26: 216B0F  		LD    HL,TXDATA
0F29: 2299FB  	    LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0F2C: 217E0F  	    LD    HL,RXDATA
0F2F: 229BFB  	    LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
              	
              	
              	;	Initialise SIO/2 A
0F32: 3E04    		LD	A,$04
0F34: D302    		OUT	(SIOA_C),A
0F36: 3EC4    		LD	A,$C4
0F38: D302    		OUT	(SIOA_C),A
              	
0F3A: 3E03    		LD	A,$03
0F3C: D302    		OUT	(SIOA_C),A
0F3E: 3EE1    		LD	A,$E1
0F40: D302    		OUT	(SIOA_C),A
              	
0F42: 3E05    		LD	A,$05
0F44: D302    		OUT	(SIOA_C),A
0F46: 3E68    		LD	A, $68
0F48: D302    		OUT	(SIOA_C),A
              	
              	    ; Print wellcome serial
0F4A: 21D016  	    LD HL, WELLCOME
0F4D: CD5D0F  	    CALL SNDSTR
              	
0F50: C9      		RET
              	
              	;-----------------------------------
              	; OUTPUT A CHARACTER TO THE TERMINAL
              	;-----------------------------------       
0F51: DD2A99FB	OUTCH:  LD   IX,(PUTCH)
0F55: DDE9    	       JP   (IX)
              	;------------------------------------
              	; INPUT A CHARACTER FROM THE TERMINAL
              	;------------------------------------
0F57: DD2A9BFB	INCH:  LD   IX,(GETCH)
0F5B: DDE9    	      JP   (IX)
              	
              	
              		
              	
              	;-----------------------------------------
              	; SEND AN ASCII STRING OUT THE SERIAL PORT
              	;-----------------------------------------
              	; 
              	; SENDS A ZERO TERMINATED STRING OR 
              	; 128 CHARACTERS MAX. OUT THE SERIAL PORT
              	;
              	;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
              	;      EXIT  : NONE
              	;
              	;       MODIFIES : A,B,C
              	;          
0F5D: 0680    	SNDSTR: LD    B,128         ;128 CHARS MAX
0F5F: 7E      	SDMSG1: LD    A,(HL)        ;GET THE CHAR
0F60: FE00    	       CP    00H          ;ZERO TERMINATOR?
0F62: 2806    	       JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
0F64: CD510F  	       CALL  OUTCH         ;TRANSMIT THE CHAR
0F67: 23      	       INC   HL
0F68: 10F5    	       DJNZ  SDMSG1        ;128 CHARS MAX!    
0F6A: C9      	SDMSG2: RET
              	
              	
              	;------------------------
              	; SERIAL TRANSMIT ROUTINE
              	;------------------------
              	;TRANSMIT BYTE SERIALLY ON DOUT
              	;
              	; ENTRY : A = BYTE TO TRANSMIT
              	;  EXIT : NO REGISTERS MODIFIED
              	;
0F6B:         	TXDATA:		
0F6B: F5      			PUSH	AF		; Store character
0F6C: CD750F  	conoutA1:	CALL	CKSIOA		; See if SIO channel A is finished transmitting
0F6F: 28FB    			JR	Z,conoutA1	; Loop until SIO flag signals ready
0F71: F1      			POP	AF		; RETrieve character
0F72: D300    			OUT	(SIOA_D),A	; OUTput the character
0F74: C9      			RET
              	
              	
              	;------------------------------------------------------------------------------
              	; I/O status check routine
              	; Use the "primaryIO" flag to determine which port to check.
              	;------------------------------------------------------------------------------
0F75:         	CKSIOA
0F75: 97      			SUB	A
0F76: D302    			OUT 	(SIOA_C),A
0F78: DB02    			IN   	A,(SIOA_C)	; Status byte D2=TX Buff Empty, D0=RX char ready	
0F7A: 0F      			RRCA			; Rotates RX status into Carry Flag,	
0F7B: CB4F    			BIT  	1,A		; Set Zero flag if still transmitting character	
0F7D: C9      	        RET
              	
              	    
              	;-----------------------
              	; SERIAL RECEIVE ROUTINE
              	;-----------------------
              	;RECEIVE SERIAL BYTE FROM DIN
              	;
              	; ENTRY : NONE
              	;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
              	;
              	; REGISTERS MODIFIED A AND F
              	;
0F7E:         	RXDATA:	
0F7E:         	waitForChar:
              	        ; Check if there is a char in channel A
0F7E: 97      			SUB	A
0F7F: D302    			OUT 	(SIOA_C),A
0F81: DB02    			IN   	A,(SIOA_C)	; Status byte D2=TX Buff Empty, D0=RX char ready	
0F83: 0F      			RRCA			; Rotates RX status into Carry Flag,	
0F84: 30F8    			JR	NC, waitForChar
0F86: DB00    			IN	A,(SIOA_D)
0F88: B7      			OR A ; clear carry
0F89: C9      			RET
              	
              	;------------------------------------------------------------
              	;------------------------------------------------------------
              	; RECEIVE INTEL HEX FILE
              	;------------------------------------------------------------
              	;------------------------------------------------------------
0F8A:         	INTELLOADER: 
0F8A: CD2302  			CALL LCD_CR
              	
0F8D: 113418  	       	LD DE, MSG_ILOAD
0F90: AF      	    	XOR A
0F91: CD1906  	    	CALL SEND_STRING_TO_GLCD
              	
0F94: 213418  	       	LD HL, MSG_ILOAD
0F97: CD5D0F  	       	CALL  SNDSTR
              	       
              	
0F9A: CDBB0F  	       	CALL  INTELH
0F9D: 200E    	       	JR    NZ,ITHEX1
              	
0F9F: 114918  	       	LD    DE,FILEOK
0FA2: AF      	       	XOR A
0FA3: CD1906  	    	CALL SEND_STRING_TO_GLCD   ;GOT FILE OK LCD
              	
0FA6: 214918  	       	LD    HL,FILEOK
0FA9: CD5D0F  	       	CALL  SNDSTR      ;GOT FILE OK Serial
              	       
0FAC: C9      	       	RET
0FAD: 115B18  	ITHEX1: LD    DE,CSUMERR
0FB0: AF      	       	XOR A
0FB1: CD1906  	    	CALL SEND_STRING_TO_GLCD
              	
0FB4: 215B18  	       	LD    HL,CSUMERR
0FB7: CD5D0F  	       	CALL  SNDSTR      ;CHECKSUM ERROR 
0FBA: C9      	       	RET  
              	
              	
              	
              	
              	
              	;-----------------------
              	; RECEIVE INTEL HEX FILE
              	;-----------------------
0FBB: DD21F0FF	INTELH:	LD	IX, SYSTEM_SP	;POINT TO SYSTEM VARIABLES
              	;
              	; WAIT FOR RECORD MARK
              	;
0FBF: AF      	INTEL1:	XOR	A
0FC0: DD7703  		LD	(IX+3),A	;CLEAR CHECKSUM
0FC3: CD7E0F  		CALL	RXDATA	;WAIT FOR THE RECORD MARK
0FC6: FE3A    		CP	':'	;TO BE TRANSMITTED
0FC8: 20F5    		JR	NZ,INTEL1	;NOT RECORD MARK
              	;
              	; GET RECORD LENGTH
              	;
0FCA: CD1710  		CALL	GETBYT
0FCD: DD7700  		LD	(IX+0),A	;NUMBER OF DATA BYTES
              	;
              	; GET ADDRESS FIELD
              	;
0FD0: CD1710  		CALL	GETBYT
0FD3: DD7702  		LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
0FD6: CD1710  		CALL	GETBYT
0FD9: DD7701  		LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
              	;
              	; GET RECORD TYPE
              	;
0FDC: CD1710  		CALL	GETBYT
0FDF: 2024    		JR	NZ,INTEL4	;END OF FILE RECORD
              	;
              	; READ IN THE DATA
              	;
0FE1: DD4600  		LD	B,(IX+0)	;NUMBER OF DATA BYTES
0FE4: DD6602  		LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
0FE7: DD6E01  		LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
              	
0FEA: CD1710  	INTEL2:	CALL	GETBYT	;GET DATA BYTE
0FED: 77      		LD	(HL),A	;STORE DATA BYTE
0FEE: 23      		INC	HL
0FEF: 10F9    		DJNZ	INTEL2	;LOAD MORE BYTES
              	;
              	; GET CHECKSUM AND COMPARE
              	;
0FF1: DD7E03  		LD	A,(IX+3)	;CONVERT CHECKSUM TO
0FF4: ED44    		NEG		;TWO'S COMPLEMENT
0FF6: DD7704  		LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
0FF9: CD1710  		CALL	GETBYT
0FFC: DD7703  		LD	(IX+3),A	;SAVE RECORD CHECKSUM
0FFF: DDBE04  		CP	(IX+4)	;COMPARE CHECKSUM
1002: 28BB    		JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
1004: C9      	    RET             ;NZ=CHECKSUM ERROR
              	;
              	; END OF FILE RECORD
              	;
1005: DD7E03  	INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1008: ED44    		NEG		;TWO'S COMPLEMENT
100A: DD7704  		LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
100D: CD1710  		CALL	GETBYT
1010: DD7703  		LD	(IX+3),A	;SAVE EOF CHECKSUM
1013: DDBE04  		CP	(IX+4)	;COMPARE CHECKSUM
1016: C9      		RET  	    ;NZ=CHECKSUM ERROR
              	;--------------------------
              	; GET BYTE FROM SERIAL PORT
              	;--------------------------
1017: C5      	GETBYT:	PUSH	BC
1018: CD7E0F  		CALL	RXDATA
101B: CB77    		BIT	6,A
101D: 2802    		JR	Z,GETBT1
101F: C609    		ADD	A,09H
1021: E60F    	GETBT1:	AND	0FH
1023: CB27    		SLA 	A
1025: CB27    		SLA	A
1027: CB27    		SLA	A
1029: CB27    		SLA	A
102B: 4F      		LD	C,A
              	;
              	; GET LOW NYBBLE
              	;
102C: CD7E0F  		CALL	RXDATA
102F: CB77    		BIT	6,A
1031: 2802    		JR	Z,GETBT2
1033: C609    		ADD	A,09H
1035: E60F    	GETBT2:	AND	0FH
1037: B1      		OR	C
1038: 47      		LD	B,A
1039: DD8603  		ADD	A,(IX+3)
103C: DD7703  		LD	(IX+3),A	;ADD TO CHECKSUM
103F: 78      		LD	A,B
1040: A7      		AND	A	;CLEAR CARRY
1041: C1      	    POP	BC
1042: C9      		RET
              	#include "Keyboard.asm"
              	
              	
              	;----------------------------------------
              	; CONVERT ASCII CHARACTER INTO HEX NYBBLE
              	;----------------------------------------
              	; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
              	; ENTRY OTHER THAN HEXADECIMAL KEYS
              	;
              	;CONVERTS ASCII 0-9,A-F INTO HEX LSN
              	;ENTRY : A= ASCII 0-9,A-F
              	;EXIT  : CARRY =  1
              	;          A= HEX 0-F IN LSN    
              	;      : CARRY = 0
              	;          A= OUT OF RANGE CHARACTER & 7FH
              	; A AND F REGISTERS MODIFIED
              	;
1043: E67F    	ASC2HEX: AND   7FH        ;STRIP OUT PARITY
1045: FE30    	       CP    30H
1047: 3812    	       JR    C,AC2HEX3    ;LESS THAN 0
1049: FE3A    	       CP    3AH
104B: 3002    	       JR    NC,AC2HEX2   ;MORE THAN 9
104D: 37      	AC2HEX1: SCF               ;SET THE CARRY - IS HEX
104E: C9      	       RET
              	;     
104F: FE41    	AC2HEX2: CP    41H
1051: 3808    	       JR    C,AC2HEX3    ;LESS THAN A
1053: FE47    	       CP    47H
1055: 3004    	       JR    NC,AC2HEX3   ;MORE THAN F
1057: D607    	       SUB   07H        ;CONVERT TO NYBBLE
1059: 18F2    	       JR    AC2HEX1  
105B: E6FF    	AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
105D: C9      	       RET
              	
              	
              	; -----------------------------------------------------------------------------
              	;   Check break key (Basic)
              	; -----------------------------------------------------------------------------
105E:         	CHKKEY:
105E: AF      	    XOR A
105F: D340    		OUT (KEY_OUT), A
1061: 00      	    NOP
1062: 00      	    NOP
1063: 00      	    NOP
1064: 00      	    NOP
1065: 00      	    NOP
1066: DB40    		IN  A, (KEY_IN)
1068: CB47    	    bit 0, a
106A: C27210  	    jp nz, GRET
106D: 3E03    		LD  A, CTRLC
106F: FE00    		CP	0
1071: C9      		RET
1072:         	GRET:
1072: 3E00    		LD  A, 0
1074: FE00    		CP 0
1076: C9      		RET
              	
              	; -----------------------------------------------------------------------------
              	;   KEYREAD - KEY In A, or 0 if not press key
              	;   aguarda até presionar uma tecla
              	; -----------------------------------------------------------------------------
1077:         	KEYREAD:
1077: C5      	    PUSH    BC
1078: D5      		PUSH	DE
1079: E5      		PUSH    HL
107A:         	i_read_key:
107A: CD6811  	    CALL NOP_TIME
107D: AF      	    xor a
107E: 32CDFB  	    LD (KEY_READ), A
1081: 32CCFB  	    ld (KEY_SHIFT), a ; Reset shift
1084: D340    	    out (KEY_OUT), a
1086: CD6811  	    CALL NOP_TIME
1089: DB40    	    in a, (KEY_IN)
108B: CB5F    	    bit 3, a
108D: C29310  	    jp NZ, r_key
1090: 32CCFB  	    ld (KEY_SHIFT), a ; se shitft a > 0
1093:         	r_key:
1093: 060D    	    ld b, 13
1095: 0E00    	    ld c, 0
1097:         	k_read_loop:
1097: 79      	    ld a, c
1098: D340    	    out (KEY_OUT), a
109A: CD6811  	    CALL NOP_TIME
109D: DB40    	    in a, (KEY_IN)
109F: E61F    	    and $1f
10A1: EE1F    	    xor $1f
10A3: CAAC10  	    jp z, k_read_fim
10A6: C5      	    push bc
10A7: 47      	    ld b, a
10A8: CDFA10  	    call trata_key
10AB: C1      	    pop bc
10AC:         	k_read_fim:
10AC: 0C      	    inc c
10AD: 10E8    	    djnz k_read_loop
10AF: 3ACDFB  	    LD A, (KEY_READ)
10B2: B7      	    OR A
10B3: E1      	    POP     HL
10B4: D1      	    POP     DE
10B5: C1      	    POP     BC
10B6: C9      	    RET ; Return KEYREAD
              	
              	
              	
              	; -----------------------------------------------------------------------------
              	;   KEYREADINIT - KEY In A 
              	;   aguarda até presionar uma tecla
              	; -----------------------------------------------------------------------------
10B7:         	KEYREADINIT:
              	    ; save registers (MSBASIC)
10B7: C5      	    PUSH    BC
10B8: D5      		PUSH	DE
10B9: E5      		PUSH    HL
10BA:         	init_read_key:
10BA: CD6811  	    CALL NOP_TIME
10BD: AF      	    xor a
10BE: 32CDFB  	    LD (KEY_READ), A
10C1: 32CCFB  	    ld (KEY_SHIFT), a ; Reset shift
10C4: D340    	    out (KEY_OUT), a
10C6: CD6811  	    CALL NOP_TIME
10C9: DB40    	    in a, (KEY_IN)
10CB: CB5F    	    bit 3, a
10CD: C2D310  	    jp NZ, read_key
10D0: 32CCFB  	    ld (KEY_SHIFT), a ; se shitft a > 0
10D3:         	read_key:
10D3: 060D    	    ld b, 13
10D5: 0E00    	    ld c, 0
10D7:         	key_read_loop:
10D7: 79      	    ld a, c
10D8: D340    	    out (KEY_OUT), a
10DA: CD6811  	    CALL NOP_TIME
10DD: DB40    	    in a, (KEY_IN)
10DF: E61F    	    and $1f
10E1: EE1F    	    xor $1f
10E3: CAEC10  	    jp z, key_read_fim
10E6: C5      	    push bc
10E7: 47      	    ld b, a
10E8: CDFA10  	    call trata_key
10EB: C1      	    pop bc
10EC:         	key_read_fim:
10EC: 0C      	    inc c
10ED: 10E8    	    djnz key_read_loop
10EF: 3ACDFB  	    LD A, (KEY_READ)
10F2: B7      	    OR A
10F3: CABA10  	    JP Z, init_read_key
10F6: E1      	    POP     HL
10F7: D1      	    POP     DE
10F8: C1      	    POP     BC
10F9: C9      	    RET ; Return KEYREADINIT
              	    
              	; C - coluna
              	; B - linha
10FA:         	trata_key:
10FA: 78      	    ld a, b
              	    
10FB: CB47    	    bit 0, a
10FD: C24A11  	    jp nz, trata_line1
              	    
1100: CB4F    	    bit 1, a
1102: C25011  	    jp nz, trata_line2
              	    
1105: CB57    	    bit 2, a
1107: C25611  	    jp nz, trata_line3
              	    
110A: CB5F    	    bit 3, a
110C: C25C11  	    jp nz, trata_line4
              	    
110F: CB67    	    bit 4, a
1111: C26211  	    jp nz, trata_line5
              	    
1114:         	L_fim:
              	    ; letra final
1114: 1600    	    ld d, 0
1116: 59      	    ld e, c
1117: 19      	    add hl, de
              	    
1118: 7E      	    ld a, (hl)
1119: B7      	    or a
111A: C8      	    ret z
              	    
              	    ; check shift
111B: 3ACCFB  	    ld a, (KEY_SHIFT)
111E: B7      	    or a
111F: CA2911  	    jp Z, load_a
1122: 1E41    	    ld e, $41 ; 65
1124: 19      	    add hl, de
              	    ; shift reset
1125: AF      	    xor a
1126: 32CCFB  	    ld (KEY_SHIFT), a
              	    
1129:         	load_a:
1129: 7E      	    ld a, (hl)
112A: B7      	    or a
112B: FE00    	    cp 0
112D: C8      	    ret Z
112E: 32CDFB  	    LD (KEY_READ), A
1131: 0664    	    LD B, $64
1133:         	debaunce_key:
1133: 110100  	    LD DE, $0001
1136: C5      	    PUSH BC
1137: CDAE11  	    CALL H_Delay
113A: C1      	    POP BC
113B: DB40    	    in a, (KEY_IN)
113D: E61F    	    and $1f
113F: EE1F    	    xor $1f
1141: 10F0    	    DJNZ debaunce_key
1143: 113200  	    ld de, $0032 ; debounce 50 ms
1146: CDAE11  	    call H_Delay
1149: C9      	    RET ; return tratar_key
              	    
              	    
114A:         	trata_line1:
114A: 216800  	    ld hl, line1
114D: C31411  	    jp L_fim
1150:         	trata_line2:
1150: 217500  	    ld hl, line2
1153: C31411  	    jp L_fim
1156:         	trata_line3:
1156: 218200  	    ld hl, line3
1159: C31411  	    jp L_fim
115C:         	trata_line4:
115C: 218F00  	    ld hl, line4
115F: C31411  	    jp L_fim
1162:         	trata_line5:
1162: 219C00  	    ld hl, line5
1165: C31411  	    jp L_fim
              	
1168:         	NOP_TIME:
1168: 00      	    NOP
1169: 00      	    NOP
116A: 00      	    NOP
116B: 00      	    NOP
116C: 00      	    NOP
116D: 00      	    NOP
116E: 00      	    NOP
116F: C9      	    RET
              	
              	;-----------------------------
              	; GET A BYTE FROM KEYBOARD
              	;-----------------------------
1170: CDB710  	GETCHR_KEYBOARD: CALL KEYREADINIT ; read key
1173: FE1B    	       CP    ESC
1175: 2833    	       JR    Z,GET_ESP
1177: FE03    	       CP    CTRLC  ; key BK (reset)
1179: CA9701  	       JP    Z, RESET_WARM
117C: 47      	       LD    B,A                ;SAVE TO ECHO      
117D: CD4310  	       CALL  ASC2HEX
1180: 30EE    	       JR    NC,GETCHR_KEYBOARD          ;REJECT NON HEX CHARS    
1182: 21C9FB  	       LD    HL, DATABYTE
1185: 77      	       LD    (HL), A 
1186: 78      	       LD    A,B         
1187: CD3502  	       CALL  LCD_PRINT_A             ;ECHO VALID HEX
              	       
118A: CDB710  	GETNYB: CALL  KEYREADINIT
118D: FE1B    	       CP    ESC
118F: 2819    	       JR    Z,GET_ESP
1191: FE03    	       CP    CTRLC  ; key BK (reset)
1193: CA9701  	       JP    Z, RESET_WARM
1196: 47      	       LD    B,A               ;SAVE TO ECHO
1197: CD4310  	       CALL  ASC2HEX
119A: 30EE    	       JR    NC,GETNYB         ;REJECT NON HEX CHARS
119C: ED6F    	       RLD
119E: 78      	       LD    A,B
119F: CD3502  	       CALL  LCD_PRINT_A             ;ECHO VALID HEX
11A2: 7E      	       LD    A,(HL)
11A3: CDA811  	       CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
11A6: 3F      	       CCF                    ;AND THEN COMPLEMENTING IT
11A7: C9      	       RET   
11A8: 37      	GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
11A9: C9      	       RET
11AA:         	GET_ESP:
11AA: 37      	    SCF
11AB: 3E0D    	    LD A, CR ; ENTER on exit
11AD: C9      	    RET
              	#include "Utils.asm"
              	; **********************************************************************
              	; Delay by DE milliseconds
              	;   On entry: DE = Delay time in milliseconds
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
11AE: F5      	H_Delay:    PUSH AF
11AF: C5      	            PUSH BC
11B0: D5      	            PUSH DE
              	; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
11B1: 011A01  	LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
              	; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
11B4: 0B      	LoopBC:    DEC  BC             ;[6]     [4]
11B5: 79      	            LD   A,C            ;[4]     [4]
11B6: B0      	            OR   B              ;[4]     [4]
11B7: C2B411  	            JP   NZ,LoopBC     ;[12/7]  [8/6] 
              	; Have we looped once for each millisecond requested?
11BA: 1B      	            DEC  DE             ;[6]     [4]
11BB: 7B      	            LD   A,E            ;[4]     [4]
11BC: B2      	            OR   D              ;[4]     [4]
11BD: 20F2    	            JR   NZ, LoopDE     ;[12/7]  [8/6]
11BF: D1      	            POP  DE
11C0: C1      	            POP  BC
11C1: F1      	            POP  AF
11C2: C9      	            RET
              	
              	
              	
              	
              	;----------------
              	;CONVERT A TO ASCII (HEX) AND SHOW LCD
              	;----------------
              	;
              	;CONVERT REG A BYTE TO ASCII 
              	;
11C3: F5      	CONV_A_HEX: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
11C4: 0F      	       RRCA              ;SHIFT HIGH NYBBLE ACROSS
11C5: 0F      	       RRCA
11C6: 0F      	       RRCA
11C7: 0F      	       RRCA
11C8: CDCC11  	       CALL CONV_A_HEX_NYBASC       ;CALL NYBBLE CONVERTER 
11CB: F1      	       POP AF            ;RESTORE LOW NYBBLE
              	;           
              	; CONVERT A NYBBLE TO ASCII
              	;
11CC: E60F    	CONV_A_HEX_NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
11CE: C690    	       ADD   A,90H       ;CONVERT TO
11D0: 27      	       DAA               ;ASCII
11D1: CE40    	       ADC   A,40H
11D3: 27      	       DAA
              	;            
              	; Print inlcd
              	;
11D4: CD3502  	    CALL LCD_PRINT_A
11D7: C9      	    RET 
              	
              	
              	;-----------------------
              	; Change led red, half byte in A
              	;-----------------------
11D8:         	LED_RED:
11D8: E60F    	    AND $0F
11DA: 47      	    LD B, A
11DB: 3A9DFB  	    LD A, (LED_ONBOARD)
11DE: E6F0    	    AND $F0
11E0: B0      	    OR B
11E1: D310    	    OUT(LEDS_ONBOARD), A
11E3: 329DFB  	    LD (LED_ONBOARD), A
11E6: C9      	    RET
              	
              	
              	;-----------------------
              	; Change led green, half byte in A
              	;-----------------------
11E7:         	LED_GREEN:
11E7: CB27    	    SLA A
11E9: CB27    	    SLA A
11EB: CB27    	    SLA A
11ED: CB27    	    SLA A
11EF: 47      	    LD B, A
11F0: 3A9DFB  	    LD A, (LED_ONBOARD)
11F3: E60F    	    AND $0F
11F5: B0      	    OR B
11F6: D310    	    OUT(LEDS_ONBOARD), A
11F8: 329DFB  	    LD (LED_ONBOARD), A
11FB: C9      	    RET
              	
              	;----------------
              	;CONVERT TO ASCII 
              	;----------------
              	;
              	; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
              	;
              	;         ENTRY :  A = BINARY TO CONVERT
              	;                  HL = CHARACTER BUFFER ADDRESS   
              	;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
              	;   
              	;        MODIFIES : DE
              	
11FC: 7A      	WRDASC: LD    A,D         ;CONVERT AND
11FD: CD0112  	       CALL  BYTASC      ;OUTPUT D
1200: 7B      	       LD    A,E         ;THEN E
              	;
              	;CONVERT A BYTE TO ASCII 
              	;
1201: F5      	BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
1202: 0F      	       RRCA              ;SHIFT HIGH NYBBLE ACROSS
1203: 0F      	       RRCA
1204: 0F      	       RRCA
1205: 0F      	       RRCA
1206: CD0A12  	       CALL NYBASC       ;CALL NYBBLE CONVERTER 
1209: F1      	       POP AF            ;RESTORE LOW NYBBLE
              	;           
              	; CONVERT A NYBBLE TO ASCII
              	;
120A: E60F    	NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
120C: C690    	       ADD   A,90H       ;CONVERT TO
120E: 27      	       DAA               ;ASCII
120F: CE40    	       ADC   A,40H
1211: 27      	       DAA
              	;            
              	; SAVE IN STRING
              	;
1212: 77      	INSBUF: LD    (HL),A
1213: 23      	       INC   HL 
1214: C9      	       RET 
              	
              	
              	;----------------------     
              	; SEND ASCII HEX VALUES        
              	;----------------------
              	;
              	; OUTPUT THE 4 BYTE, WRDOUT
              	; THE 2 BYTE, BYTOUT
              	; OR THE SINGLE BYTE, NYBOUT
              	; ASCII STRING AT HL TO THE SERIAL PORT
              	;
1215: CD1812  	WRDOUT: CALL  BYTOUT
1218: CD1B12  	BYTOUT: CALL  NYBOUT
121B: 7E      	NYBOUT: LD    A,(HL)
121C: CD3502  	       CALL  LCD_PRINT_A
121F: 23      	       INC   HL
1220: C9      	       RET   
              	#include "Menu.asm"
1221:         	SHOW_MENU:
1221: 3E0D    	    LD A, CR
1223: CDAA05  	    CALL SEND_CHAR_TO_GLCD
              	
1226: 11FB16  	    LD DE, MSG_MENU0
1229: 3E00    	    LD A, 0
122B: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
122E: 110E17  	    LD DE, MSG_MENU1
1231: 3E00    	    LD A, 0
1233: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
1236: 112317  	    LD DE, MSG_MENU2
1239: 3E00    	    LD A, 0
123B: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
123E: 112D17  	    LD DE, MSG_MENU3
1241: 3E00    	    LD A, 0
1243: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
1246: 113717  	    LD DE, MSG_MENU4
1249: 3E00    	    LD A, 0
124B: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
              	
124E: 114117  	    LD DE, MSG_MENU8
1251: 3E00    	    LD A, 0
1253: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
1256: 114C17  	    LD DE, MSG_MENU9
1259: 3E00    	    LD A, 0
125B: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
125E: 115E17  	    LD DE, MSG_MENU10
1261: 3E00    	    LD A, 0
1263: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
1266: 116F17  	    LD DE, MSG_MENU11
1269: 3E00    	    LD A, 0
126B: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
126E: 117F17  	    LD DE, MSG_MENU12
1271: 3E00    	    LD A, 0
1273: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
1276: 118C17  	    LD DE, MSG_MENU13
1279: 3E00    	    LD A, 0
127B: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
127E: 119517  	    LD DE, MSG_MENU14
1281: 3E00    	    LD A, 0
1283: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
1286: 11A117  	    LD DE, MSG_MENU15
1289: 3E00    	    LD A, 0
128B: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
128E: 11B217  	    LD DE, MSG_MENU16
1291: 3E00    	    LD A, 0
1293: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
1296: 11C317  	    LD DE, MSG_MENU17
1299: 3E00    	    LD A, 0
129B: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
129E: 11D317  	    LD DE, MSG_MENU18
12A1: 3E00    	    LD A, 0
12A3: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
12A6: 11E617  	    LD DE, MSG_MENU19
12A9: 3E00    	    LD A, 0
12AB: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
12AE: 11FB17  	    LD DE, MSG_MENU20
12B1: 3E00    	    LD A, 0
12B3: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
12B6: 110F18  	    LD DE, MSG_MENU21
12B9: 3E00    	    LD A, 0
12BB: CD1906  	    CALL SEND_STRING_TO_GLCD
              	
              	
              	
12BE: C9      	    RET
              	#include "Monitor.asm"
              	;--------------------------
              	; Start basic
              	;--------------------------
12BF:         	START_BASIC:
12BF: 3E0C    	    LD A, CS
12C1: CDAA05  	    CALL SEND_CHAR_TO_GLCD
              	
12C4: 116B18  	    LD DE, MSG_BASIC
12C7: 3E00    	    LD A, 0
12C9: CD1906  	    CALL SEND_STRING_TO_GLCD
12CC:         	START_BASIC_KEY:
12CC: CDB710  	    CALL KEYREADINIT ; read key
12CF: FE43    	    CP    'C' ; Cold
12D1: CA1D02  	    JP    Z, BASIC
12D4: FE57    	    CP    'W'  ; Warm
12D6: CA2002  	    JP    Z, BASIC_W
12D9: C3CC12  	    JP START_BASIC_KEY
              	
              	
              	;------------------------------
              	; GO <ADDR>
              	; TRANSFERS EXECUTION TO <ADDR>
              	;------------------------------
12DC:         	GOJUMP_new:
12DC: CD2302  	    CALL LCD_CR
              	
12DF:         	GOJUMP: 
12DF: 3E47    	       LD A, 'G'
12E1: CDAA05  	       CALL SEND_CHAR_TO_GLCD 
12E4: CD2902  	       CALL LCD_SPACE    
12E7: CD7011  	       CALL  GETCHR_KEYBOARD      ;GET ADDRESS HIGH BYTE
12EA: D8      	       RET   C
12EB: 32CBFB  	       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
12EE: CD7011  	       CALL  GETCHR_KEYBOARD      ;GET ADDRESS LOW BYTE
12F1: D8      	       RET   C
12F2: 32CAFB  	       LD    (ADDR),A    ;SAVE ADDRESS LOW 
              	;
              	; WAIT FOR A CR OR ESC
              	;       
12F5: CDB710  	GOJMP1: CALL  KEYREADINIT
12F8: FE1B    	       CP    ESC         ;ESC KEY?
12FA: C8      	       RET   Z
12FB: FE0D    	       CP    CR
              	       ;JR    NZ,GOJMP1
12FD: 20DD    	       JR NZ, GOJUMP_new
12FF: CD2302  	       CALL  LCD_CR ; Enter
1302: E1      	       POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
1303: 2ACAFB  	       LD    HL,(ADDR)
1306: E9      	       JP    (HL)        ;GOOD LUCK WITH THAT!
              	
              	
              	
              	
              	;----------------------------
              	; M DISPLAY AND MODIFY MEMORY
              	;----------------------------
1307: 3E4D    	MODIFY: LD A, 'M'
1309: CDAA05  	        CALL SEND_CHAR_TO_GLCD
130C: CD2902  	     CALL  LCD_SPACE
              	;
              	;GET THE ADDRESS        
              	;
130F: CD7011  	       CALL  GETCHR_KEYBOARD 
1312: D8      	       RET   C        
1313: 32CBFB  	       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
1316: CD7011  	       CALL  GETCHR_KEYBOARD
1319: D8      	       RET   C
131A: 32CAFB  	       LD    (ADDR),A    ;SAVE ADDRESS LOW 
              	;
              	; DISPLAY ON A NEW LINE
              	;       
131D: CD2302  	MDIFY1: CALL  LCD_CR       
1320: ED5BCAFB	       LD    DE,(ADDR)    
1324: 21A9FB  	       LD    HL,MSGBUF   
1327: CDFC11  	       CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
132A: 21A9FB  	       LD    HL,MSGBUF
132D: CD1512  	       CALL  WRDOUT      ;OUTPUT THE ADDRESS
1330: CD2902  	       CALL  LCD_SPACE    
              	;      
              	;GET THE DATA AT THE ADDRESS        
              	;
1333: 2ACAFB  	        LD   HL,(ADDR)       
1336: 7E      	        LD   A,(HL)
              	;
              	; DISPLAY THE DATA
              	;        
1337: 21A9FB  	       LD    HL,MSGBUF
133A: CD0112  	       CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
133D: 21A9FB  	       LD    HL,MSGBUF
1340: CD1812  	       CALL  BYTOUT      ;OUTPUT THE BYTE
1343: CD2902  	       CALL  LCD_SPACE
              	;
              	; GET NEW DATA,EXIT OR CONTINUE
              	;
1346: CD7011  	       CALL  GETCHR_KEYBOARD
1349: D8      	       RET   C
134A: 47      	       LD    B,A         ;SAVE IT FOR LATER
134B: 2ACAFB  	       LD    HL,(ADDR)
134E: 77      	       LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
134F: 78      	       LD    A,B
1350: BE      	       CP    (HL)
1351: 2805    	       JR    Z,MDIFY2
1353: 3E3F    	       LD    A,'?'
1355: CD3502  	       CALL  LCD_PRINT_A       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
              	;
              	; INCREMENT THE ADDRESS
              	;
1358: 23      	MDIFY2: INC   HL
1359: 22CAFB  	       LD    (ADDR),HL
135C: C31D13  	       JP    MDIFY1
              	
              	
              	
              	
              	;--------------------------
              	; D DISPLAY MEMORY LOCATION
              	;--------------------------
135F: 3E44    	DSPLAY: LD A, 'D'
1361: CDAA05  	        CALL SEND_CHAR_TO_GLCD
1364: CD2902  	        CALL  LCD_SPACE       ;A SPACE
1367: CD7011  	       CALL  GETCHR_KEYBOARD
136A: D8      	       RET   C         
136B: 32CBFB  	       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
136E: CD7011  	       CALL  GETCHR_KEYBOARD
1371: D8      	       RET   C
1372: 32CAFB  	       LD    (ADDR),A    ;SAVE ADDRESS LOW 
              	;
              	; WAIT FOR CR OR ESC
              	;
1375: CDB710  	DPLAY1: CALL  KEYREADINIT
1378: FE1B    	       CP    ESC
137A: C8      	       RET   Z
137B: FE0D    	       CP    CR
137D: 20F6    	       JR    NZ,DPLAY1          
137F: CD2302  	       CALL  LCD_CR      ;NEWLINE
              	;
              	; DISPLAY THE LINE
              	;
1382: CD9713  	DPLAY2: CALL  DPLINE
1385: ED53CAFB	       LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
              	;
              	; DISPLAY MORE LINES OR EXIT
              	;       
1389: CDB710  	DPLAY3: CALL  KEYREADINIT
138C: 38FB    	       JR    C,DPLAY3   
138E: FE0D    	       CP    CR        ;ENTER DISPLAYS THE NEXT LINE
1390: 28F0    	       JR    Z,DPLAY2
1392: FE1B    	       CP    ESC         ;ESC EXITS (SHIFT + C)
1394: 20F3    	       JR    NZ,DPLAY3     
1396: C9      	       RET   
              	;-------------------------
              	; DISPLAY A LINE OF MEMORY
              	;-------------------------      
1397: ED5BCAFB	DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
139B: 21A9FB  	       LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
              	;
              	; DISPLAY THE ADDRESS
              	;         
139E: CDFC11  	       CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
13A1: CDD713  	       CALL  SPCBUF        
              	;
              	; DISPLAY 4 BYTES
              	;
13A4: 0604    	       LD    B,4 ;16
13A6: 1A      	DLINE1: LD    A,(DE)
13A7: CD0112  	       CALL  BYTASC
13AA: CDD713  	       CALL  SPCBUF
13AD: 13      	       INC   DE        
13AE: 10F6    	       DJNZ  DLINE1
              	       ;CALL  SPCBUF
              	;
              	; NOW DISPLAY THE ASCII CHARACTER
              	; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
              	; BE DIFFERENT BETWEEN THE TWO PASSES!
              	;
13B0: ED5BCAFB	       LD    DE,(ADDR)    
13B4: 0604    	       LD    B,4 ; 4 bytes
13B6: 1A      	DLINE2: LD    A,(DE)   
13B7: FE20    	       CP    20H
13B9: 3807    	       JR    C,DOT
13BB: FE7F    	       CP    7FH
13BD: 3003    	       JR    NC,DOT
13BF: C3C413  	       JP    NDOT
13C2: 3E2E    	DOT:    LD    A,'.'
13C4: CDD913  	NDOT:   CALL  INBUF
13C7: 13      	       INC   DE       
13C8: 10EC    	       DJNZ  DLINE2
              	;         
              	;TERMINATE AND DISPLAY STRING
              	;       
13CA: CDDC13  	       CALL  BCRLF
13CD: 3E00    	       LD    A,00H
13CF: 77      	       LD    (HL),A
13D0: 21A9FB  	       LD    HL, MSGBUF
13D3: CD6402  	       CALL  LCD_PRINT_STRING
13D6: C9      	       RET
              	
              	
              	;
              	; PUT A SPACE IN THE BUFFER
              	;
13D7: 3E20    	SPCBUF: LD    A, 20H
13D9: 77      	INBUF:  LD    (HL),A
13DA: 23      	       INC   HL
13DB: C9      	       RET
              	;
              	; PUT A CR LF IN THE BUFFER
              	;        
13DC:         	BCRLF:  ;LD    A,CR  
              	       ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
13DC: C9      	       RET
              	
              	
              	
              	;----------------------------------------------
              	; Output value to port
              	; O AA DD - Port address in AA, Data to out in DD
              	;----------------------------------------------
13DD:         	OUTPORT:
13DD: 3E4F    	    LD A, 'O'
13DF: CDAA05  	    CALL SEND_CHAR_TO_GLCD
13E2: CD2902  	    CALL LCD_SPACE ; space and show lcd
              	
13E5: CD7011  	    CALL  GETCHR_KEYBOARD 
13E8: D8      	    RET   C
13E9: 4F      	    LD C, A
              	
13EA: CD2902  	    CALL LCD_SPACE
              	
13ED: CD7011  	    CALL  GETCHR_KEYBOARD 
13F0: D8      	    RET   C
13F1: ED79    	    OUT (C), A
13F3: 3E0D    	    LD A, CR ; retorna Enter 
13F5: C9      	    RET
              	
              	
              	;----------------------------------------------
              	; Read input port and show value to LCD
              	; I AA - Port address in AA
              	;----------------------------------------------
13F6:         	INPORT_MON:
13F6: 3E49    	    LD A, 'I'
13F8: CDAA05  	    CALL SEND_CHAR_TO_GLCD
13FB: CD2902  	    CALL LCD_SPACE ; space and show lcd
              	
13FE: CD7011  	    CALL  GETCHR_KEYBOARD 
1401: D8      	    RET   C
1402: 4F      	    LD C, A
              	
1403: ED78    	    IN A, (C)
              	
1405: 47      	    LD B, A
1406: CD2302  	    CALL LCD_CR
1409: 78      	    LD A, B
              	
140A: CDC311  	    CALL CONV_A_HEX
140D: 3E0D    	    LD A, CR
140F: C9      	    RET
              	
              	
              	
              	;--------------------------
              	; 8 - Read memory
              	;--------------------------
1410:         	READ_MEM_FILES:
1410: 110000  	    LD DE, $0000 ; start "D"? File
1413:         	READ_MEM_NEXT:
1413: CDF914  	    CALL READ_IIC_DE
1416: B7      	    OR A
1417: FE44    	    CP 'D'
1419: CA2814  	    JP Z, READ_FILE
141C: 21BA18  	    LD HL, MSG_EOF
141F: CD2302  	    CALL LCD_CR
1422: CD6402  	    CALL LCD_PRINT_STRING
1425: 3E0D    	    LD A, CR
1427: C9      	    RET
              	
1428:         	READ_FILE:
1428: CD2302  	    CALL LCD_CR ; new line
142B: CD2302  	    CALL LCD_CR ; new line
142E: 0610    	    LD B, 16
1430:         	READ_NAME:
1430: 13      	    INC DE
1431: CDF914  	    CALL READ_IIC_DE
1434: B7      	    OR A
1435: FE00    	    CP 0
1437: C43502  	    CALL NZ, LCD_PRINT_A
143A: 05      	    DEC B
143B: C23014  	    JP NZ, READ_NAME
              	
143E:         	READ_MEM_KEY:
              	    ; Show commands
143E: D5      	    PUSH DE
143F: 13      	    INC DE
1440: CDF914  	    CALL READ_IIC_DE
1443: B7      	    OR A
1444: FE00    	    CP 0
1446: CCE414  	    CALL Z, SHOW_MSG_EXE
1449: FE01    	    CP 1
144B: CCEB14  	    CALL Z, SHOW_MSG_IMG
144E: FE02    	    CP 2
1450: CCF214  	    CALL Z, SHOW_MSG_TXT
1453: D1      	    POP DE
              	    ; wait command
1454: CDB710  	    CALL KEYREADINIT ; read key
1457: FE03    	    CP    CTRLC ; key BK, read next
1459: CA7614  	    JP    Z, READ_MEM_STEP
145C: FE0D    	    CP    CR  ; key Enter, execute
145E: C23E14  	    JP    NZ, READ_MEM_KEY
              	    ;read type
1461: 13      	    INC DE
1462: CDF914  	    CALL READ_IIC_DE
1465: B7      	    OR A
1466: FE00    	    CP 0
1468: CA8D14  	    JP Z, READ_FILE_EXE
146B: FE01    	    CP 1
146D: CAA314  	    JP Z, READ_FILE_IMG
1470: FE02    	    CP 2
1472: CAC614  	    JP Z, READ_FILE_TXT
1475: C9      	    RET
              	
1476:         	READ_MEM_STEP:
1476: 13      	    INC DE ; type
1477: 13      	    INC DE ; size H
1478: CDF914  	    CALL READ_IIC_DE
147B: 67      	    LD H, A
147C: 13      	    INC DE ; size L
147D: CDF914  	    CALL READ_IIC_DE
1480: 6F      	    LD L, A
1481:         	READ_MEM_STEP_L:
1481: 13      	    INC DE ; step file
1482: 2B      	    DEC HL
1483: 7C      	    LD A, H
1484: B5      	    OR L
1485: C28114  	    JP NZ, READ_MEM_STEP_L
1488: 13      	    INC DE ; end
1489: 13      	    INC DE ; nex start
148A: C31314  	    JP READ_MEM_NEXT
              	
              	
148D:         	READ_FILE_EXE:
              	    ; read size H
148D: 13      	    INC DE
148E: CDF914  	    CALL READ_IIC_DE
1491: 47      	    LD B, A
              	
              	    ; read size L
1492: 13      	    INC DE
1493: CDF914  	    CALL READ_IIC_DE
1496: 4F      	    LD C, A
              	
1497: 13      	    INC DE ; first byte file
1498: 210080  	    LD HL, $8000 ; memory user
              	
149B: CDA20E  	    CALL I2C_MemRd
149E: E1      	    POP HL ; return
149F: C30080  	    JP $8000
14A2: C9      	    RET
              	
14A3:         	READ_FILE_IMG:
              	    ; read size H
14A3: 13      	    INC DE
14A4: CDF914  	    CALL READ_IIC_DE
14A7: 47      	    LD B, A
              	
              	    ; read size L
14A8: 13      	    INC DE
14A9: CDF914  	    CALL READ_IIC_DE
14AC: 4F      	    LD C, A
              	
14AD: 13      	    INC DE ; first byte file
14AE: 210080  	    LD HL, $8000 ; memory user
              	
14B1: CDA20E  	    CALL I2C_MemRd
              	
14B4: 2680    	    LD H, $80
14B6: 2E00    	    LD L, $00
14B8: CD7402  	    CALL LCD_IMAGE_128x64
              	
14BB:         	READ_FILE_IMG_K:
14BB: CDB710  	    CALL KEYREADINIT ; read key
14BE: FE03    	    CP    CTRLC ; key BK, read next
14C0: C2BB14  	    JP    NZ, READ_FILE_IMG_K
14C3: 3E0C    	    LD A, CS
14C5: C9      	    RET
              	
14C6:         	READ_FILE_TXT:
14C6: CD2F02  	    CALL LCD_CLEAR
              	
              	    ; read size H
14C9: 13      	    INC DE
14CA: CDF914  	    CALL READ_IIC_DE
14CD: 47      	    LD B, A
              	
              	    ; read size L
14CE: 13      	    INC DE
14CF: CDF914  	    CALL READ_IIC_DE
14D2: 4F      	    LD C, A
              	
14D3: 13      	    INC DE ; first byte file
14D4:         	READ_FILE_TXT_L:
14D4: CDF914  	    CALL READ_IIC_DE
14D7: CD3502  	    CALL LCD_PRINT_A
14DA: 13      	    INC DE ; step file
14DB: 0B      	    DEC BC
14DC: 78      	    LD A, B
14DD: B1      	    OR C
14DE: C2D414  	    JP NZ, READ_FILE_TXT_L
14E1: 13      	    INC DE ; end
14E2: 13      	    INC DE ; next start    
14E3: C9      	    RET
              	
              	
14E4:         	SHOW_MSG_EXE:
14E4: 217F18  	    LD HL, MSG_READFILE_EXE
14E7: CD6402  	    CALL LCD_PRINT_STRING
14EA: C9      	    RET
              	
14EB:         	SHOW_MSG_IMG:
14EB: 218418  	    LD HL, MSG_READFILE_IMG
14EE: CD6402  	    CALL LCD_PRINT_STRING
14F1: C9      	    RET
              	
14F2:         	SHOW_MSG_TXT:
14F2: 218918  	    LD HL, MSG_READFILE_TXT
14F5: CD6402  	    CALL LCD_PRINT_STRING
14F8: C9      	    RET
              	
              	; Read byte in i2c, address in DE, return byte in A
14F9:         	READ_IIC_DE:
14F9: C5      	    PUSH BC
14FA: D5      	    PUSH DE
14FB: E5      	    PUSH HL
14FC: 3EAE    	    LD   A, I2CA_BLOCK   ;I2C address to write to
14FE: CDB30D  	    CALL I2C_Open
1501: 7A      	    LD   A, D           ;Address (hi) in I2C memory
1502: CDBD0D  	    CALL I2C_Write      ;Write address
1505: 7B      	    LD   A,E            ;Address (lo) in I2C memory
1506: CDBD0D  	    CALL I2C_Write      ;Write address
1509: 3EAF    	    LD   A,I2CA_BLOCK+1 ;I2C device to be read from
150B: CDB30D  	    CALL I2C_Open       ;Open for read
150E: CDFA0D  	    CALL I2C_Read
1511: F5      	    PUSH AF
1512: CD320E  	    CALL I2C_Stop       ;Generate I2C stop
1515: F1      	    POP AF
1516: E1      	    POP HL
1517: D1      	    POP DE
1518: C1      	    POP BC
1519: C9      	    RET
              	
              	
              	
151A:         	I2CCPUTOMEM:
              	; Get parameters to copy a block from CPU memory to I2C memory
              	;   On entry: DE = First address in I2C memory
              	;             HL = First address in CPU memory
              	;             BC = Number of bytes to be copied
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             IX IY preserved
              	; The 24LC64 requires blocks of data to be written in 64 byte (or less)
              	; pages.
151A: CD2F02  	    CALL LCD_CLEAR
151D: 21F818  	    LD HL, MSG_CPU2MEM
1520: CD6402  	    CALL LCD_PRINT_STRING
              	
1523: CD4F15  	    CALL GET_FROM_TO_SIZE
              	
1526: 2AA3FB  	    LD HL, (ADDR_FROM)
1529: ED5BA5FB	    LD DE, (ADDR_TO)
152D: ED4BA7FB	    LD BC, (ADDR_SIZE)
1531:         	I2CCPUTOMEM_BASIC:
1531: CDD70E  	    CALL I2C_MemWr
              	    
1534: CA4315  	    JP Z, I2CCPUTOMEM_OK
1537: CD2302  	    CALL LCD_CR
153A: 21B018  	    LD HL, MSG_COPYFAIL
153D: CD6402  	    CALL LCD_PRINT_STRING
1540: 3E0D    	    LD A, CR
1542: C9      	    RET
1543:         	I2CCPUTOMEM_OK:
1543: CD2302  	    CALL LCD_CR
1546: 21A818  	    LD HL, MSG_COPYOK
1549: CD6402  	    CALL LCD_PRINT_STRING
154C: 3E0D    	    LD A, CR
154E: C9      	    RET
              	
              	
154F:         	GET_FROM_TO_SIZE:
              	    ; FROM
154F: CD2302  	    CALL LCD_CR
1552: 218E18  	    LD HL, MSG_FROM
1555: CD6402  	    CALL LCD_PRINT_STRING
              	    ;
              	    ;GET THE ADDRESS  FROM
              	    ;
1558: CD7011  	    CALL  GETCHR_KEYBOARD 
155B: D8      	    RET   C        
155C: 32A4FB  	    LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
155F: CD7011  	    CALL  GETCHR_KEYBOARD
1562: D8      	    RET   C
1563: 32A3FB  	    LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW
              	
1566: CDB710  	    CALL  KEYREADINIT
1569: FE1B    	    CP    ESC         ;ESC KEY?
156B: C8      	    RET   Z
156C: FE0D    	    CP    CR
156E: 2808    	    JR Z, GET_FROM_TO_SIZE_TO
1570: 3E0D    	    LD A, CR
1572: CD3502  	    CALL LCD_PRINT_A
1575: C34F15  	    JP GET_FROM_TO_SIZE
              	
1578:         	GET_FROM_TO_SIZE_TO:
              	    ; TO
1578: CD2302  	    CALL LCD_CR
157B: 219518  	    LD HL, MSG_TO
157E: CD6402  	    CALL LCD_PRINT_STRING
              	    ;
              	    ;GET THE ADDRESS  TO
              	    ;
1581: CD7011  	    CALL  GETCHR_KEYBOARD 
1584: D8      	    RET   C        
1585: 32A6FB  	    LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
1588: CD7011  	    CALL  GETCHR_KEYBOARD
158B: D8      	    RET   C
158C: 32A5FB  	    LD    (ADDR_TO),A    ;SAVE ADDRESS LOW
              	
158F: CDB710  	    CALL  KEYREADINIT
1592: FE1B    	    CP    ESC         ;ESC KEY?
1594: C8      	    RET   Z
1595: FE0D    	    CP    CR
1597: 20DF    	    JR NZ, GET_FROM_TO_SIZE_TO
              	
1599:         	GET_FROM_TO_SIZE_SIZE:
              	    ; SIZE
1599: CD2302  	    CALL LCD_CR
159C: 219A18  	    LD HL, MSG_SIZE
159F: CD6402  	    CALL LCD_PRINT_STRING
              	    ;
              	    ;GET THE SIZE
              	    ;
15A2: CD7011  	    CALL  GETCHR_KEYBOARD 
15A5: D8      	    RET   C        
15A6: 32A8FB  	    LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
15A9: CD7011  	    CALL  GETCHR_KEYBOARD
15AC: D8      	    RET   C
15AD: 32A7FB  	    LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW
              	
15B0: CDB710  	    CALL  KEYREADINIT
15B3: FE1B    	    CP    ESC         ;ESC KEY?
15B5: C8      	    RET   Z
15B6: FE0D    	    CP    CR
15B8: 20DF    	    JR NZ, GET_FROM_TO_SIZE_SIZE
15BA: C9      	    RET
              	
              	
              	
15BB:         	I2CMEMTOCPU:
              	    ; Get parameters to copy a block from I2C memory to CPU memory
              	;   On entry: DE = First address in I2C memory
              	;             HL = First address in CPU memory
              	;             BC = Number of bytes to be copied
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             IX IY preserved
15BB: CD2F02  	    CALL LCD_CLEAR
15BE: 210D19  	    LD HL, MSG_MEM2CPU
15C1: CD6402  	    CALL LCD_PRINT_STRING
              	
15C4: CD4F15  	    CALL GET_FROM_TO_SIZE
15C7: ED5BA3FB	    LD DE, (ADDR_FROM)
15CB: 2AA5FB  	    LD HL, (ADDR_TO)
15CE: ED4BA7FB	    LD BC, (ADDR_SIZE)
15D2:         	I2CMEMTOCPU_BASIC:
15D2: CDA20E  	    CALL I2C_MemRd  
              	
15D5: CAE415  	    JP Z, I2CMEMTOCPU_OK
15D8: CD2302  	    CALL LCD_CR
15DB: 21B018  	    LD HL, MSG_COPYFAIL
15DE: CD6402  	    CALL LCD_PRINT_STRING
15E1: 3E0D    	    LD A, CR
15E3: C9      	    RET
15E4:         	I2CMEMTOCPU_OK:
15E4: CD2302  	    CALL LCD_CR
15E7: 21A818  	    LD HL, MSG_COPYOK
15EA: CD6402  	    CALL LCD_PRINT_STRING
15ED: 3E0D    	    LD A, CR
15EF: C9      	    RET
              	
              	
              	
              	
              	; --------------------------------------
              	; I2C - Write one byte
              	; --------------------------------------
15F0:         	I2C_WR_DD:
15F0: CD2F02  	    CALL LCD_CLEAR
              	
              	    ; Show msg func
15F3: 212219  	    LD HL, MSG_I2C_WR_DD
15F6: CD6402  	    CALL LCD_PRINT_STRING
              	
              	    ; Device Address
15F9: CD9D16  	    CALL GET_DEV_ADDR ; get address
              	
15FC:         	I2C_WR_DD_LOOP:
              	    ; Get Data
15FC: CDAE16  	    CALL GET_DEV_DD   ; get data
              	
              	    ; Send
15FF: 3AA0FB  	    LD A, (I2C_ADDR) ; Open
1602: CDB30D  	    CALL I2C_Open
              	
1605: 3AA2FB  	    LD A, (I2C_DD)  ; Data
1608: CDBD0D  	    CALL I2C_Write
              	 
160B: CDBA0D  	    CALL I2C_Close  ; Close
              	
160E: 18EC    	    JR I2C_WR_DD_LOOP
              	
1610: C9      	    RET
              	
              	
              	
              	; --------------------------------------
              	; I2C - Write register one byte
              	; --------------------------------------
1611:         	I2C_WR_RR_DD:
1611: CD2F02  	    CALL LCD_CLEAR
              	
              	    ; Show msg func
1614: 213219  	    LD HL, MSG_I2C_WR_RR_DD
1617: CD6402  	    CALL LCD_PRINT_STRING
              	
              	    ; Device Address
161A: CD9D16  	    CALL GET_DEV_ADDR ; get address
              	
161D:         	I2C_WR_RR_DD_LOOP:
              	    ; Get register
161D: CDBF16  	    CALL GET_DEV_RR ; get address
              	
              	    ; Get Data
1620: CDAE16  	    CALL GET_DEV_DD   ; get data
              	
              	    ; Send
1623: 3AA0FB  	    LD A, (I2C_ADDR) ; Open
1626: CDB30D  	    CALL I2C_Open
              	
1629: 3AA1FB  	    LD A, (I2C_RR)  ; register
162C: CDBD0D  	    CALL I2C_Write
              	
162F: 3AA2FB  	    LD A, (I2C_DD)  ; Data
1632: CDBD0D  	    CALL I2C_Write
              	
1635: CDBA0D  	    CALL I2C_Close  ; Close
              	
1638: 18E3    	    JR I2C_WR_RR_DD_LOOP
              	
163A: C9      	    RET
              	
              	
              	
              	
              	; --------------------------------------
              	; I2C - Read one byte
              	; --------------------------------------
163B:         	I2C_RD:
163B: CD2F02  	    CALL LCD_CLEAR
              	
              	    ; Show msg func
163E: 214619  	    LD HL, MSG_I2C_RD
1641: CD6402  	    CALL LCD_PRINT_STRING
              	
              	    ; Device Address
1644: CD9D16  	    CALL GET_DEV_ADDR ; get address
1647: CD2302  	    CALL LCD_CR ; new line
              	
164A:         	I2C_RD_LOOP:
              	    ; Send
164A: 3AA0FB  	    LD A, (I2C_ADDR) ; Open
164D: 3C      	    INC A ; To read address + 1 (flag)
164E: CDB30D  	    CALL I2C_Open
              	
1651: CDFA0D  	    CALL I2C_Read      ; Read
1654: F5      	    PUSH AF
              	
1655: CDBA0D  	    CALL I2C_Close     ; Close
              	
              	    ; Show
1658: F1      	    POP AF
1659: CDC311  	    CALL CONV_A_HEX ; Show A to (HEX) LCD
165C: CD2302  	    CALL LCD_CR ; new line
              	
165F: CDB710  	    CALL KEYREADINIT
1662: FE03    	    CP CTRLC
1664: CA9701  	    JP Z, RESET_WARM
              	
1667: 18E1    	    JR I2C_RD_LOOP
1669: C9      	    RET
              	
              	
              	; --------------------------------------
              	; I2C - Read register one byte
              	; --------------------------------------
166A:         	I2C_RD_RR:
166A: CD2F02  	    CALL LCD_CLEAR
              	
              	    ; Show msg func
166D: 215519  	    LD HL, MSG_I2C_RD_RR
1670: CD6402  	    CALL LCD_PRINT_STRING
              	
              	    ; Device Address
1673: CD9D16  	    CALL GET_DEV_ADDR ; get address
              	
1676:         	I2C_RD_RR_LOOP:
              	    ; Get register
1676: CDBF16  	    CALL GET_DEV_RR ; get address
1679: CD2302  	    CALL LCD_CR ; new line
              	
              	    ; Send
167C: 3AA0FB  	    LD A, (I2C_ADDR) ; Open
167F: CDB30D  	    CALL I2C_Open
              	
1682: 3AA1FB  	    LD A, (I2C_RR)
1685: CDBD0D  	    CALL I2C_Write ; Register to read
              	
1688: 3AA0FB  	    LD A, (I2C_ADDR) ; Open
168B: 3C      	    INC A ; To read address + 1 (flag)
168C: CDB30D  	    CALL I2C_Open
              	
168F: CDFA0D  	    CALL I2C_Read ; Read register
1692: F5      	    PUSH AF
              	
1693: CDBA0D  	    CALL I2C_Close ; Close
              	
              	    ; Show
1696: F1      	    POP AF
1697: CDC311  	    CALL CONV_A_HEX ; Show A to (HEX) LCD
              	
169A: 18DA    	    JR I2C_RD_RR_LOOP
169C: C9      	    RET
              	
              	
              	
              	
              	
169D:         	GET_DEV_ADDR:
169D: CD2302  	    CALL LCD_CR
16A0: 21CC18  	    LD HL, MSG_DEV_ADDR
16A3: CD6402  	    CALL LCD_PRINT_STRING
16A6: CD7011  	    CALL  GETCHR_KEYBOARD 
16A9: D8      	    RET   C
16AA: 32A0FB  	    LD (I2C_ADDR), A
16AD: C9      	    RET
              	
16AE:         	GET_DEV_DD:
16AE: CD2302  	    CALL LCD_CR
16B1: 21ED18  	    LD HL, MSG_DEV_DATA
16B4: CD6402  	    CALL LCD_PRINT_STRING
              	
16B7: CD7011  	    CALL  GETCHR_KEYBOARD 
16BA: D8      	    RET   C
16BB: 32A2FB  	    LD (I2C_DD), A
16BE: C9      	    RET
              	
16BF:         	GET_DEV_RR:
16BF: CD2302  	    CALL LCD_CR
16C2: 21DE18  	    LD HL, MSG_DEV_REG
16C5: CD6402  	    CALL LCD_PRINT_STRING
              	
16C8: CD7011  	    CALL  GETCHR_KEYBOARD 
16CB: D8      	    RET   C
16CC: 32A1FB  	    LD (I2C_RR), A
16CF: C9      	    RET
              	
              	
              	
              	
              	
              	
              	
              	
16D0: 0C0D0D0A	WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
16D4: 5A383020	
16D8: 4D696E69	
16DC: 20496E69	
16E0: 63696164	
16E4: 6F0D0A00	
16E8: 5A383020	WELLCOME_LCD: .db "Z80 Mini Iniciado", CR, 00H
16EC: 4D696E69	
16F0: 20496E69	
16F4: 63696164	
16F8: 6F0D00  	
              	
16FB: 46312052	MSG_MENU0  .db "F1 RUN (JP $8000)",CR, 00H
16FF: 554E2028	
1703: 4A502024	
1707: 38303030	
170B: 290D00  	
170E: 46322049	MSG_MENU1  .db "F2 Intel hex loader",CR, 00H
1712: 6E74656C	
1716: 20686578	
171A: 206C6F61	
171E: 6465720D	
1722: 00      	
1723: 4633204C	MSG_MENU2  .db "F3 LIVRE",CR, 00H
1727: 49565245	
172B: 0D00    	
172D: 4634204C	MSG_MENU3  .db "F4 LIVRE",CR, 00H
1731: 49565245	
1735: 0D00    	
1737: 4635204C	MSG_MENU4  .db "F5 LIVRE",CR, 00H
173B: 49565245	
173F: 0D00    	
              	
1741: 42202D20	MSG_MENU8  .db "B - Basic",CR, 00H
1745: 42617369	
1749: 630D00  	
174C: 44204141	MSG_MENU9  .db "D AAAA - DISPLAY",CR,00H
1750: 4141202D	
1754: 20444953	
1758: 504C4159	
175C: 0D00    	
175E: 4D204141	MSG_MENU10 .db "M AAAA - MODIFY",CR,00H
1762: 4141202D	
1766: 204D4F44	
176A: 4946590D	
176E: 00      	
176F: 47204141	MSG_MENU11 .db "G AAAA - GO TO",CR, 00H
1773: 4141202D	
1777: 20474F20	
177B: 544F0D00	
177F: 4F204F75	MSG_MENU12 .db "O Out AA DD",CR, 00H
1783: 74204141	
1787: 2044440D	
178B: 00      	
178C: 4920496E	MSG_MENU13 .db "I In AA",CR, 00H
1790: 2041410D	
1794: 00      	
1795: 31204932	MSG_MENU14 .db "1 I2C Scan",CR, 00H
1799: 43205363	
179D: 616E0D00	
17A1: 32204932	MSG_MENU15 .db "2 I2C PC -> MEM",CR, 00H
17A5: 43205043	
17A9: 202D3E20	
17AD: 4D454D0D	
17B1: 00      	
17B2: 33204932	MSG_MENU16 .db "3 I2C MEM -> PC",CR, 00H
17B6: 43204D45	
17BA: 4D202D3E	
17BE: 2050430D	
17C2: 00      	
17C3: 34204932	MSG_MENU17 .db "4 I2C WRITE DD",CR, 00H
17C7: 43205752	
17CB: 49544520	
17CF: 44440D00	
17D3: 35204932	MSG_MENU18 .db "5 I2C WRITE RR DD",CR, 00H
17D7: 43205752	
17DB: 49544520	
17DF: 52522044	
17E3: 440D00  	
17E6: 36204932	MSG_MENU19 .db "6 I2C READ ONE BYTE",CR, 00H
17EA: 43205245	
17EE: 4144204F	
17F2: 4E452042	
17F6: 5954450D	
17FA: 00      	
17FB: 37204932	MSG_MENU20 .db "7 I2C READ RR BYTE", CR, 00H 
17FF: 43205245	
1803: 41442052	
1807: 52204259	
180B: 54450D00	
180F: 38205265	MSG_MENU21 .db "8 Read Memory", CR, 00H 
1813: 6164204D	
1817: 656D6F72	
181B: 790D00  	
              	
181E: 49324320	I2C_LIST_MSG:    .DB "I2C device found at:",CR,0
1822: 64657669	
1826: 63652066	
182A: 6F756E64	
182E: 2061743A	
1832: 0D00    	
              	
1834: 496E7465	MSG_ILOAD   .db  "Intel HEX loader...",CR, 00H
1838: 6C204845	
183C: 58206C6F	
1840: 61646572	
1844: 2E2E2E0D	
1848: 00      	
1849: 46494C45	FILEOK      .DB  "FILE RECEIVED OK",CR, 00H
184D: 20524543	
1851: 45495645	
1855: 44204F4B	
1859: 0D00    	
185B: 43484543	CSUMERR     .DB  "CHECKSUM ERROR",CR, 00H
185F: 4B53554D	
1863: 20455252	
1867: 4F520D00	
              	
186B: 2843296F	MSG_BASIC .db "(C)old or (w)arm ?",CR, 00H
186F: 6C64206F	
1873: 72202877	
1877: 2961726D	
187B: 203F0D00	
              	
187F: 5F455845	MSG_READFILE_EXE .db "_EXE", 00H
1883: 00      	
1884: 5F494D47	MSG_READFILE_IMG .db "_IMG", 00H
1888: 00      	
1889: 5F545854	MSG_READFILE_TXT .db "_TXT", 00H
188D: 00      	
              	
188E: 46524F4D	MSG_FROM    .db "FROM: ", 00H
1892: 3A2000  	
1895: 544F3A20	MSG_TO      .db "TO: ", 00H
1899: 00      	
189A: 53495A45	MSG_SIZE    .db "SIZE(BYTES): ", 00H
189E: 28425954	
18A2: 4553293A	
18A6: 2000    	
18A8: 434F5059	MSG_COPYOK  .db "COPY OK", 00H
18AC: 204F4B00	
18B0: 434F5059	MSG_COPYFAIL  .db "COPY FAIL", 00H
18B4: 20464149	
18B8: 4C00    	
18BA: 202D202D	MSG_EOF  .db " - - - FIM - - - ", 00H
18BE: 202D2046	
18C2: 494D202D	
18C6: 202D202D	
18CA: 2000    	
              	
18CC: 44455649	MSG_DEV_ADDR  .db "DEVICE ADDR(AA): ", 00H
18D0: 43452041	
18D4: 44445228	
18D8: 4141293A	
18DC: 2000    	
18DE: 52454749	MSG_DEV_REG   .db "REGISTER(RR): ", 00H
18E2: 53544552	
18E6: 28525229	
18EA: 3A2000  	
18ED: 44415441	MSG_DEV_DATA  .db "DATA(DD): ", 00H
18F1: 28444429	
18F5: 3A2000  	
              	
18F8: 434F5059	MSG_CPU2MEM .db "COPY CPU TO I2C MEM",CR, 00H
18FC: 20435055	
1900: 20544F20	
1904: 49324320	
1908: 4D454D0D	
190C: 00      	
190D: 434F5059	MSG_MEM2CPU .db "COPY I2C MEM TO CPU",CR, 00H
1911: 20493243	
1915: 204D454D	
1919: 20544F20	
191D: 4350550D	
1921: 00      	
1922: 57524954	MSG_I2C_WR_DD    .db "WRITE ONE BYTE",CR, 00H
1926: 45204F4E	
192A: 45204259	
192E: 54450D00	
1932: 57524954	MSG_I2C_WR_RR_DD .db "WRITE REG ONE BYTE",CR, 00H
1936: 45205245	
193A: 47204F4E	
193E: 45204259	
1942: 54450D00	
1946: 52454144	MSG_I2C_RD       .db "READ ONE BYTE",CR, 00H
194A: 204F4E45	
194E: 20425954	
1952: 450D00  	
1955: 52454144	MSG_I2C_RD_RR    .db "READ REG ONE BYTE",CR, 00H
1959: 20524547	
195D: 204F4E45	
1961: 20425954	
1965: 450D00  	
              	
              	
              	#include "MSBasic.asm"
              	;==================================================================================
              	; The updates to the original BASIC within this file are copyright Grant Searle
              	;
              	; You have permission to use this for NON COMMERCIAL USE ONLY
              	; If you wish to use it elsewhere, please include an acknowledgement to myself.
              	;
              	; http://searle.hostei.com/grant/index.html
              	;
              	; eMail: home.micros01@btinternet.com
              	;
              	; If the above don't work, please perform an Internet search to see if I have
              	; updated the web page hosting service.
              	;
              	;==================================================================================
              	
              	; GENERAL EQUATES
              	
0003:         	CTRLC   .EQU    03H             ; Control "C"
0007:         	CTRLG   .EQU    07H             ; Control "G"
0008:         	BKSP    .EQU    08H             ; Back space
000A:         	LF      .EQU    0AH             ; Line feed
000C:         	CS      .EQU    0CH             ; Clear screen
000D:         	CR      .EQU    0DH             ; Carriage return
000F:         	CTRLO   .EQU    0FH             ; Control "O"
0011:         	CTRLQ	.EQU	11H		        ; Control "Q"
0012:         	CTRLR   .EQU    12H             ; Control "R"
0013:         	CTRLS   .EQU    13H             ; Control "S"
0015:         	CTRLU   .EQU    15H             ; Control "U"
001B:         	ESC     .EQU    1BH             ; Escape
007F:         	DEL     .EQU    7FH             ; Delete
              	
              	
              	; BASIC WORK SPACE LOCATIONS
              	
8000:         	WRKSPC  .EQU    8000H             ; BASIC Work space |32768|
8003:         	USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
8006:         	OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
8007:         	OTPORT  .EQU    WRKSPC+7H           ; Port (p)
8009:         	DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
800A:         	DIV1    .EQU    WRKSPC+0AH           ; <- Values
800E:         	DIV2    .EQU    WRKSPC+0EH           ; <-   to
8012:         	DIV3    .EQU    WRKSPC+12H           ; <-   be
8015:         	DIV4    .EQU    WRKSPC+15H           ; <-inserted
8017:         	SEED    .EQU    WRKSPC+17H           ; Random number seed
803A:         	LSTRND  .EQU    WRKSPC+3AH           ; Last random number
803E:         	INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
803F:         	INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
8041:         	NULLS   .EQU    WRKSPC+41H           ; Number of nulls
8042:         	LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
8043:         	COMMAN  .EQU    WRKSPC+43H           ; Width for commas
8044:         	NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
8045:         	CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
8046:         	LINESC  .EQU    WRKSPC+46H           ; Lines counter
8048:         	LINESN  .EQU    WRKSPC+48H           ; Lines number
804A:         	CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
804C:         	NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
804D:         	BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
804E:         	RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
8051:         	POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
8054:         	PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
8057:         	RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
805A:         	STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
805C:         	LINEAT  .EQU    WRKSPC+5CH           ; Current line number
805E:         	BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
8061:         	BUFFER  .EQU    WRKSPC+61H           ; Input buffer
8066:         	STACK   .EQU    WRKSPC+66H           ; Initial stack
80AB:         	CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
80AC:         	LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
80AD:         	TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
80AE:         	DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
80AF:         	LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
80B1:         	TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
80B3:         	TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
80BF:         	TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
80C3:         	STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
80C5:         	CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
80C7:         	LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
80C9:         	DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
80CB:         	FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
80CC:         	LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
80CD:         	READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
80CE:         	BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
80D0:         	NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
80D2:         	ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
80D4:         	CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
80D6:         	PROGND  .EQU    WRKSPC+0D6H          ; End of program
80D8:         	VAREND  .EQU    WRKSPC+0D8H          ; End of variables
80DA:         	ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
80DC:         	NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
80DE:         	FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
80E0:         	FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
80E4:         	FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
80E7:         	FPEXP   .EQU    FPREG+3         ; Floating point exponent
80E8:         	SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
80E9:         	PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
80F6:         	MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
80F9:         	PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area |33280 + 249 = 33529|
815D:         	STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	
0000:         	NF      .EQU    00H             ; NEXT without FOR
0002:         	SN      .EQU    02H             ; Syntax error
0004:         	RG      .EQU    04H             ; RETURN without GOSUB
0006:         	OD      .EQU    06H             ; Out of DATA
0008:         	FC      .EQU    08H             ; Function call error
000A:         	OV      .EQU    0AH             ; Overflow
000C:         	OM      .EQU    0CH             ; Out of memory
000E:         	UL      .EQU    0EH             ; Undefined line number
0010:         	BS      .EQU    10H             ; Bad subscript
0012:         	DD      .EQU    12H             ; Re-DIMensioned array
0014:         	DZ      .EQU    14H             ; Division by zero (/0)
0016:         	ID      .EQU    16H             ; Illegal direct
0018:         	TM      .EQU    18H             ; Type miss-match
001A:         	OS      .EQU    1AH             ; Out of string space
001C:         	LS      .EQU    1CH             ; String too long
001E:         	ST      .EQU    1EH             ; String formula too complex
0020:         	CN      .EQU    20H             ; Can't CONTinue
0022:         	UF      .EQU    22H             ; UnDEFined FN function
0024:         	MO      .EQU    24H             ; Missing operand
0026:         	HX      .EQU    26H             ; HEX error
0028:         	BN      .EQU    28H             ; BIN error
              	
1968: FFFFFFFF	        .ORG    $6000
196C: FF...   	
              	
6000: C30660  	COLD:   JP      STARTB          ; Jump for cold start
6003: C3A460  	WARM:   JP      WARMST          ; Jump for warm start
6006:         	STARTB: 
6006: DD210000	        LD      IX,0            ; Flag cold start
600A: C31160  	        JP      CSTART          ; Jump to initialise
              	
600D: AE68    	        .WORD   DEINT           ; Get integer -32768 to 32767
600F: 2470    	        .WORD   ABPASS          ; Return integer in AB
              	
              	
6011: 210080  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
6014: F9      	        LD      SP,HL           ; Set up a temporary stack
6015: C3437C  	        JP      INITST          ; Go to initialise
              	
6018: 11C562  	INIT:   LD      DE,INITAB       ; Initialise workspace
601B: 0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
601D: 210080  	        LD      HL,WRKSPC       ; Into workspace RAM
6020: 1A      	COPY:   LD      A,(DE)          ; Get source
6021: 77      	        LD      (HL),A          ; To destination
6022: 23      	        INC     HL              ; Next destination
6023: 13      	        INC     DE              ; Next source
6024: 05      	        DEC     B               ; Count bytes
6025: C22060  	        JP      NZ,COPY         ; More to move
6028: F9      	        LD      SP,HL           ; Temporary stack
6029: CDC664  	        CALL    CLREG           ; Clear registers and stack
602C: CDA46A  	        CALL    PRNTCRLF        ; Output CRLF
602F: 32AA80  	        LD      (BUFFER+72+1),A ; Mark end of buffer
6032: 32F980  	        LD      (PROGST),A      ; Initialise program area
6035: 21CF60  	MSIZE:  LD      HL,MEMMSG       ; Point to message
6038: CD4271  	        CALL    PRS             ; Output "Memory size"
603B: CDE364  	        CALL    PROMPT          ; Get input with '?'
603E: CDFC67  	        CALL    GETCHR          ; Get next character
6041: B7      	        OR      A               ; Set flags
6042: C25A60  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
6045: 215D81  	        LD      HL,STLOOK       ; Point to start of RAM
6048: 23      	MLOOP:  INC     HL              ; Next byte
6049: 7C      	        LD      A,H             ; Above address FFFF ?
604A: B5      	        OR      L
604B: CA6C60  	        JP      Z,SETTOP        ; Yes - 64K RAM
604E: 7E      	        LD      A,(HL)          ; Get contents
604F: 47      	        LD      B,A             ; Save it
6050: 2F      	        CPL                     ; Flip all bits
6051: 77      	        LD      (HL),A          ; Put it back
6052: BE      	        CP      (HL)            ; RAM there if same
6053: 70      	        LD      (HL),B          ; Restore old contents
6054: CA4860  	        JP      Z,MLOOP         ; If RAM - test next byte
6057: C36C60  	        JP      SETTOP          ; Top of RAM found
              	
605A: CDC868  	TSTMEM: CALL    ATOH            ; Get high memory into DE
605D: B7      	        OR      A               ; Set flags on last byte
605E: C29463  	        JP      NZ,SNERR        ; ?SN Error if bad character
6061: EB      	        EX      DE,HL           ; Address into HL
6062: 2B      	        DEC     HL              ; Back one byte
6063: 3ED9    	        LD      A,11011001B     ; Test byte
6065: 46      	        LD      B,(HL)          ; Get old contents
6066: 77      	        LD      (HL),A          ; Load test byte
6067: BE      	        CP      (HL)            ; RAM there if same
6068: 70      	        LD      (HL),B          ; Restore old contents
6069: C23560  	        JP      NZ,MSIZE        ; Ask again if no RAM
              	
606C: 2B      	SETTOP: DEC     HL              ; Back one byte
606D: 115C81  	        LD      DE,STLOOK-1     ; See if enough RAM
6070: CD5C66  	        CALL    CPDEHL          ; Compare DE with HL
6073: DA3560  	        JP      C,MSIZE         ; Ask again if not enough RAM
6076: 11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
6079: 22AF80  	        LD      (LSTRAM),HL     ; Save last available RAM
607C: 19      	        ADD     HL,DE           ; Allocate string space
607D: 225A80  	        LD      (STRSPC),HL     ; Save string space
6080: CDA164  	        CALL    CLRPTR          ; Clear program area
6083: 2A5A80  	        LD      HL,(STRSPC)     ; Get end of memory
6086: 11EFFF  	        LD      DE,0-17         ; Offset for free bytes
6089: 19      	        ADD     HL,DE           ; Adjust HL
608A: 11F980  	        LD      DE,PROGST       ; Start of program text
608D: 7D      	        LD      A,L             ; Get LSB
608E: 93      	        SUB     E               ; Adjust it
608F: 6F      	        LD      L,A             ; Re-save
6090: 7C      	        LD      A,H             ; Get MSB
6091: 9A      	        SBC     A,D             ; Adjust it
6092: 67      	        LD      H,A             ; Re-save
6093: E5      	        PUSH    HL              ; Save bytes free
6094: 21BC60  	        LD      HL,SIGNON       ; Sign-on message
6097: CD4271  	        CALL    PRS             ; Output string
609A: E1      	        POP     HL              ; Get bytes free back
609B: CDE577  	        CALL    PRNTHL          ; Output amount of free memory
609E: 21AD60  	        LD      HL,BFREE        ; " Bytes free" message
60A1: CD4271  	        CALL    PRS             ; Output string
              	
60A4: 316680  	WARMST: LD      SP,STACK        ; Temporary stack
60A7: CDC664  	BRKRET: CALL    CLREG           ; Clear registers and stack
60AA: C3DF63  	        JP      PRNTOK          ; Go to get command line
              	
60AD: 20427974	BFREE:  .BYTE   " Bytes free",CR,LF,0,0
60B1: 65732066	
60B5: 7265650D	
60B9: 0A0000  	
              	
60BC: 5A383020	SIGNON: .BYTE "Z80 BASIC v4.7b",CR,CR,0,0
60C0: 42415349	
60C4: 43207634	
60C8: 2E37620D	
60CC: 0D0000  	
              	        ;.BYTE   "Z80 BASIC Ver 4.7b",CR,LF
              	        ;.BYTE   "Copyright ",40,"C",41
              	        ;.BYTE   " 1978 by Microsoft",CR,LF,0,0
              	
60CF: 4D656D6F	MEMMSG: .BYTE   "Memory top",0
60D3: 72792074	
60D7: 6F7000  	
              	
              	; FUNCTION ADDRESS TABLE (Quando precisa passar parametro?)
              	
60DA: 5A76    	FNCTAB: .WORD   SGN             ; $B6
60DC: 1E77    	        .WORD   INT             ; $B7
60DE: 7076    	        .WORD   ABS             ; $B8
60E0: 0380    	        .WORD   USR             ; $B9
60E2: 0270    	        .WORD   FRE             ; $BA
60E4: 8773    	        .WORD   INP             ; $BB
60E6: 3070    	        .WORD   POS             ; $BC
60E8: E478    	        .WORD   SQR             ; $BD
60EA: C379    	        .WORD   RND             ; $BE
60EC: FF74    	        .WORD   LOG             ; $BF
60EE: 3279    	        .WORD   EXP             ; $C0
60F0: 387A    	        .WORD   COS             ; $C1
60F2: 3E7A    	        .WORD   SIN             ; $C2
60F4: 9F7A    	        .WORD   TAN             ; $C3
60F6: B47A    	        .WORD   ATN             ; $C4
60F8: DB73    	        .WORD   PEEK            ; $C5
60FA: 1F7B    	        .WORD   DEEK            ; $C6
60FC: 5180    	        .WORD   POINT           ; $C7
60FE: B472    	        .WORD   LEN             ; $C8
6100: CC70    	        .WORD   STR             ; $C9
6102: 4E73    	        .WORD   VAL             ; $CA
6104: C372    	        .WORD   ASC             ; $CB
6106: D472    	        .WORD   CHR             ; $CC
6108: 417B    	        .WORD   HEX             ; $CD
610A: D47B    	        .WORD   BIN             ; $CE
610C: E472    	        .WORD   LEFT            ; $CF
610E: 1473    	        .WORD   RIGHT           ; $D0
6110: 1E73    	        .WORD   MID             ; $D1   
              	        
              	
              	; RESERVED WORD LIST
              	
6112: C54E44  	WORDS:  .BYTE   'E'+80H,"ND"            ; $80  WORDTB
6115: C64F52  	        .BYTE   'F'+80H,"OR"            ; $81
6118: CE455854	        .BYTE   'N'+80H,"EXT"           ; $82
611C: C4415441	        .BYTE   'D'+80H,"ATA"           ; $83
6120: C94E5055	        .BYTE   'I'+80H,"NPUT"          ; $84
6124: 54      	
6125: C4494D  	        .BYTE   'D'+80H,"IM"            ; $85
6128: D2454144	        .BYTE   'R'+80H,"EAD"           ; $86
612C: CC4554  	        .BYTE   'L'+80H,"ET"            ; $87
612F: C74F544F	        .BYTE   'G'+80H,"OTO"           ; $88
6133: D2554E  	        .BYTE   'R'+80H,"UN"            ; $89
6136: C946    	        .BYTE   'I'+80H,"F"             ; $8A
6138: D2455354	        .BYTE   'R'+80H,"ESTORE"        ; $8B
613C: 4F5245  	
613F: C74F5355	        .BYTE   'G'+80H,"OSUB"          ; $8C
6143: 42      	
6144: D2455455	        .BYTE   'R'+80H,"ETURN"         ; $8D
6148: 524E    	
614A: D2454D  	        .BYTE   'R'+80H,"EM"            ; $8E
614D: D3544F50	        .BYTE   'S'+80H,"TOP"           ; $8F
6151: CF5554  	        .BYTE   'O'+80H,"UT"            ; $90
6154: CF4E    	        .BYTE   'O'+80H,"N"             ; $91
6156: CE554C4C	        .BYTE   'N'+80H,"ULL"           ; $92
615A: D7414954	        .BYTE   'W'+80H,"AIT"           ; $93
615E: C44546  	        .BYTE   'D'+80H,"EF"            ; $94
6161: D04F4B45	        .BYTE   'P'+80H,"OKE"           ; $95
6165: C44F4B45	        .BYTE   'D'+80H,"OKE"           ; $96
6169: D4494D45	        .BYTE   'T'+80H,"IME" ;time i2c ; $97 ; LIVRE
616D: CC494E45	        .BYTE   'L'+80H,"INES"          ; $98
6171: 53      	
6172: C34C53  	        .BYTE   'C'+80H,"LS"            ; $99
6175: D7494454	        .BYTE   'W'+80H,"IDTH"          ; $9A
6179: 48      	
617A: CD4F4E49	        .BYTE   'M'+80H,"ONITOR"        ; $9B
617E: 544F52  	
6181: D34554  	        .BYTE   'S'+80H,"ET"            ; $9C
6184: D2455345	        .BYTE   'R'+80H,"ESET"          ; $9D
6188: 54      	
6189: D052494E	        .BYTE   'P'+80H,"RINT"          ; $9E
618D: 54      	
618E: C34F4E54	        .BYTE   'C'+80H,"ONT"           ; $9F
6192: CC495354	        .BYTE   'L'+80H,"IST"           ; $A0 
6196: C34C4541	        .BYTE   'C'+80H,"LEAR"          ; $A1
619A: 52      	
619B: C34C4F41	        .BYTE   'C'+80H,"LOAD"          ; $A2
619F: 44      	
61A0: C3534156	        .BYTE   'C'+80H,"SAVE"          ; $A3
61A4: 45      	
61A5: CE4557  	        .BYTE   'N'+80H,"EW"            ; $A4
              	        
              	
61A8: D4414228	        .BYTE   'T'+80H,"AB("           ; $A5
61AC: D44F    	        .BYTE   'T'+80H,"O"             ; $A6
61AE: C64E    	        .BYTE   'F'+80H,"N"             ; $A7
61B0: D3504328	        .BYTE   'S'+80H,"PC("           ; $A8
61B4: D448454E	        .BYTE   'T'+80H,"HEN"           ; $A9
61B8: CE4F54  	        .BYTE   'N'+80H,"OT"            ; $AA
61BB: D3544550	        .BYTE   'S'+80H,"TEP"           ; $AB
              	
61BF: AB      	        .BYTE   '+'+80H                 ; $AC
61C0: AD      	        .BYTE   '-'+80H                 ; $AD
61C1: AA      	        .BYTE   '*'+80H                 ; $AE
61C2: AF      	        .BYTE   '/'+80H                 ; $AF
61C3: DE      	        .BYTE   '^'+80H                 ; $B0
61C4: C14E44  	        .BYTE   'A'+80H,"ND"            ; $B1
61C7: CF52    	        .BYTE   'O'+80H,"R"             ; $B2
61C9: BE      	        .BYTE   '>'+80H                 ; $B3
61CA: BD      	        .BYTE   '='+80H                 ; $B4
61CB: BC      	        .BYTE   '<'+80H                 ; $B5
              	
61CC: D3474E  	        .BYTE   'S'+80H,"GN"            ; $B6  FNCTAB
61CF: C94E54  	        .BYTE   'I'+80H,"NT"            ; $B7
61D2: C14253  	        .BYTE   'A'+80H,"BS"            ; $B8
61D5: D55352  	        .BYTE   'U'+80H,"SR"            ; $B9
61D8: C65245  	        .BYTE   'F'+80H,"RE"            ; $BA
61DB: C94E50  	        .BYTE   'I'+80H,"NP"            ; $BB
61DE: D04F53  	        .BYTE   'P'+80H,"OS"            ; $BC
61E1: D35152  	        .BYTE   'S'+80H,"QR"            ; $BD
61E4: D24E44  	        .BYTE   'R'+80H,"ND"            ; $BE
61E7: CC4F47  	        .BYTE   'L'+80H,"OG"            ; $BF
61EA: C55850  	        .BYTE   'E'+80H,"XP"            ; $C0
61ED: C34F53  	        .BYTE   'C'+80H,"OS"            ; $C1
61F0: D3494E  	        .BYTE   'S'+80H,"IN"            ; $C2
61F3: D4414E  	        .BYTE   'T'+80H,"AN"            ; $C3
61F6: C1544E  	        .BYTE   'A'+80H,"TN"            ; $C4
61F9: D045454B	        .BYTE   'P'+80H,"EEK"           ; $C5
61FD: C445454B	        .BYTE   'D'+80H,"EEK"           ; $C6
6201: D04F494E	        .BYTE   'P'+80H,"OINT"          ; $C7
6205: 54      	
6206: CC454E  	        .BYTE   'L'+80H,"EN"            ; $C8
6209: D3545224	        .BYTE   'S'+80H,"TR$"           ; $C9
620D: D6414C  	        .BYTE   'V'+80H,"AL"            ; $CA
6210: C15343  	        .BYTE   'A'+80H,"SC"            ; $CB
6213: C3485224	        .BYTE   'C'+80H,"HR$"           ; $CC
6217: C8455824	        .BYTE   'H'+80H,"EX$"           ; $CD
621B: C2494E24	        .BYTE   'B'+80H,"IN$"           ; $CE
621F: CC454654	        .BYTE   'L'+80H,"EFT$"          ; $CF
6223: 24      	
6224: D2494748	        .BYTE   'R'+80H,"IGHT$"         ; $D0
6228: 5424    	
622A: CD494424	        .BYTE   'M'+80H,"ID$"           ; $D1
              	
              	
              	        ; Diego
622E: C4494547	        .BYTE   'D'+80H,'IEGO'
6232: 4F      	
6233: C352555A	        .BYTE   'C'+80H,'RUZ'
              	
6237: 80      	        .BYTE   80H             ; End of list marker
              	
              	; KEYWORD ADDRESS TABLE
              	
6238: 4668    	WORDTB: .WORD   PEND            ; $80
623A: 3367    	        .WORD   FOR             ; $81
623C: 1E6C    	        .WORD   NEXT            ; $82
623E: 9369    	        .WORD   DATA            ; $83
6240: 256B    	        .WORD   INPUT           ; $84
6242: 5A6E    	        .WORD   DIM             ; $85
6244: 546B    	        .WORD   READ            ; $86
6246: AA69    	        .WORD   LET             ; $87
6248: 5069    	        .WORD   GOTO            ; $88
624A: 3369    	        .WORD   RUN             ; $89
624C: 226A    	        .WORD   IF              ; $8A
624E: 0C68    	        .WORD   RESTOR          ; $8B
6250: 3F69    	        .WORD   GOSUB           ; $8C
6252: 6E69    	        .WORD   RETURN          ; $8D
6254: 9569    	        .WORD   REM             ; $8E
6256: 4468    	        .WORD   STOP            ; $8F
6258: 9373    	        .WORD   POUT            ; $90
625A: 046A    	        .WORD   ON              ; $91
625C: 8568    	        .WORD   NULL            ; $92
625E: 9973    	        .WORD   WAIT            ; $93
6260: 3870    	        .WORD   DEF             ; $94
6262: E273    	        .WORD   POKE            ; $95
6264: 2A7B    	        .WORD   DOKE            ; $96
6266: 9569    	        .WORD   REM             ; $97 ; LIVRE
6268: 107B    	        .WORD   LINES           ; $98
626A: 037B    	        .WORD   CLS             ; $99
626C: 087B    	        .WORD   WIDTH           ; $9A
626E: 407C    	        .WORD   MONITR          ; $9B
6270: 5480    	        .WORD   PSET            ; $9C
6272: 5780    	        .WORD   RESET           ; $9D
6274: 466A    	        .WORD   PRINT           ; $9E
6276: 7268    	        .WORD   CONT            ; $9F
6278: A866    	        .WORD   LIST            ; $A0
627A: ED68    	        .WORD   CLEAR           ; $A1
627C: 5A7C    	        .WORD   EELOAD ; LOAD   ; $A2
627E: 717C    	        .WORD   EESAVE ; SAVE   ; $A3
6280: A064    	        .WORD   NEW             ; $A4
              	        
              	
              	        ; Diego
6282:         	custtab:
6282: 887C    	        .WORD diego
6284: 8F7C    	        .WORD cruz
              	
              	; RESERVED WORD TOKEN VALUES
              	
0080:         	ZEND    .EQU    080H            ; END
0081:         	ZFOR    .EQU    081H            ; FOR
0083:         	ZDATA   .EQU    083H            ; DATA
0088:         	ZGOTO   .EQU    088H            ; GOTO
008C:         	ZGOSUB  .EQU    08CH            ; GOSUB
008E:         	ZREM    .EQU    08EH            ; REM
009E:         	ZPRINT  .EQU    09EH            ; PRINT
00A4:         	ZNEW    .EQU    0A4H            ; NEW
00D2:         	ZBYE	.equ	   0d2h			   ; BYE
              	
00A5:         	ZTAB    .EQU    0A5H            ; TAB
00A6:         	ZTO     .EQU    0A6H            ; TO
00A7:         	ZFN     .EQU    0A7H            ; FN
00A8:         	ZSPC    .EQU    0A8H            ; SPC
00A9:         	ZTHEN   .EQU    0A9H            ; THEN
00AA:         	ZNOT    .EQU    0AAH            ; NOT
00AB:         	ZSTEP   .EQU    0ABH            ; STEP
              	
00AC:         	ZPLUS   .EQU    0ACH            ; +
00AD:         	ZMINUS  .EQU    0ADH            ; -
00AE:         	ZTIMES  .EQU    0AEH            ; *
00AF:         	ZDIV    .EQU    0AFH            ; /
00B2:         	ZOR     .EQU    0B2H            ; OR
00B3:         	ZGTR    .EQU    0B3H            ; >
00B4:         	ZEQUAL  .EQU    0B4H            ; M
00B5:         	ZLTH    .EQU    0B5H            ; <
00B6:         	ZSGN    .EQU    0B6H            ; SGN
00C7:         	ZPOINT  .EQU    0C7H            ; POINT
00CF:         	ZLEFT   .EQU    0CDH +2         ; LEFT$
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	
6286: 79      	PRITAB: .BYTE   79H             ; Precedence value
6287: CC77    	        .WORD   PADD            ; FPREG = <last> + FPREG
              	
6289: 79      	        .BYTE   79H             ; Precedence value
628A: 0074    	        .WORD   PSUB            ; FPREG = <last> - FPREG
              	
628C: 7C      	        .BYTE   7CH             ; Precedence value
628D: 3E75    	        .WORD   MULT            ; PPREG = <last> * FPREG
              	
628F: 7C      	        .BYTE   7CH             ; Precedence value
6290: 9F75    	        .WORD   DIV             ; FPREG = <last> / FPREG
              	
6292: 7F      	        .BYTE   7FH             ; Precedence value
6293: ED78    	        .WORD   POWER           ; FPREG = <last> ^ FPREG
              	
6295: 50      	        .BYTE   50H             ; Precedence value
6296: B36D    	        .WORD   PAND            ; FPREG = <last> AND FPREG
              	
6298: 46      	        .BYTE   46H             ; Precedence value
6299: B26D    	        .WORD   POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
629B: 4E46    	ERRORS: .BYTE   "NF"            ; NEXT without FOR
629D: 534E    	        .BYTE   "SN"            ; Syntax error
629F: 5247    	        .BYTE   "RG"            ; RETURN without GOSUB
62A1: 4F44    	        .BYTE   "OD"            ; Out of DATA
62A3: 4643    	        .BYTE   "FC"            ; Illegal function call
62A5: 4F56    	        .BYTE   "OV"            ; Overflow error
62A7: 4F4D    	        .BYTE   "OM"            ; Out of memory
62A9: 554C    	        .BYTE   "UL"            ; Undefined line
62AB: 4253    	        .BYTE   "BS"            ; Bad subscript
62AD: 4444    	        .BYTE   "DD"            ; Re-DIMensioned array
62AF: 2F30    	        .BYTE   "/0"            ; Division by zero
62B1: 4944    	        .BYTE   "ID"            ; Illegal direct
62B3: 544D    	        .BYTE   "TM"            ; Type mis-match
62B5: 4F53    	        .BYTE   "OS"            ; Out of string space
62B7: 4C53    	        .BYTE   "LS"            ; String too long
62B9: 5354    	        .BYTE   "ST"            ; String formula too complex
62BB: 434E    	        .BYTE   "CN"            ; Can't CONTinue
62BD: 5546    	        .BYTE   "UF"            ; Undefined FN function
62BF: 4D4F    	        .BYTE   "MO"            ; Missing operand
62C1: 4858    	        .BYTE   "HX"            ; HEX error
62C3: 424E    	        .BYTE   "BN"            ; BIN error
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	
62C5: C3A460  	INITAB: JP      WARMST          ; Warm start jump
62C8: C3C368  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
62CB: D300    	        OUT     (0),A           ; "OUT p,n" skeleton
62CD: C9      	        RET
62CE: D600    	        SUB     0               ; Division support routine
62D0: 6F      	        LD      L,A
62D1: 7C      	        LD      A,H
62D2: DE00    	        SBC     A,0
62D4: 67      	        LD      H,A
62D5: 78      	        LD      A,B
62D6: DE00    	        SBC     A,0
62D8: 47      	        LD      B,A
62D9: 3E00    	        LD      A,0
62DB: C9      	        RET
62DC: 000000  	        .BYTE   0,0,0                   ; Random number seed table used by RND
62DF: 354ACA99	        .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
62E3: 391C7698	        .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
62E7: 2295B398	        .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
62EB: 0ADD4798	        .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
62EF: 53D19999	        .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
62F3: 0A1A9F98	        .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
62F7: 65BCCD98	        .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
62FB: D6773E98	        .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
62FF: 52C74F80	        .BYTE   052H,0C7H,04FH,080H     ; Last random number
6303: DB00    	        IN      A,(0)           ; INP (x) skeleton
6305: C9      	        RET
6306: 01      	        .BYTE   1               ; POS (x) number (1)
6307: FF      	        .BYTE   255             ; Terminal width (255 = no auto CRLF)
6308: 1C      	        .BYTE   28              ; Width for commas (3 columns)
6309: 00      	        .BYTE   0               ; No nulls after input bytes
630A: 00      	        .BYTE   0               ; Output enabled (^O off)
630B: 1400    	        .WORD   20              ; Initial lines counter
630D: 1400    	        .WORD   20              ; Initial lines number
630F: 0000    	        .WORD   0               ; Array load/save check sum
6311: 00      	        .BYTE   0               ; Break not by NMI
6312: 00      	        .BYTE   0               ; Break flag
6313: C3D965  	        JP      TTYLIN          ; Input reflection (set to TTY)
6316: C30000  	        JP      $0000           ; POINT reflection unused
6319: C30000  	        JP      $0000           ; SET reflection
631C: C30000  	        JP      $0000          	; RESET reflection
631F: 5D81    	        .WORD   STLOOK          ; Temp string space
6321: FEFF    	        .WORD   -2              ; Current line number (cold)
6323: FA80    	        .WORD   PROGST+1        ; Start of program text
6325:         	INITBE:                         
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
6325: 20457272	ERRMSG: .BYTE   " Error",0
6329: 6F7200  	
632C: 20696E20	INMSG:  .BYTE   " in ",0
6330: 00      	
6330:         	ZERBYT  .EQU    $-1             ; A zero byte
6331: 4F6B0D0A	OKMSG:  .BYTE   "Ok",CR,LF,0,0
6335: 0000    	
6337: 42726561	BRKMSG: .BYTE   "Break",0
633B: 6B00    	
              	
633D: 210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
6340: 39      	        ADD     HL,SP           ; same index as specified
6341: 7E      	LOKFOR: LD      A,(HL)          ; Get block ID
6342: 23      	        INC     HL              ; Point to index address
6343: FE81    	        CP      ZFOR            ; Is it a "FOR" token
6345: C0      	        RET     NZ              ; No - exit
6346: 4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
6347: 23      	        INC     HL
6348: 46      	        LD      B,(HL)
6349: 23      	        INC     HL              ; Point to sign of STEP
634A: E5      	        PUSH    HL              ; Save pointer to sign
634B: 69      	        LD      L,C             ; HL = address of "FOR" index
634C: 60      	        LD      H,B
634D: 7A      	        LD      A,D             ; See if an index was specified
634E: B3      	        OR      E               ; DE = 0 if no index specified
634F: EB      	        EX      DE,HL           ; Specified index into HL
6350: CA5763  	        JP      Z,INDFND        ; Skip if no index given
6353: EB      	        EX      DE,HL           ; Index back into DE
6354: CD5C66  	        CALL    CPDEHL          ; Compare index with one given
6357: 010D00  	INDFND: LD      BC,16-3         ; Offset to next block
635A: E1      	        POP     HL              ; Restore pointer to sign
635B: C8      	        RET     Z               ; Return if block found
635C: 09      	        ADD     HL,BC           ; Point to next block
635D: C34163  	        JP      LOKFOR          ; Keep on looking
              	
6360: CD7A63  	MOVUP:  CALL    ENFMEM          ; See if enough memory
6363: C5      	MOVSTR: PUSH    BC              ; Save end of source
6364: E3      	        EX      (SP),HL         ; Swap source and dest" end
6365: C1      	        POP     BC              ; Get end of destination
6366: CD5C66  	MOVLP:  CALL    CPDEHL          ; See if list moved
6369: 7E      	        LD      A,(HL)          ; Get byte
636A: 02      	        LD      (BC),A          ; Move it
636B: C8      	        RET     Z               ; Exit if all done
636C: 0B      	        DEC     BC              ; Next byte to move to
636D: 2B      	        DEC     HL              ; Next byte to move
636E: C36663  	        JP      MOVLP           ; Loop until all bytes moved
              	
6371: E5      	CHKSTK: PUSH    HL              ; Save code string address
6372: 2ADA80  	        LD      HL,(ARREND)     ; Lowest free memory
6375: 0600    	        LD      B,0             ; BC = Number of levels to test
6377: 09      	        ADD     HL,BC           ; 2 Bytes for each level
6378: 09      	        ADD     HL,BC
6379: 3E      	        .BYTE   3EH             ; Skip "PUSH HL"
637A: E5      	ENFMEM: PUSH    HL              ; Save code string address
637B: 3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
637D: 95      	        SUB     L
637E: 6F      	        LD      L,A
637F: 3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
6381: 9C      	        SBC     A,H
6382: DA8963  	        JP      C,OMERR         ; Not enough - ?OM Error
6385: 67      	        LD      H,A
6386: 39      	        ADD     HL,SP           ; Test if stack is overflowed
6387: E1      	        POP     HL              ; Restore code string address
6388: D8      	        RET     C               ; Return if enough mmory
6389: 1E0C    	OMERR:  LD      E,OM            ; ?OM Error
638B: C3A863  	        JP      ERROR
              	
638E: 2AC980  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
6391: 225C80  	        LD      (LINEAT),HL     ; Save as current line
6394: 1E02    	SNERR:  LD      E,SN            ; ?SN Error
6396: 01      	        .BYTE   01H             ; Skip "LD E,DZ"
6397: 1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
6399: 01      	        .BYTE   01H             ; Skip "LD E,NF"
639A: 1E00    	NFERR:  LD      E,NF            ; ?NF Error
639C: 01      	        .BYTE   01H             ; Skip "LD E,DD"
639D: 1E12    	DDERR:  LD      E,DD            ; ?DD Error
639F: 01      	        .BYTE   01H             ; Skip "LD E,UF"
63A0: 1E22    	UFERR:  LD      E,UF            ; ?UF Error
63A2: 01      	        .BYTE   01H             ; Skip "LD E,OV
63A3: 1E0A    	OVERR:  LD      E,OV            ; ?OV Error
63A5: 01      	        .BYTE   01H             ; Skip "LD E,TM"
63A6: 1E18    	TMERR:  LD      E,TM            ; ?TM Error
              	
63A8:         	ERROR:  
63A8: CDC664  	        CALL    CLREG           ; Clear registers and stack
63AB: 324580  	        LD      (CTLOFG),A      ; Enable output (A is 0)
63AE: CD976A  	        CALL    STTLIN          ; Start new line
63B1: 219B62  	        LD      HL,ERRORS       ; Point to error codes
63B4: 57      	        LD      D,A             ; D = 0 (A is 0)
63B5: 3E3F    	        LD      A,'?'
63B7: CD6D66  	        CALL    OUTC            ; Output '?'
63BA: 19      	        ADD     HL,DE           ; Offset to correct error code
63BB: 7E      	        LD      A,(HL)          ; First character
63BC: CD6D66  	        CALL    OUTC            ; Output it
63BF: CDFC67  	        CALL    GETCHR          ; Get next character
63C2: CD6D66  	        CALL    OUTC            ; Output it
63C5: 212563  	        LD      HL,ERRMSG       ; "Error" message
63C8: CD4271  	ERRIN:  CALL    PRS             ; Output message
63CB: 2A5C80  	        LD      HL,(LINEAT)     ; Get line of error
63CE: 11FEFF  	        LD      DE,-2           ; Cold start error if -2
63D1: CD5C66  	        CALL    CPDEHL          ; See if cold start error
63D4: CA1160  	        JP      Z,CSTART        ; Cold start error - Restart
63D7: 7C      	        LD      A,H             ; Was it a direct error?
63D8: A5      	        AND     L               ; Line = -1 if direct error
63D9: 3C      	        INC     A
63DA: C4DD77  	        CALL    NZ,LINEIN       ; No - output line of error
63DD: 3E      	        .BYTE   3EH             ; Skip "POP BC"
63DE: C1      	POPNOK: POP     BC              ; Drop address in input buffer
              	
63DF:         	PRNTOK: 
63DF: AF      	        XOR     A               ; Output "Ok" and get command
63E0: 324580  	        LD      (CTLOFG),A      ; Enable output
63E3: CD976A  	        CALL    STTLIN          ; Start new line
63E6: 213163  	        LD      HL,OKMSG        ; "Ok" message
63E9: CD4271  	        CALL    PRS             ; Output "Ok"
63EC: 21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
63EF: 225C80  	        LD      (LINEAT),HL     ; Save as current line
63F2: CDD965  	        CALL    GETLIN          ; Get an input line
63F5: DAEC63  	        JP      C,GETCMD        ; Get line again if break
63F8: CDFC67  	        CALL    GETCHR          ; Get first character
63FB: 3C      	        INC     A               ; Test if end of line
63FC: 3D      	        DEC     A               ; Without affecting Carry
63FD: CAEC63  	        JP      Z,GETCMD        ; Nothing entered - Get another
6400: F5      	        PUSH    AF              ; Save Carry status
6401: CDC868  	        CALL    ATOH            ; Get line number into DE
6404: D5      	        PUSH    DE              ; Save line number
6405: CDF064  	        CALL    CRUNCH          ; Tokenise rest of line
6408: 47      	        LD      B,A             ; Length of tokenised line
6409: D1      	        POP     DE              ; Restore line number
640A: F1      	        POP     AF              ; Restore Carry
640B: D2CC67  	        JP      NC,EXCUTE       ; No line number - Direct mode
640E: D5      	        PUSH    DE              ; Save line number
640F: C5      	        PUSH    BC              ; Save length of tokenised line
6410: AF      	        XOR     A
6411: 32CC80  	        LD      (LSTBIN),A      ; Clear last byte input
6414: CDFC67  	        CALL    GETCHR          ; Get next character
6417: B7      	        OR      A               ; Set flags
6418: F5      	        PUSH    AF              ; And save them
6419: CD8064  	        CALL    SRCHLN          ; Search for line number in DE
641C: DA2564  	        JP      C,LINFND        ; Jump if line found
641F: F1      	        POP     AF              ; Get status
6420: F5      	        PUSH    AF              ; And re-save
6421: CA6969  	        JP      Z,ULERR         ; Nothing after number - Error
6424: B7      	        OR      A               ; Clear Carry
6425: C5      	LINFND: PUSH    BC              ; Save address of line in prog
6426: D23C64  	        JP      NC,INEWLN       ; Line not found - Insert new
6429: EB      	        EX      DE,HL           ; Next line address in DE
642A: 2AD680  	        LD      HL,(PROGND)     ; End of program
642D: 1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
642E: 02      	        LD      (BC),A
642F: 03      	        INC     BC              ; Next destination
6430: 13      	        INC     DE              ; Next source
6431: CD5C66  	        CALL    CPDEHL          ; All done?
6434: C22D64  	        JP      NZ,SFTPRG       ; More to do
6437: 60      	        LD      H,B             ; HL - New end of program
6438: 69      	        LD      L,C
6439: 22D680  	        LD      (PROGND),HL     ; Update end of program
              	
643C: D1      	INEWLN: POP     DE              ; Get address of line,
643D: F1      	        POP     AF              ; Get status
643E: CA6364  	        JP      Z,SETPTR        ; No text - Set up pointers
6441: 2AD680  	        LD      HL,(PROGND)     ; Get end of program
6444: E3      	        EX      (SP),HL         ; Get length of input line
6445: C1      	        POP     BC              ; End of program to BC
6446: 09      	        ADD     HL,BC           ; Find new end
6447: E5      	        PUSH    HL              ; Save new end
6448: CD6063  	        CALL    MOVUP           ; Make space for line
644B: E1      	        POP     HL              ; Restore new end
644C: 22D680  	        LD      (PROGND),HL     ; Update end of program pointer
644F: EB      	        EX      DE,HL           ; Get line to move up in HL
6450: 74      	        LD      (HL),H          ; Save MSB
6451: D1      	        POP     DE              ; Get new line number
6452: 23      	        INC     HL              ; Skip pointer
6453: 23      	        INC     HL
6454: 73      	        LD      (HL),E          ; Save LSB of line number
6455: 23      	        INC     HL
6456: 72      	        LD      (HL),D          ; Save MSB of line number
6457: 23      	        INC     HL              ; To first byte in line
6458: 116180  	        LD      DE,BUFFER       ; Copy buffer to program
645B: 1A      	MOVBUF: LD      A,(DE)          ; Get source
645C: 77      	        LD      (HL),A          ; Save destinations
645D: 23      	        INC     HL              ; Next source
645E: 13      	        INC     DE              ; Next destination
645F: B7      	        OR      A               ; Done?
6460: C25B64  	        JP      NZ,MOVBUF       ; No - Repeat
6463: CDAC64  	SETPTR: CALL    RUNFST          ; Set line pointers
6466: 23      	        INC     HL              ; To LSB of pointer
6467: EB      	        EX      DE,HL           ; Address to DE
6468: 62      	PTRLP:  LD      H,D             ; Address to HL
6469: 6B      	        LD      L,E
646A: 7E      	        LD      A,(HL)          ; Get LSB of pointer
646B: 23      	        INC     HL              ; To MSB of pointer
646C: B6      	        OR      (HL)            ; Compare with MSB pointer
646D: CAEC63  	        JP      Z,GETCMD        ; Get command line if end
6470: 23      	        INC     HL              ; To LSB of line number
6471: 23      	        INC     HL              ; Skip line number
6472: 23      	        INC     HL              ; Point to first byte in line
6473: AF      	        XOR     A               ; Looking for 00 byte
6474: BE      	FNDEND: CP      (HL)            ; Found end of line?
6475: 23      	        INC     HL              ; Move to next byte
6476: C27464  	        JP      NZ,FNDEND       ; No - Keep looking
6479: EB      	        EX      DE,HL           ; Next line address to HL
647A: 73      	        LD      (HL),E          ; Save LSB of pointer
647B: 23      	        INC     HL
647C: 72      	        LD      (HL),D          ; Save MSB of pointer
647D: C36864  	        JP      PTRLP           ; Do next line
              	
6480: 2A5E80  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
6483: 44      	SRCHLP: LD      B,H             ; BC = Address to look at
6484: 4D      	        LD      C,L
6485: 7E      	        LD      A,(HL)          ; Get address of next line
6486: 23      	        INC     HL
6487: B6      	        OR      (HL)            ; End of program found?
6488: 2B      	        DEC     HL
6489: C8      	        RET     Z               ; Yes - Line not found
648A: 23      	        INC     HL
648B: 23      	        INC     HL
648C: 7E      	        LD      A,(HL)          ; Get LSB of line number
648D: 23      	        INC     HL
648E: 66      	        LD      H,(HL)          ; Get MSB of line number
648F: 6F      	        LD      L,A
6490: CD5C66  	        CALL    CPDEHL          ; Compare with line in DE
6493: 60      	        LD      H,B             ; HL = Start of this line
6494: 69      	        LD      L,C
6495: 7E      	        LD      A,(HL)          ; Get LSB of next line address
6496: 23      	        INC     HL
6497: 66      	        LD      H,(HL)          ; Get MSB of next line address
6498: 6F      	        LD      L,A             ; Next line to HL
6499: 3F      	        CCF
649A: C8      	        RET     Z               ; Lines found - Exit
649B: 3F      	        CCF
649C: D0      	        RET     NC              ; Line not found,at line after
649D: C38364  	        JP      SRCHLP          ; Keep looking
              	
64A0: C0      	NEW:    RET     NZ              ; Return if any more on line
64A1: 2A5E80  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
64A4: AF      	        XOR     A               ; Set program area to empty
64A5: 77      	        LD      (HL),A          ; Save LSB = 00
64A6: 23      	        INC     HL
64A7: 77      	        LD      (HL),A          ; Save MSB = 00
64A8: 23      	        INC     HL
64A9: 22D680  	        LD      (PROGND),HL     ; Set program end
              	
64AC: 2A5E80  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
64AF: 2B      	        DEC     HL
              	
64B0: 22CE80  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
64B3: 2AAF80  	        LD      HL,(LSTRAM)     ; Get end of RAM
64B6: 22C380  	        LD      (STRBOT),HL     ; Clear string space
64B9: AF      	        XOR     A
64BA: CD0C68  	        CALL    RESTOR          ; Reset DATA pointers
64BD: 2AD680  	        LD      HL,(PROGND)     ; Get end of program
64C0: 22D880  	        LD      (VAREND),HL     ; Clear variables
64C3: 22DA80  	        LD      (ARREND),HL     ; Clear arrays
              	
64C6: C1      	CLREG:  POP     BC              ; Save return address
64C7: 2A5A80  	        LD      HL,(STRSPC)     ; Get end of working RAN
64CA: F9      	        LD      SP,HL           ; Set stack
64CB: 21B380  	        LD      HL,TMSTPL       ; Temporary string pool
64CE: 22B180  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
64D1: AF      	        XOR     A               ; A = 00
64D2: 6F      	        LD      L,A             ; HL = 0000
64D3: 67      	        LD      H,A
64D4: 22D480  	        LD      (CONTAD),HL     ; No CONTinue
64D7: 32CB80  	        LD      (FORFLG),A      ; Clear FOR flag
64DA: 22DE80  	        LD      (FNRGNM),HL     ; Clear FN argument
64DD: E5      	        PUSH    HL              ; HL = 0000
64DE: C5      	        PUSH    BC              ; Put back return
64DF: 2ACE80  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
64E2: C9      	        RET                     ; Return to execution driver
              	
64E3: 3E3F    	PROMPT: LD      A,'?'           ; '?'
64E5: CD6D66  	        CALL    OUTC            ; Output character
64E8: 3E20    	        LD      A,' '           ; Space
64EA: CD6D66  	        CALL    OUTC            ; Output character
64ED: C34E80  	        JP      RINPUT          ; Get input line
              	
64F0: AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
64F1: 32AE80  	        LD      (DATFLG),A      ; Reset literal flag
64F4: 0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
64F6: 116180  	        LD      DE,BUFFER       ; Start of input buffer
64F9: 7E      	CRNCLP: LD      A,(HL)          ; Get byte
64FA: FE20    	        CP      ' '             ; Is it a space?
64FC: CA7865  	        JP      Z,MOVDIR        ; Yes - Copy direct
64FF: 47      	        LD      B,A             ; Save character
6500: FE22    	        CP      '"'             ; Is it a quote? "
6502: CA9865  	        JP      Z,CPYLIT        ; Yes - Copy literal string
6505: B7      	        OR      A               ; Is it end of buffer?
6506: CA9F65  	        JP      Z,ENDBUF        ; Yes - End buffer
6509: 3AAE80  	        LD      A,(DATFLG)      ; Get data type
650C: B7      	        OR      A               ; Literal?
650D: 7E      	        LD      A,(HL)          ; Get byte to copy
650E: C27865  	        JP      NZ,MOVDIR       ; Literal - Copy direct
6511: FE3F    	        CP      '?'             ; Is it '?' short for PRINT
6513: 3E9E    	        LD      A,ZPRINT        ; "PRINT" token
6515: CA7865  	        JP      Z,MOVDIR        ; Yes - replace it
6518: 7E      	        LD      A,(HL)          ; Get byte again
6519: FE30    	        CP      '0'             ; Is it less than '0'
651B: DA2365  	        JP      C,FNDWRD        ; Yes - Look for reserved words
651E: FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
6520: DA7865  	        JP      C,MOVDIR        ; Yes - copy it direct
6523: D5      	FNDWRD: PUSH    DE              ; Look for reserved words
6524: 111161  	        LD      DE,WORDS-1      ; Point to table
6527: C5      	        PUSH    BC              ; Save count
6528: 017465  	        LD      BC,RETNAD       ; Where to return to
652B: C5      	        PUSH    BC              ; Save return address
652C: 067F    	        LD      B,ZEND-1        ; First token value -1
652E: 7E      	        LD      A,(HL)          ; Get byte
652F: FE61    	        CP      'a'             ; Less than 'a' ?
6531: DA3C65  	        JP      C,SEARCH        ; Yes - search for words
6534: FE7B    	        CP      'z'+1           ; Greater than 'z' ?
6536: D23C65  	        JP      NC,SEARCH       ; Yes - search for words
6539: E65F    	        AND     01011111B       ; Force upper case
653B: 77      	        LD      (HL),A          ; Replace byte
653C: 4E      	SEARCH: LD      C,(HL)          ; Search for a word
653D: EB      	        EX      DE,HL
653E: 23      	GETNXT: INC     HL              ; Get next reserved word
653F: B6      	        OR      (HL)            ; Start of word?
6540: F23E65  	        JP      P,GETNXT        ; No - move on
6543: 04      	        INC     B               ; Increment token value
6544: 7E      	        LD      A, (HL)         ; Get byte from table
6545: E67F    	        AND     01111111B       ; Strip bit 7
6547: C8      	        RET     Z               ; Return if end of list
6548: B9      	        CP      C               ; Same character as in buffer?
6549: C23E65  	        JP      NZ,GETNXT       ; No - get next word
654C: EB      	        EX      DE,HL
654D: E5      	        PUSH    HL              ; Save start of word
              	
654E: 13      	NXTBYT: INC     DE              ; Look through rest of word
654F: 1A      	        LD      A,(DE)          ; Get byte from table
6550: B7      	        OR      A               ; End of word ?
6551: FA7065  	        JP      M,MATCH         ; Yes - Match found
6554: 4F      	        LD      C,A             ; Save it
6555: 78      	        LD      A,B             ; Get token value
6556: FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
6558: C25F65  	        JP      NZ,NOSPC        ; No - Don't allow spaces
655B: CDFC67  	        CALL    GETCHR          ; Get next character
655E: 2B      	        DEC     HL              ; Cancel increment from GETCHR
655F: 23      	NOSPC:  INC     HL              ; Next byte
6560: 7E      	        LD      A,(HL)          ; Get byte
6561: FE61    	        CP      'a'             ; Less than 'a' ?
6563: DA6865  	        JP      C,NOCHNG        ; Yes - don't change
6566: E65F    	        AND     01011111B       ; Make upper case
6568: B9      	NOCHNG: CP      C               ; Same as in buffer ?
6569: CA4E65  	        JP      Z,NXTBYT        ; Yes - keep testing
656C: E1      	        POP     HL              ; Get back start of word
656D: C33C65  	        JP      SEARCH          ; Look at next word
              	
6570: 48      	MATCH:  LD      C,B             ; Word found - Save token value
6571: F1      	        POP     AF              ; Throw away return
6572: EB      	        EX      DE,HL
6573: C9      	        RET                     ; Return to "RETNAD"
6574: EB      	RETNAD: EX      DE,HL           ; Get address in string
6575: 79      	        LD      A,C             ; Get token value
6576: C1      	        POP     BC              ; Restore buffer length
6577: D1      	        POP     DE              ; Get destination address
6578: 23      	MOVDIR: INC     HL              ; Next source in buffer
6579: 12      	        LD      (DE),A          ; Put byte in buffer
657A: 13      	        INC     DE              ; Move up buffer
657B: 0C      	        INC     C               ; Increment length of buffer
657C: D63A    	        SUB     ':'             ; End of statement?
657E: CA8665  	        JP      Z,SETLIT        ; Jump if multi-statement line
6581: FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
6583: C28965  	        JP      NZ,TSTREM       ; No - see if REM
6586: 32AE80  	SETLIT: LD      (DATFLG),A      ; Set literal flag
6589: D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
658B: C2F964  	        JP      NZ,CRNCLP       ; No - Leave flag
658E: 47      	        LD      B,A             ; Copy rest of buffer
658F: 7E      	NXTCHR: LD      A,(HL)          ; Get byte
6590: B7      	        OR      A               ; End of line ?
6591: CA9F65  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
6594: B8      	        CP      B               ; End of statement ?
6595: CA7865  	        JP      Z,MOVDIR        ; Yes - Get next one
6598: 23      	CPYLIT: INC     HL              ; Move up source string
6599: 12      	        LD      (DE),A          ; Save in destination
659A: 0C      	        INC     C               ; Increment length
659B: 13      	        INC     DE              ; Move up destination
659C: C38F65  	        JP      NXTCHR          ; Repeat
              	
659F: 216080  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
65A2: 12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
65A3: 13      	        INC     DE
65A4: 12      	        LD      (DE),A          ; A = 00
65A5: 13      	        INC     DE
65A6: 12      	        LD      (DE),A          ; A = 00
65A7: C9      	        RET
              	
65A8: 3A4480  	DODEL:  LD      A,(NULFLG)      ; Get null flag status 
65AB: B7      	        OR      A               ; Is it zero?
65AC: 3E00    	        LD      A,0             ; Zero A - Leave flags
65AE: 324480  	        LD      (NULFLG),A      ; Zero null flag
65B1: C2BC65  	        JP      NZ,ECHDEL       ; Set - Echo it
65B4: 05      	        DEC     B               ; Decrement length
65B5: CAD965  	        JP      Z,GETLIN        ; Get line again if empty
65B8: CD6D66  	        CALL    OUTC            ; Output null character
65BB: 3E      	        .BYTE   3EH             ; Skip "DEC B"
65BC: 05      	ECHDEL: DEC     B               ; Count bytes in buffer
65BD: 2B      	        DEC     HL              ; Back space buffer
65BE: CAD065  	        JP      Z,OTKLN         ; No buffer - Try again
65C1: 7E      	        LD      A,(HL)          ; Get deleted 
65C2: CD6D66  	        CALL    OUTC            ; Echo it
65C5: C3E265  	        JP      MORINP          ; Get more input
              	
65C8: 05      	DELCHR: DEC     B               ; Count bytes in buffer 
65C9: 2B      	        DEC     HL              ; Back space buffer
65CA: CD6D66  	        CALL    OUTC            ; Output character in A
65CD: C2E265  	        JP      NZ,MORINP       ; Not end - Get more
65D0: CD6D66  	OTKLN:  CALL    OUTC            ; Output character in A
65D3: CDA46A  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
65D6: C3D965  	        JP      TTYLIN          ; Get line again
              	
65D9:         	GETLIN:
65D9: 216180  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
65DC: 0601    	        LD      B,1             ; Set buffer as empty
65DE: AF      	        XOR     A
65DF: 324480  	        LD      (NULFLG),A      ; Clear null flag
65E2: CD9766  	MORINP: CALL    CLOTST          ; Get character and test ^O
65E5: 4F      	        LD      C,A             ; Save character in C
65E6: FE7F    	        CP      DEL             ; Delete character?
65E8: CAA865  	        JP      Z,DODEL         ; Yes - Process it
65EB: 3A4480  	        LD      A,(NULFLG)      ; Get null flag
65EE: B7      	        OR      A               ; Test null flag status
65EF: CAFB65  	        JP      Z,PROCES        ; Reset - Process character
65F2: 3E00    	        LD      A,0             ; Set a null
65F4: CD6D66  	        CALL    OUTC            ; Output null
65F7: AF      	        XOR     A               ; Clear A
65F8: 324480  	        LD      (NULFLG),A      ; Reset null flag
65FB: 79      	PROCES: LD      A,C             ; Get character
65FC: FE07    	        CP      CTRLG           ; Bell?
65FE: CA3F66  	        JP      Z,PUTCTL        ; Yes - Save it
6601: FE03    	        CP      CTRLC           ; Is it control "C"?
6603: CCA46A  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
6606: 37      	        SCF                     ; Flag break
6607: C8      	        RET     Z               ; Return if control "C"
6608: FE0D    	        CP      CR              ; Is it enter?
660A: CA9F6A  	        JP      Z,ENDINP        ; Yes - Terminate input
660D: FE15    	        CP      CTRLU           ; Is it control "U"?
660F: CAD365  	        JP      Z,KILIN         ; Yes - Get another line
6612: FE40    	        CP      '@'             ; Is it "kill line"?
6614: CAD065  	        JP      Z,OTKLN         ; Yes - Kill line
6617: FE5F    	        CP      '_'             ; Is it delete?
6619: CAC865  	        JP      Z,DELCHR        ; Yes - Delete character
661C: FE08    	        CP      BKSP            ; Is it backspace?
661E: CAC865  	        JP      Z,DELCHR        ; Yes - Delete character
6621: FE12    	        CP      CTRLR           ; Is it control "R"?
6623: C23A66  	        JP      NZ,PUTBUF       ; No - Put in buffer
6626: C5      	        PUSH    BC              ; Save buffer length
6627: D5      	        PUSH    DE              ; Save DE
6628: E5      	        PUSH    HL              ; Save buffer address
6629: 3600    	        LD      (HL),0          ; Mark end of buffer
662B: CD547C  	        CALL    OUTNCR          ; Output and do CRLF
662E: 216180  	        LD      HL,BUFFER       ; Point to buffer start
6631: CD4271  	        CALL    PRS             ; Output buffer
6634: E1      	        POP     HL              ; Restore buffer address
6635: D1      	        POP     DE              ; Restore DE
6636: C1      	        POP     BC              ; Restore buffer length
6637: C3E265  	        JP      MORINP          ; Get another character
              	
663A: FE20    	PUTBUF: CP      ' '             ; Is it a control code?
663C: DAE265  	        JP      C,MORINP        ; Yes - Ignore
663F: 78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
6640: FE49    	        CP      72+1            ; Test for line overflow
6642: 3E07    	        LD      A,CTRLG         ; Set a bell
6644: D25466  	        JP      NC,OUTNBS       ; Ring bell if buffer full
6647: 79      	        LD      A,C             ; Get character
6648: 71      	        LD      (HL),C          ; Save in buffer
6649: 32CC80  	        LD      (LSTBIN),A      ; Save last input byte
664C: 23      	        INC     HL              ; Move up buffer
664D: 04      	        INC     B               ; Increment length
664E: CD6D66  	OUTIT:  CALL    OUTC            ; Output the character entered
6651: C3E265  	        JP      MORINP          ; Get another character
              	
6654: CD6D66  	OUTNBS: CALL    OUTC            ; Output bell and back over it
6657: 3E08    	        LD      A,BKSP          ; Set back space
6659: C34E66  	        JP      OUTIT           ; Output it and get more
              	
665C: 7C      	CPDEHL: LD      A,H             ; Get H
665D: 92      	        SUB     D               ; Compare with D
665E: C0      	        RET     NZ              ; Different - Exit
665F: 7D      	        LD      A,L             ; Get L
6660: 93      	        SUB     E               ; Compare with E
6661: C9      	        RET                     ; Return status
              	
6662: 7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
6663: E3      	        EX      (SP),HL         ; Address of test byte
6664: BE      	        CP      (HL)            ; Same as in code string?
6665: 23      	        INC     HL              ; Return address
6666: E3      	        EX      (SP),HL         ; Put it back
6667: CAFC67  	        JP      Z,GETCHR        ; Yes - Get next character
666A: C39463  	        JP      SNERR           ; Different - ?SN Error
              	
666D: F5      	OUTC:   PUSH    AF              ; Save character 
666E: 3A4580  	        LD      A,(CTLOFG)      ; Get control "O" flag
6671: B7      	        OR      A               ; Is it set?
6672: C27771  	        JP      NZ,POPAF        ; Yes - don't output
6675: F1      	        POP     AF              ; Restore character
6676: C5      	        PUSH    BC              ; Save buffer length
6677: F5      	        PUSH    AF              ; Save character
6678: FE20    	        CP      ' '             ; Is it a control code?
667A: DA9166  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
667D: 3A4280  	        LD      A,(LWIDTH)      ; Get line width
6680: 47      	        LD      B,A             ; To B
6681: 3AAB80  	        LD      A,(CURPOS)      ; Get cursor position
6684: 04      	        INC     B               ; Width 255?
6685: CA8D66  	        JP      Z,INCLEN        ; Yes - No width limit
6688: 05      	        DEC     B               ; Restore width
6689: B8      	        CP      B               ; At end of line?
668A: CCA46A  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
668D: 3C      	INCLEN: INC     A               ; Move on one character
668E: 32AB80  	        LD      (CURPOS),A      ; Save new position
6691: F1      	DINPOS: POP     AF              ; Restore character
6692: C1      	        POP     BC              ; Restore buffer length
6693: CD3D7C  	        CALL    MONOUT          ; Send it
6696: C9      	        RET
              	
6697: CD017B  	CLOTST: CALL    GETINP          ; Get input character
669A: E67F    	        AND     01111111B       ; Strip bit 7
669C: FE0F    	        CP      CTRLO           ; Is it control "O"?
669E: C0      	        RET     NZ              ; No don't flip flag
669F: 3A4580  	        LD      A,(CTLOFG)      ; Get flag
66A2: 2F      	        CPL                     ; Flip it
66A3: 324580  	        LD      (CTLOFG),A      ; Put it back
66A6: AF      	        XOR     A               ; Null character
66A7: C9      	        RET
              	
66A8: CDC868  	LIST:   CALL    ATOH            ; ASCII number to DE
66AB: C0      	        RET     NZ              ; Return if anything extra
66AC: C1      	        POP     BC              ; Rubbish - Not needed
66AD: CD8064  	        CALL    SRCHLN          ; Search for line number in DE
66B0: C5      	        PUSH    BC              ; Save address of line
66B1: CDFE66  	        CALL    SETLIN          ; Set up lines counter
66B4: E1      	LISTLP: POP     HL              ; Restore address of line
66B5: 4E      	        LD      C,(HL)          ; Get LSB of next line
66B6: 23      	        INC     HL
66B7: 46      	        LD      B,(HL)          ; Get MSB of next line
66B8: 23      	        INC     HL
66B9: 78      	        LD      A,B             ; BC = 0 (End of program)?
66BA: B1      	        OR      C
66BB: CADF63  	        JP      Z,PRNTOK        ; Yes - Go to command mode
66BE: CD0767  	        CALL    COUNT           ; Count lines
66C1: CD2768  	        CALL    TSTBRK          ; Test for break key
66C4: C5      	        PUSH    BC              ; Save address of next line
66C5: CDA46A  	        CALL    PRNTCRLF        ; Output CRLF
66C8: 5E      	        LD      E,(HL)          ; Get LSB of line number
66C9: 23      	        INC     HL
66CA: 56      	        LD      D,(HL)          ; Get MSB of line number
66CB: 23      	        INC     HL
66CC: E5      	        PUSH    HL              ; Save address of line start
66CD: EB      	        EX      DE,HL           ; Line number to HL
66CE: CDE577  	        CALL    PRNTHL          ; Output line number in decimal
66D1: 3E20    	        LD      A,' '           ; Space after line number
66D3: E1      	        POP     HL              ; Restore start of line address
66D4: CD6D66  	LSTLP2: CALL    OUTC            ; Output character in A
66D7: 7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
66D8: B7      	        OR      A               ; End of line?
66D9: 23      	        INC     HL              ; To next byte in line
66DA: CAB466  	        JP      Z,LISTLP        ; Yes - get next line
66DD: F2D466  	        JP      P,LSTLP2        ; No token - output it
66E0: D67F    	        SUB     ZEND-1          ; Find and output word
66E2: 4F      	        LD      C,A             ; Token offset+1 to C
66E3: 111261  	        LD      DE,WORDS        ; Reserved word list
66E6: 1A      	FNDTOK: LD      A,(DE)          ; Get character in list
66E7: 13      	        INC     DE              ; Move on to next
66E8: B7      	        OR      A               ; Is it start of word?
66E9: F2E666  	        JP      P,FNDTOK        ; No - Keep looking for word
66EC: 0D      	        DEC     C               ; Count words
66ED: C2E666  	        JP      NZ,FNDTOK       ; Not there - keep looking
66F0: E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
66F2: CD6D66  	        CALL    OUTC            ; Output first character
66F5: 1A      	        LD      A,(DE)          ; Get next character
66F6: 13      	        INC     DE              ; Move on to next
66F7: B7      	        OR      A               ; Is it end of word?
66F8: F2F066  	        JP      P,OUTWRD        ; No - output the rest
66FB: C3D766  	        JP      LSTLP3          ; Next byte in line
              	
66FE: E5      	SETLIN: PUSH    HL              ; Set up LINES counter
66FF: 2A4880  	        LD      HL,(LINESN)     ; Get LINES number
6702: 224680  	        LD      (LINESC),HL     ; Save in LINES counter
6705: E1      	        POP     HL
6706: C9      	        RET
              	
6707: E5      	COUNT:  PUSH    HL              ; Save code string address
6708: D5      	        PUSH    DE
6709: 2A4680  	        LD      HL,(LINESC)     ; Get LINES counter
670C: 11FFFF  	        LD      DE,-1
670F: ED5A    	        ADC     HL,DE           ; Decrement
6711: 224680  	        LD      (LINESC),HL     ; Put it back
6714: D1      	        POP     DE
6715: E1      	        POP     HL              ; Restore code string address
6716: F0      	        RET     P               ; Return if more lines to go
6717: E5      	        PUSH    HL              ; Save code string address
6718: 2A4880  	        LD      HL,(LINESN)     ; Get LINES number
671B: 224680  	        LD      (LINESC),HL     ; Reset LINES counter
671E: CD017B  	        CALL    GETINP          ; Get input character
6721: FE03    	        CP      CTRLC           ; Is it control "C"?
6723: CA2A67  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
6726: E1      	        POP     HL              ; Restore code string address
6727: C30767  	        JP      COUNT           ; Keep on counting
              	
672A: 2A4880  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
672D: 224680  	        LD      (LINESC),HL     ; Reset LINES counter
6730: C3A760  	        JP      BRKRET          ; Go and output "Break"
              	
6733: 3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
6735: 32CB80  	        LD      (FORFLG),A      ; Save "FOR" flag
6738: CDAA69  	        CALL    LET             ; Set up initial index
673B: C1      	        POP     BC              ; Drop RETurn address
673C: E5      	        PUSH    HL              ; Save code string address
673D: CD9369  	        CALL    DATA            ; Get next statement address
6740: 22C780  	        LD      (LOOPST),HL     ; Save it for start of loop
6743: 210200  	        LD      HL,2            ; Offset for "FOR" block
6746: 39      	        ADD     HL,SP           ; Point to it
6747: CD4163  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
674A: D1      	        POP     DE              ; Get code string address
674B: C26367  	        JP      NZ,FORFND       ; No nesting found
674E: 09      	        ADD     HL,BC           ; Move into "FOR" block
674F: D5      	        PUSH    DE              ; Save code string address
6750: 2B      	        DEC     HL
6751: 56      	        LD      D,(HL)          ; Get MSB of loop statement
6752: 2B      	        DEC     HL
6753: 5E      	        LD      E,(HL)          ; Get LSB of loop statement
6754: 23      	        INC     HL
6755: 23      	        INC     HL
6756: E5      	        PUSH    HL              ; Save block address
6757: 2AC780  	        LD      HL,(LOOPST)     ; Get address of loop statement
675A: CD5C66  	        CALL    CPDEHL          ; Compare the FOR loops
675D: E1      	        POP     HL              ; Restore block address
675E: C24767  	        JP      NZ,FORSLP       ; Different FORs - Find another
6761: D1      	        POP     DE              ; Restore code string address
6762: F9      	        LD      SP,HL           ; Remove all nested loops
              	
6763: EB      	FORFND: EX      DE,HL           ; Code string address to HL
6764: 0E08    	        LD      C,8
6766: CD7163  	        CALL    CHKSTK          ; Check for 8 levels of stack
6769: E5      	        PUSH    HL              ; Save code string address
676A: 2AC780  	        LD      HL,(LOOPST)     ; Get first statement of loop
676D: E3      	        EX      (SP),HL         ; Save and restore code string
676E: E5      	        PUSH    HL              ; Re-save code string address
676F: 2A5C80  	        LD      HL,(LINEAT)     ; Get current line number
6772: E3      	        EX      (SP),HL         ; Save and restore code string
6773: CD6C6C  	        CALL    TSTNUM          ; Make sure it's a number
6776: CD6266  	        CALL    CHKSYN          ; Make sure "TO" is next
6779: A6      	        .BYTE   ZTO          ; "TO" token
677A: CD696C  	        CALL    GETNUM          ; Get "TO" expression value
677D: E5      	        PUSH    HL              ; Save code string address
677E: CD9776  	        CALL    BCDEFP          ; Move "TO" value to BCDE
6781: E1      	        POP     HL              ; Restore code string address
6782: C5      	        PUSH    BC              ; Save "TO" value in block
6783: D5      	        PUSH    DE
6784: 010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
6787: 51      	        LD      D,C             ; C=0
6788: 5A      	        LD      E,D             ; D=0
6789: 7E      	        LD      A,(HL)          ; Get next byte in code string
678A: FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
678C: 3E01    	        LD      A,1             ; Sign of step = 1
678E: C29F67  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
6791: CDFC67  	        CALL    GETCHR          ; Jump over "STEP" token
6794: CD696C  	        CALL    GETNUM          ; Get step value
6797: E5      	        PUSH    HL              ; Save code string address
6798: CD9776  	        CALL    BCDEFP          ; Move STEP to BCDE
679B: CD4B76  	        CALL    TSTSGN          ; Test sign of FPREG
679E: E1      	        POP     HL              ; Restore code string address
679F: C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
67A0: D5      	        PUSH    DE
67A1: F5      	        PUSH    AF              ; Save sign of STEP
67A2: 33      	        INC     SP              ; Don't save flags
67A3: E5      	        PUSH    HL              ; Save code string address
67A4: 2ACE80  	        LD      HL,(BRKLIN)     ; Get address of index variable
67A7: E3      	        EX      (SP),HL         ; Save and restore code string
67A8: 0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
67AA: C5      	        PUSH    BC              ; Save it
67AB: 33      	        INC     SP              ; Don't save C
              	
67AC: CD2768  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
67AF: 22CE80  	        LD      (BRKLIN),HL     ; Save code address for break
67B2: 7E      	        LD      A,(HL)          ; Get next byte in code string
67B3: FE3A    	        CP      ':'             ; Multi statement line?
67B5: CACC67  	        JP      Z,EXCUTE        ; Yes - Execute it
67B8: B7      	        OR      A               ; End of line?
67B9: C29463  	        JP      NZ,SNERR        ; No - Syntax error
67BC: 23      	        INC     HL              ; Point to address of next line
67BD: 7E      	        LD      A,(HL)          ; Get LSB of line pointer
67BE: 23      	        INC     HL
67BF: B6      	        OR      (HL)            ; Is it zero (End of prog)?
67C0: CA4E68  	        JP      Z,ENDPRG        ; Yes - Terminate execution
67C3: 23      	        INC     HL              ; Point to line number
67C4: 5E      	        LD      E,(HL)          ; Get LSB of line number
67C5: 23      	        INC     HL
67C6: 56      	        LD      D,(HL)          ; Get MSB of line number
67C7: EB      	        EX      DE,HL           ; Line number to HL
67C8: 225C80  	        LD      (LINEAT),HL     ; Save as current line number
67CB: EB      	        EX      DE,HL           ; Line number back to DE
67CC: CDFC67  	EXCUTE: CALL    GETCHR          ; Get key word
67CF: 11AC67  	        LD      DE,RUNCNT       ; Where to RETurn to
67D2: D5      	        PUSH    DE              ; Save for RETurn
67D3: C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
              	
              	
              	
              	
67D4:         	ONJMP:  
67D4: FED2    			cp		ZBYE			; token lesser than zbuy
67D6: 380C    			jr		c,notcust		; if so skip to original code
67D8: D6D2    			sub		ZBYE			; subtract zbye to index int custtab
67DA: 07      			rlca					; multiply by tw to make offset
67DB: 4F      			ld		c,a
67DC: 0600    			ld		b,0
67DE: EB      			ex		de,hl			; save code string addr
67DF: 218262  			ld		hl,custtab		; load tabel addr
67E2: 1812    			jr		custadd			; let the original code take over
              	
67E4:         	notcust:
              	
67E4: D680    			SUB     ZEND            ; Is it a token?
67E6: DAAA69  	        JP      C,LET           ; No - try to assign it
67E9: FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
67EB: D29463  	        JP      NC,SNERR        ; Not a key word - ?SN Error
67EE: 07      	        RLCA                    ; Double it
67EF: 4F      	        LD      C,A             ; BC = Offset into table
67F0: 0600    	        LD      B,0
67F2: EB      	        EX      DE,HL           ; Save code string address
67F3: 213862  	        LD      HL,WORDTB       ; Keyword address table
67F6:         	custadd:
67F6: 09      	        ADD     HL,BC           ; Point to routine address
67F7: 4E      	        LD      C,(HL)          ; Get LSB of routine address
67F8: 23      	        INC     HL
67F9: 46      	        LD      B,(HL)          ; Get MSB of routine address
67FA: C5      	        PUSH    BC              ; Save routine address
67FB: EB      	        EX      DE,HL           ; Restore code string address
              	
              	
              	
              	
              	
              	
              	
              	
67FC: 23      	GETCHR: INC     HL              ; Point to next character
67FD: 7E      	        LD      A,(HL)          ; Get next code string byte
67FE: FE3A    	        CP      ':'             ; Z if ':'
6800: D0      	        RET     NC              ; NC if > "9"
6801: FE20    	        CP      ' '
6803: CAFC67  	        JP      Z,GETCHR        ; Skip over spaces
6806: FE30    	        CP      '0'
6808: 3F      	        CCF                     ; NC if < '0'
6809: 3C      	        INC     A               ; Test for zero - Leave carry
680A: 3D      	        DEC     A               ; Z if Null
680B: C9      	        RET
              	
680C: EB      	RESTOR: EX      DE,HL           ; Save code string address
680D: 2A5E80  	        LD      HL,(BASTXT)     ; Point to start of program
6810: CA2168  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
6813: EB      	        EX      DE,HL           ; Restore code string address
6814: CDC868  	        CALL    ATOH            ; Get line number to DE
6817: E5      	        PUSH    HL              ; Save code string address
6818: CD8064  	        CALL    SRCHLN          ; Search for line number in DE
681B: 60      	        LD      H,B             ; HL = Address of line
681C: 69      	        LD      L,C
681D: D1      	        POP     DE              ; Restore code string address
681E: D26969  	        JP      NC,ULERR        ; ?UL Error if not found
6821: 2B      	RESTNL: DEC     HL              ; Byte before DATA statement
6822: 22DC80  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
6825: EB      	        EX      DE,HL           ; Restore code string address
6826: C9      	        RET
              	
              	
6827: DF      	TSTBRK: RST     18H             ; Check input status
6828: C8      	        RET     Z               ; No key, go back
6829: D7      	        RST     10H             ; Get the key into A
682A: FE1B    	        CP      ESC             ; Escape key?
682C: 2811    	        JR      Z,BRK           ; Yes, break
682E: FE03    	        CP      CTRLC           ; <Ctrl-C>
6830: 280D    	        JR      Z,BRK           ; Yes, break
6832: FE13    	        CP      CTRLS           ; Stop scrolling?
6834: C0      	        RET     NZ              ; Other key, ignore
              	
              	
6835: D7      	STALL:  RST     10H             ; Wait for key
6836: FE11    	        CP      CTRLQ           ; Resume scrolling?
6838: C8      	        RET      Z              ; Release the chokehold
6839: FE03    	        CP      CTRLC           ; Second break?
683B: 2807    	        JR      Z,STOP          ; Break during hold exits prog
683D: 18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
683F: 3EFF    	BRK     LD      A,$FF           ; Set BRKFLG
6841: 324D80  	        LD      (BRKFLG),A      ; Store it
              	
              	
6844: C0      	STOP:   RET     NZ              ; Exit if anything else
6845: F6      	        .BYTE   0F6H            ; Flag "STOP"
6846: C0      	PEND:   RET     NZ              ; Exit if anything else
6847: 22CE80  	        LD      (BRKLIN),HL     ; Save point of break
684A: 21      	        .BYTE   21H             ; Skip "OR 11111111B"
684B: F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
684D: C1      	        POP     BC              ; Return not needed and more
684E: 2A5C80  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
6851: F5      	        PUSH    AF              ; Save STOP / END status
6852: 7D      	        LD      A,L             ; Is it direct break?
6853: A4      	        AND     H
6854: 3C      	        INC     A               ; Line is -1 if direct break
6855: CA6168  	        JP      Z,NOLIN         ; Yes - No line number
6858: 22D280  	        LD      (ERRLIN),HL     ; Save line of break
685B: 2ACE80  	        LD      HL,(BRKLIN)     ; Get point of break
685E: 22D480  	        LD      (CONTAD),HL     ; Save point to CONTinue
6861: AF      	NOLIN:  XOR     A
6862: 324580  	        LD      (CTLOFG),A      ; Enable output
6865: CD976A  	        CALL    STTLIN          ; Start a new line
6868: F1      	        POP     AF              ; Restore STOP / END status
6869: 213763  	        LD      HL,BRKMSG       ; "Break" message
686C: C2C863  	        JP      NZ,ERRIN        ; "in line" wanted?
686F: C3DF63  	        JP      PRNTOK          ; Go to command mode
              	
6872: 2AD480  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
6875: 7C      	        LD      A,H             ; Is it zero?
6876: B5      	        OR      L
6877: 1E20    	        LD      E,CN            ; ?CN Error
6879: CAA863  	        JP      Z,ERROR         ; Yes - output "?CN Error"
687C: EB      	        EX      DE,HL           ; Save code string address
687D: 2AD280  	        LD      HL,(ERRLIN)     ; Get line of last break
6880: 225C80  	        LD      (LINEAT),HL     ; Set up current line number
6883: EB      	        EX      DE,HL           ; Restore code string address
6884: C9      	        RET                     ; CONTinue where left off
              	
6885: CDCA73  	NULL:   CALL    GETINT          ; Get integer 0-255
6888: C0      	        RET     NZ              ; Return if bad value
6889: 324180  	        LD      (NULLS),A       ; Set nulls number
688C: C9      	        RET
              	
              	
688D: E5      	ACCSUM: PUSH    HL              ; Save address in array
688E: 2A4A80  	        LD      HL,(CHKSUM)     ; Get check sum
6891: 0600    	        LD      B,0             ; BC - Value of byte
6893: 4F      	        LD      C,A
6894: 09      	        ADD     HL,BC           ; Add byte to check sum
6895: 224A80  	        LD      (CHKSUM),HL     ; Re-save check sum
6898: E1      	        POP     HL              ; Restore address in array
6899: C9      	        RET
              	
689A: 7E      	CHKLTR: LD      A,(HL)          ; Get byte
689B: FE41    	        CP      'A'             ; < 'a' ?
689D: D8      	        RET     C               ; Carry set if not letter
689E: FE5B    	        CP      'Z'+1           ; > 'z' ?
68A0: 3F      	        CCF
68A1: C9      	        RET                     ; Carry set if not letter
              	
68A2: CDFC67  	FPSINT: CALL    GETCHR          ; Get next character
68A5: CD696C  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
68A8: CD4B76  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
68AB: FAC368  	        JP      M,FCERR         ; Negative - ?FC Error
68AE: 3AE780  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
68B1: FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
68B3: DAF376  	        JP      C,FPINT         ; Yes - convert it
68B6: 018090  	        LD      BC,9080H        ; BCDE = -32768
68B9: 110000  	        LD      DE,0000
68BC: E5      	        PUSH    HL              ; Save code string address
68BD: CDC676  	        CALL    CMPNUM          ; Compare FPREG with BCDE
68C0: E1      	        POP     HL              ; Restore code string address
68C1: 51      	        LD      D,C             ; MSB to D
68C2: C8      	        RET     Z               ; Return if in range
68C3: 1E08    	FCERR:  LD      E,FC            ; ?FC Error
68C5: C3A863  	        JP      ERROR           ; Output error-
              	
68C8: 2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
68C9: 110000  	GETLN:  LD      DE,0            ; Get number to DE
68CC: CDFC67  	GTLNLP: CALL    GETCHR          ; Get next character
68CF: D0      	        RET     NC              ; Exit if not a digit
68D0: E5      	        PUSH    HL              ; Save code string address
68D1: F5      	        PUSH    AF              ; Save digit
68D2: 219819  	        LD      HL,65529/10     ; Largest number 65529
68D5: CD5C66  	        CALL    CPDEHL          ; Number in range?
68D8: DA9463  	        JP      C,SNERR         ; No - ?SN Error
68DB: 62      	        LD      H,D             ; HL = Number
68DC: 6B      	        LD      L,E
68DD: 19      	        ADD     HL,DE           ; Times 2
68DE: 29      	        ADD     HL,HL           ; Times 4
68DF: 19      	        ADD     HL,DE           ; Times 5
68E0: 29      	        ADD     HL,HL           ; Times 10
68E1: F1      	        POP     AF              ; Restore digit
68E2: D630    	        SUB     '0'             ; Make it 0 to 9
68E4: 5F      	        LD      E,A             ; DE = Value of digit
68E5: 1600    	        LD      D,0
68E7: 19      	        ADD     HL,DE           ; Add to number
68E8: EB      	        EX      DE,HL           ; Number to DE
68E9: E1      	        POP     HL              ; Restore code string address
68EA: C3CC68  	        JP      GTLNLP          ; Go to next character
              	
68ED: CAB064  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
68F0: CDA568  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
68F3: 2B      	        DEC     HL              ; Cancel increment
68F4: CDFC67  	        CALL    GETCHR          ; Get next character
68F7: E5      	        PUSH    HL              ; Save code string address
68F8: 2AAF80  	        LD      HL,(LSTRAM)     ; Get end of RAM
68FB: CA1069  	        JP      Z,STORED        ; No value given - Use stored
68FE: E1      	        POP     HL              ; Restore code string address
68FF: CD6266  	        CALL    CHKSYN          ; Check for comma
6902: 2C      	        .BYTE      ','
6903: D5      	        PUSH    DE              ; Save number
6904: CDA568  	        CALL    POSINT          ; Get integer 0 to 32767
6907: 2B      	        DEC     HL              ; Cancel increment
6908: CDFC67  	        CALL    GETCHR          ; Get next character
690B: C29463  	        JP      NZ,SNERR        ; ?SN Error if more on line
690E: E3      	        EX      (SP),HL         ; Save code string address
690F: EB      	        EX      DE,HL           ; Number to DE
6910: 7D      	STORED: LD      A,L             ; Get LSB of new RAM top
6911: 93      	        SUB     E               ; Subtract LSB of string space
6912: 5F      	        LD      E,A             ; Save LSB
6913: 7C      	        LD      A,H             ; Get MSB of new RAM top
6914: 9A      	        SBC     A,D             ; Subtract MSB of string space
6915: 57      	        LD      D,A             ; Save MSB
6916: DA8963  	        JP      C,OMERR         ; ?OM Error if not enough mem
6919: E5      	        PUSH    HL              ; Save RAM top
691A: 2AD680  	        LD      HL,(PROGND)     ; Get program end
691D: 012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
6920: 09      	        ADD     HL,BC           ; Get lowest address
6921: CD5C66  	        CALL    CPDEHL          ; Enough memory?
6924: D28963  	        JP      NC,OMERR        ; No - ?OM Error
6927: EB      	        EX      DE,HL           ; RAM top to HL
6928: 225A80  	        LD      (STRSPC),HL     ; Set new string space
692B: E1      	        POP     HL              ; End of memory to use
692C: 22AF80  	        LD      (LSTRAM),HL     ; Set new top of RAM
692F: E1      	        POP     HL              ; Restore code string address
6930: C3B064  	        JP      INTVAR          ; Initialise variables
              	
6933: CAAC64  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
6936: CDB064  	        CALL    INTVAR          ; Initialise variables
6939: 01AC67  	        LD      BC,RUNCNT       ; Execution driver loop
693C: C34F69  	        JP      RUNLIN          ; RUN from line number
              	
693F: 0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
6941: CD7163  	        CALL    CHKSTK          ; Check for 3 levels of stack
6944: C1      	        POP     BC              ; Get return address
6945: E5      	        PUSH    HL              ; Save code string for RETURN
6946: E5      	        PUSH    HL              ; And for GOSUB routine
6947: 2A5C80  	        LD      HL,(LINEAT)     ; Get current line
694A: E3      	        EX      (SP),HL         ; Into stack - Code string out
694B: 3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
694D: F5      	        PUSH    AF              ; Save token
694E: 33      	        INC     SP              ; Don't save flags
              	
694F: C5      	RUNLIN: PUSH    BC              ; Save return address
6950: CDC868  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
6953: CD9569  	        CALL    REM             ; Get end of line
6956: E5      	        PUSH    HL              ; Save end of line
6957: 2A5C80  	        LD      HL,(LINEAT)     ; Get current line
695A: CD5C66  	        CALL    CPDEHL          ; Line after current?
695D: E1      	        POP     HL              ; Restore end of line
695E: 23      	        INC     HL              ; Start of next line
695F: DC8364  	        CALL    C,SRCHLP        ; Line is after current line
6962: D48064  	        CALL    NC,SRCHLN       ; Line is before current line
6965: 60      	        LD      H,B             ; Set up code string address
6966: 69      	        LD      L,C
6967: 2B      	        DEC     HL              ; Incremented after
6968: D8      	        RET     C               ; Line found
6969: 1E0E    	ULERR:  LD      E,UL            ; ?UL Error
696B: C3A863  	        JP      ERROR           ; Output error message
              	
696E: C0      	RETURN: RET     NZ              ; Return if not just RETURN
696F: 16FF    	        LD      D,-1            ; Flag "GOSUB" search
6971: CD3D63  	        CALL    BAKSTK          ; Look "GOSUB" block
6974: F9      	        LD      SP,HL           ; Kill all FORs in subroutine
6975: FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
6977: 1E04    	        LD      E,RG            ; ?RG Error
6979: C2A863  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
697C: E1      	        POP     HL              ; Get RETURN line number
697D: 225C80  	        LD      (LINEAT),HL     ; Save as current
6980: 23      	        INC     HL              ; Was it from direct statement?
6981: 7C      	        LD      A,H
6982: B5      	        OR      L               ; Return to line
6983: C28D69  	        JP      NZ,RETLIN       ; No - Return to line
6986: 3ACC80  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
6989: B7      	        OR      A               ; If so buffer is corrupted
698A: C2DE63  	        JP      NZ,POPNOK       ; Yes - Go to command mode
698D: 21AC67  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
6990: E3      	        EX      (SP),HL         ; Into stack - Code string out
6991: 3E      	        .BYTE      3EH             ; Skip "POP HL"
6992: E1      	NXTDTA: POP     HL              ; Restore code string address
              	
6993: 013A    	DATA:   .BYTE      01H,3AH         ; ':' End of statement
6995: 0E00    	REM:    LD      C,0             ; 00  End of statement
6997: 0600    	        LD      B,0
6999: 79      	NXTSTL: LD      A,C             ; Statement and byte
699A: 48      	        LD      C,B
699B: 47      	        LD      B,A             ; Statement end byte
699C: 7E      	NXTSTT: LD      A,(HL)          ; Get byte
699D: B7      	        OR      A               ; End of line?
699E: C8      	        RET     Z               ; Yes - Exit
699F: B8      	        CP      B               ; End of statement?
69A0: C8      	        RET     Z               ; Yes - Exit
69A1: 23      	        INC     HL              ; Next byte
69A2: FE22    	        CP      '"'             ; Literal string?
69A4: CA9969  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
69A7: C39C69  	        JP      NXTSTT          ; Keep looking
              	
69AA: CD5F6E  	LET:    CALL    GETVAR          ; Get variable name
69AD: CD6266  	        CALL    CHKSYN          ; Make sure "=" follows
69B0: B4      	        .BYTE      ZEQUAL          ; "=" token
69B1: D5      	        PUSH    DE              ; Save address of variable
69B2: 3AAD80  	        LD      A,(TYPE)        ; Get data type
69B5: F5      	        PUSH    AF              ; Save type
69B6: CD7B6C  	        CALL    EVAL            ; Evaluate expression
69B9: F1      	        POP     AF              ; Restore type
69BA: E3      	        EX      (SP),HL         ; Save code - Get var addr
69BB: 22CE80  	        LD      (BRKLIN),HL     ; Save address of variable
69BE: 1F      	        RRA                     ; Adjust type
69BF: CD6E6C  	        CALL    CHKTYP          ; Check types are the same
69C2: CAFD69  	        JP      Z,LETNUM        ; Numeric - Move value
69C5: E5      	LETSTR: PUSH    HL              ; Save address of string var
69C6: 2AE480  	        LD      HL,(FPREG)      ; Pointer to string entry
69C9: E5      	        PUSH    HL              ; Save it on stack
69CA: 23      	        INC     HL              ; Skip over length
69CB: 23      	        INC     HL
69CC: 5E      	        LD      E,(HL)          ; LSB of string address
69CD: 23      	        INC     HL
69CE: 56      	        LD      D,(HL)          ; MSB of string address
69CF: 2A5E80  	        LD      HL,(BASTXT)     ; Point to start of program
69D2: CD5C66  	        CALL    CPDEHL          ; Is string before program?
69D5: D2EC69  	        JP      NC,CRESTR       ; Yes - Create string entry
69D8: 2A5A80  	        LD      HL,(STRSPC)     ; Point to string space
69DB: CD5C66  	        CALL    CPDEHL          ; Is string literal in program?
69DE: D1      	        POP     DE              ; Restore address of string
69DF: D2F469  	        JP      NC,MVSTPT       ; Yes - Set up pointer
69E2: 21BF80  	        LD      HL,TMPSTR       ; Temporary string pool
69E5: CD5C66  	        CALL    CPDEHL          ; Is string in temporary pool?
69E8: D2F469  	        JP      NC,MVSTPT       ; No - Set up pointer
69EB: 3E      	        .BYTE   3EH             ; Skip "POP DE"
69EC: D1      	CRESTR: POP     DE              ; Restore address of string
69ED: CDA372  	        CALL    BAKTMP          ; Back to last tmp-str entry
69F0: EB      	        EX      DE,HL           ; Address of string entry
69F1: CDDC70  	        CALL    SAVSTR          ; Save string in string area
69F4: CDA372  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
69F7: E1      	        POP     HL              ; Get string pointer
69F8: CDA676  	        CALL    DETHL4          ; Move string pointer to var
69FB: E1      	        POP     HL              ; Restore code string address
69FC: C9      	        RET
              	
69FD: E5      	LETNUM: PUSH    HL              ; Save address of variable
69FE: CDA376  	        CALL    FPTHL           ; Move value to variable
6A01: D1      	        POP     DE              ; Restore address of variable
6A02: E1      	        POP     HL              ; Restore code string address
6A03: C9      	        RET
              	
6A04: CDCA73  	ON:     CALL    GETINT          ; Get integer 0-255
6A07: 7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
6A08: 47      	        LD      B,A             ; Save in B
6A09: FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
6A0B: CA136A  	        JP      Z,ONGO          ; Yes - Find line number
6A0E: CD6266  	        CALL    CHKSYN          ; Make sure it's "GOTO"
6A11: 88      	        .BYTE   ZGOTO           ; "GOTO" token
6A12: 2B      	        DEC     HL              ; Cancel increment
6A13: 4B      	ONGO:   LD      C,E             ; Integer of branch value
6A14: 0D      	ONGOLP: DEC     C               ; Count branches
6A15: 78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
6A16: CAD467  	        JP      Z,ONJMP         ; Go to that line if right one
6A19: CDC968  	        CALL    GETLN           ; Get line number to DE
6A1C: FE2C    	        CP      ','             ; Another line number?
6A1E: C0      	        RET     NZ              ; No - Drop through
6A1F: C3146A  	        JP      ONGOLP          ; Yes - loop
              	
6A22: CD7B6C  	IF:     CALL    EVAL            ; Evaluate expression
6A25: 7E      	        LD      A,(HL)          ; Get token
6A26: FE88    	        CP      ZGOTO           ; "GOTO" token?
6A28: CA306A  	        JP      Z,IFGO          ; Yes - Get line
6A2B: CD6266  	        CALL    CHKSYN          ; Make sure it's "THEN"
6A2E: A9      	        .BYTE      ZTHEN           ; "THEN" token
6A2F: 2B      	        DEC     HL              ; Cancel increment
6A30: CD6C6C  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
6A33: CD4B76  	        CALL    TSTSGN          ; Test state of expression
6A36: CA9569  	        JP      Z,REM           ; False - Drop through
6A39: CDFC67  	        CALL    GETCHR          ; Get next character
6A3C: DA5069  	        JP      C,GOTO          ; Number - GOTO that line
6A3F: C3D367  	        JP      IFJMP           ; Otherwise do statement
              	
6A42: 2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
6A43: CDFC67  	        CALL    GETCHR          ; Get next character
6A46: CAA46A  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
6A49: C8      	PRNTLP: RET     Z               ; End of list - Exit
6A4A: FEA5    	        CP      ZTAB            ; "TAB(" token?
6A4C: CAD76A  	        JP      Z,DOTAB         ; Yes - Do TAB routine
6A4F: FEA8    	        CP      ZSPC            ; "SPC(" token?
6A51: CAD76A  	        JP      Z,DOTAB         ; Yes - Do SPC routine
6A54: E5      	        PUSH    HL              ; Save code string address
6A55: FE2C    	        CP      ','             ; Comma?
6A57: CAC06A  	        JP      Z,DOCOM         ; Yes - Move to next zone
6A5A: FE3B    	        CP      59 ;";"         ; Semi-colon?
6A5C: CAFA6A  	        JP      Z,NEXITM        ; Do semi-colon routine
6A5F: C1      	        POP     BC              ; Code string address to BC
6A60: CD7B6C  	        CALL    EVAL            ; Evaluate expression
6A63: E5      	        PUSH    HL              ; Save code string address
6A64: 3AAD80  	        LD      A,(TYPE)        ; Get variable type
6A67: B7      	        OR      A               ; Is it a string variable?
6A68: C2906A  	        JP      NZ,PRNTST       ; Yes - Output string contents
6A6B: CDF077  	        CALL    NUMASC          ; Convert number to text
6A6E: CD0071  	        CALL    CRTST           ; Create temporary string
6A71: 3620    	        LD      (HL),' '        ; Followed by a space
6A73: 2AE480  	        LD      HL,(FPREG)      ; Get length of output
6A76: 34      	        INC     (HL)            ; Plus 1 for the space
6A77: 2AE480  	        LD      HL,(FPREG)      ; < Not needed >
6A7A: 3A4280  	        LD      A,(LWIDTH)      ; Get width of line
6A7D: 47      	        LD      B,A             ; To B
6A7E: 04      	        INC     B               ; Width 255 (No limit)?
6A7F: CA8C6A  	        JP      Z,PRNTNB        ; Yes - Output number string
6A82: 04      	        INC     B               ; Adjust it
6A83: 3AAB80  	        LD      A,(CURPOS)      ; Get cursor position
6A86: 86      	        ADD     A,(HL)          ; Add length of string
6A87: 3D      	        DEC     A               ; Adjust it
6A88: B8      	        CP      B               ; Will output fit on this line?
6A89: D4A46A  	        CALL    NC,PRNTCRLF     ; No - CRLF first
6A8C: CD4571  	PRNTNB: CALL    PRS1            ; Output string at (HL)
6A8F: AF      	        XOR     A               ; Skip CALL by setting 'z' flag
6A90: C44571  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
6A93: E1      	        POP     HL              ; Restore code string address
6A94: C3426A  	        JP      MRPRNT          ; See if more to PRINT
              	
6A97: 3AAB80  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
6A9A: B7      	        OR      A               ; Already at start?
6A9B: C8      	        RET     Z               ; Yes - Do nothing
6A9C: C3A46A  	        JP      PRNTCRLF        ; Start a new line
              	
6A9F: 3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
6AA1: 216080  	        LD      HL,BUFFER-1     ; Point to buffer
6AA4: 3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
6AA6: CD6D66  	        CALL    OUTC            ; Output character
6AA9: 3E0A    	        LD      A,LF            ; Load a LF
6AAB: CD6D66  	        CALL    OUTC            ; Output character
6AAE: AF      	DONULL: XOR     A               ; Set to position 0
6AAF: 32AB80  	        LD      (CURPOS),A      ; Store it
6AB2: 3A4180  	        LD      A,(NULLS)       ; Get number of nulls
6AB5: 3D      	NULLP:  DEC     A               ; Count them
6AB6: C8      	        RET     Z               ; Return if done
6AB7: F5      	        PUSH    AF              ; Save count
6AB8: AF      	        XOR     A               ; Load a null
6AB9: CD6D66  	        CALL    OUTC            ; Output it
6ABC: F1      	        POP     AF              ; Restore count
6ABD: C3B56A  	        JP      NULLP           ; Keep counting
              	
6AC0: 3A4380  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
6AC3: 47      	        LD      B,A             ; Save in B
6AC4: 3AAB80  	        LD      A,(CURPOS)      ; Get current position
6AC7: B8      	        CP      B               ; Within the limit?
6AC8: D4A46A  	        CALL    NC,PRNTCRLF     ; No - output CRLF
6ACB: D2FA6A  	        JP      NC,NEXITM       ; Get next item
6ACE: D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
6AD0: D2CE6A  	        JP      NC,ZONELP       ; Repeat if more zones
6AD3: 2F      	        CPL                     ; Number of spaces to output
6AD4: C3EF6A  	        JP      ASPCS           ; Output them
              	
6AD7: F5      	DOTAB:  PUSH    AF              ; Save token
6AD8: CDC773  	        CALL    FNDNUM          ; Evaluate expression
6ADB: CD6266  	        CALL    CHKSYN          ; Make sure ")" follows
6ADE: 29      	        .BYTE   ")"
6ADF: 2B      	        DEC     HL              ; Back space on to ")"
6AE0: F1      	        POP     AF              ; Restore token
6AE1: D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
6AE3: E5      	        PUSH    HL              ; Save code string address
6AE4: CAEA6A  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
6AE7: 3AAB80  	        LD      A,(CURPOS)      ; Get current position
6AEA: 2F      	DOSPC:  CPL                     ; Number of spaces to print to
6AEB: 83      	        ADD     A,E             ; Total number to print
6AEC: D2FA6A  	        JP      NC,NEXITM       ; TAB < Current POS(X)
6AEF: 3C      	ASPCS:  INC     A               ; Output A spaces
6AF0: 47      	        LD      B,A             ; Save number to print
6AF1: 3E20    	        LD      A,' '           ; Space
6AF3: CD6D66  	SPCLP:  CALL    OUTC            ; Output character in A
6AF6: 05      	        DEC     B               ; Count them
6AF7: C2F36A  	        JP      NZ,SPCLP        ; Repeat if more
6AFA: E1      	NEXITM: POP     HL              ; Restore code string address
6AFB: CDFC67  	        CALL    GETCHR          ; Get next character
6AFE: C3496A  	        JP      PRNTLP          ; More to print
              	
6B01: 3F526564	REDO:   .BYTE   "?Redo from start",CR,LF,0
6B05: 6F206672	
6B09: 6F6D2073	
6B0D: 74617274	
6B11: 0D0A00  	
              	
6B14: 3ACD80  	BADINP: LD      A,(READFG)      ; READ or INPUT?
6B17: B7      	        OR      A
6B18: C28E63  	        JP      NZ,DATSNR       ; READ - ?SN Error
6B1B: C1      	        POP     BC              ; Throw away code string addr
6B1C: 21016B  	        LD      HL,REDO         ; "Redo from start" message
6B1F: CD4271  	        CALL    PRS             ; Output string
6B22: C3DF64  	        JP      DOAGN           ; Do last INPUT again
              	
6B25: CDAD70  	INPUT:  CALL    IDTEST          ; Test for illegal direct
6B28: 7E      	        LD      A,(HL)          ; Get character after "INPUT"
6B29: FE22    	        CP      '"'             ; Is there a prompt string? "
6B2B: 3E00    	        LD      A,0             ; Clear A and leave flags
6B2D: 324580  	        LD      (CTLOFG),A      ; Enable output
6B30: C23F6B  	        JP      NZ,NOPMPT       ; No prompt - get input
6B33: CD0171  	        CALL    QTSTR           ; Get string terminated by '"'
6B36: CD6266  	        CALL    CHKSYN          ; Check for ';' after prompt
6B39: 3B      	        .BYTE   ';'
6B3A: E5      	        PUSH    HL              ; Save code string address
6B3B: CD4571  	        CALL    PRS1            ; Output prompt string
6B3E: 3E      	        .BYTE   3EH             ; Skip "PUSH HL"
6B3F: E5      	NOPMPT: PUSH    HL              ; Save code string address
6B40: CDE364  	        CALL    PROMPT          ; Get input with "? " prompt
6B43: C1      	        POP     BC              ; Restore code string address
6B44: DA4B68  	        JP      C,INPBRK        ; Break pressed - Exit
6B47: 23      	        INC     HL              ; Next byte
6B48: 7E      	        LD      A,(HL)          ; Get it
6B49: B7      	        OR      A               ; End of line?
6B4A: 2B      	        DEC     HL              ; Back again
6B4B: C5      	        PUSH    BC              ; Re-save code string address
6B4C: CA9269  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
6B4F: 362C    	        LD      (HL),','        ; Store comma as separator
6B51: C3596B  	        JP      NXTITM          ; Get next item
              	
6B54: E5      	READ:   PUSH    HL              ; Save code string address
6B55: 2ADC80  	        LD      HL,(NXTDAT)     ; Next DATA statement
6B58: F6      	        .BYTE   0F6H            ; Flag "READ"
6B59: AF      	NXTITM: XOR     A               ; Flag "INPUT"
6B5A: 32CD80  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
6B5D: E3      	        EX      (SP),HL         ; Get code str' , Save pointer
6B5E: C3656B  	        JP      GTVLUS          ; Get values
              	
6B61: CD6266  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
6B64: 2C      	        .BYTE      ','
6B65: CD5F6E  	GTVLUS: CALL    GETVAR          ; Get variable name
6B68: E3      	        EX      (SP),HL         ; Save code str" , Get pointer
6B69: D5      	        PUSH    DE              ; Save variable address
6B6A: 7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
6B6B: FE2C    	        CP      ','             ; Comma?
6B6D: CA8D6B  	        JP      Z,ANTVLU        ; Yes - Get another value
6B70: 3ACD80  	        LD      A,(READFG)      ; Is it READ?
6B73: B7      	        OR      A
6B74: C2FA6B  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
6B77: 3E3F    	        LD      A,'?'           ; More INPUT needed
6B79: CD6D66  	        CALL    OUTC            ; Output character
6B7C: CDE364  	        CALL    PROMPT          ; Get INPUT with prompt
6B7F: D1      	        POP     DE              ; Variable address
6B80: C1      	        POP     BC              ; Code string address
6B81: DA4B68  	        JP      C,INPBRK        ; Break pressed
6B84: 23      	        INC     HL              ; Point to next DATA byte
6B85: 7E      	        LD      A,(HL)          ; Get byte
6B86: B7      	        OR      A               ; Is it zero (No input) ?
6B87: 2B      	        DEC     HL              ; Back space INPUT pointer
6B88: C5      	        PUSH    BC              ; Save code string address
6B89: CA9269  	        JP      Z,NXTDTA        ; Find end of buffer
6B8C: D5      	        PUSH    DE              ; Save variable address
6B8D: 3AAD80  	ANTVLU: LD      A,(TYPE)        ; Check data type
6B90: B7      	        OR      A               ; Is it numeric?
6B91: CAB76B  	        JP      Z,INPBIN        ; Yes - Convert to binary
6B94: CDFC67  	        CALL    GETCHR          ; Get next character
6B97: 57      	        LD      D,A             ; Save input character
6B98: 47      	        LD      B,A             ; Again
6B99: FE22    	        CP      '"'             ; Start of literal sting? "
6B9B: CAAB6B  	        JP      Z,STRENT        ; Yes - Create string entry
6B9E: 3ACD80  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
6BA1: B7      	        OR      A
6BA2: 57      	        LD      D,A             ; Save 00 if "INPUT"
6BA3: CAA86B  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
6BA6: 163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
6BA8: 062C    	ITMSEP: LD      B,','           ; Item separator
6BAA: 2B      	        DEC     HL              ; Back space for DTSTR
6BAB: CD0471  	STRENT: CALL    DTSTR           ; Get string terminated by D
6BAE: EB      	        EX      DE,HL           ; String address to DE
6BAF: 21C26B  	        LD      HL,LTSTND       ; Where to go after LETSTR
6BB2: E3      	        EX      (SP),HL         ; Save HL , get input pointer
6BB3: D5      	        PUSH    DE              ; Save address of string
6BB4: C3C569  	        JP      LETSTR          ; Assign string to variable
              	
6BB7: CDFC67  	INPBIN: CALL    GETCHR          ; Get next character
6BBA: CD5277  	        CALL    ASCTFP          ; Convert ASCII to FP number
6BBD: E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
6BBE: CDA376  	        CALL    FPTHL           ; Move FPREG to variable
6BC1: E1      	        POP     HL              ; Restore input pointer
6BC2: 2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
6BC3: CDFC67  	        CALL    GETCHR          ; Get next character
6BC6: CACE6B  	        JP      Z,MORDT         ; End of line - More needed?
6BC9: FE2C    	        CP      ','             ; Another value?
6BCB: C2146B  	        JP      NZ,BADINP       ; No - Bad input
6BCE: E3      	MORDT:  EX      (SP),HL         ; Get code string address
6BCF: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
6BD0: CDFC67  	        CALL    GETCHR          ; Get next character
6BD3: C2616B  	        JP      NZ,NEDMOR       ; More needed - Get it
6BD6: D1      	        POP     DE              ; Restore DATA pointer
6BD7: 3ACD80  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
6BDA: B7      	        OR      A
6BDB: EB      	        EX      DE,HL           ; DATA pointer to HL
6BDC: C22268  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
6BDF: D5      	        PUSH    DE              ; Save code string address
6BE0: B6      	        OR      (HL)            ; More input given?
6BE1: 21E96B  	        LD      HL,EXTIG        ; "?Extra ignored" message
6BE4: C44271  	        CALL    NZ,PRS          ; Output string if extra given
6BE7: E1      	        POP     HL              ; Restore code string address
6BE8: C9      	        RET
              	
6BE9: 3F457874	EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
6BED: 72612069	
6BF1: 676E6F72	
6BF5: 65640D0A	
6BF9: 00      	
              	
6BFA: CD9369  	FDTLP:  CALL    DATA            ; Get next statement
6BFD: B7      	        OR      A               ; End of line?
6BFE: C2136C  	        JP      NZ,FANDT        ; No - See if DATA statement
6C01: 23      	        INC     HL
6C02: 7E      	        LD      A,(HL)          ; End of program?
6C03: 23      	        INC     HL
6C04: B6      	        OR      (HL)            ; 00 00 Ends program
6C05: 1E06    	        LD      E,OD            ; ?OD Error
6C07: CAA863  	        JP      Z,ERROR         ; Yes - Out of DATA
6C0A: 23      	        INC     HL
6C0B: 5E      	        LD      E,(HL)          ; LSB of line number
6C0C: 23      	        INC     HL
6C0D: 56      	        LD      D,(HL)          ; MSB of line number
6C0E: EB      	        EX      DE,HL
6C0F: 22C980  	        LD      (DATLIN),HL     ; Set line of current DATA item
6C12: EB      	        EX      DE,HL
6C13: CDFC67  	FANDT:  CALL    GETCHR          ; Get next character
6C16: FE83    	        CP      ZDATA           ; "DATA" token
6C18: C2FA6B  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
6C1B: C38D6B  	        JP      ANTVLU          ; Found - Convert input
              	
6C1E: 110000  	NEXT:   LD      DE,0            ; In case no index given
6C21: C45F6E  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
6C24: 22CE80  	        LD      (BRKLIN),HL     ; Save code string address
6C27: CD3D63  	        CALL    BAKSTK          ; Look for "FOR" block
6C2A: C29A63  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
6C2D: F9      	        LD      SP,HL           ; Clear nested loops
6C2E: D5      	        PUSH    DE              ; Save index address
6C2F: 7E      	        LD      A,(HL)          ; Get sign of STEP
6C30: 23      	        INC     HL
6C31: F5      	        PUSH    AF              ; Save sign of STEP
6C32: D5      	        PUSH    DE              ; Save index address
6C33: CD8976  	        CALL    PHLTFP          ; Move index value to FPREG
6C36: E3      	        EX      (SP),HL         ; Save address of TO value
6C37: E5      	        PUSH    HL              ; Save address of index
6C38: CDF673  	        CALL    ADDPHL          ; Add STEP to index value
6C3B: E1      	        POP     HL              ; Restore address of index
6C3C: CDA376  	        CALL    FPTHL           ; Move value to index variable
6C3F: E1      	        POP     HL              ; Restore address of TO value
6C40: CD9A76  	        CALL    LOADFP          ; Move TO value to BCDE
6C43: E5      	        PUSH    HL              ; Save address of line of FOR
6C44: CDC676  	        CALL    CMPNUM          ; Compare index with TO value
6C47: E1      	        POP     HL              ; Restore address of line num
6C48: C1      	        POP     BC              ; Address of sign of STEP
6C49: 90      	        SUB     B               ; Compare with expected sign
6C4A: CD9A76  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
6C4D: CA596C  	        JP      Z,KILFOR        ; Loop finished - Terminate it
6C50: EB      	        EX      DE,HL           ; Loop statement line number
6C51: 225C80  	        LD      (LINEAT),HL     ; Set loop line number
6C54: 69      	        LD      L,C             ; Set code string to loop
6C55: 60      	        LD      H,B
6C56: C3A867  	        JP      PUTFID          ; Put back "FOR" and continue
              	
6C59: F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
6C5A: 2ACE80  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
6C5D: 7E      	        LD      A,(HL)          ; Get next byte in code string
6C5E: FE2C    	        CP      ','             ; More NEXTs ?
6C60: C2AC67  	        JP      NZ,RUNCNT       ; No - Do next statement
6C63: CDFC67  	        CALL    GETCHR          ; Position to index name
6C66: CD216C  	        CALL    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
6C69: CD7B6C  	GETNUM: CALL    EVAL            ; Get a numeric expression
6C6C: F6      	TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
6C6D: 37      	TSTSTR: SCF                     ; Set carry (string)
6C6E: 3AAD80  	CHKTYP: LD      A,(TYPE)        ; Check types match
6C71: 8F      	        ADC     A,A             ; Expected + actual
6C72: B7      	        OR      A               ; Clear carry , set parity
6C73: E8      	        RET     PE              ; Even parity - Types match
6C74: C3A663  	        JP      TMERR           ; Different types - Error
              	
6C77: CD6266  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
6C7A: 28      	        .BYTE   "("
6C7B: 2B      	EVAL:   DEC     HL              ; Evaluate expression & save
6C7C: 1600    	        LD      D,0             ; Precedence value
6C7E: D5      	EVAL1:  PUSH    DE              ; Save precedence
6C7F: 0E01    	        LD      C,1
6C81: CD7163  	        CALL    CHKSTK          ; Check for 1 level of stack
6C84: CDF26C  	        CALL    OPRND           ; Get next expression value
6C87: 22D080  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
6C8A: 2AD080  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
6C8D: C1      	        POP     BC              ; Precedence value and operator
6C8E: 78      	        LD      A,B             ; Get precedence value
6C8F: FE78    	        CP      78H             ; "AND" or "OR" ?
6C91: D46C6C  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
6C94: 7E      	        LD      A,(HL)          ; Get next operator / function
6C95: 1600    	        LD      D,0             ; Clear Last relation
6C97: D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
6C99: DAB36C  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
6C9C: FE03    	        CP      ZLTH+1-ZGTR     ; < = >
6C9E: D2B36C  	        JP      NC,FOPRND       ; Function - Call it
6CA1: FE01    	        CP      ZEQUAL-ZGTR     ; "="
6CA3: 17      	        RLA                     ; <- Test for legal
6CA4: AA      	        XOR     D               ; <- combinations of < = >
6CA5: BA      	        CP      D               ; <- by combining last token
6CA6: 57      	        LD      D,A             ; <- with current one
6CA7: DA9463  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
6CAA: 22C580  	        LD      (CUROPR),HL     ; Save address of current token
6CAD: CDFC67  	        CALL    GETCHR          ; Get next character
6CB0: C3976C  	        JP      RLTLP           ; Treat the two as one
              	
6CB3: 7A      	FOPRND: LD      A,D             ; < = > found ?
6CB4: B7      	        OR      A
6CB5: C2DA6D  	        JP      NZ,TSTRED       ; Yes - Test for reduction
6CB8: 7E      	        LD      A,(HL)          ; Get operator token
6CB9: 22C580  	        LD      (CUROPR),HL     ; Save operator address
6CBC: D6AC    	        SUB     ZPLUS           ; Operator or function?
6CBE: D8      	        RET     C               ; Neither - Exit
6CBF: FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
6CC1: D0      	        RET     NC              ; No - Exit
6CC2: 5F      	        LD      E,A             ; Coded operator
6CC3: 3AAD80  	        LD      A,(TYPE)        ; Get data type
6CC6: 3D      	        DEC     A               ; FF = numeric , 00 = string
6CC7: B3      	        OR      E               ; Combine with coded operator
6CC8: 7B      	        LD      A,E             ; Get coded operator
6CC9: CA3872  	        JP      Z,CONCAT        ; String concatenation
6CCC: 07      	        RLCA                    ; Times 2
6CCD: 83      	        ADD     A,E             ; Times 3
6CCE: 5F      	        LD      E,A             ; To DE (D is 0)
6CCF: 218662  	        LD      HL,PRITAB       ; Precedence table
6CD2: 19      	        ADD     HL,DE           ; To the operator concerned
6CD3: 78      	        LD      A,B             ; Last operator precedence
6CD4: 56      	        LD      D,(HL)          ; Get evaluation precedence
6CD5: BA      	        CP      D               ; Compare with eval precedence
6CD6: D0      	        RET     NC              ; Exit if higher precedence
6CD7: 23      	        INC     HL              ; Point to routine address
6CD8: CD6C6C  	        CALL    TSTNUM          ; Make sure it's a number
              	
6CDB: C5      	STKTHS: PUSH    BC              ; Save last precedence & token
6CDC: 018A6C  	        LD      BC,EVAL3        ; Where to go on prec' break
6CDF: C5      	        PUSH    BC              ; Save on stack for return
6CE0: 43      	        LD      B,E             ; Save operator
6CE1: 4A      	        LD      C,D             ; Save precedence
6CE2: CD7C76  	        CALL    STAKFP          ; Move value to stack
6CE5: 58      	        LD      E,B             ; Restore operator
6CE6: 51      	        LD      D,C             ; Restore precedence
6CE7: 4E      	        LD      C,(HL)          ; Get LSB of routine address
6CE8: 23      	        INC     HL
6CE9: 46      	        LD      B,(HL)          ; Get MSB of routine address
6CEA: 23      	        INC     HL
6CEB: C5      	        PUSH    BC              ; Save routine address
6CEC: 2AC580  	        LD      HL,(CUROPR)     ; Address of current operator
6CEF: C37E6C  	        JP      EVAL1           ; Loop until prec' break
              	
6CF2: AF      	OPRND:  XOR     A               ; Get operand routine
6CF3: 32AD80  	        LD      (TYPE),A        ; Set numeric expected
6CF6: CDFC67  	        CALL    GETCHR          ; Get next character
6CF9: 1E24    	        LD      E,MO            ; ?MO Error
6CFB: CAA863  	        JP      Z,ERROR         ; No operand - Error
6CFE: DA5277  	        JP      C,ASCTFP        ; Number - Get value
6D01: CD9A68  	        CALL    CHKLTR          ; See if a letter
6D04: D2596D  	        JP      NC,CONVAR       ; Letter - Find variable
6D07: FE26    	        CP		'&'				; &H = HEX, &B = BINARY
6D09: 2012    	        JR		NZ, NOTAMP
6D0B: CDFC67  	        CALL    GETCHR          ; Get next character
6D0E: FE48    	        CP      'H'             ; Hex number indicated? [function added]
6D10: CA967B  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
6D13: FE42    	        CP      'B'             ; Binary number indicated? [function added]
6D15: CA067C  	        JP      Z,BINTFP        ; Convert Bin to FPREG
6D18: 1E02    	        LD      E,SN            ; If neither then a ?SN Error
6D1A: CAA863  	        JP      Z,ERROR         ; 
6D1D: FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
6D1F: CAF26C  	        JP      Z,OPRND         ; Yes - Look for operand
6D22: FE2E    	        CP      '.'             ; '.' ?
6D24: CA5277  	        JP      Z,ASCTFP        ; Yes - Create FP number
6D27: FEAD    	        CP      ZMINUS          ; '-' Token ?
6D29: CA486D  	        JP      Z,MINUS         ; Yes - Do minus
6D2C: FE22    	        CP      '"'             ; Literal string ?
6D2E: CA0171  	        JP      Z,QTSTR         ; Get string terminated by '"'
6D31: FEAA    	        CP      ZNOT            ; "NOT" Token ?
6D33: CA3A6E  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
6D36: FEA7    	        CP      ZFN             ; "FN" Token ?
6D38: CA6570  	        JP      Z,DOFN          ; Yes - Do FN routine
6D3B: D6B6    	        SUB     ZSGN            ; Is it a function?
6D3D: D26A6D  	        JP      NC,FNOFST       ; Yes - Evaluate function
6D40: CD776C  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
6D43: CD6266  	        CALL    CHKSYN          ; Make sure ")" follows
6D46: 29      	        .BYTE   ")"
6D47: C9      	        RET
              	
6D48: 167D    	MINUS:  LD      D,7DH           ; '-' precedence
6D4A: CD7E6C  	        CALL    EVAL1           ; Evaluate until prec' break
6D4D: 2AD080  	        LD      HL,(NXTOPR)     ; Get next operator address
6D50: E5      	        PUSH    HL              ; Save next operator address
6D51: CD7476  	        CALL    INVSGN          ; Negate value
6D54: CD6C6C  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
6D57: E1      	        POP     HL              ; Restore next operator address
6D58: C9      	        RET
              	
6D59: CD5F6E  	CONVAR: CALL    GETVAR          ; Get variable address to DE
6D5C: E5      	FRMEVL: PUSH    HL              ; Save code string address
6D5D: EB      	        EX      DE,HL           ; Variable address to HL
6D5E: 22E480  	        LD      (FPREG),HL      ; Save address of variable
6D61: 3AAD80  	        LD      A,(TYPE)        ; Get type
6D64: B7      	        OR      A               ; Numeric?
6D65: CC8976  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
6D68: E1      	        POP     HL              ; Restore code string address
6D69: C9      	        RET
              	
6D6A: 0600    	FNOFST: LD      B,0             ; Get address of function
6D6C: 07      	        RLCA                    ; Double function offset
6D6D: 4F      	        LD      C,A             ; BC = Offset in function table
6D6E: C5      	        PUSH    BC              ; Save adjusted token value
6D6F: CDFC67  	        CALL    GETCHR          ; Get next character
6D72: 79      	        LD      A,C             ; Get adjusted token value
6D73: FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
6D75: DA916D  	        JP      C,FNVAL         ; No - Do function (if A<N got FNVAL)
6D78: CD776C  	        CALL    OPNPAR          ; Evaluate expression  (X,...
6D7B: CD6266  	        CALL    CHKSYN          ; Make sure ',' follows
6D7E: 2C      	        .BYTE      ','
6D7F: CD6D6C  	        CALL    TSTSTR          ; Make sure it's a string
6D82: EB      	        EX      DE,HL           ; Save code string address
6D83: 2AE480  	        LD      HL,(FPREG)      ; Get address of string
6D86: E3      	        EX      (SP),HL         ; Save address of string
6D87: E5      	        PUSH    HL              ; Save adjusted token value
6D88: EB      	        EX      DE,HL           ; Restore code string address
6D89: CDCA73  	        CALL    GETINT          ; Get integer 0-255
6D8C: EB      	        EX      DE,HL           ; Save code string address
6D8D: E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
6D8E: C3996D  	        JP      GOFUNC          ; Jump to string function
              	
6D91: CD406D  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
6D94: E3      	        EX      (SP),HL         ; HL = Adjusted token value
6D95: 11546D  	        LD      DE,RETNUM       ; Return number from function
6D98: D5      	        PUSH    DE              ; Save on stack
6D99: 01DA60  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
6D9C: 09      	        ADD     HL,BC           ; Point to right address
6D9D: 4E      	        LD      C,(HL)          ; Get LSB of address
6D9E: 23      	        INC     HL              ;
6D9F: 66      	        LD      H,(HL)          ; Get MSB of address
6DA0: 69      	        LD      L,C             ; Address to HL
6DA1: E9      	        JP      (HL)            ; Jump to function
              	
6DA2: 15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
6DA3: FEAD    	        CP      ZMINUS          ; '-' token ?
6DA5: C8      	        RET     Z               ; Yes - Return
6DA6: FE2D    	        CP      '-'             ; '-' ASCII ?
6DA8: C8      	        RET     Z               ; Yes - Return
6DA9: 14      	        INC     D               ; Inc to flag positive exponent
6DAA: FE2B    	        CP      '+'             ; '+' ASCII ?
6DAC: C8      	        RET     Z               ; Yes - Return
6DAD: FEAC    	        CP      ZPLUS           ; '+' token ?
6DAF: C8      	        RET     Z               ; Yes - Return
6DB0: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
6DB1: C9      	        RET                     ; Return "NZ"
              	
6DB2: F6      	POR:    .BYTE      0F6H            ; Flag "OR"
6DB3: AF      	PAND:   XOR     A               ; Flag "AND"
6DB4: F5      	        PUSH    AF              ; Save "AND" / "OR" flag
6DB5: CD6C6C  	        CALL    TSTNUM          ; Make sure it's a number
6DB8: CDAE68  	        CALL    DEINT           ; Get integer -32768 to 32767
6DBB: F1      	        POP     AF              ; Restore "AND" / "OR" flag
6DBC: EB      	        EX      DE,HL           ; <- Get last
6DBD: C1      	        POP     BC              ; <-  value
6DBE: E3      	        EX      (SP),HL         ; <-  from
6DBF: EB      	        EX      DE,HL           ; <-  stack
6DC0: CD8C76  	        CALL    FPBCDE          ; Move last value to FPREG
6DC3: F5      	        PUSH    AF              ; Save "AND" / "OR" flag
6DC4: CDAE68  	        CALL    DEINT           ; Get integer -32768 to 32767
6DC7: F1      	        POP     AF              ; Restore "AND" / "OR" flag
6DC8: C1      	        POP     BC              ; Get value
6DC9: 79      	        LD      A,C             ; Get LSB
6DCA: 212370  	        LD      HL,ACPASS       ; Address of save AC as current
6DCD: C2D56D  	        JP      NZ,POR1         ; Jump if OR
6DD0: A3      	        AND     E               ; "AND" LSBs
6DD1: 4F      	        LD      C,A             ; Save LSB
6DD2: 78      	        LD      A,B             ; Get MBS
6DD3: A2      	        AND     D               ; "AND" MSBs
6DD4: E9      	        JP      (HL)            ; Save AC as current (ACPASS)
              	
6DD5: B3      	POR1:   OR      E               ; "OR" LSBs
6DD6: 4F      	        LD      C,A             ; Save LSB
6DD7: 78      	        LD      A,B             ; Get MSB
6DD8: B2      	        OR      D               ; "OR" MSBs
6DD9: E9      	        JP      (HL)            ; Save AC as current (ACPASS)
              	
6DDA: 21EC6D  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
6DDD: 3AAD80  	        LD      A,(TYPE)        ; Get data type
6DE0: 1F      	        RRA                     ; Carry set = string
6DE1: 7A      	        LD      A,D             ; Get last precedence value
6DE2: 17      	        RLA                     ; Times 2 plus carry
6DE3: 5F      	        LD      E,A             ; To E
6DE4: 1664    	        LD      D,64H           ; Relational precedence
6DE6: 78      	        LD      A,B             ; Get current precedence
6DE7: BA      	        CP      D               ; Compare with last
6DE8: D0      	        RET     NC              ; Eval if last was rel' or log'
6DE9: C3DB6C  	        JP      STKTHS          ; Stack this one and get next
              	
6DEC: EE6D    	CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
6DEE: 79      	CMPLG1: LD      A,C             ; Get data type
6DEF: B7      	        OR      A
6DF0: 1F      	        RRA
6DF1: C1      	        POP     BC              ; Get last expression to BCDE
6DF2: D1      	        POP     DE
6DF3: F5      	        PUSH    AF              ; Save status
6DF4: CD6E6C  	        CALL    CHKTYP          ; Check that types match
6DF7: 21306E  	        LD      HL,CMPRES       ; Result to comparison
6DFA: E5      	        PUSH    HL              ; Save for RETurn
6DFB: CAC676  	        JP      Z,CMPNUM        ; Compare values if numeric
6DFE: AF      	        XOR     A               ; Compare two strings
6DFF: 32AD80  	        LD      (TYPE),A        ; Set type to numeric
6E02: D5      	        PUSH    DE              ; Save string name
6E03: CD8572  	        CALL    GSTRCU          ; Get current string
6E06: 7E      	        LD      A,(HL)          ; Get length of string
6E07: 23      	        INC     HL
6E08: 23      	        INC     HL
6E09: 4E      	        LD      C,(HL)          ; Get LSB of address
6E0A: 23      	        INC     HL
6E0B: 46      	        LD      B,(HL)          ; Get MSB of address
6E0C: D1      	        POP     DE              ; Restore string name
6E0D: C5      	        PUSH    BC              ; Save address of string
6E0E: F5      	        PUSH    AF              ; Save length of string
6E0F: CD8972  	        CALL    GSTRDE          ; Get second string
6E12: CD9A76  	        CALL    LOADFP          ; Get address of second string
6E15: F1      	        POP     AF              ; Restore length of string 1
6E16: 57      	        LD      D,A             ; Length to D
6E17: E1      	        POP     HL              ; Restore address of string 1
6E18: 7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
6E19: B2      	        OR      D               ; Bytes of string 1 to do
6E1A: C8      	        RET     Z               ; Exit if all bytes compared
6E1B: 7A      	        LD      A,D             ; Get bytes of string 1 to do
6E1C: D601    	        SUB     1
6E1E: D8      	        RET     C               ; Exit if end of string 1
6E1F: AF      	        XOR     A
6E20: BB      	        CP      E               ; Bytes of string 2 to do
6E21: 3C      	        INC     A
6E22: D0      	        RET     NC              ; Exit if end of string 2
6E23: 15      	        DEC     D               ; Count bytes in string 1
6E24: 1D      	        DEC     E               ; Count bytes in string 2
6E25: 0A      	        LD      A,(BC)          ; Byte in string 2
6E26: BE      	        CP      (HL)            ; Compare to byte in string 1
6E27: 23      	        INC     HL              ; Move up string 1
6E28: 03      	        INC     BC              ; Move up string 2
6E29: CA186E  	        JP      Z,CMPSTR        ; Same - Try next bytes
6E2C: 3F      	        CCF                     ; Flag difference (">" or "<")
6E2D: C35676  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
6E30: 3C      	CMPRES: INC     A               ; Increment current value
6E31: 8F      	        ADC     A,A             ; Double plus carry
6E32: C1      	        POP     BC              ; Get other value
6E33: A0      	        AND     B               ; Combine them
6E34: C6FF    	        ADD     A,-1            ; Carry set if different
6E36: 9F      	        SBC     A,A             ; 00 - Equal , FF - Different
6E37: C35D76  	        JP      FLGREL          ; Set current value & continue
              	
6E3A: 165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
6E3C: CD7E6C  	        CALL    EVAL1           ; Eval until precedence break
6E3F: CD6C6C  	        CALL    TSTNUM          ; Make sure it's a number
6E42: CDAE68  	        CALL    DEINT           ; Get integer -32768 - 32767
6E45: 7B      	        LD      A,E             ; Get LSB
6E46: 2F      	        CPL                     ; Invert LSB
6E47: 4F      	        LD      C,A             ; Save "NOT" of LSB
6E48: 7A      	        LD      A,D             ; Get MSB
6E49: 2F      	        CPL                     ; Invert MSB
6E4A: CD2370  	        CALL    ACPASS          ; Save AC as current
6E4D: C1      	        POP     BC              ; Clean up stack
6E4E: C38A6C  	        JP      EVAL3           ; Continue evaluation
              	
6E51: 2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
6E52: CDFC67  	        CALL    GETCHR          ; Get next character
6E55: C8      	        RET     Z               ; End of DIM statement
6E56: CD6266  	        CALL    CHKSYN          ; Make sure ',' follows
6E59: 2C      	        .BYTE      ','
6E5A: 01516E  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
6E5D: C5      	        PUSH    BC              ; Save on stack
6E5E: F6      	        .BYTE      0F6H            ; Flag "Create" variable
6E5F: AF      	GETVAR: XOR     A               ; Find variable address,to DE
6E60: 32AC80  	        LD      (LCRFLG),A      ; Set locate / create flag
6E63: 46      	        LD      B,(HL)          ; Get First byte of name
6E64: CD9A68  	GTFNAM: CALL    CHKLTR          ; See if a letter
6E67: DA9463  	        JP      C,SNERR         ; ?SN Error if not a letter
6E6A: AF      	        XOR     A
6E6B: 4F      	        LD      C,A             ; Clear second byte of name
6E6C: 32AD80  	        LD      (TYPE),A        ; Set type to numeric
6E6F: CDFC67  	        CALL    GETCHR          ; Get next character
6E72: DA7B6E  	        JP      C,SVNAM2        ; Numeric - Save in name
6E75: CD9A68  	        CALL    CHKLTR          ; See if a letter
6E78: DA886E  	        JP      C,CHARTY        ; Not a letter - Check type
6E7B: 4F      	SVNAM2: LD      C,A             ; Save second byte of name
6E7C: CDFC67  	ENDNAM: CALL    GETCHR          ; Get next character
6E7F: DA7C6E  	        JP      C,ENDNAM        ; Numeric - Get another
6E82: CD9A68  	        CALL    CHKLTR          ; See if a letter
6E85: D27C6E  	        JP      NC,ENDNAM       ; Letter - Get another
6E88: D624    	CHARTY: SUB     '$'             ; String variable?
6E8A: C2976E  	        JP      NZ,NOTSTR       ; No - Numeric variable
6E8D: 3C      	        INC     A               ; A = 1 (string type)
6E8E: 32AD80  	        LD      (TYPE),A        ; Set type to string
6E91: 0F      	        RRCA                    ; A = 80H , Flag for string
6E92: 81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
6E93: 4F      	        LD      C,A             ; Resave second byte on name
6E94: CDFC67  	        CALL    GETCHR          ; Get next character
6E97: 3ACB80  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
6E9A: 3D      	        DEC     A
6E9B: CA446F  	        JP      Z,ARLDSV        ; Yes - Get array name
6E9E: F2A76E  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
6EA1: 7E      	        LD      A,(HL)          ; Get byte again
6EA2: D628    	        SUB     '('             ; Subscripted variable?
6EA4: CA1C6F  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
              	
6EA7: AF      	NSCFOR: XOR     A               ; Simple variable
6EA8: 32CB80  	        LD      (FORFLG),A      ; Clear "FOR" flag
6EAB: E5      	        PUSH    HL              ; Save code string address
6EAC: 50      	        LD      D,B             ; DE = Variable name to find
6EAD: 59      	        LD      E,C
6EAE: 2ADE80  	        LD      HL,(FNRGNM)     ; FN argument name
6EB1: CD5C66  	        CALL    CPDEHL          ; Is it the FN argument?
6EB4: 11E080  	        LD      DE,FNARG        ; Point to argument value
6EB7: CA8C75  	        JP      Z,POPHRT        ; Yes - Return FN argument value
6EBA: 2AD880  	        LD      HL,(VAREND)     ; End of variables
6EBD: EB      	        EX      DE,HL           ; Address of end of search
6EBE: 2AD680  	        LD      HL,(PROGND)     ; Start of variables address
6EC1: CD5C66  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
6EC4: CADA6E  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
6EC7: 79      	        LD      A,C             ; Get second byte of name
6EC8: 96      	        SUB     (HL)            ; Compare with name in list
6EC9: 23      	        INC     HL              ; Move on to first byte
6ECA: C2CF6E  	        JP      NZ,FNTHR        ; Different - Find another
6ECD: 78      	        LD      A,B             ; Get first byte of name
6ECE: 96      	        SUB     (HL)            ; Compare with name in list
6ECF: 23      	FNTHR:  INC     HL              ; Move on to LSB of value
6ED0: CA0E6F  	        JP      Z,RETADR        ; Found - Return address
6ED3: 23      	        INC     HL              ; <- Skip
6ED4: 23      	        INC     HL              ; <- over
6ED5: 23      	        INC     HL              ; <- F.P.
6ED6: 23      	        INC     HL              ; <- value
6ED7: C3C16E  	        JP      FNDVAR          ; Keep looking
              	
6EDA: E1      	CFEVAL: POP     HL              ; Restore code string address
6EDB: E3      	        EX      (SP),HL         ; Get return address
6EDC: D5      	        PUSH    DE              ; Save address of variable
6EDD: 115C6D  	        LD      DE,FRMEVL       ; Return address in EVAL
6EE0: CD5C66  	        CALL    CPDEHL          ; Called from EVAL ?
6EE3: D1      	        POP     DE              ; Restore address of variable
6EE4: CA116F  	        JP      Z,RETNUL        ; Yes - Return null variable
6EE7: E3      	        EX      (SP),HL         ; Put back return
6EE8: E5      	        PUSH    HL              ; Save code string address
6EE9: C5      	        PUSH    BC              ; Save variable name
6EEA: 010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
6EED: 2ADA80  	        LD      HL,(ARREND)     ; End of arrays
6EF0: E5      	        PUSH    HL              ; Save end of arrays
6EF1: 09      	        ADD     HL,BC           ; Move up 6 bytes
6EF2: C1      	        POP     BC              ; Source address in BC
6EF3: E5      	        PUSH    HL              ; Save new end address
6EF4: CD6063  	        CALL    MOVUP           ; Move arrays up
6EF7: E1      	        POP     HL              ; Restore new end address
6EF8: 22DA80  	        LD      (ARREND),HL     ; Set new end address
6EFB: 60      	        LD      H,B             ; End of variables to HL
6EFC: 69      	        LD      L,C
6EFD: 22D880  	        LD      (VAREND),HL     ; Set new end address
              	
6F00: 2B      	ZEROLP: DEC     HL              ; Back through to zero variable
6F01: 3600    	        LD      (HL),0          ; Zero byte in variable
6F03: CD5C66  	        CALL    CPDEHL          ; Done them all?
6F06: C2006F  	        JP      NZ,ZEROLP       ; No - Keep on going
6F09: D1      	        POP     DE              ; Get variable name
6F0A: 73      	        LD      (HL),E          ; Store second character
6F0B: 23      	        INC     HL
6F0C: 72      	        LD      (HL),D          ; Store first character
6F0D: 23      	        INC     HL
6F0E: EB      	RETADR: EX      DE,HL           ; Address of variable in DE
6F0F: E1      	        POP     HL              ; Restore code string address
6F10: C9      	        RET
              	
6F11: 32E780  	RETNUL: LD      (FPEXP),A       ; Set result to zero
6F14: 213063  	        LD      HL,ZERBYT       ; Also set a null string
6F17: 22E480  	        LD      (FPREG),HL      ; Save for EVAL
6F1A: E1      	        POP     HL              ; Restore code string address
6F1B: C9      	        RET
              	
6F1C: E5      	SBSCPT: PUSH    HL              ; Save code string address
6F1D: 2AAC80  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
6F20: E3      	        EX      (SP),HL         ; Save and get code string
6F21: 57      	        LD      D,A             ; Zero number of dimensions
6F22: D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
6F23: C5      	        PUSH    BC              ; Save array name
6F24: CDA268  	        CALL    FPSINT          ; Get subscript (0-32767)
6F27: C1      	        POP     BC              ; Restore array name
6F28: F1      	        POP     AF              ; Get number of dimensions
6F29: EB      	        EX      DE,HL
6F2A: E3      	        EX      (SP),HL         ; Save subscript value
6F2B: E5      	        PUSH    HL              ; Save LCRFLG and TYPE
6F2C: EB      	        EX      DE,HL
6F2D: 3C      	        INC     A               ; Count dimensions
6F2E: 57      	        LD      D,A             ; Save in D
6F2F: 7E      	        LD      A,(HL)          ; Get next byte in code string
6F30: FE2C    	        CP      ','             ; Comma (more to come)?
6F32: CA226F  	        JP      Z,SCPTLP        ; Yes - More subscripts
6F35: CD6266  	        CALL    CHKSYN          ; Make sure ")" follows
6F38: 29      	        .BYTE      ")"
6F39: 22D080  	        LD      (NXTOPR),HL     ; Save code string address
6F3C: E1      	        POP     HL              ; Get LCRFLG and TYPE
6F3D: 22AC80  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
6F40: 1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
6F42: D5      	        PUSH    DE              ; Save number of dimensions (D)
6F43: 11      	        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
              	
6F44: E5      	ARLDSV: PUSH    HL              ; Save code string address
6F45: F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
6F46: 2AD880  	        LD      HL,(VAREND)     ; Start of arrays
6F49: 3E      	        .BYTE      3EH             ; Skip "ADD HL,DE"
6F4A: 19      	FNDARY: ADD     HL,DE           ; Move to next array start
6F4B: EB      	        EX      DE,HL
6F4C: 2ADA80  	        LD      HL,(ARREND)     ; End of arrays
6F4F: EB      	        EX      DE,HL           ; Current array pointer
6F50: CD5C66  	        CALL    CPDEHL          ; End of arrays found?
6F53: CA7C6F  	        JP      Z,CREARY        ; Yes - Create array
6F56: 7E      	        LD      A,(HL)          ; Get second byte of name
6F57: B9      	        CP      C               ; Compare with name given
6F58: 23      	        INC     HL              ; Move on
6F59: C25E6F  	        JP      NZ,NXTARY       ; Different - Find next array
6F5C: 7E      	        LD      A,(HL)          ; Get first byte of name
6F5D: B8      	        CP      B               ; Compare with name given
6F5E: 23      	NXTARY: INC     HL              ; Move on
6F5F: 5E      	        LD      E,(HL)          ; Get LSB of next array address
6F60: 23      	        INC     HL
6F61: 56      	        LD      D,(HL)          ; Get MSB of next array address
6F62: 23      	        INC     HL
6F63: C24A6F  	        JP      NZ,FNDARY       ; Not found - Keep looking
6F66: 3AAC80  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
6F69: B7      	        OR      A
6F6A: C29D63  	        JP      NZ,DDERR        ; Create - ?DD Error
6F6D: F1      	        POP     AF              ; Locate - Get number of dim'ns
6F6E: 44      	        LD      B,H             ; BC Points to array dim'ns
6F6F: 4D      	        LD      C,L
6F70: CA8C75  	        JP      Z,POPHRT        ; Jump if array load/save
6F73: 96      	        SUB     (HL)            ; Same number of dimensions?
6F74: CADA6F  	        JP      Z,FINDEL        ; Yes - Find element
6F77: 1E10    	BSERR:  LD      E,BS            ; ?BS Error
6F79: C3A863  	        JP      ERROR           ; Output error
              	
6F7C: 110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
6F7F: F1      	        POP     AF              ; Array to save or 0 dim'ns?
6F80: CAC368  	        JP      Z,FCERR         ; Yes - ?FC Error
6F83: 71      	        LD      (HL),C          ; Save second byte of name
6F84: 23      	        INC     HL
6F85: 70      	        LD      (HL),B          ; Save first byte of name
6F86: 23      	        INC     HL
6F87: 4F      	        LD      C,A             ; Number of dimensions to C
6F88: CD7163  	        CALL    CHKSTK          ; Check if enough memory
6F8B: 23      	        INC     HL              ; Point to number of dimensions
6F8C: 23      	        INC     HL
6F8D: 22C580  	        LD      (CUROPR),HL     ; Save address of pointer
6F90: 71      	        LD      (HL),C          ; Set number of dimensions
6F91: 23      	        INC     HL
6F92: 3AAC80  	        LD      A,(LCRFLG)      ; Locate of Create?
6F95: 17      	        RLA                     ; Carry set = Create
6F96: 79      	        LD      A,C             ; Get number of dimensions
6F97: 010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
6F9A: D29F6F  	        JP      NC,DEFSIZ       ; Locate - Set default size
6F9D: C1      	        POP     BC              ; Get specified dimension size
6F9E: 03      	        INC     BC              ; Include zero element
6F9F: 71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
6FA0: 23      	        INC     HL
6FA1: 70      	        LD      (HL),B          ; Save MSB of dimension size
6FA2: 23      	        INC     HL
6FA3: F5      	        PUSH    AF              ; Save num' of dim'ns an status
6FA4: E5      	        PUSH    HL              ; Save address of dim'n size
6FA5: CD3777  	        CALL    MLDEBC          ; Multiply DE by BC to find
6FA8: EB      	        EX      DE,HL           ; amount of mem needed (to DE)
6FA9: E1      	        POP     HL              ; Restore address of dimension
6FAA: F1      	        POP     AF              ; Restore number of dimensions
6FAB: 3D      	        DEC     A               ; Count them
6FAC: C2976F  	        JP      NZ,CRARLP       ; Do next dimension if more
6FAF: F5      	        PUSH    AF              ; Save locate/create flag
6FB0: 42      	        LD      B,D             ; MSB of memory needed
6FB1: 4B      	        LD      C,E             ; LSB of memory needed
6FB2: EB      	        EX      DE,HL
6FB3: 19      	        ADD     HL,DE           ; Add bytes to array start
6FB4: DA8963  	        JP      C,OMERR         ; Too big - Error
6FB7: CD7A63  	        CALL    ENFMEM          ; See if enough memory
6FBA: 22DA80  	        LD      (ARREND),HL     ; Save new end of array
              	
6FBD: 2B      	ZERARY: DEC     HL              ; Back through array data
6FBE: 3600    	        LD      (HL),0          ; Set array element to zero
6FC0: CD5C66  	        CALL    CPDEHL          ; All elements zeroed?
6FC3: C2BD6F  	        JP      NZ,ZERARY       ; No - Keep on going
6FC6: 03      	        INC     BC              ; Number of bytes + 1
6FC7: 57      	        LD      D,A             ; A=0
6FC8: 2AC580  	        LD      HL,(CUROPR)     ; Get address of array
6FCB: 5E      	        LD      E,(HL)          ; Number of dimensions
6FCC: EB      	        EX      DE,HL           ; To HL
6FCD: 29      	        ADD     HL,HL           ; Two bytes per dimension size
6FCE: 09      	        ADD     HL,BC           ; Add number of bytes
6FCF: EB      	        EX      DE,HL           ; Bytes needed to DE
6FD0: 2B      	        DEC     HL
6FD1: 2B      	        DEC     HL
6FD2: 73      	        LD      (HL),E          ; Save LSB of bytes needed
6FD3: 23      	        INC     HL
6FD4: 72      	        LD      (HL),D          ; Save MSB of bytes needed
6FD5: 23      	        INC     HL
6FD6: F1      	        POP     AF              ; Locate / Create?
6FD7: DAFE6F  	        JP      C,ENDDIM        ; A is 0 , End if create
6FDA: 47      	FINDEL: LD      B,A             ; Find array element
6FDB: 4F      	        LD      C,A
6FDC: 7E      	        LD      A,(HL)          ; Number of dimensions
6FDD: 23      	        INC     HL
6FDE: 16      	        .BYTE      16H             ; Skip "POP HL"
6FDF: E1      	FNDELP: POP     HL              ; Address of next dim' size
6FE0: 5E      	        LD      E,(HL)          ; Get LSB of dim'n size
6FE1: 23      	        INC     HL
6FE2: 56      	        LD      D,(HL)          ; Get MSB of dim'n size
6FE3: 23      	        INC     HL
6FE4: E3      	        EX      (SP),HL         ; Save address - Get index
6FE5: F5      	        PUSH    AF              ; Save number of dim'ns
6FE6: CD5C66  	        CALL    CPDEHL          ; Dimension too large?
6FE9: D2776F  	        JP      NC,BSERR        ; Yes - ?BS Error
6FEC: E5      	        PUSH    HL              ; Save index
6FED: CD3777  	        CALL    MLDEBC          ; Multiply previous by size
6FF0: D1      	        POP     DE              ; Index supplied to DE
6FF1: 19      	        ADD     HL,DE           ; Add index to pointer
6FF2: F1      	        POP     AF              ; Number of dimensions
6FF3: 3D      	        DEC     A               ; Count them
6FF4: 44      	        LD      B,H             ; MSB of pointer
6FF5: 4D      	        LD      C,L             ; LSB of pointer
6FF6: C2DF6F  	        JP      NZ,FNDELP       ; More - Keep going
6FF9: 29      	        ADD     HL,HL           ; 4 Bytes per element
6FFA: 29      	        ADD     HL,HL
6FFB: C1      	        POP     BC              ; Start of array
6FFC: 09      	        ADD     HL,BC           ; Point to element
6FFD: EB      	        EX      DE,HL           ; Address of element to DE
6FFE: 2AD080  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
7001: C9      	        RET
              	
7002: 2ADA80  	FRE:    LD      HL,(ARREND)     ; Start of free memory
7005: EB      	        EX      DE,HL           ; To DE
7006: 210000  	        LD      HL,0            ; End of free memory
7009: 39      	        ADD     HL,SP           ; Current stack value
700A: 3AAD80  	        LD      A,(TYPE)        ; Dummy argument type
700D: B7      	        OR      A
700E: CA1E70  	        JP      Z,FRENUM        ; Numeric - Free variable space
7011: CD8572  	        CALL    GSTRCU          ; Current string to pool
7014: CD8571  	        CALL    GARBGE          ; Garbage collection
7017: 2A5A80  	        LD      HL,(STRSPC)     ; Bottom of string space in use
701A: EB      	        EX      DE,HL           ; To DE
701B: 2AC380  	        LD      HL,(STRBOT)     ; Bottom of string space
701E: 7D      	FRENUM: LD      A,L             ; Get LSB of end
701F: 93      	        SUB     E               ; Subtract LSB of beginning
7020: 4F      	        LD      C,A             ; Save difference if C
7021: 7C      	        LD      A,H             ; Get MSB of end
7022: 9A      	        SBC     A,D             ; Subtract MSB of beginning
7023: 41      	ACPASS: LD      B,C             ; Return integer AC
7024: 50      	ABPASS: LD      D,B             ; Return integer AB
7025: 1E00    	        LD      E,0
7027: 21AD80  	        LD      HL,TYPE         ; Point to type
702A: 73      	        LD      (HL),E          ; Set type to numeric
702B: 0690    	        LD      B,80H+16        ; 16 bit integer
702D: C36276  	        JP      RETINT          ; Return the integr
              	
7030: 3AAB80  	POS:    LD      A,(CURPOS)      ; Get cursor position
7033: 47      	PASSA:  LD      B,A             ; Put A into AB
7034: AF      	        XOR     A               ; Zero A
7035: C32470  	        JP      ABPASS          ; Return integer AB
              	
7038: CDBB70  	DEF:    CALL    CHEKFN          ; Get "FN" and name
703B: CDAD70  	        CALL    IDTEST          ; Test for illegal direct
703E: 019369  	        LD      BC,DATA         ; To get next statement
7041: C5      	        PUSH    BC              ; Save address for RETurn
7042: D5      	        PUSH    DE              ; Save address of function ptr
7043: CD6266  	        CALL    CHKSYN          ; Make sure "(" follows
7046: 28      	        .BYTE      "("
7047: CD5F6E  	        CALL    GETVAR          ; Get argument variable name
704A: E5      	        PUSH    HL              ; Save code string address
704B: EB      	        EX      DE,HL           ; Argument address to HL
704C: 2B      	        DEC     HL
704D: 56      	        LD      D,(HL)          ; Get first byte of arg name
704E: 2B      	        DEC     HL
704F: 5E      	        LD      E,(HL)          ; Get second byte of arg name
7050: E1      	        POP     HL              ; Restore code string address
7051: CD6C6C  	        CALL    TSTNUM          ; Make sure numeric argument
7054: CD6266  	        CALL    CHKSYN          ; Make sure ")" follows
7057: 29      	        .BYTE      ")"
7058: CD6266  	        CALL    CHKSYN          ; Make sure "=" follows
705B: B4      	        .BYTE      ZEQUAL          ; "=" token
705C: 44      	        LD      B,H             ; Code string address to BC
705D: 4D      	        LD      C,L
705E: E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
705F: 71      	        LD      (HL),C          ; Save LSB of FN code string
7060: 23      	        INC     HL
7061: 70      	        LD      (HL),B          ; Save MSB of FN code string
7062: C3FA70  	        JP      SVSTAD          ; Save address and do function
              	
7065: CDBB70  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
7068: D5      	        PUSH    DE              ; Save function pointer address
7069: CD406D  	        CALL    EVLPAR          ; Evaluate expression in "()"
706C: CD6C6C  	        CALL    TSTNUM          ; Make sure numeric result
706F: E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
7070: 5E      	        LD      E,(HL)          ; Get LSB of FN code string
7071: 23      	        INC     HL
7072: 56      	        LD      D,(HL)          ; Get MSB of FN code string
7073: 23      	        INC     HL
7074: 7A      	        LD      A,D             ; And function DEFined?
7075: B3      	        OR      E
7076: CAA063  	        JP      Z,UFERR         ; No - ?UF Error
7079: 7E      	        LD      A,(HL)          ; Get LSB of argument address
707A: 23      	        INC     HL
707B: 66      	        LD      H,(HL)          ; Get MSB of argument address
707C: 6F      	        LD      L,A             ; HL = Arg variable address
707D: E5      	        PUSH    HL              ; Save it
707E: 2ADE80  	        LD      HL,(FNRGNM)     ; Get old argument name
7081: E3      	        EX      (SP),HL ;       ; Save old , Get new
7082: 22DE80  	        LD      (FNRGNM),HL     ; Set new argument name
7085: 2AE280  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
7088: E5      	        PUSH    HL              ; Save it
7089: 2AE080  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
708C: E5      	        PUSH    HL              ; Save it
708D: 21E080  	        LD      HL,FNARG        ; HL = Value of argument
7090: D5      	        PUSH    DE              ; Save FN code string address
7091: CDA376  	        CALL    FPTHL           ; Move FPREG to argument
7094: E1      	        POP     HL              ; Get FN code string address
7095: CD696C  	        CALL    GETNUM          ; Get value from function
7098: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
7099: CDFC67  	        CALL    GETCHR          ; Get next character
709C: C29463  	        JP      NZ,SNERR        ; Bad character in FN - Error
709F: E1      	        POP     HL              ; Get MSB,EXP of old arg
70A0: 22E080  	        LD      (FNARG),HL      ; Restore it
70A3: E1      	        POP     HL              ; Get LSB,NLSB of old arg
70A4: 22E280  	        LD      (FNARG+2),HL    ; Restore it
70A7: E1      	        POP     HL              ; Get name of old arg
70A8: 22DE80  	        LD      (FNRGNM),HL     ; Restore it
70AB: E1      	        POP     HL              ; Restore code string address
70AC: C9      	        RET
              	
70AD: E5      	IDTEST: PUSH    HL              ; Save code string address
70AE: 2A5C80  	        LD      HL,(LINEAT)     ; Get current line number
70B1: 23      	        INC     HL              ; -1 means direct statement
70B2: 7C      	        LD      A,H
70B3: B5      	        OR      L
70B4: E1      	        POP     HL              ; Restore code string address
70B5: C0      	        RET     NZ              ; Return if in program
70B6: 1E16    	        LD      E,ID            ; ?ID Error
70B8: C3A863  	        JP      ERROR
              	
70BB: CD6266  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
70BE: A7      	        .BYTE      ZFN             ; "FN" token
70BF: 3E80    	        LD      A,80H
70C1: 32CB80  	        LD      (FORFLG),A      ; Flag FN name to find
70C4: B6      	        OR      (HL)            ; FN name has bit 7 set
70C5: 47      	        LD      B,A             ; in first byte of name
70C6: CD646E  	        CALL    GTFNAM          ; Get FN name
70C9: C36C6C  	        JP      TSTNUM          ; Make sure numeric function
              	
70CC: CD6C6C  	STR:    CALL    TSTNUM          ; Make sure it's a number
70CF: CDF077  	        CALL    NUMASC          ; Turn number into text
70D2: CD0071  	STR1:   CALL    CRTST           ; Create string entry for it
70D5: CD8572  	        CALL    GSTRCU          ; Current string to pool
70D8: 01E072  	        LD      BC,TOPOOL       ; Save in string pool
70DB: C5      	        PUSH    BC              ; Save address on stack
              	
70DC: 7E      	SAVSTR: LD      A,(HL)          ; Get string length
70DD: 23      	        INC     HL
70DE: 23      	        INC     HL
70DF: E5      	        PUSH    HL              ; Save pointer to string
70E0: CD5B71  	        CALL    TESTR           ; See if enough string space
70E3: E1      	        POP     HL              ; Restore pointer to string
70E4: 4E      	        LD      C,(HL)          ; Get LSB of address
70E5: 23      	        INC     HL
70E6: 46      	        LD      B,(HL)          ; Get MSB of address
70E7: CDF470  	        CALL    CRTMST          ; Create string entry
70EA: E5      	        PUSH    HL              ; Save pointer to MSB of addr
70EB: 6F      	        LD      L,A             ; Length of string
70EC: CD7872  	        CALL    TOSTRA          ; Move to string area
70EF: D1      	        POP     DE              ; Restore pointer to MSB
70F0: C9      	        RET
              	
70F1: CD5B71  	MKTMST: CALL    TESTR           ; See if enough string space
70F4: 21BF80  	CRTMST: LD      HL,TMPSTR       ; Temporary string
70F7: E5      	        PUSH    HL              ; Save it
70F8: 77      	        LD      (HL),A          ; Save length of string
70F9: 23      	        INC     HL
70FA: 23      	SVSTAD: INC     HL
70FB: 73      	        LD      (HL),E          ; Save LSB of address
70FC: 23      	        INC     HL
70FD: 72      	        LD      (HL),D          ; Save MSB of address
70FE: E1      	        POP     HL              ; Restore pointer
70FF: C9      	        RET
              	
7100: 2B      	CRTST:  DEC     HL              ; DEC - INCed after
7101: 0622    	QTSTR:  LD      B,'"'           ; Terminating quote "
7103: 50      	        LD      D,B             ; Quote to D
7104: E5      	DTSTR:  PUSH    HL              ; Save start
7105: 0EFF    	        LD      C,-1            ; Set counter to -1
7107: 23      	QTSTLP: INC     HL              ; Move on
7108: 7E      	        LD      A,(HL)          ; Get byte
7109: 0C      	        INC     C               ; Count bytes
710A: B7      	        OR      A               ; End of line?
710B: CA1671  	        JP      Z,CRTSTE        ; Yes - Create string entry
710E: BA      	        CP      D               ; Terminator D found?
710F: CA1671  	        JP      Z,CRTSTE        ; Yes - Create string entry
7112: B8      	        CP      B               ; Terminator B found?
7113: C20771  	        JP      NZ,QTSTLP       ; No - Keep looking
7116: FE22    	CRTSTE: CP      '"'             ; End with '"'?
7118: CCFC67  	        CALL    Z,GETCHR        ; Yes - Get next character
711B: E3      	        EX      (SP),HL         ; Starting quote
711C: 23      	        INC     HL              ; First byte of string
711D: EB      	        EX      DE,HL           ; To DE
711E: 79      	        LD      A,C             ; Get length
711F: CDF470  	        CALL    CRTMST          ; Create string entry
7122: 11BF80  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
7125: 2AB180  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
7128: 22E480  	        LD      (FPREG),HL      ; Save address of string ptr
712B: 3E01    	        LD      A,1
712D: 32AD80  	        LD      (TYPE),A        ; Set type to string
7130: CDA676  	        CALL    DETHL4          ; Move string to pool
7133: CD5C66  	        CALL    CPDEHL          ; Out of string pool?
7136: 22B180  	        LD      (TMSTPT),HL     ; Save new pointer
7139: E1      	        POP     HL              ; Restore code string address
713A: 7E      	        LD      A,(HL)          ; Get next code byte
713B: C0      	        RET     NZ              ; Return if pool OK
713C: 1E1E    	        LD      E,ST            ; ?ST Error
713E: C3A863  	        JP      ERROR           ; String pool overflow
              	
7141: 23      	PRNUMS: INC     HL              ; Skip leading space
7142: CD0071  	PRS:    CALL    CRTST           ; Create string entry for it
7145: CD8572  	PRS1:   CALL    GSTRCU          ; Current string to pool
7148: CD9A76  	        CALL    LOADFP          ; Move string block to BCDE
714B: 1C      	        INC     E               ; Length + 1
714C: 1D      	PRSLP:  DEC     E               ; Count characters
714D: C8      	        RET     Z               ; End of string
714E: 0A      	        LD      A,(BC)          ; Get byte to output
714F: CD6D66  	        CALL    OUTC            ; Output character in A
7152: FE0D    	        CP      CR              ; Return?
7154: CCAE6A  	        CALL    Z,DONULL        ; Yes - Do nulls
7157: 03      	        INC     BC              ; Next byte in string
7158: C34C71  	        JP      PRSLP           ; More characters to output
              	
715B: B7      	TESTR:  OR      A               ; Test if enough room
715C: 0E      	        .BYTE      0EH             ; No garbage collection done
715D: F1      	GRBDON: POP     AF              ; Garbage collection done
715E: F5      	        PUSH    AF              ; Save status
715F: 2A5A80  	        LD      HL,(STRSPC)     ; Bottom of string space in use
7162: EB      	        EX      DE,HL           ; To DE
7163: 2AC380  	        LD      HL,(STRBOT)     ; Bottom of string area
7166: 2F      	        CPL                     ; Negate length (Top down)
7167: 4F      	        LD      C,A             ; -Length to BC
7168: 06FF    	        LD      B,-1            ; BC = -ve length of string
716A: 09      	        ADD     HL,BC           ; Add to bottom of space in use
716B: 23      	        INC     HL              ; Plus one for 2's complement
716C: CD5C66  	        CALL    CPDEHL          ; Below string RAM area?
716F: DA7971  	        JP      C,TESTOS        ; Tidy up if not done else err
7172: 22C380  	        LD      (STRBOT),HL     ; Save new bottom of area
7175: 23      	        INC     HL              ; Point to first byte of string
7176: EB      	        EX      DE,HL           ; Address to DE
7177: F1      	POPAF:  POP     AF              ; Throw away status push
7178: C9      	        RET
              	
7179: F1      	TESTOS: POP     AF              ; Garbage collect been done?
717A: 1E1A    	        LD      E,OS            ; ?OS Error
717C: CAA863  	        JP      Z,ERROR         ; Yes - Not enough string apace
717F: BF      	        CP      A               ; Flag garbage collect done
7180: F5      	        PUSH    AF              ; Save status
7181: 015D71  	        LD      BC,GRBDON       ; Garbage collection done
7184: C5      	        PUSH    BC              ; Save for RETurn
7185: 2AAF80  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
7188: 22C380  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
718B: 210000  	        LD      HL,0
718E: E5      	        PUSH    HL              ; Flag no string found
718F: 2A5A80  	        LD      HL,(STRSPC)     ; Get bottom of string space
7192: E5      	        PUSH    HL              ; Save bottom of string space
7193: 21B380  	        LD      HL,TMSTPL       ; Temporary string pool
7196: EB      	GRBLP:  EX      DE,HL
7197: 2AB180  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
719A: EB      	        EX      DE,HL
719B: CD5C66  	        CALL    CPDEHL          ; Temporary string pool done?
719E: 019671  	        LD      BC,GRBLP        ; Loop until string pool done
71A1: C2EA71  	        JP      NZ,STPOOL       ; No - See if in string area
71A4: 2AD680  	        LD      HL,(PROGND)     ; Start of simple variables
71A7: EB      	SMPVAR: EX      DE,HL
71A8: 2AD880  	        LD      HL,(VAREND)     ; End of simple variables
71AB: EB      	        EX      DE,HL
71AC: CD5C66  	        CALL    CPDEHL          ; All simple strings done?
71AF: CABD71  	        JP      Z,ARRLP         ; Yes - Do string arrays
71B2: 7E      	        LD      A,(HL)          ; Get type of variable
71B3: 23      	        INC     HL
71B4: 23      	        INC     HL
71B5: B7      	        OR      A               ; "S" flag set if string
71B6: CDED71  	        CALL    STRADD          ; See if string in string area
71B9: C3A771  	        JP      SMPVAR          ; Loop until simple ones done
              	
71BC: C1      	GNXARY: POP     BC              ; Scrap address of this array
71BD: EB      	ARRLP:  EX      DE,HL
71BE: 2ADA80  	        LD      HL,(ARREND)     ; End of string arrays
71C1: EB      	        EX      DE,HL
71C2: CD5C66  	        CALL    CPDEHL          ; All string arrays done?
71C5: CA1372  	        JP      Z,SCNEND        ; Yes - Move string if found
71C8: CD9A76  	        CALL    LOADFP          ; Get array name to BCDE
71CB: 7B      	        LD      A,E             ; Get type of array     
71CC: E5      	        PUSH    HL              ; Save address of num of dim'ns
71CD: 09      	        ADD     HL,BC           ; Start of next array
71CE: B7      	        OR      A               ; Test type of array
71CF: F2BC71  	        JP      P,GNXARY        ; Numeric array - Ignore it
71D2: 22C580  	        LD      (CUROPR),HL     ; Save address of next array
71D5: E1      	        POP     HL              ; Get address of num of dim'ns
71D6: 4E      	        LD      C,(HL)          ; BC = Number of dimensions
71D7: 0600    	        LD      B,0
71D9: 09      	        ADD     HL,BC           ; Two bytes per dimension size
71DA: 09      	        ADD     HL,BC
71DB: 23      	        INC     HL              ; Plus one for number of dim'ns
71DC: EB      	GRBARY: EX      DE,HL
71DD: 2AC580  	        LD      HL,(CUROPR)     ; Get address of next array
71E0: EB      	        EX      DE,HL
71E1: CD5C66  	        CALL    CPDEHL          ; Is this array finished?
71E4: CABD71  	        JP      Z,ARRLP         ; Yes - Get next one
71E7: 01DC71  	        LD      BC,GRBARY       ; Loop until array all done
71EA: C5      	STPOOL: PUSH    BC              ; Save return address
71EB: F680    	        OR      80H             ; Flag string type
71ED: 7E      	STRADD: LD      A,(HL)          ; Get string length
71EE: 23      	        INC     HL
71EF: 23      	        INC     HL
71F0: 5E      	        LD      E,(HL)          ; Get LSB of string address
71F1: 23      	        INC     HL
71F2: 56      	        LD      D,(HL)          ; Get MSB of string address
71F3: 23      	        INC     HL
71F4: F0      	        RET     P               ; Not a string - Return
71F5: B7      	        OR      A               ; Set flags on string length
71F6: C8      	        RET     Z               ; Null string - Return
71F7: 44      	        LD      B,H             ; Save variable pointer
71F8: 4D      	        LD      C,L
71F9: 2AC380  	        LD      HL,(STRBOT)     ; Bottom of new area
71FC: CD5C66  	        CALL    CPDEHL          ; String been done?
71FF: 60      	        LD      H,B             ; Restore variable pointer
7200: 69      	        LD      L,C
7201: D8      	        RET     C               ; String done - Ignore
7202: E1      	        POP     HL              ; Return address
7203: E3      	        EX      (SP),HL         ; Lowest available string area
7204: CD5C66  	        CALL    CPDEHL          ; String within string area?
7207: E3      	        EX      (SP),HL         ; Lowest available string area
7208: E5      	        PUSH    HL              ; Re-save return address
7209: 60      	        LD      H,B             ; Restore variable pointer
720A: 69      	        LD      L,C
720B: D0      	        RET     NC              ; Outside string area - Ignore
720C: C1      	        POP     BC              ; Get return , Throw 2 away
720D: F1      	        POP     AF              ; 
720E: F1      	        POP     AF              ; 
720F: E5      	        PUSH    HL              ; Save variable pointer
7210: D5      	        PUSH    DE              ; Save address of current
7211: C5      	        PUSH    BC              ; Put back return address
7212: C9      	        RET                     ; Go to it
              	
7213: D1      	SCNEND: POP     DE              ; Addresses of strings
7214: E1      	        POP     HL              ; 
7215: 7D      	        LD      A,L             ; HL = 0 if no more to do
7216: B4      	        OR      H
7217: C8      	        RET     Z               ; No more to do - Return
7218: 2B      	        DEC     HL
7219: 46      	        LD      B,(HL)          ; MSB of address of string
721A: 2B      	        DEC     HL
721B: 4E      	        LD      C,(HL)          ; LSB of address of string
721C: E5      	        PUSH    HL              ; Save variable address
721D: 2B      	        DEC     HL
721E: 2B      	        DEC     HL
721F: 6E      	        LD      L,(HL)          ; HL = Length of string
7220: 2600    	        LD      H,0
7222: 09      	        ADD     HL,BC           ; Address of end of string+1
7223: 50      	        LD      D,B             ; String address to DE
7224: 59      	        LD      E,C
7225: 2B      	        DEC     HL              ; Last byte in string
7226: 44      	        LD      B,H             ; Address to BC
7227: 4D      	        LD      C,L
7228: 2AC380  	        LD      HL,(STRBOT)     ; Current bottom of string area
722B: CD6363  	        CALL    MOVSTR          ; Move string to new address
722E: E1      	        POP     HL              ; Restore variable address
722F: 71      	        LD      (HL),C          ; Save new LSB of address
7230: 23      	        INC     HL
7231: 70      	        LD      (HL),B          ; Save new MSB of address
7232: 69      	        LD      L,C             ; Next string area+1 to HL
7233: 60      	        LD      H,B
7234: 2B      	        DEC     HL              ; Next string area address
7235: C38871  	        JP      GARBLP          ; Look for more strings
              	
7238: C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
7239: E5      	        PUSH    HL              ; 
723A: 2AE480  	        LD      HL,(FPREG)      ; Get first string
723D: E3      	        EX      (SP),HL         ; Save first string
723E: CDF26C  	        CALL    OPRND           ; Get second string
7241: E3      	        EX      (SP),HL         ; Restore first string
7242: CD6D6C  	        CALL    TSTSTR          ; Make sure it's a string
7245: 7E      	        LD      A,(HL)          ; Get length of second string
7246: E5      	        PUSH    HL              ; Save first string
7247: 2AE480  	        LD      HL,(FPREG)      ; Get second string
724A: E5      	        PUSH    HL              ; Save second string
724B: 86      	        ADD     A,(HL)          ; Add length of second string
724C: 1E1C    	        LD      E,LS            ; ?LS Error
724E: DAA863  	        JP      C,ERROR         ; String too long - Error
7251: CDF170  	        CALL    MKTMST          ; Make temporary string
7254: D1      	        POP     DE              ; Get second string to DE
7255: CD8972  	        CALL    GSTRDE          ; Move to string pool if needed
7258: E3      	        EX      (SP),HL         ; Get first string
7259: CD8872  	        CALL    GSTRHL          ; Move to string pool if needed
725C: E5      	        PUSH    HL              ; Save first string
725D: 2AC180  	        LD      HL,(TMPSTR+2)   ; Temporary string address
7260: EB      	        EX      DE,HL           ; To DE
7261: CD6F72  	        CALL    SSTSA           ; First string to string area
7264: CD6F72  	        CALL    SSTSA           ; Second string to string area
7267: 21876C  	        LD      HL,EVAL2        ; Return to evaluation loop
726A: E3      	        EX      (SP),HL         ; Save return,get code string
726B: E5      	        PUSH    HL              ; Save code string address
726C: C32271  	        JP      TSTOPL          ; To temporary string to pool
              	
726F: E1      	SSTSA:  POP     HL              ; Return address
7270: E3      	        EX      (SP),HL         ; Get string block,save return
7271: 7E      	        LD      A,(HL)          ; Get length of string
7272: 23      	        INC     HL
7273: 23      	        INC     HL
7274: 4E      	        LD      C,(HL)          ; Get LSB of string address
7275: 23      	        INC     HL
7276: 46      	        LD      B,(HL)          ; Get MSB of string address
7277: 6F      	        LD      L,A             ; Length to L
7278: 2C      	TOSTRA: INC     L               ; INC - DECed after
7279: 2D      	TSALP:  DEC     L               ; Count bytes moved
727A: C8      	        RET     Z               ; End of string - Return
727B: 0A      	        LD      A,(BC)          ; Get source
727C: 12      	        LD      (DE),A          ; Save destination
727D: 03      	        INC     BC              ; Next source
727E: 13      	        INC     DE              ; Next destination
727F: C37972  	        JP      TSALP           ; Loop until string moved
              	
7282: CD6D6C  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
7285: 2AE480  	GSTRCU: LD      HL,(FPREG)      ; Get current string
7288: EB      	GSTRHL: EX      DE,HL           ; Save DE
7289: CDA372  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
728C: EB      	        EX      DE,HL           ; Restore DE
728D: C0      	        RET     NZ              ; No - Return
728E: D5      	        PUSH    DE              ; Save string
728F: 50      	        LD      D,B             ; String block address to DE
7290: 59      	        LD      E,C
7291: 1B      	        DEC     DE              ; Point to length
7292: 4E      	        LD      C,(HL)          ; Get string length
7293: 2AC380  	        LD      HL,(STRBOT)     ; Current bottom of string area
7296: CD5C66  	        CALL    CPDEHL          ; Last one in string area?
7299: C2A172  	        JP      NZ,POPHL        ; No - Return
729C: 47      	        LD      B,A             ; Clear B (A=0)
729D: 09      	        ADD     HL,BC           ; Remove string from str' area
729E: 22C380  	        LD      (STRBOT),HL     ; Save new bottom of str' area
72A1: E1      	POPHL:  POP     HL              ; Restore string
72A2: C9      	        RET
              	
72A3: 2AB180  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
72A6: 2B      	        DEC     HL              ; Back
72A7: 46      	        LD      B,(HL)          ; Get MSB of address
72A8: 2B      	        DEC     HL              ; Back
72A9: 4E      	        LD      C,(HL)          ; Get LSB of address
72AA: 2B      	        DEC     HL              ; Back
72AB: 2B      	        DEC     HL              ; Back
72AC: CD5C66  	        CALL    CPDEHL          ; String last in string pool?
72AF: C0      	        RET     NZ              ; Yes - Leave it
72B0: 22B180  	        LD      (TMSTPT),HL     ; Save new string pool top
72B3: C9      	        RET
              	
72B4: 013370  	LEN:    LD      BC,PASSA        ; To return integer A
72B7: C5      	        PUSH    BC              ; Save address
72B8: CD8272  	GETLEN: CALL    GETSTR          ; Get string and its length
72BB: AF      	        XOR     A
72BC: 57      	        LD      D,A             ; Clear D
72BD: 32AD80  	        LD      (TYPE),A        ; Set type to numeric
72C0: 7E      	        LD      A,(HL)          ; Get length of string
72C1: B7      	        OR      A               ; Set status flags
72C2: C9      	        RET
              	
72C3: 013370  	ASC:    LD      BC,PASSA        ; To return integer A
72C6: C5      	        PUSH    BC              ; Save address
72C7: CDB872  	GTFLNM: CALL    GETLEN          ; Get length of string
72CA: CAC368  	        JP      Z,FCERR         ; Null string - Error
72CD: 23      	        INC     HL
72CE: 23      	        INC     HL
72CF: 5E      	        LD      E,(HL)          ; Get LSB of address
72D0: 23      	        INC     HL
72D1: 56      	        LD      D,(HL)          ; Get MSB of address
72D2: 1A      	        LD      A,(DE)          ; Get first byte of string
72D3: C9      	        RET
              	
72D4: 3E01    	CHR:    LD      A,1             ; One character string
72D6: CDF170  	        CALL    MKTMST          ; Make a temporary string
72D9: CDCD73  	        CALL    MAKINT          ; Make it integer A
72DC: 2AC180  	        LD      HL,(TMPSTR+2)   ; Get address of string
72DF: 73      	        LD      (HL),E          ; Save character
72E0: C1      	TOPOOL: POP     BC              ; Clean up stack
72E1: C32271  	        JP      TSTOPL          ; Temporary string to pool
              	
72E4: CD7D73  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
72E7: AF      	        XOR     A               ; Start at first byte in string
72E8: E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
72E9: 4F      	        LD      C,A             ; Starting position in string
72EA: E5      	MID1:   PUSH    HL              ; Save string block address
72EB: 7E      	        LD      A,(HL)          ; Get length of string
72EC: B8      	        CP      B               ; Compare with number given
72ED: DAF272  	        JP      C,ALLFOL        ; All following bytes required
72F0: 78      	        LD      A,B             ; Get new length
72F1: 11      	        .BYTE      11H             ; Skip "LD C,0"
72F2: 0E00    	ALLFOL: LD      C,0             ; First byte of string
72F4: C5      	        PUSH    BC              ; Save position in string
72F5: CD5B71  	        CALL    TESTR           ; See if enough string space
72F8: C1      	        POP     BC              ; Get position in string
72F9: E1      	        POP     HL              ; Restore string block address
72FA: E5      	        PUSH    HL              ; And re-save it
72FB: 23      	        INC     HL
72FC: 23      	        INC     HL
72FD: 46      	        LD      B,(HL)          ; Get LSB of address
72FE: 23      	        INC     HL
72FF: 66      	        LD      H,(HL)          ; Get MSB of address
7300: 68      	        LD      L,B             ; HL = address of string
7301: 0600    	        LD      B,0             ; BC = starting address
7303: 09      	        ADD     HL,BC           ; Point to that byte
7304: 44      	        LD      B,H             ; BC = source string
7305: 4D      	        LD      C,L
7306: CDF470  	        CALL    CRTMST          ; Create a string entry
7309: 6F      	        LD      L,A             ; Length of new string
730A: CD7872  	        CALL    TOSTRA          ; Move string to string area
730D: D1      	        POP     DE              ; Clear stack
730E: CD8972  	        CALL    GSTRDE          ; Move to string pool if needed
7311: C32271  	        JP      TSTOPL          ; Temporary string to pool
              	
7314: CD7D73  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
7317: D1      	        POP     DE              ; Get string length
7318: D5      	        PUSH    DE              ; And re-save
7319: 1A      	        LD      A,(DE)          ; Get length
731A: 90      	        SUB     B               ; Move back N bytes
731B: C3E872  	        JP      RIGHT1          ; Go and get sub-string
              	
731E: EB      	MID:    EX      DE,HL           ; Get code string address
731F: 7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
7320: CD8273  	        CALL    MIDNUM          ; Get number supplied
7323: 04      	        INC     B               ; Is it character zero?
7324: 05      	        DEC     B
7325: CAC368  	        JP      Z,FCERR         ; Yes - Error
7328: C5      	        PUSH    BC              ; Save starting position
7329: 1EFF    	        LD      E,255           ; All of string
732B: FE29    	        CP      ')'             ; Any length given?
732D: CA3773  	        JP      Z,RSTSTR        ; No - Rest of string
7330: CD6266  	        CALL    CHKSYN          ; Make sure ',' follows
7333: 2C      	        .BYTE      ','
7334: CDCA73  	        CALL    GETINT          ; Get integer 0-255
7337: CD6266  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
733A: 29      	        .BYTE      ")"
733B: F1      	        POP     AF              ; Restore starting position
733C: E3      	        EX      (SP),HL         ; Get string,8ave code string
733D: 01EA72  	        LD      BC,MID1         ; Continuation of MID$ routine
7340: C5      	        PUSH    BC              ; Save for return
7341: 3D      	        DEC     A               ; Starting position-1
7342: BE      	        CP      (HL)            ; Compare with length
7343: 0600    	        LD      B,0             ; Zero bytes length
7345: D0      	        RET     NC              ; Null string if start past end
7346: 4F      	        LD      C,A             ; Save starting position-1
7347: 7E      	        LD      A,(HL)          ; Get length of string
7348: 91      	        SUB     C               ; Subtract start
7349: BB      	        CP      E               ; Enough string for it?
734A: 47      	        LD      B,A             ; Save maximum length available
734B: D8      	        RET     C               ; Truncate string if needed
734C: 43      	        LD      B,E             ; Set specified length
734D: C9      	        RET                     ; Go and create string
              	
734E: CDB872  	VAL:    CALL    GETLEN          ; Get length of string
7351: CA6B74  	        JP      Z,RESZER        ; Result zero
7354: 5F      	        LD      E,A             ; Save length
7355: 23      	        INC     HL
7356: 23      	        INC     HL
7357: 7E      	        LD      A,(HL)          ; Get LSB of address
7358: 23      	        INC     HL
7359: 66      	        LD      H,(HL)          ; Get MSB of address
735A: 6F      	        LD      L,A             ; HL = String address
735B: E5      	        PUSH    HL              ; Save string address
735C: 19      	        ADD     HL,DE
735D: 46      	        LD      B,(HL)          ; Get end of string+1 byte
735E: 72      	        LD      (HL),D          ; Zero it to terminate
735F: E3      	        EX      (SP),HL         ; Save string end,get start
7360: C5      	        PUSH    BC              ; Save end+1 byte
7361: 7E      	        LD      A,(HL)          ; Get starting byte
7362: FE24    	    CP	'$'		; Hex number indicated? [function added]
7364: C26C73  	    JP	NZ,VAL1
7367: CD967B  	    CALL	HEXTFP		; Convert Hex to FPREG
736A: 180D    	    JR	VAL3
736C: FE25    	VAL1:	CP	'%'		; Binary number indicated? [function added]
736E: C27673  	    JP	NZ,VAL2
7371: CD067C  	    CALL	BINTFP		; Convert Bin to FPREG
7374: 1803    	    JR	VAL3
7376: CD5277  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
7379: C1      	VAL3:   POP     BC              ; Restore end+1 byte
737A: E1      	        POP     HL              ; Restore end+1 address
737B: 70      	        LD      (HL),B          ; Put back original byte
737C: C9      	        RET
              	
737D: EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
737E: CD6266  	        CALL    CHKSYN          ; Make sure ")" follows
7381: 29      	        .BYTE      ")"
7382: C1      	MIDNUM: POP     BC              ; Get return address
7383: D1      	        POP     DE              ; Get number supplied
7384: C5      	        PUSH    BC              ; Re-save return address
7385: 43      	        LD      B,E             ; Number to B
7386: C9      	        RET
              	
7387: CDCD73  	INP:    CALL    MAKINT          ; Make it integer A               
738A: 323F80  	        LD      (INPORT),A      ; Set input port
738D: CD3E80  	        CALL    INPSUB          ; Get input from port
7390: C33370  	        JP      PASSA           ; Return integer A
              	
7393: CDB773  	POUT:   CALL    SETIO           ; Set up port number
7396: C30680  	        JP      OUTSUB          ; Output data and return
              	
7399: CDB773  	WAIT:   CALL    SETIO           ; Set up port number
739C: F5      	        PUSH    AF              ; Save AND mask
739D: 1E00    	        LD      E,0             ; Assume zero if none given
739F: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
73A0: CDFC67  	        CALL    GETCHR          ; Get next character
73A3: CAAD73  	        JP      Z,NOXOR         ; No XOR byte given
73A6: CD6266  	        CALL    CHKSYN          ; Make sure ',' follows
73A9: 2C      	        .BYTE      ','
73AA: CDCA73  	        CALL    GETINT          ; Get integer 0-255 to XOR with
73AD: C1      	NOXOR:  POP     BC              ; Restore AND mask
73AE: CD3E80  	WAITLP: CALL    INPSUB          ; Get input
73B1: AB      	        XOR     E               ; Flip selected bits
73B2: A0      	        AND     B               ; Result non-zero?
73B3: CAAE73  	        JP      Z,WAITLP        ; No = keep waiting
73B6: C9      	        RET
              	
73B7: CDCA73  	SETIO:  CALL    GETINT          ; Get integer 0-255
73BA: 323F80  	        LD      (INPORT),A      ; Set input port
73BD: 320780  	        LD      (OTPORT),A      ; Set output port
73C0: CD6266  	        CALL    CHKSYN          ; Make sure ',' follows
73C3: 2C      	        .BYTE      ','
73C4: C3CA73  	        JP      GETINT          ; Get integer 0-255 and return
              	
73C7: CDFC67  	FNDNUM: CALL    GETCHR          ; Get next character
73CA: CD696C  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
73CD: CDA868  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
73D0: 7A      	        LD      A,D             ; Get MSB of number
73D1: B7      	        OR      A               ; Zero?
73D2: C2C368  	        JP      NZ,FCERR        ; No - Error
73D5: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
73D6: CDFC67  	        CALL    GETCHR          ; Get next character
73D9: 7B      	        LD      A,E             ; Get number to A
73DA: C9      	        RET
              	
73DB: CDAE68  	PEEK:   CALL    DEINT           ; Get memory address
73DE: 1A      	        LD      A,(DE)          ; Get byte in memory
73DF: C33370  	        JP      PASSA           ; Return integer A
              	
73E2: CD696C  	POKE:   CALL    GETNUM          ; Get memory address
73E5: CDAE68  	        CALL    DEINT           ; Get integer -32768 to 3276
73E8: D5      	        PUSH    DE              ; Save memory address
73E9: CD6266  	        CALL    CHKSYN          ; Make sure ',' follows
73EC: 2C      	        .BYTE      ','
73ED: CDCA73  	        CALL    GETINT          ; Get integer 0-255
73F0: D1      	        POP     DE              ; Restore memory address
73F1: 12      	        LD      (DE),A          ; Load it into memory
73F2: C9      	        RET
              	
73F3: 21C978  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
73F6: CD9A76  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
73F9: C30574  	        JP      FPADD           ; Add BCDE to FPREG
              	
73FC: CD9A76  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
73FF: 21      	        .BYTE      21H             ; Skip "POP BC" and "POP DE"
7400: C1      	PSUB:   POP     BC              ; Get FP number from stack
7401: D1      	        POP     DE
7402: CD7476  	SUBCDE: CALL    INVSGN          ; Negate FPREG
7405: 78      	FPADD:  LD      A,B             ; Get FP exponent
7406: B7      	        OR      A               ; Is number zero?
7407: C8      	        RET     Z               ; Yes - Nothing to add
7408: 3AE780  	        LD      A,(FPEXP)       ; Get FPREG exponent
740B: B7      	        OR      A               ; Is this number zero?
740C: CA8C76  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
740F: 90      	        SUB     B               ; BCDE number larger?
7410: D21F74  	        JP      NC,NOSWAP       ; No - Don't swap them
7413: 2F      	        CPL                     ; Two's complement
7414: 3C      	        INC     A               ;  FP exponent
7415: EB      	        EX      DE,HL
7416: CD7C76  	        CALL    STAKFP          ; Put FPREG on stack
7419: EB      	        EX      DE,HL
741A: CD8C76  	        CALL    FPBCDE          ; Move BCDE to FPREG
741D: C1      	        POP     BC              ; Restore number from stack
741E: D1      	        POP     DE
741F: FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
7421: D0      	        RET     NC              ; Yes - First number is result
7422: F5      	        PUSH    AF              ; Save number of bits to scale
7423: CDB176  	        CALL    SIGNS           ; Set MSBs & sign of result
7426: 67      	        LD      H,A             ; Save sign of result
7427: F1      	        POP     AF              ; Restore scaling factor
7428: CDCA74  	        CALL    SCALE           ; Scale BCDE to same exponent
742B: B4      	        OR      H               ; Result to be positive?
742C: 21E480  	        LD      HL,FPREG        ; Point to FPREG
742F: F24574  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
7432: CDAA74  	        CALL    PLUCDE          ; Add FPREG to CDE
7435: D28B74  	        JP      NC,RONDUP       ; No overflow - Round it up
7438: 23      	        INC     HL              ; Point to exponent
7439: 34      	        INC     (HL)            ; Increment it
743A: CAA363  	        JP      Z,OVERR         ; Number overflowed - Error
743D: 2E01    	        LD      L,1             ; 1 bit to shift right
743F: CDE074  	        CALL    SHRT1           ; Shift result right
7442: C38B74  	        JP      RONDUP          ; Round it up
              	
7445: AF      	MINCDE: XOR     A               ; Clear A and carry
7446: 90      	        SUB     B               ; Negate exponent
7447: 47      	        LD      B,A             ; Re-save exponent
7448: 7E      	        LD      A,(HL)          ; Get LSB of FPREG
7449: 9B      	        SBC     A, E            ; Subtract LSB of BCDE
744A: 5F      	        LD      E,A             ; Save LSB of BCDE
744B: 23      	        INC     HL
744C: 7E      	        LD      A,(HL)          ; Get NMSB of FPREG
744D: 9A      	        SBC     A,D             ; Subtract NMSB of BCDE
744E: 57      	        LD      D,A             ; Save NMSB of BCDE
744F: 23      	        INC     HL
7450: 7E      	        LD      A,(HL)          ; Get MSB of FPREG
7451: 99      	        SBC     A,C             ; Subtract MSB of BCDE
7452: 4F      	        LD      C,A             ; Save MSB of BCDE
7453: DCB674  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
              	
7456: 68      	BNORM:  LD      L,B             ; L = Exponent
7457: 63      	        LD      H,E             ; H = LSB
7458: AF      	        XOR     A
7459: 47      	BNRMLP: LD      B,A             ; Save bit count
745A: 79      	        LD      A,C             ; Get MSB
745B: B7      	        OR      A               ; Is it zero?
745C: C27874  	        JP      NZ,PNORM        ; No - Do it bit at a time
745F: 4A      	        LD      C,D             ; MSB = NMSB
7460: 54      	        LD      D,H             ; NMSB= LSB
7461: 65      	        LD      H,L             ; LSB = VLSB
7462: 6F      	        LD      L,A             ; VLSB= 0
7463: 78      	        LD      A,B             ; Get exponent
7464: D608    	        SUB     8               ; Count 8 bits
7466: FEE0    	        CP      -24-8           ; Was number zero?
7468: C25974  	        JP      NZ,BNRMLP       ; No - Keep normalising
746B: AF      	RESZER: XOR     A               ; Result is zero
746C: 32E780  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
746F: C9      	        RET
              	
7470: 05      	NORMAL: DEC     B               ; Count bits
7471: 29      	        ADD     HL,HL           ; Shift HL left
7472: 7A      	        LD      A,D             ; Get NMSB
7473: 17      	        RLA                     ; Shift left with last bit
7474: 57      	        LD      D,A             ; Save NMSB
7475: 79      	        LD      A,C             ; Get MSB
7476: 8F      	        ADC     A,A             ; Shift left with last bit
7477: 4F      	        LD      C,A             ; Save MSB
7478: F27074  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
747B: 78      	        LD      A,B             ; Number of bits shifted
747C: 5C      	        LD      E,H             ; Save HL in EB
747D: 45      	        LD      B,L
747E: B7      	        OR      A               ; Any shifting done?
747F: CA8B74  	        JP      Z,RONDUP        ; No - Round it up
7482: 21E780  	        LD      HL,FPEXP        ; Point to exponent
7485: 86      	        ADD     A,(HL)          ; Add shifted bits
7486: 77      	        LD      (HL),A          ; Re-save exponent
7487: D26B74  	        JP      NC,RESZER       ; Underflow - Result is zero
748A: C8      	        RET     Z               ; Result is zero
748B: 78      	RONDUP: LD      A,B             ; Get VLSB of number
748C: 21E780  	RONDB:  LD      HL,FPEXP        ; Point to exponent
748F: B7      	        OR      A               ; Any rounding?
7490: FC9D74  	        CALL    M,FPROND        ; Yes - Round number up
7493: 46      	        LD      B,(HL)          ; B = Exponent
7494: 23      	        INC     HL
7495: 7E      	        LD      A,(HL)          ; Get sign of result
7496: E680    	        AND     10000000B       ; Only bit 7 needed
7498: A9      	        XOR     C               ; Set correct sign
7499: 4F      	        LD      C,A             ; Save correct sign in number
749A: C38C76  	        JP      FPBCDE          ; Move BCDE to FPREG
              	
749D: 1C      	FPROND: INC     E               ; Round LSB
749E: C0      	        RET     NZ              ; Return if ok
749F: 14      	        INC     D               ; Round NMSB
74A0: C0      	        RET     NZ              ; Return if ok
74A1: 0C      	        INC     C               ; Round MSB
74A2: C0      	        RET     NZ              ; Return if ok
74A3: 0E80    	        LD      C,80H           ; Set normal value
74A5: 34      	        INC     (HL)            ; Increment exponent
74A6: C0      	        RET     NZ              ; Return if ok
74A7: C3A363  	        JP      OVERR           ; Overflow error
              	
74AA: 7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
74AB: 83      	        ADD     A,E             ; Add LSB of BCDE
74AC: 5F      	        LD      E,A             ; Save LSB of BCDE
74AD: 23      	        INC     HL
74AE: 7E      	        LD      A,(HL)          ; Get NMSB of FPREG
74AF: 8A      	        ADC     A,D             ; Add NMSB of BCDE
74B0: 57      	        LD      D,A             ; Save NMSB of BCDE
74B1: 23      	        INC     HL
74B2: 7E      	        LD      A,(HL)          ; Get MSB of FPREG
74B3: 89      	        ADC     A,C             ; Add MSB of BCDE
74B4: 4F      	        LD      C,A             ; Save MSB of BCDE
74B5: C9      	        RET
              	
74B6: 21E880  	COMPL:  LD      HL,SGNRES       ; Sign of result
74B9: 7E      	        LD      A,(HL)          ; Get sign of result
74BA: 2F      	        CPL                     ; Negate it
74BB: 77      	        LD      (HL),A          ; Put it back
74BC: AF      	        XOR     A
74BD: 6F      	        LD      L,A             ; Set L to zero
74BE: 90      	        SUB     B               ; Negate exponent,set carry
74BF: 47      	        LD      B,A             ; Re-save exponent
74C0: 7D      	        LD      A,L             ; Load zero
74C1: 9B      	        SBC     A,E             ; Negate LSB
74C2: 5F      	        LD      E,A             ; Re-save LSB
74C3: 7D      	        LD      A,L             ; Load zero
74C4: 9A      	        SBC     A,D             ; Negate NMSB
74C5: 57      	        LD      D,A             ; Re-save NMSB
74C6: 7D      	        LD      A,L             ; Load zero
74C7: 99      	        SBC     A,C             ; Negate MSB
74C8: 4F      	        LD      C,A             ; Re-save MSB
74C9: C9      	        RET
              	
74CA: 0600    	SCALE:  LD      B,0             ; Clear underflow
74CC: D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
74CE: DAD974  	        JP      C,SHRITE        ; No - Shift right A bits
74D1: 43      	        LD      B,E             ; <- Shift
74D2: 5A      	        LD      E,D             ; <- right
74D3: 51      	        LD      D,C             ; <- eight
74D4: 0E00    	        LD      C,0             ; <- bits
74D6: C3CC74  	        JP      SCALLP          ; More bits to shift
              	
74D9: C609    	SHRITE: ADD     A,8+1           ; Adjust count
74DB: 6F      	        LD      L,A             ; Save bits to shift
74DC: AF      	SHRLP:  XOR     A               ; Flag for all done
74DD: 2D      	        DEC     L               ; All shifting done?
74DE: C8      	        RET     Z               ; Yes - Return
74DF: 79      	        LD      A,C             ; Get MSB
74E0: 1F      	SHRT1:  RRA                     ; Shift it right
74E1: 4F      	        LD      C,A             ; Re-save
74E2: 7A      	        LD      A,D             ; Get NMSB
74E3: 1F      	        RRA                     ; Shift right with last bit
74E4: 57      	        LD      D,A             ; Re-save it
74E5: 7B      	        LD      A,E             ; Get LSB
74E6: 1F      	        RRA                     ; Shift right with last bit
74E7: 5F      	        LD      E,A             ; Re-save it
74E8: 78      	        LD      A,B             ; Get underflow
74E9: 1F      	        RRA                     ; Shift right with last bit
74EA: 47      	        LD      B,A             ; Re-save underflow
74EB: C3DC74  	        JP      SHRLP           ; More bits to do
              	
74EE: 00000081	UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
              	
74F2: 03      	LOGTAB: .BYTE      3                       ; Table used by LOG
74F3: AA561980	        .BYTE      0AAH,056H,019H,080H     ; 0.59898
74F7: F1227680	        .BYTE      0F1H,022H,076H,080H     ; 0.96147
74FB: 45AA3882	        .BYTE      045H,0AAH,038H,082H     ; 2.88539
              	
74FF: CD4B76  	LOG:    CALL    TSTSGN          ; Test sign of value
7502: B7      	        OR      A
7503: EAC368  	        JP      PE,FCERR        ; ?FC Error if <= zero
7506: 21E780  	        LD      HL,FPEXP        ; Point to exponent
7509: 7E      	        LD      A,(HL)          ; Get exponent
750A: 013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
750D: 11F304  	        LD      DE,04F3H
7510: 90      	        SUB     B               ; Scale value to be < 1
7511: F5      	        PUSH    AF              ; Save scale factor
7512: 70      	        LD      (HL),B          ; Save new exponent
7513: D5      	        PUSH    DE              ; Save SQR(1/2)
7514: C5      	        PUSH    BC
7515: CD0574  	        CALL    FPADD           ; Add SQR(1/2) to value
7518: C1      	        POP     BC              ; Restore SQR(1/2)
7519: D1      	        POP     DE
751A: 04      	        INC     B               ; Make it SQR(2)
751B: CDA175  	        CALL    DVBCDE          ; Divide by SQR(2)
751E: 21EE74  	        LD      HL,UNITY        ; Point to 1.
7521: CDFC73  	        CALL    SUBPHL          ; Subtract FPREG from 1
7524: 21F274  	        LD      HL,LOGTAB       ; Coefficient table
7527: CD9379  	        CALL    SUMSER          ; Evaluate sum of series
752A: 018080  	        LD      BC,8080H        ; BCDE = -0.5
752D: 110000  	        LD      DE,0000H
7530: CD0574  	        CALL    FPADD           ; Subtract 0.5 from FPREG
7533: F1      	        POP     AF              ; Restore scale factor
7534: CDC677  	        CALL    RSCALE          ; Re-scale number
7537: 013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
753A: 111872  	        LD      DE,7218H
753D: 21      	        .BYTE      21H             ; Skip "POP BC" and "POP DE"
              	
753E: C1      	MULT:   POP     BC              ; Get number from stack
753F: D1      	        POP     DE
7540: CD4B76  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
7543: C8      	        RET     Z               ; Return zero if zero
7544: 2E00    	        LD      L,0             ; Flag add exponents
7546: CD0976  	        CALL    ADDEXP          ; Add exponents
7549: 79      	        LD      A,C             ; Get MSB of multiplier
754A: 32F680  	        LD      (MULVAL),A      ; Save MSB of multiplier
754D: EB      	        EX      DE,HL
754E: 22F780  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
7551: 010000  	        LD      BC,0            ; Partial product (BCDE) = zero
7554: 50      	        LD      D,B
7555: 58      	        LD      E,B
7556: 215674  	        LD      HL,BNORM        ; Address of normalise
7559: E5      	        PUSH    HL              ; Save for return
755A: 216275  	        LD      HL,MULT8        ; Address of 8 bit multiply
755D: E5      	        PUSH    HL              ; Save for NMSB,MSB
755E: E5      	        PUSH    HL              ; 
755F: 21E480  	        LD      HL,FPREG        ; Point to number
7562: 7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
7563: 23      	        INC     HL              ; Point to NMSB
7564: B7      	        OR      A               ; Test LSB
7565: CA8E75  	        JP      Z,BYTSFT        ; Zero - shift to next byte
7568: E5      	        PUSH    HL              ; Save address of number
7569: 2E08    	        LD      L,8             ; 8 bits to multiply by
756B: 1F      	MUL8LP: RRA                     ; Shift LSB right
756C: 67      	        LD      H,A             ; Save LSB
756D: 79      	        LD      A,C             ; Get MSB
756E: D27C75  	        JP      NC,NOMADD       ; Bit was zero - Don't add
7571: E5      	        PUSH    HL              ; Save LSB and count
7572: 2AF780  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
7575: 19      	        ADD     HL,DE           ; Add NMSB and LSB
7576: EB      	        EX      DE,HL           ; Leave sum in DE
7577: E1      	        POP     HL              ; Restore MSB and count
7578: 3AF680  	        LD      A,(MULVAL)      ; Get MSB of multiplier
757B: 89      	        ADC     A,C             ; Add MSB
757C: 1F      	NOMADD: RRA                     ; Shift MSB right
757D: 4F      	        LD      C,A             ; Re-save MSB
757E: 7A      	        LD      A,D             ; Get NMSB
757F: 1F      	        RRA                     ; Shift NMSB right
7580: 57      	        LD      D,A             ; Re-save NMSB
7581: 7B      	        LD      A,E             ; Get LSB
7582: 1F      	        RRA                     ; Shift LSB right
7583: 5F      	        LD      E,A             ; Re-save LSB
7584: 78      	        LD      A,B             ; Get VLSB
7585: 1F      	        RRA                     ; Shift VLSB right
7586: 47      	        LD      B,A             ; Re-save VLSB
7587: 2D      	        DEC     L               ; Count bits multiplied
7588: 7C      	        LD      A,H             ; Get LSB of multiplier
7589: C26B75  	        JP      NZ,MUL8LP       ; More - Do it
758C: E1      	POPHRT: POP     HL              ; Restore address of number
758D: C9      	        RET
              	
758E: 43      	BYTSFT: LD      B,E             ; Shift partial product left
758F: 5A      	        LD      E,D
7590: 51      	        LD      D,C
7591: 4F      	        LD      C,A
7592: C9      	        RET
              	
7593: CD7C76  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
7596: 012084  	        LD      BC,8420H        ; BCDE = 10.
7599: 110000  	        LD      DE,0000H
759C: CD8C76  	        CALL    FPBCDE          ; Move 10 to FPREG
              	
759F: C1      	DIV:    POP     BC              ; Get number from stack
75A0: D1      	        POP     DE
75A1: CD4B76  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
75A4: CA9763  	        JP      Z,DZERR         ; Error if division by zero
75A7: 2EFF    	        LD      L,-1            ; Flag subtract exponents
75A9: CD0976  	        CALL    ADDEXP          ; Subtract exponents
75AC: 34      	        INC     (HL)            ; Add 2 to exponent to adjust
75AD: 34      	        INC     (HL)
75AE: 2B      	        DEC     HL              ; Point to MSB
75AF: 7E      	        LD      A,(HL)          ; Get MSB of dividend
75B0: 321280  	        LD      (DIV3),A        ; Save for subtraction
75B3: 2B      	        DEC     HL
75B4: 7E      	        LD      A,(HL)          ; Get NMSB of dividend
75B5: 320E80  	        LD      (DIV2),A        ; Save for subtraction
75B8: 2B      	        DEC     HL
75B9: 7E      	        LD      A,(HL)          ; Get MSB of dividend
75BA: 320A80  	        LD      (DIV1),A        ; Save for subtraction
75BD: 41      	        LD      B,C             ; Get MSB
75BE: EB      	        EX      DE,HL           ; NMSB,LSB to HL
75BF: AF      	        XOR     A
75C0: 4F      	        LD      C,A             ; Clear MSB of quotient
75C1: 57      	        LD      D,A             ; Clear NMSB of quotient
75C2: 5F      	        LD      E,A             ; Clear LSB of quotient
75C3: 321580  	        LD      (DIV4),A        ; Clear overflow count
75C6: E5      	DIVLP:  PUSH    HL              ; Save divisor
75C7: C5      	        PUSH    BC
75C8: 7D      	        LD      A,L             ; Get LSB of number
75C9: CD0980  	        CALL    DIVSUP          ; Subt' divisor from dividend
75CC: DE00    	        SBC     A,0             ; Count for overflows
75CE: 3F      	        CCF
75CF: D2D975  	        JP      NC,RESDIV       ; Restore divisor if borrow
75D2: 321580  	        LD      (DIV4),A        ; Re-save overflow count
75D5: F1      	        POP     AF              ; Scrap divisor
75D6: F1      	        POP     AF
75D7: 37      	        SCF                     ; Set carry to
75D8: D2      	        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
              	
75D9: C1      	RESDIV: POP     BC              ; Restore divisor
75DA: E1      	        POP     HL
75DB: 79      	        LD      A,C             ; Get MSB of quotient
75DC: 3C      	        INC     A
75DD: 3D      	        DEC     A
75DE: 1F      	        RRA                     ; Bit 0 to bit 7
75DF: FA8C74  	        JP      M,RONDB         ; Done - Normalise result
75E2: 17      	        RLA                     ; Restore carry
75E3: 7B      	        LD      A,E             ; Get LSB of quotient
75E4: 17      	        RLA                     ; Double it
75E5: 5F      	        LD      E,A             ; Put it back
75E6: 7A      	        LD      A,D             ; Get NMSB of quotient
75E7: 17      	        RLA                     ; Double it
75E8: 57      	        LD      D,A             ; Put it back
75E9: 79      	        LD      A,C             ; Get MSB of quotient
75EA: 17      	        RLA                     ; Double it
75EB: 4F      	        LD      C,A             ; Put it back
75EC: 29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
75ED: 78      	        LD      A,B             ; Get MSB of divisor
75EE: 17      	        RLA                     ; Double it
75EF: 47      	        LD      B,A             ; Put it back
75F0: 3A1580  	        LD      A,(DIV4)        ; Get VLSB of quotient
75F3: 17      	        RLA                     ; Double it
75F4: 321580  	        LD      (DIV4),A        ; Put it back
75F7: 79      	        LD      A,C             ; Get MSB of quotient
75F8: B2      	        OR      D               ; Merge NMSB
75F9: B3      	        OR      E               ; Merge LSB
75FA: C2C675  	        JP      NZ,DIVLP        ; Not done - Keep dividing
75FD: E5      	        PUSH    HL              ; Save divisor
75FE: 21E780  	        LD      HL,FPEXP        ; Point to exponent
7601: 35      	        DEC     (HL)            ; Divide by 2
7602: E1      	        POP     HL              ; Restore divisor
7603: C2C675  	        JP      NZ,DIVLP        ; Ok - Keep going
7606: C3A363  	        JP      OVERR           ; Overflow error
              	
7609: 78      	ADDEXP: LD      A,B             ; Get exponent of dividend
760A: B7      	        OR      A               ; Test it
760B: CA2D76  	        JP      Z,OVTST3        ; Zero - Result zero
760E: 7D      	        LD      A,L             ; Get add/subtract flag
760F: 21E780  	        LD      HL,FPEXP        ; Point to exponent
7612: AE      	        XOR     (HL)            ; Add or subtract it
7613: 80      	        ADD     A,B             ; Add the other exponent
7614: 47      	        LD      B,A             ; Save new exponent
7615: 1F      	        RRA                     ; Test exponent for overflow
7616: A8      	        XOR     B
7617: 78      	        LD      A,B             ; Get exponent
7618: F22C76  	        JP      P,OVTST2        ; Positive - Test for overflow
761B: C680    	        ADD     A,80H           ; Add excess 128
761D: 77      	        LD      (HL),A          ; Save new exponent
761E: CA8C75  	        JP      Z,POPHRT        ; Zero - Result zero
7621: CDB176  	        CALL    SIGNS           ; Set MSBs and sign of result
7624: 77      	        LD      (HL),A          ; Save new exponent
7625: 2B      	        DEC     HL              ; Point to MSB
7626: C9      	        RET
              	
7627: CD4B76  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
762A: 2F      	        CPL                     ; Invert sign
762B: E1      	        POP     HL              ; Clean up stack
762C: B7      	OVTST2: OR      A               ; Test if new exponent zero
762D: E1      	OVTST3: POP     HL              ; Clear off return address
762E: F26B74  	        JP      P,RESZER        ; Result zero
7631: C3A363  	        JP      OVERR           ; Overflow error
              	
7634: CD9776  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
7637: 78      	        LD      A,B             ; Get exponent
7638: B7      	        OR      A               ; Is it zero?
7639: C8      	        RET     Z               ; Yes - Result is zero
763A: C602    	        ADD     A,2             ; Multiply by 4
763C: DAA363  	        JP      C,OVERR         ; Overflow - ?OV Error
763F: 47      	        LD      B,A             ; Re-save exponent
7640: CD0574  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
7643: 21E780  	        LD      HL,FPEXP        ; Point to exponent
7646: 34      	        INC     (HL)            ; Double number (Times 10)
7647: C0      	        RET     NZ              ; Ok - Return
7648: C3A363  	        JP      OVERR           ; Overflow error
              	
764B: 3AE780  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
764E: B7      	        OR      A
764F: C8      	        RET     Z               ; RETurn if number is zero
7650: 3AE680  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
7653: FE      	        .BYTE      0FEH            ; Test sign
7654: 2F      	RETREL: CPL                     ; Invert sign
7655: 17      	        RLA                     ; Sign bit to carry
7656: 9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
7657: C0      	        RET     NZ              ; Return -1 if negative
7658: 3C      	        INC     A               ; Bump to +1
7659: C9      	        RET                     ; Positive - Return +1
              	
765A: CD4B76  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
765D: 0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
765F: 110000  	        LD      DE,0            ; Zero NMSB and LSB
7662: 21E780  	RETINT: LD      HL,FPEXP        ; Point to exponent
7665: 4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
7666: 70      	        LD      (HL),B          ; Save exponent
7667: 0600    	        LD      B,0             ; CDE = integer to normalise
7669: 23      	        INC     HL              ; Point to sign of result
766A: 3680    	        LD      (HL),80H        ; Set sign of result
766C: 17      	        RLA                     ; Carry = sign of integer
766D: C35374  	        JP      CONPOS          ; Set sign of result
              	
7670: CD4B76  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
7673: F0      	        RET     P               ; Return if positive
7674: 21E680  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
7677: 7E      	        LD      A,(HL)          ; Get sign of mantissa
7678: EE80    	        XOR     80H             ; Invert sign of mantissa
767A: 77      	        LD      (HL),A          ; Re-save sign of mantissa
767B: C9      	        RET
              	
767C: EB      	STAKFP: EX      DE,HL           ; Save code string address
767D: 2AE480  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
7680: E3      	        EX      (SP),HL         ; Stack them,get return
7681: E5      	        PUSH    HL              ; Re-save return
7682: 2AE680  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
7685: E3      	        EX      (SP),HL         ; Stack them,get return
7686: E5      	        PUSH    HL              ; Re-save return
7687: EB      	        EX      DE,HL           ; Restore code string address
7688: C9      	        RET
              	
7689: CD9A76  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
768C: EB      	FPBCDE: EX      DE,HL           ; Save code string address
768D: 22E480  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
7690: 60      	        LD      H,B             ; Exponent of number
7691: 69      	        LD      L,C             ; MSB of number
7692: 22E680  	        LD      (FPREG+2),HL    ; Save MSB and exponent
7695: EB      	        EX      DE,HL           ; Restore code string address
7696: C9      	        RET
              	
7697: 21E480  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
769A: 5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
769B: 23      	        INC     HL
769C: 56      	        LD      D,(HL)          ; Get NMSB of number
769D: 23      	        INC     HL
769E: 4E      	        LD      C,(HL)          ; Get MSB of number
769F: 23      	        INC     HL
76A0: 46      	        LD      B,(HL)          ; Get exponent of number
76A1: 23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
76A2: C9      	        RET
              	
76A3: 11E480  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
76A6: 0604    	DETHL4: LD      B,4             ; 4 bytes to move
76A8: 1A      	DETHLB: LD      A,(DE)          ; Get source
76A9: 77      	        LD      (HL),A          ; Save destination
76AA: 13      	        INC     DE              ; Next source
76AB: 23      	        INC     HL              ; Next destination
76AC: 05      	        DEC     B               ; Count bytes
76AD: C2A876  	        JP      NZ,DETHLB       ; Loop if more
76B0: C9      	        RET
              	
76B1: 21E680  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
76B4: 7E      	        LD      A,(HL)          ; Get MSB
76B5: 07      	        RLCA                    ; Old sign to carry
76B6: 37      	        SCF                     ; Set MSBit
76B7: 1F      	        RRA                     ; Set MSBit of MSB
76B8: 77      	        LD      (HL),A          ; Save new MSB
76B9: 3F      	        CCF                     ; Complement sign
76BA: 1F      	        RRA                     ; Old sign to carry
76BB: 23      	        INC     HL
76BC: 23      	        INC     HL
76BD: 77      	        LD      (HL),A          ; Set sign of result
76BE: 79      	        LD      A,C             ; Get MSB
76BF: 07      	        RLCA                    ; Old sign to carry
76C0: 37      	        SCF                     ; Set MSBit
76C1: 1F      	        RRA                     ; Set MSBit of MSB
76C2: 4F      	        LD      C,A             ; Save MSB
76C3: 1F      	        RRA
76C4: AE      	        XOR     (HL)            ; New sign of result
76C5: C9      	        RET
              	
76C6: 78      	CMPNUM: LD      A,B             ; Get exponent of number
76C7: B7      	        OR      A
76C8: CA4B76  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
76CB: 215476  	        LD      HL,RETREL       ; Return relation routine
76CE: E5      	        PUSH    HL              ; Save for return
76CF: CD4B76  	        CALL    TSTSGN          ; Test sign of FPREG
76D2: 79      	        LD      A,C             ; Get MSB of number
76D3: C8      	        RET     Z               ; FPREG zero - Number's MSB
76D4: 21E680  	        LD      HL,FPREG+2      ; MSB of FPREG
76D7: AE      	        XOR     (HL)            ; Combine signs
76D8: 79      	        LD      A,C             ; Get MSB of number
76D9: F8      	        RET     M               ; Exit if signs different
76DA: CDE076  	        CALL    CMPFP           ; Compare FP numbers
76DD: 1F      	        RRA                     ; Get carry to sign
76DE: A9      	        XOR     C               ; Combine with MSB of number
76DF: C9      	        RET
              	
76E0: 23      	CMPFP:  INC     HL              ; Point to exponent
76E1: 78      	        LD      A,B             ; Get exponent
76E2: BE      	        CP      (HL)            ; Compare exponents
76E3: C0      	        RET     NZ              ; Different
76E4: 2B      	        DEC     HL              ; Point to MBS
76E5: 79      	        LD      A,C             ; Get MSB
76E6: BE      	        CP      (HL)            ; Compare MSBs
76E7: C0      	        RET     NZ              ; Different
76E8: 2B      	        DEC     HL              ; Point to NMSB
76E9: 7A      	        LD      A,D             ; Get NMSB
76EA: BE      	        CP      (HL)            ; Compare NMSBs
76EB: C0      	        RET     NZ              ; Different
76EC: 2B      	        DEC     HL              ; Point to LSB
76ED: 7B      	        LD      A,E             ; Get LSB
76EE: 96      	        SUB     (HL)            ; Compare LSBs
76EF: C0      	        RET     NZ              ; Different
76F0: E1      	        POP     HL              ; Drop RETurn
76F1: E1      	        POP     HL              ; Drop another RETurn
76F2: C9      	        RET
              	
76F3: 47      	FPINT:  LD      B,A             ; <- Move
76F4: 4F      	        LD      C,A             ; <- exponent
76F5: 57      	        LD      D,A             ; <- to all
76F6: 5F      	        LD      E,A             ; <- bits
76F7: B7      	        OR      A               ; Test exponent
76F8: C8      	        RET     Z               ; Zero - Return zero
76F9: E5      	        PUSH    HL              ; Save pointer to number
76FA: CD9776  	        CALL    BCDEFP          ; Move FPREG to BCDE
76FD: CDB176  	        CALL    SIGNS           ; Set MSBs & sign of result
7700: AE      	        XOR     (HL)            ; Combine with sign of FPREG
7701: 67      	        LD      H,A             ; Save combined signs
7702: FC1777  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
7705: 3E98    	        LD      A,80H+24        ; 24 bits
7707: 90      	        SUB     B               ; Bits to shift
7708: CDCA74  	        CALL    SCALE           ; Shift BCDE
770B: 7C      	        LD      A,H             ; Get combined sign
770C: 17      	        RLA                     ; Sign to carry
770D: DC9D74  	        CALL    C,FPROND        ; Negative - Round number up
7710: 0600    	        LD      B,0             ; Zero exponent
7712: DCB674  	        CALL    C,COMPL         ; If negative make positive
7715: E1      	        POP     HL              ; Restore pointer to number
7716: C9      	        RET
              	
7717: 1B      	DCBCDE: DEC     DE              ; Decrement BCDE
7718: 7A      	        LD      A,D             ; Test LSBs
7719: A3      	        AND     E
771A: 3C      	        INC     A
771B: C0      	        RET     NZ              ; Exit if LSBs not FFFF
771C: 0B      	        DEC     BC              ; Decrement MSBs
771D: C9      	        RET
              	
771E: 21E780  	INT:    LD      HL,FPEXP        ; Point to exponent
7721: 7E      	        LD      A,(HL)          ; Get exponent
7722: FE98    	        CP      80H+24          ; Integer accuracy only?
7724: 3AE480  	        LD      A,(FPREG)       ; Get LSB
7727: D0      	        RET     NC              ; Yes - Already integer
7728: 7E      	        LD      A,(HL)          ; Get exponent
7729: CDF376  	        CALL    FPINT           ; F.P to integer
772C: 3698    	        LD      (HL),80H+24     ; Save 24 bit integer
772E: 7B      	        LD      A,E             ; Get LSB of number
772F: F5      	        PUSH    AF              ; Save LSB
7730: 79      	        LD      A,C             ; Get MSB of number
7731: 17      	        RLA                     ; Sign to carry
7732: CD5374  	        CALL    CONPOS          ; Set sign of result
7735: F1      	        POP     AF              ; Restore LSB of number
7736: C9      	        RET
              	
7737: 210000  	MLDEBC: LD      HL,0            ; Clear partial product
773A: 78      	        LD      A,B             ; Test multiplier
773B: B1      	        OR      C
773C: C8      	        RET     Z               ; Return zero if zero
773D: 3E10    	        LD      A,16            ; 16 bits
773F: 29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
7740: DA776F  	        JP      C,BSERR         ; ?BS Error if overflow
7743: EB      	        EX      DE,HL
7744: 29      	        ADD     HL,HL           ; Shift multiplier left
7745: EB      	        EX      DE,HL
7746: D24D77  	        JP      NC,NOMLAD       ; Bit was zero - No add
7749: 09      	        ADD     HL,BC           ; Add multiplicand
774A: DA776F  	        JP      C,BSERR         ; ?BS Error if overflow
774D: 3D      	NOMLAD: DEC     A               ; Count bits
774E: C23F77  	        JP      NZ,MLDBLP       ; More
7751: C9      	        RET
              	
7752: FE2D    	ASCTFP: CP      '-'             ; Negative?
7754: F5      	        PUSH    AF              ; Save it and flags
7755: CA5E77  	        JP      Z,CNVNUM        ; Yes - Convert number
7758: FE2B    	        CP      '+'             ; Positive?
775A: CA5E77  	        JP      Z,CNVNUM        ; Yes - Convert number
775D: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
775E: CD6B74  	CNVNUM: CALL    RESZER          ; Set result to zero
7761: 47      	        LD      B,A             ; Digits after point counter
7762: 57      	        LD      D,A             ; Sign of exponent
7763: 5F      	        LD      E,A             ; Exponent of ten
7764: 2F      	        CPL
7765: 4F      	        LD      C,A             ; Before or after point flag
7766: CDFC67  	MANLP:  CALL    GETCHR          ; Get next character
7769: DAAF77  	        JP      C,ADDIG         ; Digit - Add to number
776C: FE2E    	        CP      '.'
776E: CA8A77  	        JP      Z,DPOINT        ; '.' - Flag point
7771: FE45    	        CP      'E'
7773: C28E77  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
7776: CDFC67  	        CALL    GETCHR          ; Get next character
7779: CDA26D  	        CALL    SGNEXP          ; Get sign of exponent
777C: CDFC67  	EXPLP:  CALL    GETCHR          ; Get next character
777F: DAD177  	        JP      C,EDIGIT        ; Digit - Add to exponent
7782: 14      	        INC     D               ; Is sign negative?
7783: C28E77  	        JP      NZ,CONEXP       ; No - Scale number
7786: AF      	        XOR     A
7787: 93      	        SUB     E               ; Negate exponent
7788: 5F      	        LD      E,A             ; And re-save it
7789: 0C      	        INC     C               ; Flag end of number
778A: 0C      	DPOINT: INC     C               ; Flag point passed
778B: CA6677  	        JP      Z,MANLP         ; Zero - Get another digit
778E: E5      	CONEXP: PUSH    HL              ; Save code string address
778F: 7B      	        LD      A,E             ; Get exponent
7790: 90      	        SUB     B               ; Subtract digits after point
7791: F4A777  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
7794: F29D77  	        JP      P,ENDCON        ; Positive - All done
7797: F5      	        PUSH    AF              ; Save number of times to /10
7798: CD9375  	        CALL    DIV10           ; Divide by 10
779B: F1      	        POP     AF              ; Restore count
779C: 3C      	        INC     A               ; Count divides
              	
779D: C29177  	ENDCON: JP      NZ,SCALMI       ; More to do
77A0: D1      	        POP     DE              ; Restore code string address
77A1: F1      	        POP     AF              ; Restore sign of number
77A2: CC7476  	        CALL    Z,INVSGN        ; Negative - Negate number
77A5: EB      	        EX      DE,HL           ; Code string address to HL
77A6: C9      	        RET
              	
77A7: C8      	SCALPL: RET     Z               ; Exit if no scaling needed
77A8: F5      	MULTEN: PUSH    AF              ; Save count
77A9: CD3476  	        CALL    MLSP10          ; Multiply number by 10
77AC: F1      	        POP     AF              ; Restore count
77AD: 3D      	        DEC     A               ; Count multiplies
77AE: C9      	        RET
              	
77AF: D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
77B0: 57      	        LD      D,A             ; Save digit
77B1: 78      	        LD      A,B             ; Get digits after point
77B2: 89      	        ADC     A,C             ; Add one if after point
77B3: 47      	        LD      B,A             ; Re-save counter
77B4: C5      	        PUSH    BC              ; Save point flags
77B5: E5      	        PUSH    HL              ; Save code string address
77B6: D5      	        PUSH    DE              ; Save digit
77B7: CD3476  	        CALL    MLSP10          ; Multiply number by 10
77BA: F1      	        POP     AF              ; Restore digit
77BB: D630    	        SUB     '0'             ; Make it absolute
77BD: CDC677  	        CALL    RSCALE          ; Re-scale number
77C0: E1      	        POP     HL              ; Restore code string address
77C1: C1      	        POP     BC              ; Restore point flags
77C2: D1      	        POP     DE              ; Restore sign of exponent
77C3: C36677  	        JP      MANLP           ; Get another digit
              	
77C6: CD7C76  	RSCALE: CALL    STAKFP          ; Put number on stack
77C9: CD5D76  	        CALL    FLGREL          ; Digit to add to FPREG
77CC: C1      	PADD:   POP     BC              ; Restore number
77CD: D1      	        POP     DE
77CE: C30574  	        JP      FPADD           ; Add BCDE to FPREG and return
              	
77D1: 7B      	EDIGIT: LD      A,E             ; Get digit
77D2: 07      	        RLCA                    ; Times 2
77D3: 07      	        RLCA                    ; Times 4
77D4: 83      	        ADD     A,E             ; Times 5
77D5: 07      	        RLCA                    ; Times 10
77D6: 86      	        ADD     A,(HL)          ; Add next digit
77D7: D630    	        SUB     '0'             ; Make it absolute
77D9: 5F      	        LD      E,A             ; Save new digit
77DA: C37C77  	        JP      EXPLP           ; Look for another digit
              	
77DD: E5      	LINEIN: PUSH    HL              ; Save code string address
77DE: 212C63  	        LD      HL,INMSG        ; Output " in "
77E1: CD4271  	        CALL    PRS             ; Output string at HL
77E4: E1      	        POP     HL              ; Restore code string address
77E5: EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
77E6: AF      	        XOR     A
77E7: 0698    	        LD      B,80H+24        ; 24 bits
77E9: CD6276  	        CALL    RETINT          ; Return the integer
77EC: 214171  	        LD      HL,PRNUMS       ; Print number string
77EF: E5      	        PUSH    HL              ; Save for return
77F0: 21E980  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
77F3: E5      	        PUSH    HL              ; Save for return
77F4: CD4B76  	        CALL    TSTSGN          ; Test sign of FPREG
77F7: 3620    	        LD      (HL),' '        ; Space at start
77F9: F2FE77  	        JP      P,SPCFST        ; Positive - Space to start
77FC: 362D    	        LD      (HL),'-'        ; '-' sign at start
77FE: 23      	SPCFST: INC     HL              ; First byte of number
77FF: 3630    	        LD      (HL),'0'        ; '0' if zero
7801: CAB478  	        JP      Z,JSTZER        ; Return '0' if zero
7804: E5      	        PUSH    HL              ; Save buffer address
7805: FC7476  	        CALL    M,INVSGN        ; Negate FPREG if negative
7808: AF      	        XOR     A               ; Zero A
7809: F5      	        PUSH    AF              ; Save it
780A: CDBA78  	        CALL    RNGTST          ; Test number is in range
780D: 014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
7810: 11F84F  	        LD      DE,4FF8H
7813: CDC676  	        CALL    CMPNUM          ; Compare numbers
7816: B7      	        OR      A
7817: E22B78  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
781A: F1      	        POP     AF              ; Restore count
781B: CDA877  	        CALL    MULTEN          ; Multiply by ten
781E: F5      	        PUSH    AF              ; Re-save count
781F: C30D78  	        JP      SIXDIG          ; Test it again
              	
7822: CD9375  	GTSIXD: CALL    DIV10           ; Divide by 10
7825: F1      	        POP     AF              ; Get count
7826: 3C      	        INC     A               ; Count divides
7827: F5      	        PUSH    AF              ; Re-save count
7828: CDBA78  	        CALL    RNGTST          ; Test number is in range
782B: CDF373  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
782E: 3C      	        INC     A
782F: CDF376  	        CALL    FPINT           ; F.P to integer
7832: CD8C76  	        CALL    FPBCDE          ; Move BCDE to FPREG
7835: 010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
7838: F1      	        POP     AF              ; Restore count
7839: 81      	        ADD     A,C             ; 6 digits before point
783A: 3C      	        INC     A               ; Add one
783B: FA4778  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
783E: FE08    	        CP      6+1+1           ; More than 999999 ?
7840: D24778  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
7843: 3C      	        INC     A               ; Adjust for exponent
7844: 47      	        LD      B,A             ; Exponent of number
7845: 3E02    	        LD      A,2             ; Make it zero after
              	
7847: 3D      	MAKNUM: DEC     A               ; Adjust for digits to do
7848: 3D      	        DEC     A
7849: E1      	        POP     HL              ; Restore buffer address
784A: F5      	        PUSH    AF              ; Save count
784B: 11CD78  	        LD      DE,POWERS       ; Powers of ten
784E: 05      	        DEC     B               ; Count digits before point
784F: C25878  	        JP      NZ,DIGTXT       ; Not zero - Do number
7852: 362E    	        LD      (HL),'.'        ; Save point
7854: 23      	        INC     HL              ; Move on
7855: 3630    	        LD      (HL),'0'        ; Save zero
7857: 23      	        INC     HL              ; Move on
7858: 05      	DIGTXT: DEC     B               ; Count digits before point
7859: 362E    	        LD      (HL),'.'        ; Save point in case
785B: CCA176  	        CALL    Z,INCHL         ; Last digit - move on
785E: C5      	        PUSH    BC              ; Save digits before point
785F: E5      	        PUSH    HL              ; Save buffer address
7860: D5      	        PUSH    DE              ; Save powers of ten
7861: CD9776  	        CALL    BCDEFP          ; Move FPREG to BCDE
7864: E1      	        POP     HL              ; Powers of ten table
7865: 062F    	        LD      B, '0'-1        ; ASCII '0' - 1
7867: 04      	TRYAGN: INC     B               ; Count subtractions
7868: 7B      	        LD      A,E             ; Get LSB
7869: 96      	        SUB     (HL)            ; Subtract LSB
786A: 5F      	        LD      E,A             ; Save LSB
786B: 23      	        INC     HL
786C: 7A      	        LD      A,D             ; Get NMSB
786D: 9E      	        SBC     A,(HL)          ; Subtract NMSB
786E: 57      	        LD      D,A             ; Save NMSB
786F: 23      	        INC     HL
7870: 79      	        LD      A,C             ; Get MSB
7871: 9E      	        SBC     A,(HL)          ; Subtract MSB
7872: 4F      	        LD      C,A             ; Save MSB
7873: 2B      	        DEC     HL              ; Point back to start
7874: 2B      	        DEC     HL
7875: D26778  	        JP      NC,TRYAGN       ; No overflow - Try again
7878: CDAA74  	        CALL    PLUCDE          ; Restore number
787B: 23      	        INC     HL              ; Start of next number
787C: CD8C76  	        CALL    FPBCDE          ; Move BCDE to FPREG
787F: EB      	        EX      DE,HL           ; Save point in table
7880: E1      	        POP     HL              ; Restore buffer address
7881: 70      	        LD      (HL),B          ; Save digit in buffer
7882: 23      	        INC     HL              ; And move on
7883: C1      	        POP     BC              ; Restore digit count
7884: 0D      	        DEC     C               ; Count digits
7885: C25878  	        JP      NZ,DIGTXT       ; More - Do them
7888: 05      	        DEC     B               ; Any decimal part?
7889: CA9878  	        JP      Z,DOEBIT        ; No - Do 'E' bit
788C: 2B      	SUPTLZ: DEC     HL              ; Move back through buffer
788D: 7E      	        LD      A,(HL)          ; Get character
788E: FE30    	        CP      '0'             ; '0' character?
7890: CA8C78  	        JP      Z,SUPTLZ        ; Yes - Look back for more
7893: FE2E    	        CP      '.'             ; A decimal point?
7895: C4A176  	        CALL    NZ,INCHL        ; Move back over digit
              	
7898: F1      	DOEBIT: POP     AF              ; Get 'E' flag
7899: CAB778  	        JP      Z,NOENED        ; No 'E' needed - End buffer
789C: 3645    	        LD      (HL),'E'        ; Put 'E' in buffer
789E: 23      	        INC     HL              ; And move on
789F: 362B    	        LD      (HL),'+'        ; Put '+' in buffer
78A1: F2A878  	        JP      P,OUTEXP        ; Positive - Output exponent
78A4: 362D    	        LD      (HL),'-'        ; Put '-' in buffer
78A6: 2F      	        CPL                     ; Negate exponent
78A7: 3C      	        INC     A
78A8: 062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
78AA: 04      	EXPTEN: INC     B               ; Count subtractions
78AB: D60A    	        SUB     10              ; Tens digit
78AD: D2AA78  	        JP      NC,EXPTEN       ; More to do
78B0: C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
78B2: 23      	        INC     HL              ; Move on
78B3: 70      	        LD      (HL),B          ; Save MSB of exponent
78B4: 23      	JSTZER: INC     HL              ;
78B5: 77      	        LD      (HL),A          ; Save LSB of exponent
78B6: 23      	        INC     HL
78B7: 71      	NOENED: LD      (HL),C          ; Mark end of buffer
78B8: E1      	        POP     HL              ; Restore code string address
78B9: C9      	        RET
              	
78BA: 017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
78BD: 11F723  	        LD      DE,23F7H
78C0: CDC676  	        CALL    CMPNUM          ; Compare numbers
78C3: B7      	        OR      A
78C4: E1      	        POP     HL              ; Return address to HL
78C5: E22278  	        JP      PO,GTSIXD       ; Too big - Divide by ten
78C8: E9      	        JP      (HL)            ; Otherwise return to caller
              	
78C9: 00000080	HALF:   .BYTE      00H,00H,00H,80H ; 0.5
              	
78CD: A08601  	POWERS: .BYTE      0A0H,086H,001H  ; 100000
78D0: 102700  	        .BYTE      010H,027H,000H  ;  10000
78D3: E80300  	        .BYTE      0E8H,003H,000H  ;   1000
78D6: 640000  	        .BYTE      064H,000H,000H  ;    100
78D9: 0A0000  	        .BYTE      00AH,000H,000H  ;     10
78DC: 010000  	        .BYTE      001H,000H,000H  ;      1
              	
78DF: 217476  	NEGAFT: LD  HL,INVSGN           ; Negate result
78E2: E3      	        EX      (SP),HL         ; To be done after caller
78E3: E9      	        JP      (HL)            ; Return to caller
              	
78E4: CD7C76  	SQR:    CALL    STAKFP          ; Put value on stack
78E7: 21C978  	        LD      HL,HALF         ; Set power to 1/2
78EA: CD8976  	        CALL    PHLTFP          ; Move 1/2 to FPREG
              	
78ED: C1      	POWER:  POP     BC              ; Get base
78EE: D1      	        POP     DE
78EF: CD4B76  	        CALL    TSTSGN          ; Test sign of power
78F2: 78      	        LD      A,B             ; Get exponent of base
78F3: CA3279  	        JP      Z,EXP           ; Make result 1 if zero
78F6: F2FD78  	        JP      P,POWER1        ; Positive base - Ok
78F9: B7      	        OR      A               ; Zero to negative power?
78FA: CA9763  	        JP      Z,DZERR         ; Yes - ?/0 Error
78FD: B7      	POWER1: OR      A               ; Base zero?
78FE: CA6C74  	        JP      Z,SAVEXP        ; Yes - Return zero
7901: D5      	        PUSH    DE              ; Save base
7902: C5      	        PUSH    BC
7903: 79      	        LD      A,C             ; Get MSB of base
7904: F67F    	        OR      01111111B       ; Get sign status
7906: CD9776  	        CALL    BCDEFP          ; Move power to BCDE
7909: F21A79  	        JP      P,POWER2        ; Positive base - Ok
790C: D5      	        PUSH    DE              ; Save power
790D: C5      	        PUSH    BC
790E: CD1E77  	        CALL    INT             ; Get integer of power
7911: C1      	        POP     BC              ; Restore power
7912: D1      	        POP     DE
7913: F5      	        PUSH    AF              ; MSB of base
7914: CDC676  	        CALL    CMPNUM          ; Power an integer?
7917: E1      	        POP     HL              ; Restore MSB of base
7918: 7C      	        LD      A,H             ; but don't affect flags
7919: 1F      	        RRA                     ; Exponent odd or even?
791A: E1      	POWER2: POP     HL              ; Restore MSB and exponent
791B: 22E680  	        LD      (FPREG+2),HL    ; Save base in FPREG
791E: E1      	        POP     HL              ; LSBs of base
791F: 22E480  	        LD      (FPREG),HL      ; Save in FPREG
7922: DCDF78  	        CALL    C,NEGAFT        ; Odd power - Negate result
7925: CC7476  	        CALL    Z,INVSGN        ; Negative base - Negate it
7928: D5      	        PUSH    DE              ; Save power
7929: C5      	        PUSH    BC
792A: CDFF74  	        CALL    LOG             ; Get LOG of base
792D: C1      	        POP     BC              ; Restore power
792E: D1      	        POP     DE
792F: CD4075  	        CALL    FPMULT          ; Multiply LOG by power
              	
7932: CD7C76  	EXP:    CALL    STAKFP          ; Put value on stack
7935: 013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
7938: 113BAA  	        LD      DE,0AA3BH
793B: CD4075  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
793E: 3AE780  	        LD      A,(FPEXP)       ; Get exponent
7941: FE88    	        CP      80H+8           ; Is it in range?
7943: D22776  	        JP      NC,OVTST1       ; No - Test for overflow
7946: CD1E77  	        CALL    INT             ; Get INT of FPREG
7949: C680    	        ADD     A,80H           ; For excess 128
794B: C602    	        ADD     A,2             ; Exponent > 126?
794D: DA2776  	        JP      C,OVTST1        ; Yes - Test for overflow
7950: F5      	        PUSH    AF              ; Save scaling factor
7951: 21EE74  	        LD      HL,UNITY        ; Point to 1.
7954: CDF673  	        CALL    ADDPHL          ; Add 1 to FPREG
7957: CD3775  	        CALL    MULLN2          ; Multiply by LN(2)
795A: F1      	        POP     AF              ; Restore scaling factor
795B: C1      	        POP     BC              ; Restore exponent
795C: D1      	        POP     DE
795D: F5      	        PUSH    AF              ; Save scaling factor
795E: CD0274  	        CALL    SUBCDE          ; Subtract exponent from FPREG
7961: CD7476  	        CALL    INVSGN          ; Negate result
7964: 217279  	        LD      HL,EXPTAB       ; Coefficient table
7967: CDA279  	        CALL    SMSER1          ; Sum the series
796A: 110000  	        LD      DE,0            ; Zero LSBs
796D: C1      	        POP     BC              ; Scaling factor
796E: 4A      	        LD      C,D             ; Zero MSB
796F: C34075  	        JP      FPMULT          ; Scale result to correct value
              	
7972: 08      	EXPTAB: .BYTE      8                       ; Table used by EXP
7973: 402E9474	        .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
7977: 704F2E77	        .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
797B: 6E02887A	        .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
797F: E6A02A7C	        .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
7983: 50AAAA7E	        .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
7987: FFFF7F7F	        .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
798B: 00008081	        .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
798F: 00000081	        .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
              	
7993: CD7C76  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
7996: 113E75  	        LD      DE,MULT         ; Multiply by "X"
7999: D5      	        PUSH    DE              ; To be done after
799A: E5      	        PUSH    HL              ; Save address of table
799B: CD9776  	        CALL    BCDEFP          ; Move FPREG to BCDE
799E: CD4075  	        CALL    FPMULT          ; Square the value
79A1: E1      	        POP     HL              ; Restore address of table
79A2: CD7C76  	SMSER1: CALL    STAKFP          ; Put value on stack
79A5: 7E      	        LD      A,(HL)          ; Get number of coefficients
79A6: 23      	        INC     HL              ; Point to start of table
79A7: CD8976  	        CALL    PHLTFP          ; Move coefficient to FPREG
79AA: 06      	        .BYTE      06H             ; Skip "POP AF"
79AB: F1      	SUMLP:  POP     AF              ; Restore count
79AC: C1      	        POP     BC              ; Restore number
79AD: D1      	        POP     DE
79AE: 3D      	        DEC     A               ; Cont coefficients
79AF: C8      	        RET     Z               ; All done
79B0: D5      	        PUSH    DE              ; Save number
79B1: C5      	        PUSH    BC
79B2: F5      	        PUSH    AF              ; Save count
79B3: E5      	        PUSH    HL              ; Save address in table
79B4: CD4075  	        CALL    FPMULT          ; Multiply FPREG by BCDE
79B7: E1      	        POP     HL              ; Restore address in table
79B8: CD9A76  	        CALL    LOADFP          ; Number at HL to BCDE
79BB: E5      	        PUSH    HL              ; Save address in table
79BC: CD0574  	        CALL    FPADD           ; Add coefficient to FPREG
79BF: E1      	        POP     HL              ; Restore address in table
79C0: C3AB79  	        JP      SUMLP           ; More coefficients
              	
79C3: CD4B76  	RND:    CALL    TSTSGN          ; Test sign of FPREG
79C6: 211980  	        LD      HL,SEED+2       ; Random number seed
79C9: FA247A  	        JP      M,RESEED        ; Negative - Re-seed
79CC: 213A80  	        LD      HL,LSTRND       ; Last random number
79CF: CD8976  	        CALL    PHLTFP          ; Move last RND to FPREG
79D2: 211980  	        LD      HL,SEED+2       ; Random number seed
79D5: C8      	        RET     Z               ; Return if RND(0)
79D6: 86      	        ADD     A,(HL)          ; Add (SEED)+2)
79D7: E607    	        AND     00000111B       ; 0 to 7
79D9: 0600    	        LD      B,0
79DB: 77      	        LD      (HL),A          ; Re-save seed
79DC: 23      	        INC     HL              ; Move to coefficient table
79DD: 87      	        ADD     A,A             ; 4 bytes
79DE: 87      	        ADD     A,A             ; per entry
79DF: 4F      	        LD      C,A             ; BC = Offset into table
79E0: 09      	        ADD     HL,BC           ; Point to coefficient
79E1: CD9A76  	        CALL    LOADFP          ; Coefficient to BCDE
79E4: CD4075  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
79E7: 3A1880  	        LD      A,(SEED+1)      ; Get (SEED+1)
79EA: 3C      	        INC     A               ; Add 1
79EB: E603    	        AND     00000011B       ; 0 to 3
79ED: 0600    	        LD      B,0
79EF: FE01    	        CP      1               ; Is it zero?
79F1: 88      	        ADC     A,B             ; Yes - Make it 1
79F2: 321880  	        LD      (SEED+1),A      ; Re-save seed
79F5: 21287A  	        LD      HL,RNDTAB-4     ; Addition table
79F8: 87      	        ADD     A,A             ; 4 bytes
79F9: 87      	        ADD     A,A             ; per entry
79FA: 4F      	        LD      C,A             ; BC = Offset into table
79FB: 09      	        ADD     HL,BC           ; Point to value
79FC: CDF673  	        CALL    ADDPHL          ; Add value to FPREG
79FF: CD9776  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
7A02: 7B      	        LD      A,E             ; Get LSB
7A03: 59      	        LD      E,C             ; LSB = MSB
7A04: EE4F    	        XOR     01001111B       ; Fiddle around
7A06: 4F      	        LD      C,A             ; New MSB
7A07: 3680    	        LD      (HL),80H        ; Set exponent
7A09: 2B      	        DEC     HL              ; Point to MSB
7A0A: 46      	        LD      B,(HL)          ; Get MSB
7A0B: 3680    	        LD      (HL),80H        ; Make value -0.5
7A0D: 211780  	        LD      HL,SEED         ; Random number seed
7A10: 34      	        INC     (HL)            ; Count seed
7A11: 7E      	        LD      A,(HL)          ; Get seed
7A12: D6AB    	        SUB     171             ; Do it modulo 171
7A14: C21B7A  	        JP      NZ,RND2         ; Non-zero - Ok
7A17: 77      	        LD      (HL),A          ; Zero seed
7A18: 0C      	        INC     C               ; Fillde about
7A19: 15      	        DEC     D               ; with the
7A1A: 1C      	        INC     E               ; number
7A1B: CD5674  	RND2:   CALL    BNORM           ; Normalise number
7A1E: 213A80  	        LD      HL,LSTRND       ; Save random number
7A21: C3A376  	        JP      FPTHL           ; Move FPREG to last and return
              	
7A24: 77      	RESEED: LD      (HL),A          ; Re-seed random numbers
7A25: 2B      	        DEC     HL
7A26: 77      	        LD      (HL),A
7A27: 2B      	        DEC     HL
7A28: 77      	        LD      (HL),A
7A29: C3FF79  	        JP      RND1            ; Return RND seed
              	
7A2C: 68B14668	RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
7A30: 99E99269	        .BYTE   099H,0E9H,092H,069H
7A34: 10D17568	        .BYTE   010H,0D1H,075H,068H
              	
7A38: 21827A  	COS:    LD      HL,HALFPI       ; Point to PI/2
7A3B: CDF673  	        CALL    ADDPHL          ; Add it to PPREG
7A3E: CD7C76  	SIN:    CALL    STAKFP          ; Put angle on stack
7A41: 014983  	        LD      BC,8349H        ; BCDE = 2 PI
7A44: 11DB0F  	        LD      DE,0FDBH
7A47: CD8C76  	        CALL    FPBCDE          ; Move 2 PI to FPREG
7A4A: C1      	        POP     BC              ; Restore angle
7A4B: D1      	        POP     DE
7A4C: CDA175  	        CALL    DVBCDE          ; Divide angle by 2 PI
7A4F: CD7C76  	        CALL    STAKFP          ; Put it on stack
7A52: CD1E77  	        CALL    INT             ; Get INT of result
7A55: C1      	        POP     BC              ; Restore number
7A56: D1      	        POP     DE
7A57: CD0274  	        CALL    SUBCDE          ; Make it 0 <= value < 1
7A5A: 21867A  	        LD      HL,QUARTR       ; Point to 0.25
7A5D: CDFC73  	        CALL    SUBPHL          ; Subtract value from 0.25
7A60: CD4B76  	        CALL    TSTSGN          ; Test sign of value
7A63: 37      	        SCF                     ; Flag positive
7A64: F26E7A  	        JP      P,SIN1          ; Positive - Ok
7A67: CDF373  	        CALL    ROUND           ; Add 0.5 to value
7A6A: CD4B76  	        CALL    TSTSGN          ; Test sign of value
7A6D: B7      	        OR      A               ; Flag negative
7A6E: F5      	SIN1:   PUSH    AF              ; Save sign
7A6F: F47476  	        CALL    P,INVSGN        ; Negate value if positive
7A72: 21867A  	        LD      HL,QUARTR       ; Point to 0.25
7A75: CDF673  	        CALL    ADDPHL          ; Add 0.25 to value
7A78: F1      	        POP     AF              ; Restore sign
7A79: D47476  	        CALL    NC,INVSGN       ; Negative - Make positive
7A7C: 218A7A  	        LD      HL,SINTAB       ; Coefficient table
7A7F: C39379  	        JP      SUMSER          ; Evaluate sum of series
              	
7A82: DB0F4981	HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
              	
7A86: 0000007F	QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
              	
7A8A: 05      	SINTAB: .BYTE   5                       ; Table used by SIN
7A8B: BAD71E86	        .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
7A8F: 64269987	        .BYTE   064H,026H,099H,087H     ;-76.575
7A93: 58342387	        .BYTE   058H,034H,023H,087H     ; 81.602
7A97: E05DA586	        .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
7A9B: DA0F4983	        .BYTE   0DAH,00FH,049H,083H     ;  6.2832
              	
7A9F: CD7C76  	TAN:    CALL    STAKFP          ; Put angle on stack
7AA2: CD3E7A  	        CALL    SIN             ; Get SIN of angle
7AA5: C1      	        POP     BC              ; Restore angle
7AA6: E1      	        POP     HL
7AA7: CD7C76  	        CALL    STAKFP          ; Save SIN of angle
7AAA: EB      	        EX      DE,HL           ; BCDE = Angle
7AAB: CD8C76  	        CALL    FPBCDE          ; Angle to FPREG
7AAE: CD387A  	        CALL    COS             ; Get COS of angle
7AB1: C39F75  	        JP      DIV             ; TAN = SIN / COS
              	
7AB4: CD4B76  	ATN:    CALL    TSTSGN          ; Test sign of value
7AB7: FCDF78  	        CALL    M,NEGAFT        ; Negate result after if -ve
7ABA: FC7476  	        CALL    M,INVSGN        ; Negate value if -ve
7ABD: 3AE780  	        LD      A,(FPEXP)       ; Get exponent
7AC0: FE81    	        CP      81H             ; Number less than 1?
7AC2: DAD17A  	        JP      C,ATN1          ; Yes - Get arc tangnt
7AC5: 010081  	        LD      BC,8100H        ; BCDE = 1
7AC8: 51      	        LD      D,C
7AC9: 59      	        LD      E,C
7ACA: CDA175  	        CALL    DVBCDE          ; Get reciprocal of number
7ACD: 21FC73  	        LD      HL,SUBPHL       ; Sub angle from PI/2
7AD0: E5      	        PUSH    HL              ; Save for angle > 1
7AD1: 21DB7A  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
7AD4: CD9379  	        CALL    SUMSER          ; Evaluate sum of series
7AD7: 21827A  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
7ADA: C9      	        RET                     ; Number > 1 - Sub from PI/2
              	
7ADB: 09      	ATNTAB: .BYTE   9                       ; Table used by ATN
7ADC: 4AD73B78	        .BYTE   04AH,0D7H,03BH,078H     ; 1/17
7AE0: 026E847B	        .BYTE   002H,06EH,084H,07BH     ;-1/15
7AE4: FEC12F7C	        .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
7AE8: 74319A7D	        .BYTE   074H,031H,09AH,07DH     ;-1/11
7AEC: 843D5A7D	        .BYTE   084H,03DH,05AH,07DH     ; 1/9
7AF0: C87F917E	        .BYTE   0C8H,07FH,091H,07EH     ;-1/7
7AF4: E4BB4C7E	        .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
7AF8: 6CAAAA7F	        .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
7AFC: 00000081	        .BYTE   000H,000H,000H,081H     ; 1/1
              	
              	
7B00: C9      	ARET:   RET                     ; A RETurn instruction
              	
7B01: D7      	GETINP: RST	    10H             ;input a character
7B02: C9      	        RET
              	
7B03:         	CLS: 
7B03: 3E0C    	        LD      A,CS            ; ASCII Clear screen
7B05: C33D7C  	        JP      MONOUT          ; Output character
              	
7B08: CDCA73  	WIDTH:  CALL    GETINT          ; Get integer 0-255
7B0B: 7B      	        LD      A,E             ; Width to A
7B0C: 324280  	        LD      (LWIDTH),A      ; Set width
7B0F: C9      	        RET
              	
7B10: CD696C  	LINES:  CALL    GETNUM          ; Get a number
7B13: CDAE68  	        CALL    DEINT           ; Get integer -32768 to 32767
7B16: ED534680	        LD      (LINESC),DE     ; Set lines counter
7B1A: ED534880	        LD      (LINESN),DE     ; Set lines number
7B1E: C9      	        RET
              	
7B1F: CDAE68  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
7B22: D5      	        PUSH    DE              ; Save number
7B23: E1      	        POP     HL              ; Number to HL
7B24: 46      	        LD      B,(HL)          ; Get LSB of contents
7B25: 23      	        INC     HL
7B26: 7E      	        LD      A,(HL)          ; Get MSB of contents
7B27: C32470  	        JP      ABPASS          ; Return integer AB
              	
7B2A: CD696C  	DOKE:   CALL    GETNUM          ; Get a number
7B2D: CDAE68  	        CALL    DEINT           ; Get integer -32768 to 32767
7B30: D5      	        PUSH    DE              ; Save address
7B31: CD6266  	        CALL    CHKSYN          ; Make sure ',' follows
7B34: 2C      	        .BYTE      ','
7B35: CD696C  	        CALL    GETNUM          ; Get a number
7B38: CDAE68  	        CALL    DEINT           ; Get integer -32768 to 32767
7B3B: E3      	        EX      (SP),HL         ; Save value,get address
7B3C: 73      	        LD      (HL),E          ; Save LSB of value
7B3D: 23      	        INC     HL
7B3E: 72      	        LD      (HL),D          ; Save MSB of value
7B3F: E1      	        POP     HL              ; Restore code string address
7B40: C9      	        RET
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
              	
7B41: CD6C6C  	HEX: 	CALL	TSTNUM          ; Verify it's a number
7B44: CDAE68  	        CALL	DEINT           ; Get integer -32768 to 32767
7B47: C5      	        PUSH	BC              ; Save contents of BC
7B48: 21E980  	        LD	    HL,PBUFF
7B4B: 7A      	        LD	    A,D             ; Get high order into A
7B4C: FE00    	        CP      $0
7B4E: 280C    			JR      Z,HEX2          ; Skip output if both high digits are zero
7B50: CD797B  	        CALL    BYT2ASC         ; Convert D to ASCII
7B53: 78      			LD      A,B
7B54: FE30    			CP      '0'
7B56: 2802    			JR      Z,HEX1          ; Don't store high digit if zero
7B58: 70      	        LD	    (HL),B          ; Store it to PBUFF
7B59: 23      	        INC	    HL              ; Next location
7B5A: 71      	HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
7B5B: 23      	        INC     HL              ; Next location
7B5C: 7B      	HEX2:   LD	    A,E             ; Get lower byte
7B5D: CD797B  	        CALL    BYT2ASC         ; Convert E to ASCII
7B60: 7A      			LD      A,D
7B61: FE00    	        CP      $0
7B63: 2005    			JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
7B65: 78      			LD      A,B
7B66: FE30    			CP      '0'             ; If high digit of lower byte is zero then don't print
7B68: 2802    			JR      Z,HEX4
7B6A: 70      	HEX3:   LD      (HL),B          ; to PBUFF+2
7B6B: 23      	        INC     HL              ; Next location
7B6C: 71      	HEX4:   LD      (HL),C          ; to PBUFF+3
7B6D: 23      	        INC     HL              ; PBUFF+4 to zero
7B6E: AF      	        XOR     A               ; Terminating character
7B6F: 77      	        LD      (HL),A          ; Store zero to terminate
7B70: 23      	        INC     HL              ; Make sure PBUFF is terminated
7B71: 77      	        LD      (HL),A          ; Store the double zero there
7B72: C1      	        POP     BC              ; Get BC back
7B73: 21E980  	        LD      HL,PBUFF        ; Reset to start of PBUFF
7B76: C3D270  	        JP      STR1            ; Convert the PBUFF to a string and return it
              	
7B79: 47      	BYT2ASC	LD      B,A             ; Save original value
7B7A: E60F    	        AND     $0F             ; Strip off upper nybble
7B7C: FE0A    	        CP      $0A             ; 0-9?
7B7E: 3802    	        JR      C,ADD30         ; If A-F, add 7 more
7B80: C607    	        ADD     A,$07           ; Bring value up to ASCII A-F
7B82: C630    	ADD30	ADD     A,$30           ; And make ASCII
7B84: 4F      	        LD      C,A             ; Save converted char to C
7B85: 78      	        LD      A,B             ; Retrieve original value
7B86: 0F      	        RRCA                    ; and Rotate it right
7B87: 0F      	        RRCA
7B88: 0F      	        RRCA
7B89: 0F      	        RRCA
7B8A: E60F    	        AND     $0F             ; Mask off upper nybble
7B8C: FE0A    	        CP      $0A             ; 0-9? < A hex?
7B8E: 3802    	        JR      C,ADD301        ; Skip Add 7
7B90: C607    	        ADD     A,$07           ; Bring it up to ASCII A-F
7B92: C630    	ADD301	ADD     A,$30           ; And make it full ASCII
7B94: 47      	        LD      B,A             ; Store high order byte
7B95: C9      	        RET	
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
7B96: EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
7B97: 210000  	        LD      HL,$0000        ; Zero out the value
7B9A: CDAF7B  	        CALL    GETHEX          ; Check the number for valid hex
7B9D: DACF7B  	        JP      C,HXERR         ; First value wasn't hex, HX error
7BA0: 1805    	        JR      HEXLP1          ; Convert first character
7BA2: CDAF7B  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
7BA5: 381F    	        JR      C,HEXIT         ; Exit if not a hex character
7BA7: 29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
7BA8: 29      	        ADD     HL,HL
7BA9: 29      	        ADD     HL,HL
7BAA: 29      	        ADD     HL,HL
7BAB: B5      	        OR      L               ; Add in D0-D3 into L
7BAC: 6F      	        LD      L,A             ; Save new value
7BAD: 18F3    	        JR      HEXLP           ; And continue until all hex characters are in
              	
7BAF: 13      	GETHEX  INC     DE              ; Next location
7BB0: 1A      	        LD      A,(DE)          ; Load character at pointer
7BB1: FE20    	        CP      ' '
7BB3: CAAF7B  	        JP      Z,GETHEX        ; Skip spaces
7BB6: D630    	        SUB     $30             ; Get absolute value
7BB8: D8      	        RET     C               ; < "0", error
7BB9: FE0A    	        CP      $0A
7BBB: 3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
7BBD: D607    	        SUB     $07             ; Reduce to A-F
7BBF: FE0A    	        CP      $0A             ; Value should be $0A-$0F at this point
7BC1: D8      	        RET     C               ; CY set if was :            ; < = > ? @
7BC2: FE10    	NOSUB7  CP      $10             ; > Greater than "F"?
7BC4: 3F      	        CCF
7BC5: C9      	        RET                     ; CY set if it wasn't valid hex
              	    
7BC6: EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
7BC7: 7A      	        LD      A,D             ; Load DE into AC
7BC8: 4B      	        LD      C,E             ; For prep to 
7BC9: E5      	        PUSH    HL
7BCA: CD2370  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
7BCD: E1      	        POP     HL
7BCE: C9      	        RET
              	
7BCF: 1E26    	HXERR:  LD      E,HX            ; ?HEX Error
7BD1: C3A863  	        JP      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
7BD4: CD6C6C  	BIN:    CALL    TSTNUM          ; Verify it's a number
7BD7: CDAE68  	        CALL    DEINT           ; Get integer -32768 to 32767
7BDA: C5      	BIN2:   PUSH    BC              ; Save contents of BC
7BDB: 21E980  	        LD      HL,PBUFF
7BDE: 0611    	        LD      B,17            ; One higher than max char count
7BE0:         	ZEROSUP:                        ; Suppress leading zeros
7BE0: 05      	        DEC     B               ; Max 16 chars
7BE1: 78      	        LD      A,B
7BE2: FE01    	        CP      $01
7BE4: 2808    	        JR      Z,BITOUT        ; Always output at least one character
7BE6: CB13    	        RL      E
7BE8: CB12    	        RL      D
7BEA: 30F4    	        JR      NC,ZEROSUP
7BEC: 1804    	        JR      BITOUT2
7BEE:         	BITOUT:      
7BEE: CB13    	        RL      E
7BF0: CB12    	        RL      D               ; Top bit now in carry
7BF2:         	BITOUT2:
7BF2: 3E30    	        LD      A,'0'           ; Char for '0'
7BF4: CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
7BF6: 77      	        LD      (HL),A
7BF7: 23      	        INC     HL
7BF8: 05      	        DEC     B
7BF9: 20F3    	        JR      NZ,BITOUT
7BFB: AF      	        XOR     A               ; Terminating character
7BFC: 77      	        LD      (HL),A          ; Store zero to terminate
7BFD: 23      	        INC     HL              ; Make sure PBUFF is terminated
7BFE: 77      	        LD      (HL),A          ; Store the double zero there
7BFF: C1      	        POP     BC
7C00: 21E980  	        LD      HL,PBUFF
7C03: C3D270  	        JP      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
7C06: EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
7C07: 210000  	        LD      HL,$0000        ; Zero out the value
7C0A: CD237C  	        CALL    CHKBIN          ; Check the number for valid bin
7C0D: DA317C  	        JP      C,BINERR        ; First value wasn't bin, HX error
7C10: D630    	BINIT:  SUB     '0'
7C12: 29      	        ADD     HL,HL           ; Rotate HL left
7C13: B5      	        OR      L
7C14: 6F      	        LD      L,A
7C15: CD237C  	        CALL    CHKBIN          ; Get second and addtional characters
7C18: 30F6    	        JR      NC,BINIT        ; Process if a bin character
7C1A: EB      	        EX      DE,HL           ; Value into DE, Code string into HL
7C1B: 7A      	        LD      A,D             ; Load DE into AC
7C1C: 4B      	        LD      C,E             ; For prep to 
7C1D: E5      	        PUSH    HL
7C1E: CD2370  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
7C21: E1      	        POP     HL
7C22: C9      	        RET
              	
              	; Char is in A, NC if char is 0 or 1
7C23: 13      	CHKBIN: INC     DE
7C24: 1A      	        LD      A,(DE)
7C25: FE20    	        CP      ' '
7C27: CA237C  	        JP      Z,CHKBIN        ; Skip spaces
7C2A: FE30    	        CP      '0'             ; Set C if < '0'
7C2C: D8      	        RET     C
7C2D: FE32    	        CP      '2'
7C2F: 3F      	        CCF                     ; Set C if > '1'
7C30: C9      	        RET
              	
7C31: 1E28    	BINERR: LD      E,BN            ; ?BIN Error
7C33: C3A863  	        JP      ERROR
              	
              	
7C36:         	JJUMP1: 
7C36: DD21FFFF	        LD      IX,-1           ; Flag cold start
7C3A: C31160  	        JP      CSTART          ; Go and initialise
              	
7C3D:         	MONOUT: 
7C3D: C30800  	        JP      $0008           ; output a char
              	
              	
7C40:         	MONITR: 
7C40: C30000  	        JP      $0000           ; Restart (Normally Monitor Start)
              	
              	
7C43: 3E00    	INITST: LD      A,0             ; Clear break flag
7C45: 324D80  	        LD      (BRKFLG),A
7C48: C31860  	        JP      INIT
              	
7C4B: ED45    	ARETN:  RETN                    ; Return from NMI
              	
              	
7C4D: F5      	TSTBIT: PUSH    AF              ; Save bit mask
7C4E: A0      	        AND     B               ; Get common bits
7C4F: C1      	        POP     BC              ; Restore bit mask
7C50: B8      	        CP      B               ; Same bit set?
7C51: 3E00    	        LD      A,0             ; Return 0 in A
7C53: C9      	        RET
              	
7C54: CD6D66  	OUTNCR: CALL    OUTC            ; Output character in A
7C57: C3A46A  	        JP      PRNTCRLF        ; Output CRLF
              	
7C5A:         	EELOAD:
7C5A: F5      	        PUSH AF
7C5B: E5      	        PUSH HL
7C5C: D5      	        PUSH DE
7C5D: C5      	        PUSH BC
              	
7C5E: 110000  	        LD DE, $0000
7C61: 210080  	        LD HL, $8000 ; BASIC
7C64: 010020  	        LD BC, $2000 ; copy 8kb from EEPROM I2C
              	        ;CALL I2CMEMTOCPU_BASIC
              	
7C67: 3E0D    	        LD A, CR ; new line
7C69: CD3D7C  	        CALL MONOUT
              	
7C6C: C1      	        POP BC
7C6D: D1      	        POP DE
7C6E: E1      	        POP HL
7C6F: F1      	        POP AF 
7C70: C9      	        RET
              	
              	
7C71:         	EESAVE:
7C71: F5      	        PUSH AF
7C72: E5      	        PUSH HL
7C73: D5      	        PUSH DE
7C74: C5      	        PUSH BC
              	
7C75: 210080  	        LD HL, $8000
7C78: 110000  	        LD DE, $0000
7C7B: 010020  	        LD BC, $2000 ; save 8kb to EEPROM I2C
              	        ;CALL I2CCPUTOMEM_BASIC
              	
7C7E: 3E0D    	        LD A, CR ; new line
7C80: CD3D7C  	        CALL MONOUT
              	
7C83: C1      	        POP BC
7C84: D1      	        POP DE
7C85: E1      	        POP HL
7C86: F1      	        POP AF
7C87: C9      	        RET
              	
              	
7C88:         	diego:
7C88: 3E01    	        LD a, 1
7C8A: D300    	        OUT(0),A
7C8C: C3DF63  	        JP PRNTOK
              	
7C8F:         	cruz:
7C8F: CDCA73  	        CALL GETINT
7C92: 7B      	        LD A, E
7C93: D300    	        OUT(0), A 
7C95: C9      	        RET
7C96: C3DF63  	        JP PRNTOK
              	
              	;.end
              	
              	; RAM Locations - Move this section to RAM if necessary
              	;---------------
              	
7C99: FFFFFFFF	.ORG $F000              ;Start location
7C9D: FF...   	
              	        
0780:         	SBUF:   EQU 16 * $78     ;Scroll Buffer size  16 * 60 = 960 byte (10 lines), change to 20 lines (16 * 120($78))
F000: FFFFFFFF	        DS SBUF         ;Scroll Buffer space abover GBUF 
F004: FF...   	
F780: FFFFFFFF	GBUF:   DS 0400H        ;Graphics Buffer 16 * 64 = 1024 byte
F784: FF...   	
F780:         	TGBUF:  EQU GBUF        ;Terminal GBUF
FB80: 80F7    	VPORT:  DW GBUF         ;View port start address
FB82: 80F7    	TBUF:   DW GBUF         ;Top of Buffer pointer
FB84: 0000    	ENDPT:  DW 0000H        ;End Point for Line
FB86: 00      	SX:     DB 00H          ;Sign of X
FB87: 00      	SY:     DB 00H          ;Sign of Y
FB88: 0000    	DX:     DW 0000H        ;Change of X
FB8A: 0000    	DY:     DW 0000H        ;Change of Y
FB8C: 0000    	ERR:    DW 0000H        ;Error Rate
FB8E: 0000    	RAD:    DW 0000H        ;Radius
FB90: 00      	CLRBUF: DB 00H          ;Clear Buffer Flag on LCD Displaying
FB91: 0000    	CURSOR_XY: DW 0000H     ;Cursor Address X,Y
FB91:         	CURSOR_Y: EQU CURSOR_XY   ;Cursor Y
FB92:         	CURSOR_X: EQU CURSOR_XY+1 ;Cursor X
FB93: 00      	CURSOR_YS: DB 00H       ;Start Y row for new line
FB94: 00      	CURSOR_ON: DB 00H       ;Cursor on/off flag
FB95: 00      	INVERSE: DB 00H         ;Inverse Flag
FB96: 00      	PIXEL_X: DB 00H         ;Pixel X length
              	
FB97: 0000    	BAUD:   DW  0000H       ; Serial baud
FB99: 0000    	PUTCH:  DW  0000H       ; Serial
FB9B: 0000    	GETCH:  DW  0000H       ; Serial
              	
FB9D: 00      	LED_ONBOARD:  DB 00H      ; Led onboard
              	
FB9E: 00      	BDEL:     DB    00H  ; Flag to delete char MSBasic
              	
FB9F: 00      	I2C_RAMCPY:         .DB    $00   ; 1 byte - RAM copy of output port
FBA0: 00      	I2C_ADDR            .DB    $00   ; 1 byte - device address
FBA1: 00      	I2C_RR              .DB    $00   ; 1 byte - register
FBA2: 00      	I2C_DD              .DB    $00   ; 1 byte - data
              	
FBA3: 0000    	ADDR_FROM    DW  0000H
FBA5: 0000    	ADDR_TO      DW  0000H
FBA7: 0000    	ADDR_SIZE    DW  0000H
              	
FBA9: FFFFFFFF	MSGBUF:      DS  20H ; 32 bytes...   
FBAD: FF...   	
FBC9: 00      	DATABYTE:    DB  00H
FBCA: 0000    	ADDR:        DW  0000H
              	
FBCC: 00      	KEY_SHIFT:   DB  00H
FBCD: 00      	KEY_READ:    DB  00H
              	
              	.end


; +++ segments +++

#CODE          = $0000 =     0,  size = $FBCE = 64462

; +++ global symbols +++

ABPASS        = $7024 = 28708          MSBasic.asm:2451
ABS           = $7670 = 30320          MSBasic.asm:3474
ABSHL         = $03DB =   987          LCD.asm:457
AC2HEX1       = $104D =  4173          Keyboard.asm:22
AC2HEX2       = $104F =  4175          Keyboard.asm:25
AC2HEX3       = $105B =  4187          Keyboard.asm:31
ACCSUM        = $688D = 26765          MSBasic.asm:1353 (unused)
ACPASS        = $7023 = 28707          MSBasic.asm:2450
ADD30         = $7B82 = 31618          MSBasic.asm:4222
ADD301        = $7B92 = 31634          MSBasic.asm:4233
ADDEXP        = $7609 = 30217          MSBasic.asm:3409
ADDIG         = $77AF = 30639          MSBasic.asm:3697
ADDPHL        = $73F6 = 29686          MSBasic.asm:3056
ADDR          = $FBCA = 64458          Z80Mini.asm:424
ADDR_FROM     = $FBA3 = 64419          Z80Mini.asm:418
ADDR_SIZE     = $FBA7 = 64423          Z80Mini.asm:420
ADDR_TO       = $FBA5 = 64421          Z80Mini.asm:419
ALLFOL        = $72F2 = 29426          MSBasic.asm:2898
ANTVLU        = $6B8D = 27533          MSBasic.asm:1760
API           = $00EA =   234          Z80Mini.asm:151 (unused)
ARET          = $7B00 = 31488          MSBasic.asm:4137 (unused)
ARETN         = $7C4B = 31819          MSBasic.asm:4365 (unused)
ARLDSV        = $6F44 = 28484          MSBasic.asm:2306
ARREND        = $80DA = 32986          MSBasic.asm:88
ARRLP         = $71BD = 29117          MSBasic.asm:2689
ASC           = $72C3 = 29379          MSBasic.asm:2868
ASC2HEX       = $1043 =  4163          Keyboard.asm:17
ASCTFP        = $7752 = 30546          MSBasic.asm:3643
ASPCS         = $6AEF = 27375          MSBasic.asm:1683
ATN           = $7AB4 = 31412          MSBasic.asm:4108
ATN1          = $7AD1 = 31441          MSBasic.asm:4120
ATNTAB        = $7ADB = 31451          MSBasic.asm:4125
ATOH          = $68C8 = 26824          MSBasic.asm:1386
BADINP        = $6B14 = 27412          MSBasic.asm:1695
BAKSTK        = $633D = 25405          MSBasic.asm:534
BAKTMP        = $72A3 = 29347          MSBasic.asm:2846
BASE_COL      = $04FE =  1278          LCD.asm:707
BASIC         = $021D =   541          Z80Mini.asm:300
BASIC_W       = $0220 =   544          Z80Mini.asm:302
BASTXT        = $805E = 32862          MSBasic.asm:64
BAUD          = $FB97 = 64407          Z80Mini.asm:405 (unused)
BCDEFP        = $7697 = 30359          MSBasic.asm:3501
BCRLF         = $13DC =  5084          Monitor.asm:209
BDEL          = $FB9E = 64414          Z80Mini.asm:411
BFREE         = $60AD = 24749          MSBasic.asm:217
BIN           = $7BD4 = 31700          MSBasic.asm:4282
BIN2          = $7BDA = 31706          MSBasic.asm:4284 (unused)
BINERR        = $7C31 = 31793          MSBasic.asm:4345
BINIT         = $7C10 = 31760          MSBasic.asm:4320
BINTFP        = $7C06 = 31750          MSBasic.asm:4316
BITOUT        = $7BEE = 31726          MSBasic.asm:4296
BITOUT2       = $7BF2 = 31730          MSBasic.asm:4299
BKSP          = $0008 =     8          Z80Mini.asm:67
BN            = $0028 =    40          MSBasic.asm:122
BNORM         = $7456 = 29782          MSBasic.asm:3115
BNRMLP        = $7459 = 29785          MSBasic.asm:3118
BRK           = $683F = 26687          MSBasic.asm:1308
BRKFLG        = $804D = 32845          MSBasic.asm:57
BRKLIN        = $80CE = 32974          MSBasic.asm:82
BRKMSG        = $6337 = 25399          MSBasic.asm:532
BRKRET        = $60A7 = 24743          MSBasic.asm:214
BS            = $0010 =    16          MSBasic.asm:110
BSERR         = $6F77 = 28535          MSBasic.asm:2337
BUFFER        = $8061 = 32865          MSBasic.asm:65
BYT2ASC       = $7B79 = 31609          MSBasic.asm:4217
BYTASC        = $1201 =  4609          Utils.asm:104
BYTOUT        = $1218 =  4632          Utils.asm:137
BYTSFT        = $758E = 30094          MSBasic.asm:3326
CFEVAL        = $6EDA = 28378          MSBasic.asm:2237
CHARTY        = $6E88 = 28296          MSBasic.asm:2193
CHEKFN        = $70BB = 28859          MSBasic.asm:2542
CHKBIN        = $7C23 = 31779          MSBasic.asm:4335
CHKKEY        = $105E =  4190          Keyboard.asm:38
CHKLTR        = $689A = 26778          MSBasic.asm:1362
CHKSTK        = $6371 = 25457          MSBasic.asm:571
CHKSUM        = $804A = 32842          MSBasic.asm:55
CHKSYN        = $6662 = 26210          MSBasic.asm:1007
CHKTYP        = $6C6E = 27758          MSBasic.asm:1875
CHR           = $72D4 = 29396          MSBasic.asm:2880
CIRCLE_LOOP   = $0401 =  1025          LCD.asm:507
CKSIOA        = $0F75 =  3957          Serial.asm:88
CLEAR         = $68ED = 26861          MSBasic.asm:1410
CLEAR_GBUF    = $02A2 =   674          LCD.asm:197
CLEAR_GR_LCD  = $02B2 =   690          LCD.asm:208
CLEAR_PIXEL   = $04CB =  1227          LCD.asm:652
CLEAR_TXT_LCD = $02D9 =   729          LCD.asm:232
CLK_LOOP      = $0797 =  1943          LCD.asm:1290
CLOTST        = $6697 = 26263          MSBasic.asm:1039
CLRBUF        = $FB90 = 64400          Z80Mini.asm:396
CLREG         = $64C6 = 25798          MSBasic.asm:779
CLRPTR        = $64A1 = 25761          MSBasic.asm:759
CLR_ROWS      = $02E8 =   744          LCD.asm:239
CLR_X         = $02B7 =   695          LCD.asm:211
CLR_Y         = $02CA =   714          LCD.asm:221
CLS           = $7B03 = 31491          MSBasic.asm:4142
CMPFP         = $76E0 = 30432          MSBasic.asm:3559
CMPLG1        = $6DEE = 28142          MSBasic.asm:2099
CMPLOG        = $6DEC = 28140          MSBasic.asm:2098
CMPNUM        = $76C6 = 30406          MSBasic.asm:3542
CMPRES        = $6E30 = 28208          MSBasic.asm:2147
CMPSTR        = $6E18 = 28184          MSBasic.asm:2127
CN            = $0020 =    32          MSBasic.asm:118
CNVNUM        = $775E = 30558          MSBasic.asm:3649
COLD          = $6000 = 24576          MSBasic.asm:126 (unused)
COMMAN        = $8043 = 32835          MSBasic.asm:50
COMPL         = $74B6 = 29878          MSBasic.asm:3189
CONCAT        = $7238 = 29240          MSBasic.asm:2779
CONEXP        = $778E = 30606          MSBasic.asm:3673
CONPOS        = $7453 = 29779          MSBasic.asm:3113
CONT          = $6872 = 26738          MSBasic.asm:1336
CONTAD        = $80D4 = 32980          MSBasic.asm:85
CONVAR        = $6D59 = 27993          MSBasic.asm:1999
CONV_A_HEX    = $11C3 =  4547          Utils.asm:34
CONV_A_HEX_NYBASC = $11CC =  4556          Utils.asm:44
COPY          = $6020 = 24608          MSBasic.asm:143
COS           = $7A38 = 31288          MSBasic.asm:4056
COUNT         = $6707 = 26375          MSBasic.asm:1105
CPDEHL        = $665C = 26204          MSBasic.asm:1000
CPYLIT        = $6598 = 26008          MSBasic.asm:897
CR            = $000D =    13          Z80Mini.asm:71
CRARLP        = $6F97 = 28567          MSBasic.asm:2357
CREARY        = $6F7C = 28540          MSBasic.asm:2340
CRESTR        = $69EC = 27116          MSBasic.asm:1549
CRNCLP        = $64F9 = 25849          MSBasic.asm:805
CRTMST        = $70F4 = 28916          MSBasic.asm:2575
CRTST         = $7100 = 28928          MSBasic.asm:2586
CRTSTE        = $7116 = 28950          MSBasic.asm:2600
CRUNCH        = $64F0 = 25840          MSBasic.asm:801
CS            = $000C =    12          Z80Mini.asm:70
CSTART        = $6011 = 24593          MSBasic.asm:136
CSUMERR       = $185B =  6235          Z80Mini.asm:349
CTLOFG        = $8045 = 32837          MSBasic.asm:52
CTRLC         = $0003 =     3          Z80Mini.asm:65
CTRLG         = $0007 =     7          Z80Mini.asm:66
CTRLO         = $000F =    15          Z80Mini.asm:72
CTRLQ         = $0011 =    17          Z80Mini.asm:73
CTRLR         = $0012 =    18          Z80Mini.asm:74
CTRLS         = $0013 =    19          Z80Mini.asm:75
CTRLU         = $0015 =    21          Z80Mini.asm:76
CUROPR        = $80C5 = 32965          MSBasic.asm:76
CURPOS        = $80AB = 32939          MSBasic.asm:67
CURSOR        = $008F =   143          LCD.asm:70
CURSOR_ON     = $FB94 = 64404          Z80Mini.asm:401
CURSOR_X      = $FB92 = 64402          Z80Mini.asm:399
CURSOR_XY     = $FB91 = 64401          Z80Mini.asm:397
CURSOR_Y      = $FB91 = 64401          Z80Mini.asm:398
CURSOR_YS     = $FB93 = 64403          Z80Mini.asm:400
DATA          = $6993 = 27027          MSBasic.asm:1501
DATABYTE      = $FBC9 = 64457          Z80Mini.asm:423
DATFLG        = $80AE = 32942          MSBasic.asm:70
DATLIN        = $80C9 = 32969          MSBasic.asm:78
DATSNR        = $638E = 25486          MSBasic.asm:591
DCBCDE        = $7717 = 30487          MSBasic.asm:3602
DD            = $0012 =    18          MSBasic.asm:111
DDERR         = $639D = 25501          MSBasic.asm:599
DEC_CURSOR    = $06E7 =  1767          LCD.asm:1087
DEEK          = $7B1F = 31519          MSBasic.asm:4157
DEF           = $7038 = 28728          MSBasic.asm:2463
DEFSIZ        = $6F9F = 28575          MSBasic.asm:2361
DEINT         = $68AE = 26798          MSBasic.asm:1373
DEL           = $007F =   127          Z80Mini.asm:78
DELAY_MS      = $0583 =  1411          LCD.asm:816
DELAY_US      = $0580 =  1408          LCD.asm:814
DELCHR        = $65C8 = 26056          MSBasic.asm:927
DELETE_CHAR   = $0259 =   601          LCD.asm:129
DEPINT        = $68A8 = 26792          MSBasic.asm:1371
DETHL4        = $76A6 = 30374          MSBasic.asm:3513
DETHLB        = $76A8 = 30376          MSBasic.asm:3514
DIGTXT        = $7858 = 30808          MSBasic.asm:3795
DIM           = $6E5A = 28250          MSBasic.asm:2173
DIMRET        = $6E51 = 28241          MSBasic.asm:2168
DINPOS        = $6691 = 26257          MSBasic.asm:1034
DISPLAY_CURSOR = $0711 =  1809          LCD.asm:1118
DIV           = $759F = 30111          MSBasic.asm:3337
DIV1          = $800A = 32778          MSBasic.asm:40
DIV10         = $7593 = 30099          MSBasic.asm:3332
DIV2          = $800E = 32782          MSBasic.asm:41
DIV3          = $8012 = 32786          MSBasic.asm:42
DIV4          = $8015 = 32789          MSBasic.asm:43
DIVLP         = $75C6 = 30150          MSBasic.asm:3361
DIVSUP        = $8009 = 32777          MSBasic.asm:39
DLINE1        = $13A6 =  5030          Monitor.asm:165
DLINE2        = $13B6 =  5046          Monitor.asm:178
DN            = $00B6 =   182          LCD.asm:63
DOAGN         = $64DF = 25823          MSBasic.asm:792
DOCOM         = $6AC0 = 27328          MSBasic.asm:1659
DODEL         = $65A8 = 26024          MSBasic.asm:911
DOEBIT        = $7898 = 30872          MSBasic.asm:3838
DOFN          = $7065 = 28773          MSBasic.asm:2491
DOKE          = $7B2A = 31530          MSBasic.asm:4165
DONULL        = $6AAE = 27310          MSBasic.asm:1648
DOSPC         = $6AEA = 27370          MSBasic.asm:1680
DOT           = $13C2 =  5058          Monitor.asm:184
DOTAB         = $6AD7 = 27351          MSBasic.asm:1670
DO_BS         = $05DE =  1502          LCD.asm:892 (unused)
DO_CHAR       = $0603 =  1539          LCD.asm:909
DO_CR         = $05C0 =  1472          LCD.asm:876
DO_FF         = $05DA =  1498          LCD.asm:889
DO_SCRL_DN    = $05B8 =  1464          LCD.asm:871
DO_SCRL_UP    = $05AD =  1453          LCD.asm:865 (unused)
DO_TAB        = $05EC =  1516          LCD.asm:899
DPLAY1        = $1375 =  4981          Monitor.asm:130
DPLAY2        = $1382 =  4994          Monitor.asm:139
DPLAY3        = $1389 =  5001          Monitor.asm:144
DPLINE        = $1397 =  5015          Monitor.asm:154
DPOINT        = $778A = 30602          MSBasic.asm:3671
DRAW_A        = $0637 =  1591          LCD.asm:952
DRAW_BOX      = $02FF =   767          LCD.asm:261
DRAW_CIRCLE   = $03E5 =   997          LCD.asm:486
DRAW_CURSOR   = $0609 =  1545          LCD.asm:912
DRAW_GRAPHIC  = $071D =  1821          LCD.asm:1139
DRAW_LINE     = $033A =   826          LCD.asm:338
DRAW_PIXEL    = $04BA =  1210          LCD.asm:632
DS1           = $046D =  1133          LCD.asm:575
DS2           = $0491 =  1169          LCD.asm:594
DS3           = $04A4 =  1188          LCD.asm:606
DSPLAY        = $135F =  4959          Monitor.asm:118
DS_EXIT       = $0560 =  1376          LCD.asm:782
DS_LOOP       = $0556 =  1366          LCD.asm:775
DTSTR         = $7104 = 28932          MSBasic.asm:2589
DVBCDE        = $75A1 = 30113          MSBasic.asm:3339
DX            = $FB88 = 64392          Z80Mini.asm:392
DY            = $FB8A = 64394          Z80Mini.asm:393
DZ            = $0014 =    20          MSBasic.asm:112
DZERR         = $6397 = 25495          MSBasic.asm:595
ECHDEL        = $65BC = 26044          MSBasic.asm:920
EDIGIT        = $77D1 = 30673          MSBasic.asm:3720
EELOAD        = $7C5A = 31834          MSBasic.asm:4378
EESAVE        = $7C71 = 31857          MSBasic.asm:4399
ENDBUF        = $659F = 26015          MSBasic.asm:903
ENDCON        = $779D = 30621          MSBasic.asm:3683
ENDDIM        = $6FFE = 28670          MSBasic.asm:2430
ENDINP        = $6A9F = 27295          MSBasic.asm:1642
ENDNAM        = $6E7C = 28284          MSBasic.asm:2189
ENDPRG        = $684E = 26702          MSBasic.asm:1319
ENDPT         = $FB84 = 64388          Z80Mini.asm:389
ENFMEM        = $637A = 25466          MSBasic.asm:577
ERR           = $FB8C = 64396          Z80Mini.asm:394
ERRIN         = $63C8 = 25544          MSBasic.asm:621
ERRLIN        = $80D2 = 32978          MSBasic.asm:84
ERRMSG        = $6325 = 25381          MSBasic.asm:528
ERROR         = $63A8 = 25512          MSBasic.asm:607
ERRORS        = $629B = 25243          MSBasic.asm:457
ERR_JAM       = $0001 =     1          I2C.asm:98 (unused)
ERR_NOACK     = $0002 =     2          I2C.asm:99
ERR_NONE      = $0000 =     0          I2C.asm:97 (unused)
ERR_TOUT      = $0003 =     3          I2C.asm:100
ESC           = $001B =    27          Z80Mini.asm:77
EVAL          = $6C7B = 27771          MSBasic.asm:1883
EVAL1         = $6C7E = 27774          MSBasic.asm:1885
EVAL2         = $6C87 = 27783          MSBasic.asm:1889
EVAL3         = $6C8A = 27786          MSBasic.asm:1890
EVLPAR        = $6D40 = 27968          MSBasic.asm:1985
EVNOT         = $6E3A = 28218          MSBasic.asm:2155
EXCUTE        = $67CC = 26572          MSBasic.asm:1216
EXP           = $7932 = 31026          MSBasic.asm:3925
EXPLP         = $777C = 30588          MSBasic.asm:3663
EXPTAB        = $7972 = 31090          MSBasic.asm:3953
EXPTEN        = $78AA = 30890          MSBasic.asm:3848
EXTIG         = $6BE9 = 27625          MSBasic.asm:1808
FANDT         = $6C13 = 27667          MSBasic.asm:1826
FC            = $0008 =     8          MSBasic.asm:106
FCERR         = $68C3 = 26819          MSBasic.asm:1383
FDTLP         = $6BFA = 27642          MSBasic.asm:1810
FILEOK        = $1849 =  6217          Z80Mini.asm:348
FILL_BOX      = $032A =   810          LCD.asm:306
FILL_CIRCLE   = $04AC =  1196          LCD.asm:616
FINDEL        = $6FDA = 28634          MSBasic.asm:2402
FLGDIF        = $7656 = 30294          MSBasic.asm:3457
FLGREL        = $765D = 30301          MSBasic.asm:3463
FLIP_PIXEL    = $04DD =  1245          LCD.asm:673
FNARG         = $80E0 = 32992          MSBasic.asm:91
FNCTAB        = $60DA = 24794          MSBasic.asm:228
FNDARY        = $6F4A = 28490          MSBasic.asm:2310
FNDELP        = $6FDF = 28639          MSBasic.asm:2407
FNDEND        = $6474 = 25716          MSBasic.asm:722
FNDNUM        = $73C7 = 29639          MSBasic.asm:3030
FNDTOK        = $66E6 = 26342          MSBasic.asm:1085
FNDVAR        = $6EC1 = 28353          MSBasic.asm:2221
FNDWRD        = $6523 = 25891          MSBasic.asm:825
FNOFST        = $6D6A = 28010          MSBasic.asm:2009
FNRGNM        = $80DE = 32990          MSBasic.asm:90
FNTHR         = $6ECF = 28367          MSBasic.asm:2229
FNVAL         = $6D91 = 28049          MSBasic.asm:2031
FONT_DATA     = $07B3 =  1971          LCD.asm:1324
FOPRND        = $6CB3 = 27827          MSBasic.asm:1911
FOR           = $6733 = 26419          MSBasic.asm:1127
FORFLG        = $80CB = 32971          MSBasic.asm:79
FORFND        = $6763 = 26467          MSBasic.asm:1155
FORSLP        = $6747 = 26439          MSBasic.asm:1136
FPADD         = $7405 = 29701          MSBasic.asm:3064
FPBCDE        = $768C = 30348          MSBasic.asm:3493
FPEXP         = $80E7 = 32999          MSBasic.asm:93
FPINT         = $76F3 = 30451          MSBasic.asm:3579
FPMULT        = $7540 = 30016          MSBasic.asm:3275
FPREG         = $80E4 = 32996          MSBasic.asm:92
FPROND        = $749D = 29853          MSBasic.asm:3165
FPSINT        = $68A2 = 26786          MSBasic.asm:1369
FPTHL         = $76A3 = 30371          MSBasic.asm:3512
FRE           = $7002 = 28674          MSBasic.asm:2433
FRENUM        = $701E = 28702          MSBasic.asm:2445
FRMEVL        = $6D5C = 27996          MSBasic.asm:2000
GARBGE        = $7185 = 29061          MSBasic.asm:2662
GARBLP        = $7188 = 29064          MSBasic.asm:2663
GBOTTOM       = $030B =   779          LCD.asm:273
GBUF          = $F780 = 63360          Z80Mini.asm:385
GETBT1        = $1021 =  4129          Serial.asm:227
GETBT2        = $1035 =  4149          Serial.asm:240
GETBYT        = $1017 =  4119          Serial.asm:222
GETCH         = $FB9B = 64411          Z80Mini.asm:407
GETCHR        = $67FC = 26620          MSBasic.asm:1261
GETCHR_KEYBOARD = $1170 =  4464          Keyboard.asm:239
GETCMD        = $63EC = 25580          MSBasic.asm:639
GETHEX        = $7BAF = 31663          MSBasic.asm:4255
GETINP        = $7B01 = 31489          MSBasic.asm:4139
GETINT        = $73CA = 29642          MSBasic.asm:3031
GETLEN        = $72B8 = 29368          MSBasic.asm:2860
GETLIN        = $65D9 = 26073          MSBasic.asm:935
GETLN         = $68C9 = 26825          MSBasic.asm:1387
GETNUM        = $6C69 = 27753          MSBasic.asm:1872
GETNXT        = $653E = 25918          MSBasic.asm:840
GETNYB        = $118A =  4490          Keyboard.asm:252
GETOUT        = $11A8 =  4520          Keyboard.asm:267
GETSTR        = $7282 = 29314          MSBasic.asm:2826
GETVAR        = $6E5F = 28255          MSBasic.asm:2176
GET_CURSOR    = $070C =  1804          LCD.asm:1111
GET_DEV_ADDR  = $169D =  5789          Monitor.asm:749
GET_DEV_DD    = $16AE =  5806          Monitor.asm:758
GET_DEV_RR    = $16BF =  5823          Monitor.asm:768
GET_ESP       = $11AA =  4522          Keyboard.asm:269
GET_FROM_TO_SIZE = $154F =  5455          Monitor.asm:490
GET_FROM_TO_SIZE_SIZE = $1599 =  5529          Monitor.asm:535
GET_FROM_TO_SIZE_TO = $1578 =  5496          Monitor.asm:514
GLEFT         = $0315 =   789          LCD.asm:282
GNXARY        = $71BC = 29116          MSBasic.asm:2688
GOFUNC        = $6D99 = 28057          MSBasic.asm:2035
GOJMP1        = $12F5 =  4853          Monitor.asm:40 (unused)
GOJUMP        = $12DF =  4831          Monitor.asm:27
GOJUMP_new    = $12DC =  4828          Monitor.asm:24
GOSUB         = $693F = 26943          MSBasic.asm:1452
GOTO          = $6950 = 26960          MSBasic.asm:1464
GRBARY        = $71DC = 29148          MSBasic.asm:2707
GRBDON        = $715D = 29021          MSBasic.asm:2637
GRBLP         = $7196 = 29078          MSBasic.asm:2669
GRET          = $1072 =  4210          Keyboard.asm:52
GRIGHT        = $0320 =   800          LCD.asm:292
GSTRCU        = $7285 = 29317          MSBasic.asm:2827
GSTRDE        = $7289 = 29321          MSBasic.asm:2829
GSTRHL        = $7288 = 29320          MSBasic.asm:2828
GTFLNM        = $72C7 = 29383          MSBasic.asm:2870 (unused)
GTFNAM        = $6E64 = 28260          MSBasic.asm:2179
GTLNLP        = $68CC = 26828          MSBasic.asm:1388
GTOP          = $0300 =   768          LCD.asm:263
GTSIXD        = $7822 = 30754          MSBasic.asm:3764
GTVLUS        = $6B65 = 27493          MSBasic.asm:1738
HALF          = $78C9 = 30921          MSBasic.asm:3869
HALFPI        = $7A82 = 31362          MSBasic.asm:4087
HEX           = $7B41 = 31553          MSBasic.asm:4182
HEX1          = $7B5A = 31578          MSBasic.asm:4195
HEX2          = $7B5C = 31580          MSBasic.asm:4197
HEX3          = $7B6A = 31594          MSBasic.asm:4205
HEX4          = $7B6C = 31596          MSBasic.asm:4207
HEXIT         = $7BC6 = 31686          MSBasic.asm:4270
HEXLP         = $7BA2 = 31650          MSBasic.asm:4245
HEXLP1        = $7BA7 = 31655          MSBasic.asm:4247
HEXTFP        = $7B96 = 31638          MSBasic.asm:4240
HX            = $0026 =    38          MSBasic.asm:121
HXERR         = $7BCF = 31695          MSBasic.asm:4278
H_Delay       = $11AE =  4526          Utils.asm:5
HexOut        = $0F0D =  3853          I2C.asm:454
HexOutHex     = $0F1A =  3866          I2C.asm:464
HexOutSkip    = $0F20 =  3872          I2C.asm:467
I2CA_BLOCK    = $00AE =   174          Z80Mini.asm:106
I2CCPUTOMEM   = $151A =  5402          Monitor.asm:453
I2CCPUTOMEM_BASIC = $1531 =  5425          Monitor.asm:473 (unused)
I2CCPUTOMEM_OK = $1543 =  5443          Monitor.asm:482
I2CLIST       = $0E73 =  3699          I2C.asm:325
I2CMEMTOCPU   = $15BB =  5563          Monitor.asm:559
I2CMEMTOCPU_BASIC = $15D2 =  5586          Monitor.asm:576 (unused)
I2CMEMTOCPU_OK = $15E4 =  5604          Monitor.asm:585
I2C_ADDR      = $FBA0 = 64416          Z80Mini.asm:414
I2C_Close     = $0DBA =  3514          I2C.asm:22
I2C_DD        = $FBA2 = 64418          Z80Mini.asm:416
I2C_INIT      = $0E40 =  3648          I2C.asm:228
I2C_LIST_MSG  = $181E =  6174          Z80Mini.asm:345
I2C_MemRd     = $0EA2 =  3746          I2C.asm:368
I2C_MemRdRead = $0EC6 =  3782          I2C.asm:390
I2C_MemRdReady = $0EB7 =  3767          I2C.asm:382
I2C_MemRdRepeat = $0EA6 =  3750          I2C.asm:370
I2C_MemWr     = $0ED7 =  3799          I2C.asm:414
I2C_MemWrBlock = $0EED =  3821          I2C.asm:429 (unused)
I2C_MemWrReady = $0EEC =  3820          I2C.asm:428
I2C_MemWrRepeat = $0EDB =  3803          I2C.asm:416
I2C_MemWrStore = $0F05 =  3845          I2C.asm:444
I2C_MemWrWrite = $0EF5 =  3829          I2C.asm:433
I2C_Open      = $0DB3 =  3507          I2C.asm:10
I2C_PORT      = $0021 =    33          I2C.asm:88
I2C_QUIES     = $0081 =   129          I2C.asm:93
I2C_RAMCPY    = $FB9F = 64415          Z80Mini.asm:413
I2C_RD        = $163B =  5691          Monitor.asm:669
I2C_RD_LOOP   = $164A =  5706          Monitor.asm:680
I2C_RD_RR     = $166A =  5738          Monitor.asm:707
I2C_RD_RR_LOOP = $1676 =  5750          Monitor.asm:717
I2C_RR        = $FBA1 = 64417          Z80Mini.asm:415
I2C_RdPort    = $0E6A =  3690          I2C.asm:254
I2C_Read      = $0DFA =  3578          I2C.asm:163
I2C_ReadNoAck = $0E1C =  3612          I2C.asm:183
I2C_ReadRd_Loop = $0E02 =  3586          I2C.asm:168
I2C_ReadRotate = $0E0E =  3598          I2C.asm:174
I2C_SCL_HI    = $0E44 =  3652          I2C.asm:231
I2C_SCL_LO    = $0E4B =  3659          I2C.asm:235
I2C_SCL_RD    = $0000 =     0          I2C.asm:92 (unused)
I2C_SCL_WR    = $0000 =     0          I2C.asm:91
I2C_SDA_HI    = $0E52 =  3666          I2C.asm:239
I2C_SDA_LO    = $0E59 =  3673          I2C.asm:243
I2C_SDA_RD    = $0007 =     7          I2C.asm:90
I2C_SDA_WR    = $0007 =     7          I2C.asm:89
I2C_Start     = $0E27 =  3623          I2C.asm:198
I2C_Stop      = $0E32 =  3634          I2C.asm:214
I2C_WR_DD     = $15F0 =  5616          Monitor.asm:598
I2C_WR_DD_LOOP = $15FC =  5628          Monitor.asm:608
I2C_WR_RR_DD  = $1611 =  5649          Monitor.asm:630
I2C_WR_RR_DD_LOOP = $161D =  5661          Monitor.asm:640
I2C_WrPort    = $0E5E =  3678          I2C.asm:246
I2C_Write     = $0DBD =  3517          I2C.asm:116
I2C_WriteBit_Clk = $0DCE =  3534          I2C.asm:125
I2C_WriteBit_Hi = $0DCB =  3531          I2C.asm:124
I2C_WriteNoAck = $0DEB =  3563          I2C.asm:143
I2C_WriteWr_Loop = $0DC2 =  3522          I2C.asm:120
ID            = $0016 =    22          MSBasic.asm:113
IDTEST        = $70AD = 28845          MSBasic.asm:2532
IF            = $6A22 = 27170          MSBasic.asm:1582
IFGO          = $6A30 = 27184          MSBasic.asm:1589
IFJMP         = $67D3 = 26579          MSBasic.asm:1219
INBUF         = $13D9 =  5081          Monitor.asm:203
INCH          = $0F57 =  3927          Serial.asm:39 (unused)
INCHL         = $76A1 = 30369          MSBasic.asm:3509
INCLEN        = $668D = 26253          MSBasic.asm:1032
INC_CURSOR    = $066C =  1644          LCD.asm:1006
INC_ROW       = $0679 =  1657          LCD.asm:1013
INDFND        = $6357 = 25431          MSBasic.asm:553
INEWLN        = $643C = 25660          MSBasic.asm:682
INIT          = $6018 = 24600          MSBasic.asm:140
INITAB        = $62C5 = 25285          MSBasic.asm:481
INITBE        = $6325 = 25381          MSBasic.asm:524
INITST        = $7C43 = 31811          MSBasic.asm:4361
INIT_BASIC    = $07A9 =  1961          LCD.asm:1304
INIT_LCD      = $028D =   653          LCD.asm:183
INIT_SERIAL   = $0F26 =  3878          Serial.asm:1
INIT_TERMINAL = $0596 =  1430          LCD.asm:839
INMSG         = $632C = 25388          MSBasic.asm:529
INP           = $7387 = 29575          MSBasic.asm:2999
INPBIN        = $6BB7 = 27575          MSBasic.asm:1782
INPBRK        = $684B = 26699          MSBasic.asm:1317
INPORT        = $803F = 32831          MSBasic.asm:47
INPORT_MON    = $13F6 =  5110          Monitor.asm:241
INPSUB        = $803E = 32830          MSBasic.asm:46
INPUT         = $6B25 = 27429          MSBasic.asm:1703
INRNG         = $782B = 30763          MSBasic.asm:3769
INSBUF        = $1212 =  4626          Utils.asm:122 (unused)
INT           = $771E = 30494          MSBasic.asm:3610
INTEL1        = $0FBF =  4031          Serial.asm:165
INTEL2        = $0FEA =  4074          Serial.asm:194
INTEL4        = $1005 =  4101          Serial.asm:212
INTELH        = $0FBB =  4027          Serial.asm:161
INTELLOADER   = $0F8A =  3978          Serial.asm:124
INTVAR        = $64B0 = 25776          MSBasic.asm:770
INVERSE       = $FB95 = 64405          Z80Mini.asm:402
INVSGN        = $7674 = 30324          MSBasic.asm:3476
INV_BIT       = $074D =  1869          LCD.asm:1176
INV_GRAPHIC   = $0715 =  1813          LCD.asm:1125
ITHEX1        = $0FAD =  4013          Serial.asm:146
ITMSEP        = $6BA8 = 27560          MSBasic.asm:1773
JJUMP1        = $7C36 = 31798          MSBasic.asm:4349 (unused)
JSTZER        = $78B4 = 30900          MSBasic.asm:3854
KDOWN         = $00B6 =   182          Z80Mini.asm:55
KEYREAD       = $1077 =  4215          Keyboard.asm:61
KEYREADINIT   = $10B7 =  4279          Keyboard.asm:107
KEY_IN        = $0040 =    64          Z80Mini.asm:45
KEY_OUT       = $0040 =    64          Z80Mini.asm:46
KEY_READ      = $FBCD = 64461          Z80Mini.asm:427
KEY_SHIFT     = $FBCC = 64460          Z80Mini.asm:426
KF1           = $0080 =   128          Z80Mini.asm:56
KF2           = $0081 =   129          Z80Mini.asm:57
KF3           = $0082 =   130          Z80Mini.asm:58
KF4           = $0083 =   131          Z80Mini.asm:59
KF5           = $0084 =   132          Z80Mini.asm:60
KILFOR        = $6C59 = 27737          MSBasic.asm:1863
KILIN         = $65D3 = 26067          MSBasic.asm:932
KLEFT         = $00B4 =   180          Z80Mini.asm:52
KRIGHT        = $00B7 =   183          Z80Mini.asm:53
KUP           = $00B5 =   181          Z80Mini.asm:54
LCDCTRL       = $0070 =   112          Z80Mini.asm:43 (unused)
LCDDATA       = $0071 =   113          Z80Mini.asm:44 (unused)
LCD_CLEAR     = $022F =   559          LCD.asm:92
LCD_CR        = $0223 =   547          LCD.asm:76
LCD_DATA      = $077E =  1918          LCD.asm:1245
LCD_DR        = $0071 =   113          LCD.asm:51
LCD_IMAGE_128x64 = $0274 =   628          LCD.asm:163
LCD_INST      = $0779 =  1913          LCD.asm:1228
LCD_IR        = $0070 =   112          LCD.asm:50
LCD_PRINT_A   = $0235 =   565          LCD.asm:101
LCD_PRINT_A_FIM = $0254 =   596          LCD.asm:122
LCD_PRINT_A_OK = $0251 =   593          LCD.asm:120
LCD_PRINT_STRING = $0264 =   612          LCD.asm:144
LCD_SER       = $0000 =     0          LCD.asm:52
LCD_SPACE     = $0229 =   553          LCD.asm:84
LCRFLG        = $80AC = 32940          MSBasic.asm:68
LEDS_ONBOARD  = $0010 =    16          Z80Mini.asm:47
LED_GREEN     = $11E7 =  4583          Utils.asm:73
LED_ONBOARD   = $FB9D = 64413          Z80Mini.asm:409
LED_RED       = $11D8 =  4568          Utils.asm:59
LEFT          = $72E4 = 29412          MSBasic.asm:2888
LEN           = $72B4 = 29364          MSBasic.asm:2858
LET           = $69AA = 27050          MSBasic.asm:1517
LETNUM        = $69FD = 27133          MSBasic.asm:1559
LETSTR        = $69C5 = 27077          MSBasic.asm:1530
LF            = $000A =    10          Z80Mini.asm:68
LFRGNM        = $737D = 29565          MSBasic.asm:2990
LINEAT        = $805C = 32860          MSBasic.asm:63
LINEIN        = $77DD = 30685          MSBasic.asm:3730
LINES         = $7B10 = 31504          MSBasic.asm:4151
LINESC        = $8046 = 32838          MSBasic.asm:53
LINESN        = $8048 = 32840          MSBasic.asm:54
LINE_LOOP     = $0395 =   917          LCD.asm:407
LINFND        = $6425 = 25637          MSBasic.asm:668
LIST          = $66A8 = 26280          MSBasic.asm:1049
LISTLOOP      = $0E7C =  3708          I2C.asm:329
LISTLP        = $66B4 = 26292          MSBasic.asm:1055
LISTNEXT      = $0E8D =  3725          I2C.asm:338
LISTTEST      = $0E99 =  3737          I2C.asm:351
LL2           = $03C0 =   960          LCD.asm:439
LL3           = $03CD =   973          LCD.asm:447
LOADFP        = $769A = 30362          MSBasic.asm:3502
LOG           = $74FF = 29951          MSBasic.asm:3243
LOGTAB        = $74F2 = 29938          MSBasic.asm:3238
LOKFOR        = $6341 = 25409          MSBasic.asm:536
LOOPST        = $80C7 = 32967          MSBasic.asm:77
LOOP_MONITOR  = $01BF =   447          Z80Mini.asm:242
LS            = $001C =    28          MSBasic.asm:116
LSTBIN        = $80CC = 32972          MSBasic.asm:80
LSTLP2        = $66D4 = 26324          MSBasic.asm:1076
LSTLP3        = $66D7 = 26327          MSBasic.asm:1077
LSTRAM        = $80AF = 32943          MSBasic.asm:71
LSTRND        = $803A = 32826          MSBasic.asm:45
LTSTND        = $6BC2 = 27586          MSBasic.asm:1787
LWIDTH        = $8042 = 32834          MSBasic.asm:49
L_fim         = $1114 =  4372          Keyboard.asm:169
LoopBC        = $11B4 =  4532          Utils.asm:11
LoopDE        = $11B1 =  4529          Utils.asm:9
MAKINT        = $73CD = 29645          MSBasic.asm:3032
MAKNUM        = $7847 = 30791          MSBasic.asm:3784
MANLP         = $7766 = 30566          MSBasic.asm:3655
MATCH         = $6570 = 25968          MSBasic.asm:872
MDIFY1        = $131D =  4893          Monitor.asm:72
MDIFY2        = $1358 =  4952          Monitor.asm:108
MEMMSG        = $60CF = 24783          MSBasic.asm:224
MID           = $731E = 29470          MSBasic.asm:2928
MID1          = $72EA = 29418          MSBasic.asm:2892
MIDNUM        = $7382 = 29570          MSBasic.asm:2993
MINCDE        = $7445 = 29765          MSBasic.asm:3099
MINUS         = $6D48 = 27976          MSBasic.asm:1990
MKTMST        = $70F1 = 28913          MSBasic.asm:2574
MLDBLP        = $773F = 30527          MSBasic.asm:3631
MLDEBC        = $7737 = 30519          MSBasic.asm:3626
MLOOP         = $6048 = 24648          MSBasic.asm:161
MLSP10        = $7634 = 30260          MSBasic.asm:3437
MO            = $0024 =    36          MSBasic.asm:120
MODIFY        = $1307 =  4871          Monitor.asm:57
MONITR        = $7C40 = 31808          MSBasic.asm:4357
MONOUT        = $7C3D = 31805          MSBasic.asm:4353
MORDT         = $6BCE = 27598          MSBasic.asm:1792
MORINP        = $65E2 = 26082          MSBasic.asm:940
MOVBUF        = $645B = 25691          MSBasic.asm:703
MOVDIR        = $6578 = 25976          MSBasic.asm:880
MOVE_DOWN     = $06DC =  1756          LCD.asm:1077
MOVE_UP       = $06CE =  1742          LCD.asm:1068 (unused)
MOVE_VPORT    = $06C7 =  1735          LCD.asm:1063
MOVLP         = $6366 = 25446          MSBasic.asm:563
MOVSTR        = $6363 = 25443          MSBasic.asm:560
MOVUP         = $6360 = 25440          MSBasic.asm:559
MRPRNT        = $6A42 = 27202          MSBasic.asm:1596
MSGBUF        = $FBA9 = 64425          Z80Mini.asm:422
MSG_BASIC     = $186B =  6251          Z80Mini.asm:351
MSG_COPYFAIL  = $18B0 =  6320          Z80Mini.asm:361
MSG_COPYOK    = $18A8 =  6312          Z80Mini.asm:360
MSG_CPU2MEM   = $18F8 =  6392          Z80Mini.asm:368
MSG_DEV_ADDR  = $18CC =  6348          Z80Mini.asm:364
MSG_DEV_DATA  = $18ED =  6381          Z80Mini.asm:366
MSG_DEV_REG   = $18DE =  6366          Z80Mini.asm:365
MSG_EOF       = $18BA =  6330          Z80Mini.asm:362
MSG_FROM      = $188E =  6286          Z80Mini.asm:357
MSG_I2C_RD    = $1946 =  6470          Z80Mini.asm:372
MSG_I2C_RD_RR = $1955 =  6485          Z80Mini.asm:373
MSG_I2C_WR_DD = $1922 =  6434          Z80Mini.asm:370
MSG_I2C_WR_RR_DD = $1932 =  6450          Z80Mini.asm:371
MSG_ILOAD     = $1834 =  6196          Z80Mini.asm:347
MSG_MEM2CPU   = $190D =  6413          Z80Mini.asm:369
MSG_MENU0     = $16FB =  5883          Z80Mini.asm:324
MSG_MENU1     = $170E =  5902          Z80Mini.asm:325
MSG_MENU10    = $175E =  5982          Z80Mini.asm:332
MSG_MENU11    = $176F =  5999          Z80Mini.asm:333
MSG_MENU12    = $177F =  6015          Z80Mini.asm:334
MSG_MENU13    = $178C =  6028          Z80Mini.asm:335
MSG_MENU14    = $1795 =  6037          Z80Mini.asm:336
MSG_MENU15    = $17A1 =  6049          Z80Mini.asm:337
MSG_MENU16    = $17B2 =  6066          Z80Mini.asm:338
MSG_MENU17    = $17C3 =  6083          Z80Mini.asm:339
MSG_MENU18    = $17D3 =  6099          Z80Mini.asm:340
MSG_MENU19    = $17E6 =  6118          Z80Mini.asm:341
MSG_MENU2     = $1723 =  5923          Z80Mini.asm:326
MSG_MENU20    = $17FB =  6139          Z80Mini.asm:342
MSG_MENU21    = $180F =  6159          Z80Mini.asm:343
MSG_MENU3     = $172D =  5933          Z80Mini.asm:327
MSG_MENU4     = $1737 =  5943          Z80Mini.asm:328
MSG_MENU8     = $1741 =  5953          Z80Mini.asm:330
MSG_MENU9     = $174C =  5964          Z80Mini.asm:331
MSG_READFILE_EXE = $187F =  6271          Z80Mini.asm:353
MSG_READFILE_IMG = $1884 =  6276          Z80Mini.asm:354
MSG_READFILE_TXT = $1889 =  6281          Z80Mini.asm:355
MSG_SIZE      = $189A =  6298          Z80Mini.asm:359
MSG_TO        = $1895 =  6293          Z80Mini.asm:358
MSIZE         = $6035 = 24629          MSBasic.asm:154
MUL8LP        = $756B = 30059          MSBasic.asm:3298
MULLN2        = $7537 = 30007          MSBasic.asm:3269
MULT          = $753E = 30014          MSBasic.asm:3273
MULT8         = $7562 = 30050          MSBasic.asm:3292
MULTEN        = $77A8 = 30632          MSBasic.asm:3691
MULVAL        = $80F6 = 33014          MSBasic.asm:96
MVSTPT        = $69F4 = 27124          MSBasic.asm:1553
NDOT          = $13C4 =  5060          Monitor.asm:185
NEDMOR        = $6B61 = 27489          MSBasic.asm:1736
NEGAFT        = $78DF = 30943          MSBasic.asm:3878
NEW           = $64A0 = 25760          MSBasic.asm:758
NEXITM        = $6AFA = 27386          MSBasic.asm:1689
NEXT          = $6C1E = 27678          MSBasic.asm:1831
NEXT1         = $6C21 = 27681          MSBasic.asm:1832
NEXT_CIRCLE   = $04AE =  1198          LCD.asm:618
NEXT_CMD      = $0292 =   658          LCD.asm:186
NEXT_PIXEL    = $032B =   811          LCD.asm:308
NF            = $0000 =     0          MSBasic.asm:102
NFERR         = $639A = 25498          MSBasic.asm:597
NIBBLE_TO_GLCD = $0640 =  1600          LCD.asm:960
NMIFLG        = $804C = 32844          MSBasic.asm:56 (unused)
NOCHNG        = $6568 = 25960          MSBasic.asm:867
NOENED        = $78B7 = 30903          MSBasic.asm:3857
NOLIN         = $6861 = 26721          MSBasic.asm:1328
NOMADD        = $757C = 30076          MSBasic.asm:3309
NOMLAD        = $774D = 30541          MSBasic.asm:3639
NOPMPT        = $6B3F = 27455          MSBasic.asm:1715
NOP_TIME      = $1168 =  4456          Keyboard.asm:226
NORMAL        = $7470 = 29808          MSBasic.asm:3134
NOSPC         = $655F = 25951          MSBasic.asm:862
NOSUB7        = $7BC2 = 31682          MSBasic.asm:4266
NOSWAP        = $741F = 29727          MSBasic.asm:3080
NOTAMP        = $6D1D = 27933          MSBasic.asm:1971
NOTSTR        = $6E97 = 28311          MSBasic.asm:2201
NOXOR         = $73AD = 29613          MSBasic.asm:3016
NSCFOR        = $6EA7 = 28327          MSBasic.asm:2209
NULFLG        = $8044 = 32836          MSBasic.asm:51
NULL          = $6885 = 26757          MSBasic.asm:1347
NULLP         = $6AB5 = 27317          MSBasic.asm:1651
NULLS         = $8041 = 32833          MSBasic.asm:48
NUMASC        = $77F0 = 30704          MSBasic.asm:3740
NXTARY        = $6F5E = 28510          MSBasic.asm:2322
NXTBYT        = $654E = 25934          MSBasic.asm:852
NXTCHR        = $658F = 25999          MSBasic.asm:892
NXTDAT        = $80DC = 32988          MSBasic.asm:89
NXTDTA        = $6992 = 27026          MSBasic.asm:1499
NXTITM        = $6B59 = 27481          MSBasic.asm:1731
NXTOPR        = $80D0 = 32976          MSBasic.asm:83
NXTSTL        = $6999 = 27033          MSBasic.asm:1504
NXTSTT        = $699C = 27036          MSBasic.asm:1507
NYBASC        = $120A =  4618          Utils.asm:114
NYBOUT        = $121B =  4635          Utils.asm:138
OD            = $0006 =     6          MSBasic.asm:105
OKMSG         = $6331 = 25393          MSBasic.asm:531
OM            = $000C =    12          MSBasic.asm:108
OMERR         = $6389 = 25481          MSBasic.asm:588
ON            = $6A04 = 27140          MSBasic.asm:1565
ONGO          = $6A13 = 27155          MSBasic.asm:1573
ONGOLP        = $6A14 = 27156          MSBasic.asm:1574
ONJMP         = $67D4 = 26580          MSBasic.asm:1224
OPNPAR        = $6C77 = 27767          MSBasic.asm:1881
OPRND         = $6CF2 = 27890          MSBasic.asm:1954
OS            = $001A =    26          MSBasic.asm:115
OTKLN         = $65D0 = 26064          MSBasic.asm:931
OTPORT        = $8007 = 32775          MSBasic.asm:38
OUTC          = $666D = 26221          MSBasic.asm:1015
OUTCH         = $0F51 =  3921          Serial.asm:34
OUTEXP        = $78A8 = 30888          MSBasic.asm:3847
OUTIT         = $664E = 26190          MSBasic.asm:993
OUTNBS        = $6654 = 26196          MSBasic.asm:996
OUTNCR        = $7C54 = 31828          MSBasic.asm:4375
OUTPORT       = $13DD =  5085          Monitor.asm:219
OUTSUB        = $8006 = 32774          MSBasic.asm:37
OUTWRD        = $66F0 = 26352          MSBasic.asm:1091
OV            = $000A =    10          MSBasic.asm:107
OVERR         = $63A3 = 25507          MSBasic.asm:603
OVTST1        = $7627 = 30247          MSBasic.asm:3429
OVTST2        = $762C = 30252          MSBasic.asm:3432
OVTST3        = $762D = 30253          MSBasic.asm:3433
PADD          = $77CC = 30668          MSBasic.asm:3716
PAND          = $6DB3 = 28083          MSBasic.asm:2057
PASSA         = $7033 = 28723          MSBasic.asm:2459
PBUFF         = $80E9 = 33001          MSBasic.asm:95
PC_LOOP       = $0577 =  1399          LCD.asm:805
PEEK          = $73DB = 29659          MSBasic.asm:3041
PEND          = $6846 = 26694          MSBasic.asm:1314
PHLTFP        = $7689 = 30345          MSBasic.asm:3492
PIXEL_X       = $FB96 = 64406          Z80Mini.asm:403
PLOT_BIT      = $0751 =  1873          LCD.asm:1180
PLOT_BYTE     = $073A =  1850          LCD.asm:1160
PLOT_COLUMN   = $052A =  1322          LCD.asm:739
PLOT_GRAPHIC  = $0730 =  1840          LCD.asm:1154
PLOT_ROW      = $0512 =  1298          LCD.asm:727
PLOT_TO_LCD   = $050D =  1293          LCD.asm:724
PLUCDE        = $74AA = 29866          MSBasic.asm:3176
PNORM         = $7478 = 29816          MSBasic.asm:3142
POINT         = $8051 = 32849          MSBasic.asm:59
POKE          = $73E2 = 29666          MSBasic.asm:3045
POPAF         = $7177 = 29047          MSBasic.asm:2652
POPHL         = $72A1 = 29345          MSBasic.asm:2843
POPHRT        = $758C = 30092          MSBasic.asm:3323
POPNOK        = $63DE = 25566          MSBasic.asm:631
POR           = $6DB2 = 28082          MSBasic.asm:2056
POR1          = $6DD5 = 28117          MSBasic.asm:2080
POS           = $7030 = 28720          MSBasic.asm:2458
POSINT        = $68A5 = 26789          MSBasic.asm:1370
POUT          = $7393 = 29587          MSBasic.asm:3004
POWER         = $78ED = 30957          MSBasic.asm:3886
POWER1        = $78FD = 30973          MSBasic.asm:3894
POWER2        = $791A = 31002          MSBasic.asm:3912
POWERS        = $78CD = 30925          MSBasic.asm:3871
PRINT         = $6A46 = 27206          MSBasic.asm:1598
PRINT_CHARS   = $0561 =  1377          LCD.asm:792
PRINT_STRING  = $053F =  1343          LCD.asm:761
PRITAB        = $6286 = 25222          MSBasic.asm:434
PRNTCRLF      = $6AA4 = 27300          MSBasic.asm:1644
PRNTHL        = $77E5 = 30693          MSBasic.asm:3734
PRNTLP        = $6A49 = 27209          MSBasic.asm:1599
PRNTNB        = $6A8C = 27276          MSBasic.asm:1631
PRNTOK        = $63DF = 25567          MSBasic.asm:633
PRNTST        = $6A90 = 27280          MSBasic.asm:1633
PRNUMS        = $7141 = 28993          MSBasic.asm:2621
PROCES        = $65FB = 26107          MSBasic.asm:951
PROGND        = $80D6 = 32982          MSBasic.asm:86
PROGST        = $80F9 = 33017          MSBasic.asm:97
PROMPT        = $64E3 = 25827          MSBasic.asm:795
PRS           = $7142 = 28994          MSBasic.asm:2622
PRS1          = $7145 = 28997          MSBasic.asm:2623
PRSLP         = $714C = 29004          MSBasic.asm:2626
PS1           = $061A =  1562          LCD.asm:931
PSET          = $8054 = 32852          MSBasic.asm:60
PSUB          = $7400 = 29696          MSBasic.asm:3061
PTRLP         = $6468 = 25704          MSBasic.asm:712
PUTBUF        = $663A = 26170          MSBasic.asm:982
PUTCH         = $FB99 = 64409          Z80Mini.asm:406
PUTCTL        = $663F = 26175          MSBasic.asm:984
PUTFID        = $67A8 = 26536          MSBasic.asm:1193
QTSTLP        = $7107 = 28935          MSBasic.asm:2591
QTSTR         = $7101 = 28929          MSBasic.asm:2587
QUARTR        = $7A86 = 31366          MSBasic.asm:4089
RAD           = $FB8E = 64398          Z80Mini.asm:395
READ          = $6B54 = 27476          MSBasic.asm:1728
READFG        = $80CD = 32973          MSBasic.asm:81
READ_FILE     = $1428 =  5160          Monitor.asm:278
READ_FILE_EXE = $148D =  5261          Monitor.asm:341
READ_FILE_IMG = $14A3 =  5283          Monitor.asm:360
READ_FILE_IMG_K = $14BB =  5307          Monitor.asm:380
READ_FILE_TXT = $14C6 =  5318          Monitor.asm:387
READ_FILE_TXT_L = $14D4 =  5332          Monitor.asm:401
READ_IIC_DE   = $14F9 =  5369          Monitor.asm:430
READ_MEM_FILES = $1410 =  5136          Monitor.asm:265
READ_MEM_KEY  = $143E =  5182          Monitor.asm:291
READ_MEM_NEXT = $1413 =  5139          Monitor.asm:267
READ_MEM_STEP = $1476 =  5238          Monitor.asm:322
READ_MEM_STEP_L = $1481 =  5249          Monitor.asm:330
READ_NAME     = $1430 =  5168          Monitor.asm:282
REDO          = $6B01 = 27393          MSBasic.asm:1693
REM           = $6995 = 27029          MSBasic.asm:1502
REMOVE_PIXEL  = $075B =  1883          LCD.asm:1186
RESDIV        = $75D9 = 30169          MSBasic.asm:3374
RESEED        = $7A24 = 31268          MSBasic.asm:4045
RESET         = $8057 = 32855          MSBasic.asm:61
RESET_WARM    = $0197 =   407          Z80Mini.asm:215
RESTNL        = $6821 = 26657          MSBasic.asm:1284
RESTOR        = $680C = 26636          MSBasic.asm:1273
RESZER        = $746B = 29803          MSBasic.asm:3130
RETADR        = $6F0E = 28430          MSBasic.asm:2269
RETINT        = $7662 = 30306          MSBasic.asm:3465
RETLIN        = $698D = 27021          MSBasic.asm:1496
RETNAD        = $6574 = 25972          MSBasic.asm:876
RETNUL        = $6F11 = 28433          MSBasic.asm:2273
RETNUM        = $6D54 = 27988          MSBasic.asm:1995
RETREL        = $7654 = 30292          MSBasic.asm:3455
RETURN        = $696E = 26990          MSBasic.asm:1480
RG            = $0004 =     4          MSBasic.asm:104
RIGHT         = $7314 = 29460          MSBasic.asm:2921
RIGHT1        = $72E8 = 29416          MSBasic.asm:2890
RINPUT        = $804E = 32846          MSBasic.asm:58
RLTLP         = $6C97 = 27799          MSBasic.asm:1897
RND           = $79C3 = 31171          MSBasic.asm:3992
RND1          = $79FF = 31231          MSBasic.asm:4023
RND2          = $7A1B = 31259          MSBasic.asm:4041
RNDTAB        = $7A2C = 31276          MSBasic.asm:4052
RNGTST        = $78BA = 30906          MSBasic.asm:3861
RONDB         = $748C = 29836          MSBasic.asm:3154
RONDUP        = $748B = 29835          MSBasic.asm:3153
ROUND         = $73F3 = 29683          MSBasic.asm:3055
ROWS          = $07A5 =  1957          LCD.asm:1302
RSCALE        = $77C6 = 30662          MSBasic.asm:3714
RSLNBK        = $672A = 26410          MSBasic.asm:1123
RST00         = $0000 =     0          Z80Mini.asm:111 (unused)
RST08         = $0008 =     8          Z80Mini.asm:115 (unused)
RST10         = $0010 =    16          Z80Mini.asm:118 (unused)
RST18         = $0018 =    24          Z80Mini.asm:121 (unused)
RST20         = $001B =    27          Z80Mini.asm:123 (unused)
RST28         = $0021 =    33          Z80Mini.asm:126 (unused)
RST30         = $0030 =    48          Z80Mini.asm:130 (unused)
RST38         = $0031 =    49          Z80Mini.asm:132 (unused)
RST66         = $003A =    58          Z80Mini.asm:135 (unused)
RSTSTR        = $7337 = 29495          MSBasic.asm:2941
RUN           = $6933 = 26931          MSBasic.asm:1447
RUNCNT        = $67AC = 26540          MSBasic.asm:1197
RUNFST        = $64AC = 25772          MSBasic.asm:767
RUNLIN        = $694F = 26959          MSBasic.asm:1463
RXDATA        = $0F7E =  3966          Serial.asm:107
SAVEXP        = $746C = 29804          MSBasic.asm:3131
SAVE_COL      = $06EC =  1772          LCD.asm:1090
SAVE_ROW      = $068D =  1677          LCD.asm:1024
SAVE_VPORT    = $06D7 =  1751          LCD.asm:1073
SAVSTP        = $679F = 26527          MSBasic.asm:1186
SAVSTR        = $70DC = 28892          MSBasic.asm:2558
SBSCPT        = $6F1C = 28444          MSBasic.asm:2279
SBUF          = $0780 =  1920          Z80Mini.asm:383
SCALE         = $74CA = 29898          MSBasic.asm:3208
SCALLP        = $74CC = 29900          MSBasic.asm:3209
SCALMI        = $7791 = 30609          MSBasic.asm:3676
SCALPL        = $77A7 = 30631          MSBasic.asm:3690
SCNEND        = $7213 = 29203          MSBasic.asm:2748
SCPTLP        = $6F22 = 28450          MSBasic.asm:2283
SDMSG1        = $0F5F =  3935          Serial.asm:58
SDMSG2        = $0F6A =  3946          Serial.asm:64
SEARCH        = $653C = 25916          MSBasic.asm:838
SEED          = $8017 = 32791          MSBasic.asm:44
SEND_A_TO_GLCD = $0632 =  1586          LCD.asm:949
SEND_CHAR_TO_GLCD = $05AA =  1450          LCD.asm:861
SEND_HL_TO_GLCD = $064F =  1615          LCD.asm:972
SEND_PART     = $078C =  1932          LCD.asm:1268
SEND_STRING_TO_GLCD = $0619 =  1561          LCD.asm:929
SER_BT        = $00F8 =   248          LCD.asm:61 (unused)
SER_BYTE      = $0783 =  1923          LCD.asm:1260 (unused)
SER_SYNC      = $0791 =  1937          LCD.asm:1275
SETIO         = $73B7 = 29623          MSBasic.asm:3023
SETLIN        = $66FE = 26366          MSBasic.asm:1099
SETLIT        = $6586 = 25990          MSBasic.asm:888
SETPTR        = $6463 = 25699          MSBasic.asm:709
SETTOP        = $606C = 24684          MSBasic.asm:186
SET_BUF_CLEAR = $0589 =  1417          LCD.asm:825
SET_BUF_NO_CLEAR = $0591 =  1425          LCD.asm:830
SET_CURSOR    = $065B =  1627          LCD.asm:985
SET_GBUF      = $04EE =  1262          LCD.asm:694
SET_GR_MODE   = $02F0 =   752          LCD.asm:246
SET_TXT_MODE  = $02FA =   762          LCD.asm:253
SFTPRG        = $642D = 25645          MSBasic.asm:672
SGN           = $765A = 30298          MSBasic.asm:3462
SGNEXP        = $6DA2 = 28066          MSBasic.asm:2043
SGNRES        = $80E8 = 33000          MSBasic.asm:94
SHIFT_BIT     = $0507 =  1287          LCD.asm:716
SHIFT_BUFFER  = $0691 =  1681          LCD.asm:1031
SHOW_MENU     = $1221 =  4641          Menu.asm:1
SHOW_MSG_EXE  = $14E4 =  5348          Monitor.asm:414
SHOW_MSG_IMG  = $14EB =  5355          Monitor.asm:419
SHOW_MSG_TXT  = $14F2 =  5362          Monitor.asm:424
SHRITE        = $74D9 = 29913          MSBasic.asm:3217
SHRLP         = $74DC = 29916          MSBasic.asm:3219
SHRT1         = $74E0 = 29920          MSBasic.asm:3223
SIGNON        = $60BC = 24764          MSBasic.asm:219
SIGNS         = $76B1 = 30385          MSBasic.asm:3522
SIN           = $7A3E = 31294          MSBasic.asm:4058
SIN1          = $7A6E = 31342          MSBasic.asm:4078
SINTAB        = $7A8A = 31370          MSBasic.asm:4091
SIOA_C        = $0002 =     2          Z80Mini.asm:94
SIOA_D        = $0000 =     0          Z80Mini.asm:93
SIOB_C        = $0003 =     3          Z80Mini.asm:96 (unused)
SIOB_D        = $0001 =     1          Z80Mini.asm:95 (unused)
SIXDIG        = $780D = 30733          MSBasic.asm:3754
SKIP_TBUF     = $06A5 =  1701          LCD.asm:1042
SMPVAR        = $71A7 = 29095          MSBasic.asm:2676
SMSER1        = $79A2 = 31138          MSBasic.asm:3970
SN            = $0002 =     2          MSBasic.asm:103
SNDSTR        = $0F5D =  3933          Serial.asm:57
SNERR         = $6394 = 25492          MSBasic.asm:593
SPACE         = $0020 =    32          LCD.asm:69
SPCBUF        = $13D7 =  5079          Monitor.asm:202
SPCFST        = $77FE = 30718          MSBasic.asm:3746
SPCLP         = $6AF3 = 27379          MSBasic.asm:1686
SPI_WR        = $0792 =  1938          LCD.asm:1285
SQR           = $78E4 = 30948          MSBasic.asm:3882
SRCHLN        = $6480 = 25728          MSBasic.asm:731
SRCHLP        = $6483 = 25731          MSBasic.asm:732
SSTSA         = $726F = 29295          MSBasic.asm:2808
ST            = $001E =    30          MSBasic.asm:117
STACK         = $8066 = 32870          MSBasic.asm:66
STAKFP        = $767C = 30332          MSBasic.asm:3482
STALL         = $6835 = 26677          MSBasic.asm:1301
STARTB        = $6006 = 24582          MSBasic.asm:128
START_BASIC   = $12BF =  4799          Monitor.asm:4
START_BASIC_KEY = $12CC =  4812          Monitor.asm:11
START_SYSTEM  = $0190 =   400          Z80Mini.asm:210
STKTHS        = $6CDB = 27867          MSBasic.asm:1938
STLOOK        = $815D = 33117          MSBasic.asm:98
STOP          = $6844 = 26692          MSBasic.asm:1312
STORED        = $6910 = 26896          MSBasic.asm:1427
STPOOL        = $71EA = 29162          MSBasic.asm:2713
STR           = $70CC = 28876          MSBasic.asm:2551
STR1          = $70D2 = 28882          MSBasic.asm:2553
STRADD        = $71ED = 29165          MSBasic.asm:2715
STRBOT        = $80C3 = 32963          MSBasic.asm:75
STRENT        = $6BAB = 27563          MSBasic.asm:1775
STRSPC        = $805A = 32858          MSBasic.asm:62
STTLIN        = $6A97 = 27287          MSBasic.asm:1637
SUBCDE        = $7402 = 29698          MSBasic.asm:3063
SUBPHL        = $73FC = 29692          MSBasic.asm:3059
SUMLP         = $79AB = 31147          MSBasic.asm:3975
SUMSER        = $7993 = 31123          MSBasic.asm:3963
SUPTLZ        = $788C = 30860          MSBasic.asm:3831
SVNAM2        = $6E7B = 28283          MSBasic.asm:2188
SVSTAD        = $70FA = 28922          MSBasic.asm:2579
SX            = $FB86 = 64390          Z80Mini.asm:390
SY            = $FB87 = 64391          Z80Mini.asm:391
SYSTEM_SP     = $FFF0 = 65520          Z80Mini.asm:101
TAB           = $0009 =     9          LCD.asm:65
TAN           = $7A9F = 31391          MSBasic.asm:4098
TBUF          = $FB82 = 64386          Z80Mini.asm:388
TESTOS        = $7179 = 29049          MSBasic.asm:2655
TESTR         = $715B = 29019          MSBasic.asm:2635
TGBUF         = $F780 = 63360          Z80Mini.asm:386
TIMEOUT       = $2710 = 10000          Z80Mini.asm:107
TM            = $0018 =    24          MSBasic.asm:114
TMERR         = $63A6 = 25510          MSBasic.asm:605
TMPSTR        = $80BF = 32959          MSBasic.asm:74
TMSTPL        = $80B3 = 32947          MSBasic.asm:73
TMSTPT        = $80B1 = 32945          MSBasic.asm:72
TOPOOL        = $72E0 = 29408          MSBasic.asm:2885
TOSTRA        = $7278 = 29304          MSBasic.asm:2817
TRYAGN        = $7867 = 30823          MSBasic.asm:3804
TSALP         = $7279 = 29305          MSBasic.asm:2818
TSTBIT        = $7C4D = 31821          MSBasic.asm:4368 (unused)
TSTBRK        = $6827 = 26663          MSBasic.asm:1290
TSTMEM        = $605A = 24666          MSBasic.asm:174
TSTNUM        = $6C6C = 27756          MSBasic.asm:1873
TSTOPL        = $7122 = 28962          MSBasic.asm:2607
TSTRED        = $6DDA = 28122          MSBasic.asm:2086
TSTREM        = $6589 = 25993          MSBasic.asm:889
TSTSGN        = $764B = 30283          MSBasic.asm:3450
TSTSTR        = $6C6D = 27757          MSBasic.asm:1874
TTYLIN        = $65D9 = 26073          MSBasic.asm:936
TXDATA        = $0F6B =  3947          Serial.asm:75
TYPE          = $80AD = 32941          MSBasic.asm:69
UF            = $0022 =    34          MSBasic.asm:119
UFERR         = $63A0 = 25504          MSBasic.asm:601
UL            = $000E =    14          MSBasic.asm:109
ULERR         = $6969 = 26985          MSBasic.asm:1477
UNITY         = $74EE = 29934          MSBasic.asm:3236
UP            = $00B5 =   181          LCD.asm:62
UPDATA        = $6822 = 26658          MSBasic.asm:1285
USR           = $8003 = 32771          MSBasic.asm:36
VAL           = $734E = 29518          MSBasic.asm:2960
VAL1          = $736C = 29548          MSBasic.asm:2980
VAL2          = $7376 = 29558          MSBasic.asm:2984
VAL3          = $7379 = 29561          MSBasic.asm:2985
VAREND        = $80D8 = 32984          MSBasic.asm:87
VPORT         = $FB80 = 64384          Z80Mini.asm:387
VT            = $000B =    11          Z80Mini.asm:69 (unused)
V_DELAY_US    = $0010 =    16          LCD.asm:53
WAIT          = $7399 = 29593          MSBasic.asm:3007
WAITLP        = $73AE = 29614          MSBasic.asm:3017
WARM          = $6003 = 24579          MSBasic.asm:127 (unused)
WARMST        = $60A4 = 24740          MSBasic.asm:213
WELLCOME      = $16D0 =  5840          Z80Mini.asm:321
WELLCOME_LCD  = $16E8 =  5864          Z80Mini.asm:322
WIDTH         = $7B08 = 31496          MSBasic.asm:4146
WORDS         = $6112 = 24850          MSBasic.asm:260
WORDTB        = $6238 = 25144          MSBasic.asm:356
WRDASC        = $11FC =  4604          Utils.asm:98
WRDOUT        = $1215 =  4629          Utils.asm:136
WRKSPC        = $8000 = 32768          MSBasic.asm:35
ZBYE          = $00D2 =   210          MSBasic.asm:410
ZDATA         = $0083 =   131          MSBasic.asm:404
ZDIV          = $00AF =   175          MSBasic.asm:423 (unused)
ZEND          = $0080 =   128          MSBasic.asm:402
ZEQUAL        = $00B4 =   180          MSBasic.asm:426
ZERARY        = $6FBD = 28605          MSBasic.asm:2382
ZERBYT        = $6330 = 25392          MSBasic.asm:530
ZEROLP        = $6F00 = 28416          MSBasic.asm:2260
ZEROSUP       = $7BE0 = 31712          MSBasic.asm:4287
ZFN           = $00A7 =   167          MSBasic.asm:414
ZFOR          = $0081 =   129          MSBasic.asm:403
ZGOSUB        = $008C =   140          MSBasic.asm:406
ZGOTO         = $0088 =   136          MSBasic.asm:405
ZGTR          = $00B3 =   179          MSBasic.asm:425
ZLEFT         = $00CF =   207          MSBasic.asm:430
ZLTH          = $00B5 =   181          MSBasic.asm:427
ZMINUS        = $00AD =   173          MSBasic.asm:421
ZNEW          = $00A4 =   164          MSBasic.asm:409
ZNOT          = $00AA =   170          MSBasic.asm:417
ZONELP        = $6ACE = 27342          MSBasic.asm:1665
ZOR           = $00B2 =   178          MSBasic.asm:424
ZPLUS         = $00AC =   172          MSBasic.asm:420
ZPOINT        = $00C7 =   199          MSBasic.asm:429 (unused)
ZPRINT        = $009E =   158          MSBasic.asm:408
ZREM          = $008E =   142          MSBasic.asm:407
ZSGN          = $00B6 =   182          MSBasic.asm:428
ZSPC          = $00A8 =   168          MSBasic.asm:415
ZSTEP         = $00AB =   171          MSBasic.asm:418
ZTAB          = $00A5 =   165          MSBasic.asm:412
ZTHEN         = $00A9 =   169          MSBasic.asm:416
ZTIMES        = $00AE =   174          MSBasic.asm:422 (unused)
ZTO           = $00A6 =   166          MSBasic.asm:413
_end          = $FBCE = 64462          Z80Mini.asm:110 (unused)
_size         = $FBCE = 64462          Z80Mini.asm:110 (unused)
_z80_         = $0001 =     1          Z80Mini.asm:1 (unused)
conoutA1      = $0F6C =  3948          Serial.asm:77
cruz          = $7C8F = 31887          MSBasic.asm:4425
custadd       = $67F6 = 26614          MSBasic.asm:1246
custtab       = $6282 = 25218          MSBasic.asm:396
debaunce_key  = $1133 =  4403          Keyboard.asm:196
diego         = $7C88 = 31880          MSBasic.asm:4420
i_read_key    = $107A =  4218          Keyboard.asm:65 (unused)
init_read_key = $10BA =  4282          Keyboard.asm:112
kCPUClock     = $8000 =7372800          Z80Mini.asm:83
kDelayCnt     = $011A =   282          Z80Mini.asm:88
kDelayLP      = $001A =    26          Z80Mini.asm:85
kDelayOH      = $0024 =    36          Z80Mini.asm:84
kDelayTA      = $1CCC =  7372          Z80Mini.asm:86
kDelayTB      = $1CA8 =  7336          Z80Mini.asm:87
k_read_fim    = $10AC =  4268          Keyboard.asm:91
k_read_loop   = $1097 =  4247          Keyboard.asm:79
key_read_fim  = $10EC =  4332          Keyboard.asm:138
key_read_loop = $10D7 =  4311          Keyboard.asm:126
line1         = $0068 =   104          Z80Mini.asm:139
line1_shift   = $00A9 =   169          Z80Mini.asm:144 (unused)
line2         = $0075 =   117          Z80Mini.asm:140
line2_shift   = $00B6 =   182          Z80Mini.asm:145 (unused)
line3         = $0082 =   130          Z80Mini.asm:141
line3_shift   = $00C3 =   195          Z80Mini.asm:146 (unused)
line4         = $008F =   143          Z80Mini.asm:142
line4_shift   = $00D0 =   208          Z80Mini.asm:147 (unused)
line5         = $009C =   156          Z80Mini.asm:143
line5_shift   = $00DD =   221          Z80Mini.asm:148 (unused)
load_a        = $1129 =  4393          Keyboard.asm:189
notcust       = $67E4 = 26596          MSBasic.asm:1235
r_key         = $1093 =  4243          Keyboard.asm:76
read_key      = $10D3 =  4307          Keyboard.asm:123
trata_key     = $10FA =  4346          Keyboard.asm:151
trata_line1   = $114A =  4426          Keyboard.asm:210
trata_line2   = $1150 =  4432          Keyboard.asm:213
trata_line3   = $1156 =  4438          Keyboard.asm:216
trata_line4   = $115C =  4444          Keyboard.asm:219
trata_line5   = $1162 =  4450          Keyboard.asm:222
waitForChar   = $0F7E =  3966          Serial.asm:108


total time: 0.2184 sec.
no errors
