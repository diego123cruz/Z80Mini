0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; GENERAL EQUATES
0017   0000             
0018   0000             CTRLC   .EQU    03H             ; Control "C"
0019   0000             CTRLG   .EQU    07H             ; Control "G"
0020   0000             BKSP    .EQU    08H             ; Back space
0021   0000             LF      .EQU    0AH             ; Line feed
0022   0000             CS      .EQU    0CH             ; Clear screen
0023   0000             CR      .EQU    0DH             ; Carriage return
0024   0000             CTRLO   .EQU    0FH             ; Control "O"
0025   0000             CTRLQ	.EQU	11H		        ; Control "Q"
0026   0000             CTRLR   .EQU    12H             ; Control "R"
0027   0000             CTRLS   .EQU    13H             ; Control "S"
0028   0000             CTRLU   .EQU    15H             ; Control "U"
0029   0000             ESC     .EQU    1BH             ; Escape
0030   0000             DEL     .EQU    7FH             ; Delete
0031   0000             
0032   0000             
0033   0000             ; BASIC WORK SPACE LOCATIONS
0034   0000             
0035   0000             WRKSPC  .EQU    8200H             ; BASIC Work space |33280|
0036   0000             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0037   0000             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0038   0000             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0039   0000             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0040   0000             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0041   0000             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0042   0000             DIV3    .EQU    WRKSPC+12H           ; <-   be
0043   0000             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0044   0000             SEED    .EQU    WRKSPC+17H           ; Random number seed
0045   0000             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0046   0000             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0047   0000             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0048   0000             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0049   0000             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0050   0000             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0051   0000             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0052   0000             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0053   0000             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0054   0000             LINESN  .EQU    WRKSPC+48H           ; Lines number
0055   0000             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0056   0000             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0057   0000             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0058   0000             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0059   0000             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0060   0000             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0061   0000             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0062   0000             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0063   0000             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0064   0000             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0065   0000             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0066   0000             STACK   .EQU    WRKSPC+66H           ; Initial stack
0067   0000             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0068   0000             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0069   0000             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0070   0000             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0071   0000             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0072   0000             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0073   0000             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0074   0000             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0075   0000             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0076   0000             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0077   0000             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0078   0000             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0079   0000             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0080   0000             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0081   0000             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0082   0000             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0083   0000             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0084   0000             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0085   0000             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0086   0000             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0087   0000             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0088   0000             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0089   0000             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0090   0000             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0091   0000             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0092   0000             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0093   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0094   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0095   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0096   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0097   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area |33280 + 249 = 33529|
0098   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0099   0000             
0100   0000             ; BASIC ERROR CODE VALUES
0101   0000             
0102   0000             NF      .EQU    00H             ; NEXT without FOR
0103   0000             SN      .EQU    02H             ; Syntax error
0104   0000             RG      .EQU    04H             ; RETURN without GOSUB
0105   0000             OD      .EQU    06H             ; Out of DATA
0106   0000             FC      .EQU    08H             ; Function call error
0107   0000             OV      .EQU    0AH             ; Overflow
0108   0000             OM      .EQU    0CH             ; Out of memory
0109   0000             UL      .EQU    0EH             ; Undefined line number
0110   0000             BS      .EQU    10H             ; Bad subscript
0111   0000             DD      .EQU    12H             ; Re-DIMensioned array
0112   0000             DZ      .EQU    14H             ; Division by zero (/0)
0113   0000             ID      .EQU    16H             ; Illegal direct
0114   0000             TM      .EQU    18H             ; Type miss-match
0115   0000             OS      .EQU    1AH             ; Out of string space
0116   0000             LS      .EQU    1CH             ; String too long
0117   0000             ST      .EQU    1EH             ; String formula too complex
0118   0000             CN      .EQU    20H             ; Can't CONTinue
0119   0000             UF      .EQU    22H             ; UnDEFined FN function
0120   0000             MO      .EQU    24H             ; Missing operand
0121   0000             HX      .EQU    26H             ; HEX error
0122   0000             BN      .EQU    28H             ; BIN error
0123   0000             
0124   0400                     .ORG    0400H
0125   0400             
0126   0400 C3 06 04    COLD:   JP      STARTB          ; Jump for cold start
0127   0403 C3 A4 04    WARM:   JP      WARMST          ; Jump for warm start
0128   0406             STARTB: 
0129   0406 DD 21 00 00         LD      IX,0            ; Flag cold start
0130   040A C3 11 04            JP      CSTART          ; Jump to initialise
0131   040D             
0132   040D B7 0C               .WORD   DEINT           ; Get integer -32768 to 32767
0133   040F 2D 14               .WORD   ABPASS          ; Return integer in AB
0134   0411             
0135   0411             
0136   0411 21 00 82    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0137   0414 F9                  LD      SP,HL           ; Set up a temporary stack
0138   0415 C3 4C 20            JP      INITST          ; Go to initialise
0139   0418             
0140   0418 11 DE 06    INIT:   LD      DE,INITAB       ; Initialise workspace
0141   041B 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0142   041D 21 00 82            LD      HL,WRKSPC       ; Into workspace RAM
0143   0420 1A          COPY:   LD      A,(DE)          ; Get source
0144   0421 77                  LD      (HL),A          ; To destination
0145   0422 23                  INC     HL              ; Next destination
0146   0423 13                  INC     DE              ; Next source
0147   0424 05                  DEC     B               ; Count bytes
0148   0425 C2 20 04            JP      NZ,COPY         ; More to move
0149   0428 F9                  LD      SP,HL           ; Temporary stack
0150   0429 CD DF 08            CALL    CLREG           ; Clear registers and stack
0151   042C CD AD 0E            CALL    PRNTCRLF        ; Output CRLF
0152   042F 32 AA 82            LD      (BUFFER+72+1),A ; Mark end of buffer
0153   0432 32 F9 82            LD      (PROGST),A      ; Initialise program area
0154   0435 21 F3 04    MSIZE:  LD      HL,MEMMSG       ; Point to message
0155   0438 CD 4B 15            CALL    PRS             ; Output "Memory size"
0156   043B CD FC 08            CALL    PROMPT          ; Get input with '?'
0157   043E CD 05 0C            CALL    GETCHR          ; Get next character
0158   0441 B7                  OR      A               ; Set flags
0159   0442 C2 5A 04            JP      NZ,TSTMEM       ; If number - Test if RAM there
0160   0445 21 5D 83            LD      HL,STLOOK       ; Point to start of RAM
0161   0448 23          MLOOP:  INC     HL              ; Next byte
0162   0449 7C                  LD      A,H             ; Above address FFFF ?
0163   044A B5                  OR      L
0164   044B CA 6C 04            JP      Z,SETTOP        ; Yes - 64K RAM
0165   044E 7E                  LD      A,(HL)          ; Get contents
0166   044F 47                  LD      B,A             ; Save it
0167   0450 2F                  CPL                     ; Flip all bits
0168   0451 77                  LD      (HL),A          ; Put it back
0169   0452 BE                  CP      (HL)            ; RAM there if same
0170   0453 70                  LD      (HL),B          ; Restore old contents
0171   0454 CA 48 04            JP      Z,MLOOP         ; If RAM - test next byte
0172   0457 C3 6C 04            JP      SETTOP          ; Top of RAM found
0173   045A             
0174   045A CD D1 0C    TSTMEM: CALL    ATOH            ; Get high memory into DE
0175   045D B7                  OR      A               ; Set flags on last byte
0176   045E C2 AD 07            JP      NZ,SNERR        ; ?SN Error if bad character
0177   0461 EB                  EX      DE,HL           ; Address into HL
0178   0462 2B                  DEC     HL              ; Back one byte
0179   0463 3E D9               LD      A,11011001B     ; Test byte
0180   0465 46                  LD      B,(HL)          ; Get old contents
0181   0466 77                  LD      (HL),A          ; Load test byte
0182   0467 BE                  CP      (HL)            ; RAM there if same
0183   0468 70                  LD      (HL),B          ; Restore old contents
0184   0469 C2 35 04            JP      NZ,MSIZE        ; Ask again if no RAM
0185   046C             
0186   046C 2B          SETTOP: DEC     HL              ; Back one byte
0187   046D 11 5C 83            LD      DE,STLOOK-1     ; See if enough RAM
0188   0470 CD 75 0A            CALL    CPDEHL          ; Compare DE with HL
0189   0473 DA 35 04            JP      C,MSIZE         ; Ask again if not enough RAM
0190   0476 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0191   0479 22 AF 82            LD      (LSTRAM),HL     ; Save last available RAM
0192   047C 19                  ADD     HL,DE           ; Allocate string space
0193   047D 22 5A 82            LD      (STRSPC),HL     ; Save string space
0194   0480 CD BA 08            CALL    CLRPTR          ; Clear program area
0195   0483 2A 5A 82            LD      HL,(STRSPC)     ; Get end of memory
0196   0486 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0197   0489 19                  ADD     HL,DE           ; Adjust HL
0198   048A 11 F9 82            LD      DE,PROGST       ; Start of program text
0199   048D 7D                  LD      A,L             ; Get LSB
0200   048E 93                  SUB     E               ; Adjust it
0201   048F 6F                  LD      L,A             ; Re-save
0202   0490 7C                  LD      A,H             ; Get MSB
0203   0491 9A                  SBC     A,D             ; Adjust it
0204   0492 67                  LD      H,A             ; Re-save
0205   0493 E5                  PUSH    HL              ; Save bytes free
0206   0494 21 BC 04            LD      HL,SIGNON       ; Sign-on message
0207   0497 CD 4B 15            CALL    PRS             ; Output string
0208   049A E1                  POP     HL              ; Get bytes free back
0209   049B CD EE 1B            CALL    PRNTHL          ; Output amount of free memory
0210   049E 21 AD 04            LD      HL,BFREE        ; " Bytes free" message
0211   04A1 CD 4B 15            CALL    PRS             ; Output string
0212   04A4             
0213   04A4 31 66 82    WARMST: LD      SP,STACK        ; Temporary stack
0214   04A7 CD DF 08    BRKRET: CALL    CLREG           ; Clear registers and stack
0215   04AA C3 F8 07            JP      PRNTOK          ; Go to get command line
0216   04AD             
0217   04AD 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0217   04B3 20667265650D0A0000
0218   04BC             
0219   04BC 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0219   04C2 5349432056657220342E37620D0A
0220   04D0 436F70797269        .BYTE   "Copyright ",40,"C",41
0220   04D6 67687420284329
0221   04DD 203139373820        .BYTE   " 1978 by Microsoft",CR,LF,0,0
0221   04E3 6279204D6963726F736F66740D0A0000
0222   04F3             
0223   04F3 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0223   04F9 20746F7000
0224   04FE             
0225   04FE             ; FUNCTION ADDRESS TABLE
0226   04FE             
0227   04FE 63 1A       FNCTAB: .WORD   SGN
0228   0500 27 1B               .WORD   INT
0229   0502 79 1A               .WORD   ABS
0230   0504 03 82               .WORD   USR
0231   0506 0B 14               .WORD   FRE
0232   0508 90 17               .WORD   INP
0233   050A 39 14               .WORD   POS
0234   050C ED 1C               .WORD   SQR
0235   050E CC 1D               .WORD   RND
0236   0510 08 19               .WORD   LOG
0237   0512 3B 1D               .WORD   EXP
0238   0514 41 1E               .WORD   COS
0239   0516 47 1E               .WORD   SIN
0240   0518 A8 1E               .WORD   TAN
0241   051A BD 1E               .WORD   ATN
0242   051C E4 17               .WORD   PEEK
0243   051E 28 1F               .WORD   DEEK
0244   0520 51 82               .WORD   POINT
0245   0522 BD 16               .WORD   LEN
0246   0524 D5 14               .WORD   STR
0247   0526 57 17               .WORD   VAL
0248   0528 CC 16               .WORD   ASC
0249   052A DD 16               .WORD   CHR
0250   052C 4A 1F               .WORD   HEX
0251   052E DD 1F               .WORD   BIN
0252   0530 ED 16               .WORD   LEFT
0253   0532 1D 17               .WORD   RIGHT
0254   0534 27 17               .WORD   MID
0255   0536             
0256   0536             ; RESERVED WORD LIST
0257   0536             
0258   0536 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0259   0539 C6 4F 52            .BYTE   'F'+80H,"OR"
0260   053C CE 45 58 54         .BYTE   'N'+80H,"EXT"
0261   0540 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0262   0544 C94E505554          .BYTE   'I'+80H,"NPUT"
0263   0549 C4 49 4D            .BYTE   'D'+80H,"IM"
0264   054C D2 45 41 44         .BYTE   'R'+80H,"EAD"
0265   0550 CC 45 54            .BYTE   'L'+80H,"ET"
0266   0553 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0267   0557 D2 55 4E            .BYTE   'R'+80H,"UN"
0268   055A C9 46               .BYTE   'I'+80H,"F"
0269   055C D24553544F52        .BYTE   'R'+80H,"ESTORE"
0269   0562 45
0270   0563 C74F535542          .BYTE   'G'+80H,"OSUB"
0271   0568 D2455455524E        .BYTE   'R'+80H,"ETURN"
0272   056E D2 45 4D            .BYTE   'R'+80H,"EM"
0273   0571 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0274   0575 CF 55 54            .BYTE   'O'+80H,"UT"
0275   0578 CF 4E               .BYTE   'O'+80H,"N"
0276   057A CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0277   057E D7 41 49 54         .BYTE   'W'+80H,"AIT"
0278   0582 C4 45 46            .BYTE   'D'+80H,"EF"
0279   0585 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0280   0589 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0281   058D D3435245454E        .BYTE   'S'+80H,"CREEN"
0282   0593 CC494E4553          .BYTE   'L'+80H,"INES"
0283   0598 C3 4C 53            .BYTE   'C'+80H,"LS"
0284   059B D749445448          .BYTE   'W'+80H,"IDTH"
0285   05A0 CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0285   05A6 52
0286   05A7 D3 45 54            .BYTE   'S'+80H,"ET"
0287   05AA D245534554          .BYTE   'R'+80H,"ESET"
0288   05AF D052494E54          .BYTE   'P'+80H,"RINT"
0289   05B4 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0290   05B8 CC 49 53 54         .BYTE   'L'+80H,"IST"
0291   05BC C34C454152          .BYTE   'C'+80H,"LEAR"
0292   05C1 C34C4F4144          .BYTE   'C'+80H,"LOAD"
0293   05C6 C353415645          .BYTE   'C'+80H,"SAVE"
0294   05CB CE 45 57            .BYTE   'N'+80H,"EW"
0295   05CE             
0296   05CE D4 41 42 28         .BYTE   'T'+80H,"AB("
0297   05D2 D4 4F               .BYTE   'T'+80H,"O"
0298   05D4 C6 4E               .BYTE   'F'+80H,"N"
0299   05D6 D3 50 43 28         .BYTE   'S'+80H,"PC("
0300   05DA D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0301   05DE CE 4F 54            .BYTE   'N'+80H,"OT"
0302   05E1 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0303   05E5             
0304   05E5 AB                  .BYTE   '+'+80H
0305   05E6 AD                  .BYTE   '-'+80H
0306   05E7 AA                  .BYTE   '*'+80H
0307   05E8 AF                  .BYTE   '/'+80H
0308   05E9 DE                  .BYTE   '^'+80H
0309   05EA C1 4E 44            .BYTE   'A'+80H,"ND"
0310   05ED CF 52               .BYTE   'O'+80H,"R"
0311   05EF BE                  .BYTE   '>'+80H
0312   05F0 BD                  .BYTE   '='+80H
0313   05F1 BC                  .BYTE   '<'+80H
0314   05F2             
0315   05F2 D3 47 4E            .BYTE   'S'+80H,"GN"
0316   05F5 C9 4E 54            .BYTE   'I'+80H,"NT"
0317   05F8 C1 42 53            .BYTE   'A'+80H,"BS"
0318   05FB D5 53 52            .BYTE   'U'+80H,"SR"
0319   05FE C6 52 45            .BYTE   'F'+80H,"RE"
0320   0601 C9 4E 50            .BYTE   'I'+80H,"NP"
0321   0604 D0 4F 53            .BYTE   'P'+80H,"OS"
0322   0607 D3 51 52            .BYTE   'S'+80H,"QR"
0323   060A D2 4E 44            .BYTE   'R'+80H,"ND"
0324   060D CC 4F 47            .BYTE   'L'+80H,"OG"
0325   0610 C5 58 50            .BYTE   'E'+80H,"XP"
0326   0613 C3 4F 53            .BYTE   'C'+80H,"OS"
0327   0616 D3 49 4E            .BYTE   'S'+80H,"IN"
0328   0619 D4 41 4E            .BYTE   'T'+80H,"AN"
0329   061C C1 54 4E            .BYTE   'A'+80H,"TN"
0330   061F D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0331   0623 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0332   0627 D04F494E54          .BYTE   'P'+80H,"OINT"
0333   062C CC 45 4E            .BYTE   'L'+80H,"EN"
0334   062F D3 54 52 24         .BYTE   'S'+80H,"TR$"
0335   0633 D6 41 4C            .BYTE   'V'+80H,"AL"
0336   0636 C1 53 43            .BYTE   'A'+80H,"SC"
0337   0639 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0338   063D C8 45 58 24         .BYTE   'H'+80H,"EX$"
0339   0641 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0340   0645 CC45465424          .BYTE   'L'+80H,"EFT$"
0341   064A D24947485424        .BYTE   'R'+80H,"IGHT$"
0342   0650 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0343   0654 80                  .BYTE   80H             ; End of list marker
0344   0655             
0345   0655             ; KEYWORD ADDRESS TABLE
0346   0655             
0347   0655 4F 0C       WORDTB: .WORD   PEND
0348   0657 4C 0B               .WORD   FOR
0349   0659 27 10               .WORD   NEXT
0350   065B 9C 0D               .WORD   DATA
0351   065D 2E 0F               .WORD   INPUT
0352   065F 63 12               .WORD   DIM
0353   0661 5D 0F               .WORD   READ
0354   0663 B3 0D               .WORD   LET
0355   0665 59 0D               .WORD   GOTO
0356   0667 3C 0D               .WORD   RUN
0357   0669 2B 0E               .WORD   IF
0358   066B 15 0C               .WORD   RESTOR
0359   066D 48 0D               .WORD   GOSUB
0360   066F 77 0D               .WORD   RETURN
0361   0671 9E 0D               .WORD   REM
0362   0673 4D 0C               .WORD   STOP
0363   0675 9C 17               .WORD   POUT
0364   0677 0D 0E               .WORD   ON
0365   0679 8E 0C               .WORD   NULL
0366   067B A2 17               .WORD   WAIT
0367   067D 41 14               .WORD   DEF
0368   067F EB 17               .WORD   POKE
0369   0681 33 1F               .WORD   DOKE
0370   0683 9E 0D               .WORD   REM
0371   0685 19 1F               .WORD   LINES
0372   0687 0C 1F               .WORD   CLS
0373   0689 11 1F               .WORD   WIDTH
0374   068B 49 20               .WORD   MONITR
0375   068D 54 82               .WORD   PSET
0376   068F 57 82               .WORD   RESET
0377   0691 4F 0E               .WORD   PRINT
0378   0693 7B 0C               .WORD   CONT
0379   0695 C1 0A               .WORD   LIST
0380   0697 F6 0C               .WORD   CLEAR
0381   0699 9E 0D               .WORD   REM
0382   069B 9E 0D               .WORD   REM
0383   069D B9 08               .WORD   NEW
0384   069F             
0385   069F             ; RESERVED WORD TOKEN VALUES
0386   069F             
0387   069F             ZEND    .EQU    080H            ; END
0388   069F             ZFOR    .EQU    081H            ; FOR
0389   069F             ZDATA   .EQU    083H            ; DATA
0390   069F             ZGOTO   .EQU    088H            ; GOTO
0391   069F             ZGOSUB  .EQU    08CH            ; GOSUB
0392   069F             ZREM    .EQU    08EH            ; REM
0393   069F             ZPRINT  .EQU    09EH            ; PRINT
0394   069F             ZNEW    .EQU    0A4H            ; NEW
0395   069F             
0396   069F             ZTAB    .EQU    0A5H            ; TAB
0397   069F             ZTO     .EQU    0A6H            ; TO
0398   069F             ZFN     .EQU    0A7H            ; FN
0399   069F             ZSPC    .EQU    0A8H            ; SPC
0400   069F             ZTHEN   .EQU    0A9H            ; THEN
0401   069F             ZNOT    .EQU    0AAH            ; NOT
0402   069F             ZSTEP   .EQU    0ABH            ; STEP
0403   069F             
0404   069F             ZPLUS   .EQU    0ACH            ; +
0405   069F             ZMINUS  .EQU    0ADH            ; -
0406   069F             ZTIMES  .EQU    0AEH            ; *
0407   069F             ZDIV    .EQU    0AFH            ; /
0408   069F             ZOR     .EQU    0B2H            ; OR
0409   069F             ZGTR    .EQU    0B3H            ; >
0410   069F             ZEQUAL  .EQU    0B4H            ; M
0411   069F             ZLTH    .EQU    0B5H            ; <
0412   069F             ZSGN    .EQU    0B6H            ; SGN
0413   069F             ZPOINT  .EQU    0C7H            ; POINT
0414   069F             ZLEFT   .EQU    0CDH +2         ; LEFT$
0415   069F             
0416   069F             ; ARITHMETIC PRECEDENCE TABLE
0417   069F             
0418   069F 79          PRITAB: .BYTE   79H             ; Precedence value
0419   06A0 D5 1B               .WORD   PADD            ; FPREG = <last> + FPREG
0420   06A2             
0421   06A2 79                  .BYTE   79H             ; Precedence value
0422   06A3 09 18               .WORD   PSUB            ; FPREG = <last> - FPREG
0423   06A5             
0424   06A5 7C                  .BYTE   7CH             ; Precedence value
0425   06A6 47 19               .WORD   MULT            ; PPREG = <last> * FPREG
0426   06A8             
0427   06A8 7C                  .BYTE   7CH             ; Precedence value
0428   06A9 A8 19               .WORD   DIV             ; FPREG = <last> / FPREG
0429   06AB             
0430   06AB 7F                  .BYTE   7FH             ; Precedence value
0431   06AC F6 1C               .WORD   POWER           ; FPREG = <last> ^ FPREG
0432   06AE             
0433   06AE 50                  .BYTE   50H             ; Precedence value
0434   06AF BC 11               .WORD   PAND            ; FPREG = <last> AND FPREG
0435   06B1             
0436   06B1 46                  .BYTE   46H             ; Precedence value
0437   06B2 BB 11               .WORD   POR             ; FPREG = <last> OR FPREG
0438   06B4             
0439   06B4             ; BASIC ERROR CODE LIST
0440   06B4             
0441   06B4 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0442   06B6 53 4E               .BYTE   "SN"            ; Syntax error
0443   06B8 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0444   06BA 4F 44               .BYTE   "OD"            ; Out of DATA
0445   06BC 46 43               .BYTE   "FC"            ; Illegal function call
0446   06BE 4F 56               .BYTE   "OV"            ; Overflow error
0447   06C0 4F 4D               .BYTE   "OM"            ; Out of memory
0448   06C2 55 4C               .BYTE   "UL"            ; Undefined line
0449   06C4 42 53               .BYTE   "BS"            ; Bad subscript
0450   06C6 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0451   06C8 2F 30               .BYTE   "/0"            ; Division by zero
0452   06CA 49 44               .BYTE   "ID"            ; Illegal direct
0453   06CC 54 4D               .BYTE   "TM"            ; Type mis-match
0454   06CE 4F 53               .BYTE   "OS"            ; Out of string space
0455   06D0 4C 53               .BYTE   "LS"            ; String too long
0456   06D2 53 54               .BYTE   "ST"            ; String formula too complex
0457   06D4 43 4E               .BYTE   "CN"            ; Can't CONTinue
0458   06D6 55 46               .BYTE   "UF"            ; Undefined FN function
0459   06D8 4D 4F               .BYTE   "MO"            ; Missing operand
0460   06DA 48 58               .BYTE   "HX"            ; HEX error
0461   06DC 42 4E               .BYTE   "BN"            ; BIN error
0462   06DE             
0463   06DE             ; INITIALISATION TABLE -------------------------------------------------------
0464   06DE             
0465   06DE C3 A4 04    INITAB: JP      WARMST          ; Warm start jump
0466   06E1 C3 CC 0C            JP      FCERR           ; "USR (X)" jump (Set to Error)
0467   06E4 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0468   06E6 C9                  RET
0469   06E7 D6 00               SUB     0               ; Division support routine
0470   06E9 6F                  LD      L,A
0471   06EA 7C                  LD      A,H
0472   06EB DE 00               SBC     A,0
0473   06ED 67                  LD      H,A
0474   06EE 78                  LD      A,B
0475   06EF DE 00               SBC     A,0
0476   06F1 47                  LD      B,A
0477   06F2 3E 00               LD      A,0
0478   06F4 C9                  RET
0479   06F5 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0480   06F8 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0481   06FC 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0482   0700 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0483   0704 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0484   0708 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0485   070C 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0486   0710 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0487   0714 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0488   0718 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0489   071C DB 00               IN      A,(0)           ; INP (x) skeleton
0490   071E C9                  RET
0491   071F 01                  .BYTE   1               ; POS (x) number (1)
0492   0720 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0493   0721 1C                  .BYTE   28              ; Width for commas (3 columns)
0494   0722 00                  .BYTE   0               ; No nulls after input bytes
0495   0723 00                  .BYTE   0               ; Output enabled (^O off)
0496   0724 14 00               .WORD   20              ; Initial lines counter
0497   0726 14 00               .WORD   20              ; Initial lines number
0498   0728 00 00               .WORD   0               ; Array load/save check sum
0499   072A 00                  .BYTE   0               ; Break not by NMI
0500   072B 00                  .BYTE   0               ; Break flag
0501   072C C3 F2 09            JP      TTYLIN          ; Input reflection (set to TTY)
0502   072F C3 00 00            JP      $0000           ; POINT reflection unused
0503   0732 C3 00 00            JP      $0000           ; SET reflection
0504   0735 C3 00 00            JP      $0000          	; RESET reflection
0505   0738 5D 83               .WORD   STLOOK          ; Temp string space
0506   073A FE FF               .WORD   -2              ; Current line number (cold)
0507   073C FA 82               .WORD   PROGST+1        ; Start of program text
0508   073E             INITBE:                         
0509   073E             
0510   073E             ; END OF INITIALISATION TABLE ---------------------------------------------------
0511   073E             
0512   073E 204572726F72ERRMSG: .BYTE   " Error",0
0512   0744 00
0513   0745 20696E2000  INMSG:  .BYTE   " in ",0
0514   074A             ZERBYT  .EQU    $-1             ; A zero byte
0515   074A 4F6B0D0A0000OKMSG:  .BYTE   "Ok",CR,LF,0,0
0516   0750 427265616B00BRKMSG: .BYTE   "Break",0
0517   0756             
0518   0756 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0519   0759 39                  ADD     HL,SP           ; same index as specified
0520   075A 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0521   075B 23                  INC     HL              ; Point to index address
0522   075C FE 81               CP      ZFOR            ; Is it a "FOR" token
0523   075E C0                  RET     NZ              ; No - exit
0524   075F 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0525   0760 23                  INC     HL
0526   0761 46                  LD      B,(HL)
0527   0762 23                  INC     HL              ; Point to sign of STEP
0528   0763 E5                  PUSH    HL              ; Save pointer to sign
0529   0764 69                  LD      L,C             ; HL = address of "FOR" index
0530   0765 60                  LD      H,B
0531   0766 7A                  LD      A,D             ; See if an index was specified
0532   0767 B3                  OR      E               ; DE = 0 if no index specified
0533   0768 EB                  EX      DE,HL           ; Specified index into HL
0534   0769 CA 70 07            JP      Z,INDFND        ; Skip if no index given
0535   076C EB                  EX      DE,HL           ; Index back into DE
0536   076D CD 75 0A            CALL    CPDEHL          ; Compare index with one given
0537   0770 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0538   0773 E1                  POP     HL              ; Restore pointer to sign
0539   0774 C8                  RET     Z               ; Return if block found
0540   0775 09                  ADD     HL,BC           ; Point to next block
0541   0776 C3 5A 07            JP      LOKFOR          ; Keep on looking
0542   0779             
0543   0779 CD 93 07    MOVUP:  CALL    ENFMEM          ; See if enough memory
0544   077C C5          MOVSTR: PUSH    BC              ; Save end of source
0545   077D E3                  EX      (SP),HL         ; Swap source and dest" end
0546   077E C1                  POP     BC              ; Get end of destination
0547   077F CD 75 0A    MOVLP:  CALL    CPDEHL          ; See if list moved
0548   0782 7E                  LD      A,(HL)          ; Get byte
0549   0783 02                  LD      (BC),A          ; Move it
0550   0784 C8                  RET     Z               ; Exit if all done
0551   0785 0B                  DEC     BC              ; Next byte to move to
0552   0786 2B                  DEC     HL              ; Next byte to move
0553   0787 C3 7F 07            JP      MOVLP           ; Loop until all bytes moved
0554   078A             
0555   078A E5          CHKSTK: PUSH    HL              ; Save code string address
0556   078B 2A DA 82            LD      HL,(ARREND)     ; Lowest free memory
0557   078E 06 00               LD      B,0             ; BC = Number of levels to test
0558   0790 09                  ADD     HL,BC           ; 2 Bytes for each level
0559   0791 09                  ADD     HL,BC
0560   0792 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0561   0793 E5          ENFMEM: PUSH    HL              ; Save code string address
0562   0794 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0563   0796 95                  SUB     L
0564   0797 6F                  LD      L,A
0565   0798 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0566   079A 9C                  SBC     A,H
0567   079B DA A2 07            JP      C,OMERR         ; Not enough - ?OM Error
0568   079E 67                  LD      H,A
0569   079F 39                  ADD     HL,SP           ; Test if stack is overflowed
0570   07A0 E1                  POP     HL              ; Restore code string address
0571   07A1 D8                  RET     C               ; Return if enough mmory
0572   07A2 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0573   07A4 C3 C1 07            JP      ERROR
0574   07A7             
0575   07A7 2A C9 82    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0576   07AA 22 5C 82            LD      (LINEAT),HL     ; Save as current line
0577   07AD 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0578   07AF 01                  .BYTE   01H             ; Skip "LD E,DZ"
0579   07B0 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0580   07B2 01                  .BYTE   01H             ; Skip "LD E,NF"
0581   07B3 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0582   07B5 01                  .BYTE   01H             ; Skip "LD E,DD"
0583   07B6 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0584   07B8 01                  .BYTE   01H             ; Skip "LD E,UF"
0585   07B9 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0586   07BB 01                  .BYTE   01H             ; Skip "LD E,OV
0587   07BC 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0588   07BE 01                  .BYTE   01H             ; Skip "LD E,TM"
0589   07BF 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0590   07C1             
0591   07C1             ERROR:  
0592   07C1 CD DF 08            CALL    CLREG           ; Clear registers and stack
0593   07C4 32 45 82            LD      (CTLOFG),A      ; Enable output (A is 0)
0594   07C7 CD A0 0E            CALL    STTLIN          ; Start new line
0595   07CA 21 B4 06            LD      HL,ERRORS       ; Point to error codes
0596   07CD 57                  LD      D,A             ; D = 0 (A is 0)
0597   07CE 3E 3F               LD      A,'?'
0598   07D0 CD 86 0A            CALL    OUTC            ; Output '?'
0599   07D3 19                  ADD     HL,DE           ; Offset to correct error code
0600   07D4 7E                  LD      A,(HL)          ; First character
0601   07D5 CD 86 0A            CALL    OUTC            ; Output it
0602   07D8 CD 05 0C            CALL    GETCHR          ; Get next character
0603   07DB CD 86 0A            CALL    OUTC            ; Output it
0604   07DE 21 3E 07            LD      HL,ERRMSG       ; "Error" message
0605   07E1 CD 4B 15    ERRIN:  CALL    PRS             ; Output message
0606   07E4 2A 5C 82            LD      HL,(LINEAT)     ; Get line of error
0607   07E7 11 FE FF            LD      DE,-2           ; Cold start error if -2
0608   07EA CD 75 0A            CALL    CPDEHL          ; See if cold start error
0609   07ED CA 11 04            JP      Z,CSTART        ; Cold start error - Restart
0610   07F0 7C                  LD      A,H             ; Was it a direct error?
0611   07F1 A5                  AND     L               ; Line = -1 if direct error
0612   07F2 3C                  INC     A
0613   07F3 C4 E6 1B            CALL    NZ,LINEIN       ; No - output line of error
0614   07F6 3E                  .BYTE   3EH             ; Skip "POP BC"
0615   07F7 C1          POPNOK: POP     BC              ; Drop address in input buffer
0616   07F8             
0617   07F8             PRNTOK: 
0618   07F8 AF                  XOR     A               ; Output "Ok" and get command
0619   07F9 32 45 82            LD      (CTLOFG),A      ; Enable output
0620   07FC CD A0 0E            CALL    STTLIN          ; Start new line
0621   07FF 21 4A 07            LD      HL,OKMSG        ; "Ok" message
0622   0802 CD 4B 15            CALL    PRS             ; Output "Ok"
0623   0805 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0624   0808 22 5C 82            LD      (LINEAT),HL     ; Save as current line
0625   080B CD F2 09            CALL    GETLIN          ; Get an input line
0626   080E DA 05 08            JP      C,GETCMD        ; Get line again if break
0627   0811 CD 05 0C            CALL    GETCHR          ; Get first character
0628   0814 3C                  INC     A               ; Test if end of line
0629   0815 3D                  DEC     A               ; Without affecting Carry
0630   0816 CA 05 08            JP      Z,GETCMD        ; Nothing entered - Get another
0631   0819 F5                  PUSH    AF              ; Save Carry status
0632   081A CD D1 0C            CALL    ATOH            ; Get line number into DE
0633   081D D5                  PUSH    DE              ; Save line number
0634   081E CD 09 09            CALL    CRUNCH          ; Tokenise rest of line
0635   0821 47                  LD      B,A             ; Length of tokenised line
0636   0822 D1                  POP     DE              ; Restore line number
0637   0823 F1                  POP     AF              ; Restore Carry
0638   0824 D2 E5 0B            JP      NC,EXCUTE       ; No line number - Direct mode
0639   0827 D5                  PUSH    DE              ; Save line number
0640   0828 C5                  PUSH    BC              ; Save length of tokenised line
0641   0829 AF                  XOR     A
0642   082A 32 CC 82            LD      (LSTBIN),A      ; Clear last byte input
0643   082D CD 05 0C            CALL    GETCHR          ; Get next character
0644   0830 B7                  OR      A               ; Set flags
0645   0831 F5                  PUSH    AF              ; And save them
0646   0832 CD 99 08            CALL    SRCHLN          ; Search for line number in DE
0647   0835 DA 3E 08            JP      C,LINFND        ; Jump if line found
0648   0838 F1                  POP     AF              ; Get status
0649   0839 F5                  PUSH    AF              ; And re-save
0650   083A CA 72 0D            JP      Z,ULERR         ; Nothing after number - Error
0651   083D B7                  OR      A               ; Clear Carry
0652   083E C5          LINFND: PUSH    BC              ; Save address of line in prog
0653   083F D2 55 08            JP      NC,INEWLN       ; Line not found - Insert new
0654   0842 EB                  EX      DE,HL           ; Next line address in DE
0655   0843 2A D6 82            LD      HL,(PROGND)     ; End of program
0656   0846 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0657   0847 02                  LD      (BC),A
0658   0848 03                  INC     BC              ; Next destination
0659   0849 13                  INC     DE              ; Next source
0660   084A CD 75 0A            CALL    CPDEHL          ; All done?
0661   084D C2 46 08            JP      NZ,SFTPRG       ; More to do
0662   0850 60                  LD      H,B             ; HL - New end of program
0663   0851 69                  LD      L,C
0664   0852 22 D6 82            LD      (PROGND),HL     ; Update end of program
0665   0855             
0666   0855 D1          INEWLN: POP     DE              ; Get address of line,
0667   0856 F1                  POP     AF              ; Get status
0668   0857 CA 7C 08            JP      Z,SETPTR        ; No text - Set up pointers
0669   085A 2A D6 82            LD      HL,(PROGND)     ; Get end of program
0670   085D E3                  EX      (SP),HL         ; Get length of input line
0671   085E C1                  POP     BC              ; End of program to BC
0672   085F 09                  ADD     HL,BC           ; Find new end
0673   0860 E5                  PUSH    HL              ; Save new end
0674   0861 CD 79 07            CALL    MOVUP           ; Make space for line
0675   0864 E1                  POP     HL              ; Restore new end
0676   0865 22 D6 82            LD      (PROGND),HL     ; Update end of program pointer
0677   0868 EB                  EX      DE,HL           ; Get line to move up in HL
0678   0869 74                  LD      (HL),H          ; Save MSB
0679   086A D1                  POP     DE              ; Get new line number
0680   086B 23                  INC     HL              ; Skip pointer
0681   086C 23                  INC     HL
0682   086D 73                  LD      (HL),E          ; Save LSB of line number
0683   086E 23                  INC     HL
0684   086F 72                  LD      (HL),D          ; Save MSB of line number
0685   0870 23                  INC     HL              ; To first byte in line
0686   0871 11 61 82            LD      DE,BUFFER       ; Copy buffer to program
0687   0874 1A          MOVBUF: LD      A,(DE)          ; Get source
0688   0875 77                  LD      (HL),A          ; Save destinations
0689   0876 23                  INC     HL              ; Next source
0690   0877 13                  INC     DE              ; Next destination
0691   0878 B7                  OR      A               ; Done?
0692   0879 C2 74 08            JP      NZ,MOVBUF       ; No - Repeat
0693   087C CD C5 08    SETPTR: CALL    RUNFST          ; Set line pointers
0694   087F 23                  INC     HL              ; To LSB of pointer
0695   0880 EB                  EX      DE,HL           ; Address to DE
0696   0881 62          PTRLP:  LD      H,D             ; Address to HL
0697   0882 6B                  LD      L,E
0698   0883 7E                  LD      A,(HL)          ; Get LSB of pointer
0699   0884 23                  INC     HL              ; To MSB of pointer
0700   0885 B6                  OR      (HL)            ; Compare with MSB pointer
0701   0886 CA 05 08            JP      Z,GETCMD        ; Get command line if end
0702   0889 23                  INC     HL              ; To LSB of line number
0703   088A 23                  INC     HL              ; Skip line number
0704   088B 23                  INC     HL              ; Point to first byte in line
0705   088C AF                  XOR     A               ; Looking for 00 byte
0706   088D BE          FNDEND: CP      (HL)            ; Found end of line?
0707   088E 23                  INC     HL              ; Move to next byte
0708   088F C2 8D 08            JP      NZ,FNDEND       ; No - Keep looking
0709   0892 EB                  EX      DE,HL           ; Next line address to HL
0710   0893 73                  LD      (HL),E          ; Save LSB of pointer
0711   0894 23                  INC     HL
0712   0895 72                  LD      (HL),D          ; Save MSB of pointer
0713   0896 C3 81 08            JP      PTRLP           ; Do next line
0714   0899             
0715   0899 2A 5E 82    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0716   089C 44          SRCHLP: LD      B,H             ; BC = Address to look at
0717   089D 4D                  LD      C,L
0718   089E 7E                  LD      A,(HL)          ; Get address of next line
0719   089F 23                  INC     HL
0720   08A0 B6                  OR      (HL)            ; End of program found?
0721   08A1 2B                  DEC     HL
0722   08A2 C8                  RET     Z               ; Yes - Line not found
0723   08A3 23                  INC     HL
0724   08A4 23                  INC     HL
0725   08A5 7E                  LD      A,(HL)          ; Get LSB of line number
0726   08A6 23                  INC     HL
0727   08A7 66                  LD      H,(HL)          ; Get MSB of line number
0728   08A8 6F                  LD      L,A
0729   08A9 CD 75 0A            CALL    CPDEHL          ; Compare with line in DE
0730   08AC 60                  LD      H,B             ; HL = Start of this line
0731   08AD 69                  LD      L,C
0732   08AE 7E                  LD      A,(HL)          ; Get LSB of next line address
0733   08AF 23                  INC     HL
0734   08B0 66                  LD      H,(HL)          ; Get MSB of next line address
0735   08B1 6F                  LD      L,A             ; Next line to HL
0736   08B2 3F                  CCF
0737   08B3 C8                  RET     Z               ; Lines found - Exit
0738   08B4 3F                  CCF
0739   08B5 D0                  RET     NC              ; Line not found,at line after
0740   08B6 C3 9C 08            JP      SRCHLP          ; Keep looking
0741   08B9             
0742   08B9 C0          NEW:    RET     NZ              ; Return if any more on line
0743   08BA 2A 5E 82    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0744   08BD AF                  XOR     A               ; Set program area to empty
0745   08BE 77                  LD      (HL),A          ; Save LSB = 00
0746   08BF 23                  INC     HL
0747   08C0 77                  LD      (HL),A          ; Save MSB = 00
0748   08C1 23                  INC     HL
0749   08C2 22 D6 82            LD      (PROGND),HL     ; Set program end
0750   08C5             
0751   08C5 2A 5E 82    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0752   08C8 2B                  DEC     HL
0753   08C9             
0754   08C9 22 CE 82    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0755   08CC 2A AF 82            LD      HL,(LSTRAM)     ; Get end of RAM
0756   08CF 22 C3 82            LD      (STRBOT),HL     ; Clear string space
0757   08D2 AF                  XOR     A
0758   08D3 CD 15 0C            CALL    RESTOR          ; Reset DATA pointers
0759   08D6 2A D6 82            LD      HL,(PROGND)     ; Get end of program
0760   08D9 22 D8 82            LD      (VAREND),HL     ; Clear variables
0761   08DC 22 DA 82            LD      (ARREND),HL     ; Clear arrays
0762   08DF             
0763   08DF C1          CLREG:  POP     BC              ; Save return address
0764   08E0 2A 5A 82            LD      HL,(STRSPC)     ; Get end of working RAN
0765   08E3 F9                  LD      SP,HL           ; Set stack
0766   08E4 21 B3 82            LD      HL,TMSTPL       ; Temporary string pool
0767   08E7 22 B1 82            LD      (TMSTPT),HL     ; Reset temporary string ptr
0768   08EA AF                  XOR     A               ; A = 00
0769   08EB 6F                  LD      L,A             ; HL = 0000
0770   08EC 67                  LD      H,A
0771   08ED 22 D4 82            LD      (CONTAD),HL     ; No CONTinue
0772   08F0 32 CB 82            LD      (FORFLG),A      ; Clear FOR flag
0773   08F3 22 DE 82            LD      (FNRGNM),HL     ; Clear FN argument
0774   08F6 E5                  PUSH    HL              ; HL = 0000
0775   08F7 C5                  PUSH    BC              ; Put back return
0776   08F8 2A CE 82    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0777   08FB C9                  RET                     ; Return to execution driver
0778   08FC             
0779   08FC 3E 3F       PROMPT: LD      A,'?'           ; '?'
0780   08FE CD 86 0A            CALL    OUTC            ; Output character
0781   0901 3E 20               LD      A,' '           ; Space
0782   0903 CD 86 0A            CALL    OUTC            ; Output character
0783   0906 C3 4E 82            JP      RINPUT          ; Get input line
0784   0909             
0785   0909 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0786   090A 32 AE 82            LD      (DATFLG),A      ; Reset literal flag
0787   090D 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0788   090F 11 61 82            LD      DE,BUFFER       ; Start of input buffer
0789   0912 7E          CRNCLP: LD      A,(HL)          ; Get byte
0790   0913 FE 20               CP      ' '             ; Is it a space?
0791   0915 CA 91 09            JP      Z,MOVDIR        ; Yes - Copy direct
0792   0918 47                  LD      B,A             ; Save character
0793   0919 FE 22               CP      '"'             ; Is it a quote?
0794   091B CA B1 09            JP      Z,CPYLIT        ; Yes - Copy literal string
0795   091E B7                  OR      A               ; Is it end of buffer?
0796   091F CA B8 09            JP      Z,ENDBUF        ; Yes - End buffer
0797   0922 3A AE 82            LD      A,(DATFLG)      ; Get data type
0798   0925 B7                  OR      A               ; Literal?
0799   0926 7E                  LD      A,(HL)          ; Get byte to copy
0800   0927 C2 91 09            JP      NZ,MOVDIR       ; Literal - Copy direct
0801   092A FE 3F               CP      '?'             ; Is it '?' short for PRINT
0802   092C 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0803   092E CA 91 09            JP      Z,MOVDIR        ; Yes - replace it
0804   0931 7E                  LD      A,(HL)          ; Get byte again
0805   0932 FE 30               CP      '0'             ; Is it less than '0'
0806   0934 DA 3C 09            JP      C,FNDWRD        ; Yes - Look for reserved words
0807   0937 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0808   0939 DA 91 09            JP      C,MOVDIR        ; Yes - copy it direct
0809   093C D5          FNDWRD: PUSH    DE              ; Look for reserved words
0810   093D 11 35 05            LD      DE,WORDS-1      ; Point to table
0811   0940 C5                  PUSH    BC              ; Save count
0812   0941 01 8D 09            LD      BC,RETNAD       ; Where to return to
0813   0944 C5                  PUSH    BC              ; Save return address
0814   0945 06 7F               LD      B,ZEND-1        ; First token value -1
0815   0947 7E                  LD      A,(HL)          ; Get byte
0816   0948 FE 61               CP      'a'             ; Less than 'a' ?
0817   094A DA 55 09            JP      C,SEARCH        ; Yes - search for words
0818   094D FE 7B               CP      'z'+1           ; Greater than 'z' ?
0819   094F D2 55 09            JP      NC,SEARCH       ; Yes - search for words
0820   0952 E6 5F               AND     01011111B       ; Force upper case
0821   0954 77                  LD      (HL),A          ; Replace byte
0822   0955 4E          SEARCH: LD      C,(HL)          ; Search for a word
0823   0956 EB                  EX      DE,HL
0824   0957 23          GETNXT: INC     HL              ; Get next reserved word
0825   0958 B6                  OR      (HL)            ; Start of word?
0826   0959 F2 57 09            JP      P,GETNXT        ; No - move on
0827   095C 04                  INC     B               ; Increment token value
0828   095D 7E                  LD      A, (HL)         ; Get byte from table
0829   095E E6 7F               AND     01111111B       ; Strip bit 7
0830   0960 C8                  RET     Z               ; Return if end of list
0831   0961 B9                  CP      C               ; Same character as in buffer?
0832   0962 C2 57 09            JP      NZ,GETNXT       ; No - get next word
0833   0965 EB                  EX      DE,HL
0834   0966 E5                  PUSH    HL              ; Save start of word
0835   0967             
0836   0967 13          NXTBYT: INC     DE              ; Look through rest of word
0837   0968 1A                  LD      A,(DE)          ; Get byte from table
0838   0969 B7                  OR      A               ; End of word ?
0839   096A FA 89 09            JP      M,MATCH         ; Yes - Match found
0840   096D 4F                  LD      C,A             ; Save it
0841   096E 78                  LD      A,B             ; Get token value
0842   096F FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0843   0971 C2 78 09            JP      NZ,NOSPC        ; No - Don't allow spaces
0844   0974 CD 05 0C            CALL    GETCHR          ; Get next character
0845   0977 2B                  DEC     HL              ; Cancel increment from GETCHR
0846   0978 23          NOSPC:  INC     HL              ; Next byte
0847   0979 7E                  LD      A,(HL)          ; Get byte
0848   097A FE 61               CP      'a'             ; Less than 'a' ?
0849   097C DA 81 09            JP      C,NOCHNG        ; Yes - don't change
0850   097F E6 5F               AND     01011111B       ; Make upper case
0851   0981 B9          NOCHNG: CP      C               ; Same as in buffer ?
0852   0982 CA 67 09            JP      Z,NXTBYT        ; Yes - keep testing
0853   0985 E1                  POP     HL              ; Get back start of word
0854   0986 C3 55 09            JP      SEARCH          ; Look at next word
0855   0989             
0856   0989 48          MATCH:  LD      C,B             ; Word found - Save token value
0857   098A F1                  POP     AF              ; Throw away return
0858   098B EB                  EX      DE,HL
0859   098C C9                  RET                     ; Return to "RETNAD"
0860   098D EB          RETNAD: EX      DE,HL           ; Get address in string
0861   098E 79                  LD      A,C             ; Get token value
0862   098F C1                  POP     BC              ; Restore buffer length
0863   0990 D1                  POP     DE              ; Get destination address
0864   0991 23          MOVDIR: INC     HL              ; Next source in buffer
0865   0992 12                  LD      (DE),A          ; Put byte in buffer
0866   0993 13                  INC     DE              ; Move up buffer
0867   0994 0C                  INC     C               ; Increment length of buffer
0868   0995 D6 3A               SUB     ':'             ; End of statement?
0869   0997 CA 9F 09            JP      Z,SETLIT        ; Jump if multi-statement line
0870   099A FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0871   099C C2 A2 09            JP      NZ,TSTREM       ; No - see if REM
0872   099F 32 AE 82    SETLIT: LD      (DATFLG),A      ; Set literal flag
0873   09A2 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0874   09A4 C2 12 09            JP      NZ,CRNCLP       ; No - Leave flag
0875   09A7 47                  LD      B,A             ; Copy rest of buffer
0876   09A8 7E          NXTCHR: LD      A,(HL)          ; Get byte
0877   09A9 B7                  OR      A               ; End of line ?
0878   09AA CA B8 09            JP      Z,ENDBUF        ; Yes - Terminate buffer
0879   09AD B8                  CP      B               ; End of statement ?
0880   09AE CA 91 09            JP      Z,MOVDIR        ; Yes - Get next one
0881   09B1 23          CPYLIT: INC     HL              ; Move up source string
0882   09B2 12                  LD      (DE),A          ; Save in destination
0883   09B3 0C                  INC     C               ; Increment length
0884   09B4 13                  INC     DE              ; Move up destination
0885   09B5 C3 A8 09            JP      NXTCHR          ; Repeat
0886   09B8             
0887   09B8 21 60 82    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0888   09BB 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0889   09BC 13                  INC     DE
0890   09BD 12                  LD      (DE),A          ; A = 00
0891   09BE 13                  INC     DE
0892   09BF 12                  LD      (DE),A          ; A = 00
0893   09C0 C9                  RET
0894   09C1             
0895   09C1 3A 44 82    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0896   09C4 B7                  OR      A               ; Is it zero?
0897   09C5 3E 00               LD      A,0             ; Zero A - Leave flags
0898   09C7 32 44 82            LD      (NULFLG),A      ; Zero null flag
0899   09CA C2 D5 09            JP      NZ,ECHDEL       ; Set - Echo it
0900   09CD 05                  DEC     B               ; Decrement length
0901   09CE CA F2 09            JP      Z,GETLIN        ; Get line again if empty
0902   09D1 CD 86 0A            CALL    OUTC            ; Output null character
0903   09D4 3E                  .BYTE   3EH             ; Skip "DEC B"
0904   09D5 05          ECHDEL: DEC     B               ; Count bytes in buffer
0905   09D6 2B                  DEC     HL              ; Back space buffer
0906   09D7 CA E9 09            JP      Z,OTKLN         ; No buffer - Try again
0907   09DA 7E                  LD      A,(HL)          ; Get deleted byte
0908   09DB CD 86 0A            CALL    OUTC            ; Echo it
0909   09DE C3 FB 09            JP      MORINP          ; Get more input
0910   09E1             
0911   09E1 05          DELCHR: DEC     B               ; Count bytes in buffer
0912   09E2 2B                  DEC     HL              ; Back space buffer
0913   09E3 CD 86 0A            CALL    OUTC            ; Output character in A
0914   09E6 C2 FB 09            JP      NZ,MORINP       ; Not end - Get more
0915   09E9 CD 86 0A    OTKLN:  CALL    OUTC            ; Output character in A
0916   09EC CD AD 0E    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0917   09EF C3 F2 09            JP      TTYLIN          ; Get line again
0918   09F2             
0919   09F2             GETLIN:
0920   09F2 21 61 82    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0921   09F5 06 01               LD      B,1             ; Set buffer as empty
0922   09F7 AF                  XOR     A
0923   09F8 32 44 82            LD      (NULFLG),A      ; Clear null flag
0924   09FB CD B0 0A    MORINP: CALL    CLOTST          ; Get character and test ^O
0925   09FE 4F                  LD      C,A             ; Save character in C
0926   09FF FE 7F               CP      DEL             ; Delete character?
0927   0A01 CA C1 09            JP      Z,DODEL         ; Yes - Process it
0928   0A04 3A 44 82            LD      A,(NULFLG)      ; Get null flag
0929   0A07 B7                  OR      A               ; Test null flag status
0930   0A08 CA 14 0A            JP      Z,PROCES        ; Reset - Process character
0931   0A0B 3E 00               LD      A,0             ; Set a null
0932   0A0D CD 86 0A            CALL    OUTC            ; Output null
0933   0A10 AF                  XOR     A               ; Clear A
0934   0A11 32 44 82            LD      (NULFLG),A      ; Reset null flag
0935   0A14 79          PROCES: LD      A,C             ; Get character
0936   0A15 FE 07               CP      CTRLG           ; Bell?
0937   0A17 CA 58 0A            JP      Z,PUTCTL        ; Yes - Save it
0938   0A1A FE 03               CP      CTRLC           ; Is it control "C"?
0939   0A1C CC AD 0E            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0940   0A1F 37                  SCF                     ; Flag break
0941   0A20 C8                  RET     Z               ; Return if control "C"
0942   0A21 FE 0D               CP      CR              ; Is it enter?
0943   0A23 CA A8 0E            JP      Z,ENDINP        ; Yes - Terminate input
0944   0A26 FE 15               CP      CTRLU           ; Is it control "U"?
0945   0A28 CA EC 09            JP      Z,KILIN         ; Yes - Get another line
0946   0A2B FE 40               CP      '@'             ; Is it "kill line"?
0947   0A2D CA E9 09            JP      Z,OTKLN         ; Yes - Kill line
0948   0A30 FE 5F               CP      '_'             ; Is it delete?
0949   0A32 CA E1 09            JP      Z,DELCHR        ; Yes - Delete character
0950   0A35 FE 08               CP      BKSP            ; Is it backspace?
0951   0A37 CA E1 09            JP      Z,DELCHR        ; Yes - Delete character
0952   0A3A FE 12               CP      CTRLR           ; Is it control "R"?
0953   0A3C C2 53 0A            JP      NZ,PUTBUF       ; No - Put in buffer
0954   0A3F C5                  PUSH    BC              ; Save buffer length
0955   0A40 D5                  PUSH    DE              ; Save DE
0956   0A41 E5                  PUSH    HL              ; Save buffer address
0957   0A42 36 00               LD      (HL),0          ; Mark end of buffer
0958   0A44 CD 5D 20            CALL    OUTNCR          ; Output and do CRLF
0959   0A47 21 61 82            LD      HL,BUFFER       ; Point to buffer start
0960   0A4A CD 4B 15            CALL    PRS             ; Output buffer
0961   0A4D E1                  POP     HL              ; Restore buffer address
0962   0A4E D1                  POP     DE              ; Restore DE
0963   0A4F C1                  POP     BC              ; Restore buffer length
0964   0A50 C3 FB 09            JP      MORINP          ; Get another character
0965   0A53             
0966   0A53 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0967   0A55 DA FB 09            JP      C,MORINP        ; Yes - Ignore
0968   0A58 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0969   0A59 FE 49               CP      72+1            ; Test for line overflow
0970   0A5B 3E 07               LD      A,CTRLG         ; Set a bell
0971   0A5D D2 6D 0A            JP      NC,OUTNBS       ; Ring bell if buffer full
0972   0A60 79                  LD      A,C             ; Get character
0973   0A61 71                  LD      (HL),C          ; Save in buffer
0974   0A62 32 CC 82            LD      (LSTBIN),A      ; Save last input byte
0975   0A65 23                  INC     HL              ; Move up buffer
0976   0A66 04                  INC     B               ; Increment length
0977   0A67 CD 86 0A    OUTIT:  CALL    OUTC            ; Output the character entered
0978   0A6A C3 FB 09            JP      MORINP          ; Get another character
0979   0A6D             
0980   0A6D CD 86 0A    OUTNBS: CALL    OUTC            ; Output bell and back over it
0981   0A70 3E 08               LD      A,BKSP          ; Set back space
0982   0A72 C3 67 0A            JP      OUTIT           ; Output it and get more
0983   0A75             
0984   0A75 7C          CPDEHL: LD      A,H             ; Get H
0985   0A76 92                  SUB     D               ; Compare with D
0986   0A77 C0                  RET     NZ              ; Different - Exit
0987   0A78 7D                  LD      A,L             ; Get L
0988   0A79 93                  SUB     E               ; Compare with E
0989   0A7A C9                  RET                     ; Return status
0990   0A7B             
0991   0A7B 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0992   0A7C E3                  EX      (SP),HL         ; Address of test byte
0993   0A7D BE                  CP      (HL)            ; Same as in code string?
0994   0A7E 23                  INC     HL              ; Return address
0995   0A7F E3                  EX      (SP),HL         ; Put it back
0996   0A80 CA 05 0C            JP      Z,GETCHR        ; Yes - Get next character
0997   0A83 C3 AD 07            JP      SNERR           ; Different - ?SN Error
0998   0A86             
0999   0A86 F5          OUTC:   PUSH    AF              ; Save character
1000   0A87 3A 45 82            LD      A,(CTLOFG)      ; Get control "O" flag
1001   0A8A B7                  OR      A               ; Is it set?
1002   0A8B C2 80 15            JP      NZ,POPAF        ; Yes - don't output
1003   0A8E F1                  POP     AF              ; Restore character
1004   0A8F C5                  PUSH    BC              ; Save buffer length
1005   0A90 F5                  PUSH    AF              ; Save character
1006   0A91 FE 20               CP      ' '             ; Is it a control code?
1007   0A93 DA AA 0A            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1008   0A96 3A 42 82            LD      A,(LWIDTH)      ; Get line width
1009   0A99 47                  LD      B,A             ; To B
1010   0A9A 3A AB 82            LD      A,(CURPOS)      ; Get cursor position
1011   0A9D 04                  INC     B               ; Width 255?
1012   0A9E CA A6 0A            JP      Z,INCLEN        ; Yes - No width limit
1013   0AA1 05                  DEC     B               ; Restore width
1014   0AA2 B8                  CP      B               ; At end of line?
1015   0AA3 CC AD 0E            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1016   0AA6 3C          INCLEN: INC     A               ; Move on one character
1017   0AA7 32 AB 82            LD      (CURPOS),A      ; Save new position
1018   0AAA F1          DINPOS: POP     AF              ; Restore character
1019   0AAB C1                  POP     BC              ; Restore buffer length
1020   0AAC CD 46 20            CALL    MONOUT          ; Send it
1021   0AAF C9                  RET
1022   0AB0             
1023   0AB0 CD 0A 1F    CLOTST: CALL    GETINP          ; Get input character
1024   0AB3 E6 7F               AND     01111111B       ; Strip bit 7
1025   0AB5 FE 0F               CP      CTRLO           ; Is it control "O"?
1026   0AB7 C0                  RET     NZ              ; No don't flip flag
1027   0AB8 3A 45 82            LD      A,(CTLOFG)      ; Get flag
1028   0ABB 2F                  CPL                     ; Flip it
1029   0ABC 32 45 82            LD      (CTLOFG),A      ; Put it back
1030   0ABF AF                  XOR     A               ; Null character
1031   0AC0 C9                  RET
1032   0AC1             
1033   0AC1 CD D1 0C    LIST:   CALL    ATOH            ; ASCII number to DE
1034   0AC4 C0                  RET     NZ              ; Return if anything extra
1035   0AC5 C1                  POP     BC              ; Rubbish - Not needed
1036   0AC6 CD 99 08            CALL    SRCHLN          ; Search for line number in DE
1037   0AC9 C5                  PUSH    BC              ; Save address of line
1038   0ACA CD 17 0B            CALL    SETLIN          ; Set up lines counter
1039   0ACD E1          LISTLP: POP     HL              ; Restore address of line
1040   0ACE 4E                  LD      C,(HL)          ; Get LSB of next line
1041   0ACF 23                  INC     HL
1042   0AD0 46                  LD      B,(HL)          ; Get MSB of next line
1043   0AD1 23                  INC     HL
1044   0AD2 78                  LD      A,B             ; BC = 0 (End of program)?
1045   0AD3 B1                  OR      C
1046   0AD4 CA F8 07            JP      Z,PRNTOK        ; Yes - Go to command mode
1047   0AD7 CD 20 0B            CALL    COUNT           ; Count lines
1048   0ADA CD 30 0C            CALL    TSTBRK          ; Test for break key
1049   0ADD C5                  PUSH    BC              ; Save address of next line
1050   0ADE CD AD 0E            CALL    PRNTCRLF        ; Output CRLF
1051   0AE1 5E                  LD      E,(HL)          ; Get LSB of line number
1052   0AE2 23                  INC     HL
1053   0AE3 56                  LD      D,(HL)          ; Get MSB of line number
1054   0AE4 23                  INC     HL
1055   0AE5 E5                  PUSH    HL              ; Save address of line start
1056   0AE6 EB                  EX      DE,HL           ; Line number to HL
1057   0AE7 CD EE 1B            CALL    PRNTHL          ; Output line number in decimal
1058   0AEA 3E 20               LD      A,' '           ; Space after line number
1059   0AEC E1                  POP     HL              ; Restore start of line address
1060   0AED CD 86 0A    LSTLP2: CALL    OUTC            ; Output character in A
1061   0AF0 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1062   0AF1 B7                  OR      A               ; End of line?
1063   0AF2 23                  INC     HL              ; To next byte in line
1064   0AF3 CA CD 0A            JP      Z,LISTLP        ; Yes - get next line
1065   0AF6 F2 ED 0A            JP      P,LSTLP2        ; No token - output it
1066   0AF9 D6 7F               SUB     ZEND-1          ; Find and output word
1067   0AFB 4F                  LD      C,A             ; Token offset+1 to C
1068   0AFC 11 36 05            LD      DE,WORDS        ; Reserved word list
1069   0AFF 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1070   0B00 13                  INC     DE              ; Move on to next
1071   0B01 B7                  OR      A               ; Is it start of word?
1072   0B02 F2 FF 0A            JP      P,FNDTOK        ; No - Keep looking for word
1073   0B05 0D                  DEC     C               ; Count words
1074   0B06 C2 FF 0A            JP      NZ,FNDTOK       ; Not there - keep looking
1075   0B09 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1076   0B0B CD 86 0A            CALL    OUTC            ; Output first character
1077   0B0E 1A                  LD      A,(DE)          ; Get next character
1078   0B0F 13                  INC     DE              ; Move on to next
1079   0B10 B7                  OR      A               ; Is it end of word?
1080   0B11 F2 09 0B            JP      P,OUTWRD        ; No - output the rest
1081   0B14 C3 F0 0A            JP      LSTLP3          ; Next byte in line
1082   0B17             
1083   0B17 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1084   0B18 2A 48 82            LD      HL,(LINESN)     ; Get LINES number
1085   0B1B 22 46 82            LD      (LINESC),HL     ; Save in LINES counter
1086   0B1E E1                  POP     HL
1087   0B1F C9                  RET
1088   0B20             
1089   0B20 E5          COUNT:  PUSH    HL              ; Save code string address
1090   0B21 D5                  PUSH    DE
1091   0B22 2A 46 82            LD      HL,(LINESC)     ; Get LINES counter
1092   0B25 11 FF FF            LD      DE,-1
1093   0B28 ED 5A               ADC     HL,DE           ; Decrement
1094   0B2A 22 46 82            LD      (LINESC),HL     ; Put it back
1095   0B2D D1                  POP     DE
1096   0B2E E1                  POP     HL              ; Restore code string address
1097   0B2F F0                  RET     P               ; Return if more lines to go
1098   0B30 E5                  PUSH    HL              ; Save code string address
1099   0B31 2A 48 82            LD      HL,(LINESN)     ; Get LINES number
1100   0B34 22 46 82            LD      (LINESC),HL     ; Reset LINES counter
1101   0B37 CD 0A 1F            CALL    GETINP          ; Get input character
1102   0B3A FE 03               CP      CTRLC           ; Is it control "C"?
1103   0B3C CA 43 0B            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1104   0B3F E1                  POP     HL              ; Restore code string address
1105   0B40 C3 20 0B            JP      COUNT           ; Keep on counting
1106   0B43             
1107   0B43 2A 48 82    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1108   0B46 22 46 82            LD      (LINESC),HL     ; Reset LINES counter
1109   0B49 C3 A7 04            JP      BRKRET          ; Go and output "Break"
1110   0B4C             
1111   0B4C 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1112   0B4E 32 CB 82            LD      (FORFLG),A      ; Save "FOR" flag
1113   0B51 CD B3 0D            CALL    LET             ; Set up initial index
1114   0B54 C1                  POP     BC              ; Drop RETurn address
1115   0B55 E5                  PUSH    HL              ; Save code string address
1116   0B56 CD 9C 0D            CALL    DATA            ; Get next statement address
1117   0B59 22 C7 82            LD      (LOOPST),HL     ; Save it for start of loop
1118   0B5C 21 02 00            LD      HL,2            ; Offset for "FOR" block
1119   0B5F 39                  ADD     HL,SP           ; Point to it
1120   0B60 CD 5A 07    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1121   0B63 D1                  POP     DE              ; Get code string address
1122   0B64 C2 7C 0B            JP      NZ,FORFND       ; No nesting found
1123   0B67 09                  ADD     HL,BC           ; Move into "FOR" block
1124   0B68 D5                  PUSH    DE              ; Save code string address
1125   0B69 2B                  DEC     HL
1126   0B6A 56                  LD      D,(HL)          ; Get MSB of loop statement
1127   0B6B 2B                  DEC     HL
1128   0B6C 5E                  LD      E,(HL)          ; Get LSB of loop statement
1129   0B6D 23                  INC     HL
1130   0B6E 23                  INC     HL
1131   0B6F E5                  PUSH    HL              ; Save block address
1132   0B70 2A C7 82            LD      HL,(LOOPST)     ; Get address of loop statement
1133   0B73 CD 75 0A            CALL    CPDEHL          ; Compare the FOR loops
1134   0B76 E1                  POP     HL              ; Restore block address
1135   0B77 C2 60 0B            JP      NZ,FORSLP       ; Different FORs - Find another
1136   0B7A D1                  POP     DE              ; Restore code string address
1137   0B7B F9                  LD      SP,HL           ; Remove all nested loops
1138   0B7C             
1139   0B7C EB          FORFND: EX      DE,HL           ; Code string address to HL
1140   0B7D 0E 08               LD      C,8
1141   0B7F CD 8A 07            CALL    CHKSTK          ; Check for 8 levels of stack
1142   0B82 E5                  PUSH    HL              ; Save code string address
1143   0B83 2A C7 82            LD      HL,(LOOPST)     ; Get first statement of loop
1144   0B86 E3                  EX      (SP),HL         ; Save and restore code string
1145   0B87 E5                  PUSH    HL              ; Re-save code string address
1146   0B88 2A 5C 82            LD      HL,(LINEAT)     ; Get current line number
1147   0B8B E3                  EX      (SP),HL         ; Save and restore code string
1148   0B8C CD 75 10            CALL    TSTNUM          ; Make sure it's a number
1149   0B8F CD 7B 0A            CALL    CHKSYN          ; Make sure "TO" is next
1150   0B92 A6                  .BYTE   ZTO          ; "TO" token
1151   0B93 CD 72 10            CALL    GETNUM          ; Get "TO" expression value
1152   0B96 E5                  PUSH    HL              ; Save code string address
1153   0B97 CD A0 1A            CALL    BCDEFP          ; Move "TO" value to BCDE
1154   0B9A E1                  POP     HL              ; Restore code string address
1155   0B9B C5                  PUSH    BC              ; Save "TO" value in block
1156   0B9C D5                  PUSH    DE
1157   0B9D 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1158   0BA0 51                  LD      D,C             ; C=0
1159   0BA1 5A                  LD      E,D             ; D=0
1160   0BA2 7E                  LD      A,(HL)          ; Get next byte in code string
1161   0BA3 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1162   0BA5 3E 01               LD      A,1             ; Sign of step = 1
1163   0BA7 C2 B8 0B            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1164   0BAA CD 05 0C            CALL    GETCHR          ; Jump over "STEP" token
1165   0BAD CD 72 10            CALL    GETNUM          ; Get step value
1166   0BB0 E5                  PUSH    HL              ; Save code string address
1167   0BB1 CD A0 1A            CALL    BCDEFP          ; Move STEP to BCDE
1168   0BB4 CD 54 1A            CALL    TSTSGN          ; Test sign of FPREG
1169   0BB7 E1                  POP     HL              ; Restore code string address
1170   0BB8 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1171   0BB9 D5                  PUSH    DE
1172   0BBA F5                  PUSH    AF              ; Save sign of STEP
1173   0BBB 33                  INC     SP              ; Don't save flags
1174   0BBC E5                  PUSH    HL              ; Save code string address
1175   0BBD 2A CE 82            LD      HL,(BRKLIN)     ; Get address of index variable
1176   0BC0 E3                  EX      (SP),HL         ; Save and restore code string
1177   0BC1 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1178   0BC3 C5                  PUSH    BC              ; Save it
1179   0BC4 33                  INC     SP              ; Don't save C
1180   0BC5             
1181   0BC5 CD 30 0C    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1182   0BC8 22 CE 82            LD      (BRKLIN),HL     ; Save code address for break
1183   0BCB 7E                  LD      A,(HL)          ; Get next byte in code string
1184   0BCC FE 3A               CP      ':'             ; Multi statement line?
1185   0BCE CA E5 0B            JP      Z,EXCUTE        ; Yes - Execute it
1186   0BD1 B7                  OR      A               ; End of line?
1187   0BD2 C2 AD 07            JP      NZ,SNERR        ; No - Syntax error
1188   0BD5 23                  INC     HL              ; Point to address of next line
1189   0BD6 7E                  LD      A,(HL)          ; Get LSB of line pointer
1190   0BD7 23                  INC     HL
1191   0BD8 B6                  OR      (HL)            ; Is it zero (End of prog)?
1192   0BD9 CA 57 0C            JP      Z,ENDPRG        ; Yes - Terminate execution
1193   0BDC 23                  INC     HL              ; Point to line number
1194   0BDD 5E                  LD      E,(HL)          ; Get LSB of line number
1195   0BDE 23                  INC     HL
1196   0BDF 56                  LD      D,(HL)          ; Get MSB of line number
1197   0BE0 EB                  EX      DE,HL           ; Line number to HL
1198   0BE1 22 5C 82            LD      (LINEAT),HL     ; Save as current line number
1199   0BE4 EB                  EX      DE,HL           ; Line number back to DE
1200   0BE5 CD 05 0C    EXCUTE: CALL    GETCHR          ; Get key word
1201   0BE8 11 C5 0B            LD      DE,RUNCNT       ; Where to RETurn to
1202   0BEB D5                  PUSH    DE              ; Save for RETurn
1203   0BEC C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1204   0BED D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1205   0BEF DA B3 0D            JP      C,LET           ; No - try to assign it
1206   0BF2 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1207   0BF4 D2 AD 07            JP      NC,SNERR        ; Not a key word - ?SN Error
1208   0BF7 07                  RLCA                    ; Double it
1209   0BF8 4F                  LD      C,A             ; BC = Offset into table
1210   0BF9 06 00               LD      B,0
1211   0BFB EB                  EX      DE,HL           ; Save code string address
1212   0BFC 21 55 06            LD      HL,WORDTB       ; Keyword address table
1213   0BFF 09                  ADD     HL,BC           ; Point to routine address
1214   0C00 4E                  LD      C,(HL)          ; Get LSB of routine address
1215   0C01 23                  INC     HL
1216   0C02 46                  LD      B,(HL)          ; Get MSB of routine address
1217   0C03 C5                  PUSH    BC              ; Save routine address
1218   0C04 EB                  EX      DE,HL           ; Restore code string address
1219   0C05             
1220   0C05 23          GETCHR: INC     HL              ; Point to next character
1221   0C06 7E                  LD      A,(HL)          ; Get next code string byte
1222   0C07 FE 3A               CP      ':'             ; Z if ':'
1223   0C09 D0                  RET     NC              ; NC if > "9"
1224   0C0A FE 20               CP      ' '
1225   0C0C CA 05 0C            JP      Z,GETCHR        ; Skip over spaces
1226   0C0F FE 30               CP      '0'
1227   0C11 3F                  CCF                     ; NC if < '0'
1228   0C12 3C                  INC     A               ; Test for zero - Leave carry
1229   0C13 3D                  DEC     A               ; Z if Null
1230   0C14 C9                  RET
1231   0C15             
1232   0C15 EB          RESTOR: EX      DE,HL           ; Save code string address
1233   0C16 2A 5E 82            LD      HL,(BASTXT)     ; Point to start of program
1234   0C19 CA 2A 0C            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1235   0C1C EB                  EX      DE,HL           ; Restore code string address
1236   0C1D CD D1 0C            CALL    ATOH            ; Get line number to DE
1237   0C20 E5                  PUSH    HL              ; Save code string address
1238   0C21 CD 99 08            CALL    SRCHLN          ; Search for line number in DE
1239   0C24 60                  LD      H,B             ; HL = Address of line
1240   0C25 69                  LD      L,C
1241   0C26 D1                  POP     DE              ; Restore code string address
1242   0C27 D2 72 0D            JP      NC,ULERR        ; ?UL Error if not found
1243   0C2A 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1244   0C2B 22 DC 82    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1245   0C2E EB                  EX      DE,HL           ; Restore code string address
1246   0C2F C9                  RET
1247   0C30             
1248   0C30             
1249   0C30 DF          TSTBRK: RST     18H             ; Check input status
1250   0C31 C8                  RET     Z               ; No key, go back
1251   0C32 D7                  RST     10H             ; Get the key into A
1252   0C33 FE 1B               CP      ESC             ; Escape key?
1253   0C35 28 11               JR      Z,BRK           ; Yes, break
1254   0C37 FE 03               CP      CTRLC           ; <Ctrl-C>
1255   0C39 28 0D               JR      Z,BRK           ; Yes, break
1256   0C3B FE 13               CP      CTRLS           ; Stop scrolling?
1257   0C3D C0                  RET     NZ              ; Other key, ignore
1258   0C3E             
1259   0C3E             
1260   0C3E D7          STALL:  RST     10H             ; Wait for key
1261   0C3F FE 11               CP      CTRLQ           ; Resume scrolling?
1262   0C41 C8                  RET      Z              ; Release the chokehold
1263   0C42 FE 03               CP      CTRLC           ; Second break?
1264   0C44 28 07               JR      Z,STOP          ; Break during hold exits prog
1265   0C46 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1266   0C48             
1267   0C48 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1268   0C4A 32 4D 82            LD      (BRKFLG),A      ; Store it
1269   0C4D             
1270   0C4D             
1271   0C4D C0          STOP:   RET     NZ              ; Exit if anything else
1272   0C4E F6                  .BYTE   0F6H            ; Flag "STOP"
1273   0C4F C0          PEND:   RET     NZ              ; Exit if anything else
1274   0C50 22 CE 82            LD      (BRKLIN),HL     ; Save point of break
1275   0C53 21                  .BYTE   21H             ; Skip "OR 11111111B"
1276   0C54 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1277   0C56 C1                  POP     BC              ; Return not needed and more
1278   0C57 2A 5C 82    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1279   0C5A F5                  PUSH    AF              ; Save STOP / END status
1280   0C5B 7D                  LD      A,L             ; Is it direct break?
1281   0C5C A4                  AND     H
1282   0C5D 3C                  INC     A               ; Line is -1 if direct break
1283   0C5E CA 6A 0C            JP      Z,NOLIN         ; Yes - No line number
1284   0C61 22 D2 82            LD      (ERRLIN),HL     ; Save line of break
1285   0C64 2A CE 82            LD      HL,(BRKLIN)     ; Get point of break
1286   0C67 22 D4 82            LD      (CONTAD),HL     ; Save point to CONTinue
1287   0C6A AF          NOLIN:  XOR     A
1288   0C6B 32 45 82            LD      (CTLOFG),A      ; Enable output
1289   0C6E CD A0 0E            CALL    STTLIN          ; Start a new line
1290   0C71 F1                  POP     AF              ; Restore STOP / END status
1291   0C72 21 50 07            LD      HL,BRKMSG       ; "Break" message
1292   0C75 C2 E1 07            JP      NZ,ERRIN        ; "in line" wanted?
1293   0C78 C3 F8 07            JP      PRNTOK          ; Go to command mode
1294   0C7B             
1295   0C7B 2A D4 82    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1296   0C7E 7C                  LD      A,H             ; Is it zero?
1297   0C7F B5                  OR      L
1298   0C80 1E 20               LD      E,CN            ; ?CN Error
1299   0C82 CA C1 07            JP      Z,ERROR         ; Yes - output "?CN Error"
1300   0C85 EB                  EX      DE,HL           ; Save code string address
1301   0C86 2A D2 82            LD      HL,(ERRLIN)     ; Get line of last break
1302   0C89 22 5C 82            LD      (LINEAT),HL     ; Set up current line number
1303   0C8C EB                  EX      DE,HL           ; Restore code string address
1304   0C8D C9                  RET                     ; CONTinue where left off
1305   0C8E             
1306   0C8E CD D3 17    NULL:   CALL    GETINT          ; Get integer 0-255
1307   0C91 C0                  RET     NZ              ; Return if bad value
1308   0C92 32 41 82            LD      (NULLS),A       ; Set nulls number
1309   0C95 C9                  RET
1310   0C96             
1311   0C96             
1312   0C96 E5          ACCSUM: PUSH    HL              ; Save address in array
1313   0C97 2A 4A 82            LD      HL,(CHKSUM)     ; Get check sum
1314   0C9A 06 00               LD      B,0             ; BC - Value of byte
1315   0C9C 4F                  LD      C,A
1316   0C9D 09                  ADD     HL,BC           ; Add byte to check sum
1317   0C9E 22 4A 82            LD      (CHKSUM),HL     ; Re-save check sum
1318   0CA1 E1                  POP     HL              ; Restore address in array
1319   0CA2 C9                  RET
1320   0CA3             
1321   0CA3 7E          CHKLTR: LD      A,(HL)          ; Get byte
1322   0CA4 FE 41               CP      'A'             ; < 'a' ?
1323   0CA6 D8                  RET     C               ; Carry set if not letter
1324   0CA7 FE 5B               CP      'Z'+1           ; > 'z' ?
1325   0CA9 3F                  CCF
1326   0CAA C9                  RET                     ; Carry set if not letter
1327   0CAB             
1328   0CAB CD 05 0C    FPSINT: CALL    GETCHR          ; Get next character
1329   0CAE CD 72 10    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1330   0CB1 CD 54 1A    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1331   0CB4 FA CC 0C            JP      M,FCERR         ; Negative - ?FC Error
1332   0CB7 3A E7 82    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1333   0CBA FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1334   0CBC DA FC 1A            JP      C,FPINT         ; Yes - convert it
1335   0CBF 01 80 90            LD      BC,9080H        ; BCDE = -32768
1336   0CC2 11 00 00            LD      DE,0000
1337   0CC5 E5                  PUSH    HL              ; Save code string address
1338   0CC6 CD CF 1A            CALL    CMPNUM          ; Compare FPREG with BCDE
1339   0CC9 E1                  POP     HL              ; Restore code string address
1340   0CCA 51                  LD      D,C             ; MSB to D
1341   0CCB C8                  RET     Z               ; Return if in range
1342   0CCC 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1343   0CCE C3 C1 07            JP      ERROR           ; Output error-
1344   0CD1             
1345   0CD1 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1346   0CD2 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1347   0CD5 CD 05 0C    GTLNLP: CALL    GETCHR          ; Get next character
1348   0CD8 D0                  RET     NC              ; Exit if not a digit
1349   0CD9 E5                  PUSH    HL              ; Save code string address
1350   0CDA F5                  PUSH    AF              ; Save digit
1351   0CDB 21 98 19            LD      HL,65529/10     ; Largest number 65529
1352   0CDE CD 75 0A            CALL    CPDEHL          ; Number in range?
1353   0CE1 DA AD 07            JP      C,SNERR         ; No - ?SN Error
1354   0CE4 62                  LD      H,D             ; HL = Number
1355   0CE5 6B                  LD      L,E
1356   0CE6 19                  ADD     HL,DE           ; Times 2
1357   0CE7 29                  ADD     HL,HL           ; Times 4
1358   0CE8 19                  ADD     HL,DE           ; Times 5
1359   0CE9 29                  ADD     HL,HL           ; Times 10
1360   0CEA F1                  POP     AF              ; Restore digit
1361   0CEB D6 30               SUB     '0'             ; Make it 0 to 9
1362   0CED 5F                  LD      E,A             ; DE = Value of digit
1363   0CEE 16 00               LD      D,0
1364   0CF0 19                  ADD     HL,DE           ; Add to number
1365   0CF1 EB                  EX      DE,HL           ; Number to DE
1366   0CF2 E1                  POP     HL              ; Restore code string address
1367   0CF3 C3 D5 0C            JP      GTLNLP          ; Go to next character
1368   0CF6             
1369   0CF6 CA C9 08    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1370   0CF9 CD AE 0C            CALL    POSINT          ; Get integer 0 to 32767 to DE
1371   0CFC 2B                  DEC     HL              ; Cancel increment
1372   0CFD CD 05 0C            CALL    GETCHR          ; Get next character
1373   0D00 E5                  PUSH    HL              ; Save code string address
1374   0D01 2A AF 82            LD      HL,(LSTRAM)     ; Get end of RAM
1375   0D04 CA 19 0D            JP      Z,STORED        ; No value given - Use stored
1376   0D07 E1                  POP     HL              ; Restore code string address
1377   0D08 CD 7B 0A            CALL    CHKSYN          ; Check for comma
1378   0D0B 2C                  .BYTE      ','
1379   0D0C D5                  PUSH    DE              ; Save number
1380   0D0D CD AE 0C            CALL    POSINT          ; Get integer 0 to 32767
1381   0D10 2B                  DEC     HL              ; Cancel increment
1382   0D11 CD 05 0C            CALL    GETCHR          ; Get next character
1383   0D14 C2 AD 07            JP      NZ,SNERR        ; ?SN Error if more on line
1384   0D17 E3                  EX      (SP),HL         ; Save code string address
1385   0D18 EB                  EX      DE,HL           ; Number to DE
1386   0D19 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1387   0D1A 93                  SUB     E               ; Subtract LSB of string space
1388   0D1B 5F                  LD      E,A             ; Save LSB
1389   0D1C 7C                  LD      A,H             ; Get MSB of new RAM top
1390   0D1D 9A                  SBC     A,D             ; Subtract MSB of string space
1391   0D1E 57                  LD      D,A             ; Save MSB
1392   0D1F DA A2 07            JP      C,OMERR         ; ?OM Error if not enough mem
1393   0D22 E5                  PUSH    HL              ; Save RAM top
1394   0D23 2A D6 82            LD      HL,(PROGND)     ; Get program end
1395   0D26 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1396   0D29 09                  ADD     HL,BC           ; Get lowest address
1397   0D2A CD 75 0A            CALL    CPDEHL          ; Enough memory?
1398   0D2D D2 A2 07            JP      NC,OMERR        ; No - ?OM Error
1399   0D30 EB                  EX      DE,HL           ; RAM top to HL
1400   0D31 22 5A 82            LD      (STRSPC),HL     ; Set new string space
1401   0D34 E1                  POP     HL              ; End of memory to use
1402   0D35 22 AF 82            LD      (LSTRAM),HL     ; Set new top of RAM
1403   0D38 E1                  POP     HL              ; Restore code string address
1404   0D39 C3 C9 08            JP      INTVAR          ; Initialise variables
1405   0D3C             
1406   0D3C CA C5 08    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1407   0D3F CD C9 08            CALL    INTVAR          ; Initialise variables
1408   0D42 01 C5 0B            LD      BC,RUNCNT       ; Execution driver loop
1409   0D45 C3 58 0D            JP      RUNLIN          ; RUN from line number
1410   0D48             
1411   0D48 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1412   0D4A CD 8A 07            CALL    CHKSTK          ; Check for 3 levels of stack
1413   0D4D C1                  POP     BC              ; Get return address
1414   0D4E E5                  PUSH    HL              ; Save code string for RETURN
1415   0D4F E5                  PUSH    HL              ; And for GOSUB routine
1416   0D50 2A 5C 82            LD      HL,(LINEAT)     ; Get current line
1417   0D53 E3                  EX      (SP),HL         ; Into stack - Code string out
1418   0D54 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1419   0D56 F5                  PUSH    AF              ; Save token
1420   0D57 33                  INC     SP              ; Don't save flags
1421   0D58             
1422   0D58 C5          RUNLIN: PUSH    BC              ; Save return address
1423   0D59 CD D1 0C    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1424   0D5C CD 9E 0D            CALL    REM             ; Get end of line
1425   0D5F E5                  PUSH    HL              ; Save end of line
1426   0D60 2A 5C 82            LD      HL,(LINEAT)     ; Get current line
1427   0D63 CD 75 0A            CALL    CPDEHL          ; Line after current?
1428   0D66 E1                  POP     HL              ; Restore end of line
1429   0D67 23                  INC     HL              ; Start of next line
1430   0D68 DC 9C 08            CALL    C,SRCHLP        ; Line is after current line
1431   0D6B D4 99 08            CALL    NC,SRCHLN       ; Line is before current line
1432   0D6E 60                  LD      H,B             ; Set up code string address
1433   0D6F 69                  LD      L,C
1434   0D70 2B                  DEC     HL              ; Incremented after
1435   0D71 D8                  RET     C               ; Line found
1436   0D72 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1437   0D74 C3 C1 07            JP      ERROR           ; Output error message
1438   0D77             
1439   0D77 C0          RETURN: RET     NZ              ; Return if not just RETURN
1440   0D78 16 FF               LD      D,-1            ; Flag "GOSUB" search
1441   0D7A CD 56 07            CALL    BAKSTK          ; Look "GOSUB" block
1442   0D7D F9                  LD      SP,HL           ; Kill all FORs in subroutine
1443   0D7E FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1444   0D80 1E 04               LD      E,RG            ; ?RG Error
1445   0D82 C2 C1 07            JP      NZ,ERROR        ; Error if no "GOSUB" found
1446   0D85 E1                  POP     HL              ; Get RETURN line number
1447   0D86 22 5C 82            LD      (LINEAT),HL     ; Save as current
1448   0D89 23                  INC     HL              ; Was it from direct statement?
1449   0D8A 7C                  LD      A,H
1450   0D8B B5                  OR      L               ; Return to line
1451   0D8C C2 96 0D            JP      NZ,RETLIN       ; No - Return to line
1452   0D8F 3A CC 82            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1453   0D92 B7                  OR      A               ; If so buffer is corrupted
1454   0D93 C2 F7 07            JP      NZ,POPNOK       ; Yes - Go to command mode
1455   0D96 21 C5 0B    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1456   0D99 E3                  EX      (SP),HL         ; Into stack - Code string out
1457   0D9A 3E                  .BYTE      3EH             ; Skip "POP HL"
1458   0D9B E1          NXTDTA: POP     HL              ; Restore code string address
1459   0D9C             
1460   0D9C 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1461   0D9E 0E 00       REM:    LD      C,0             ; 00  End of statement
1462   0DA0 06 00               LD      B,0
1463   0DA2 79          NXTSTL: LD      A,C             ; Statement and byte
1464   0DA3 48                  LD      C,B
1465   0DA4 47                  LD      B,A             ; Statement end byte
1466   0DA5 7E          NXTSTT: LD      A,(HL)          ; Get byte
1467   0DA6 B7                  OR      A               ; End of line?
1468   0DA7 C8                  RET     Z               ; Yes - Exit
1469   0DA8 B8                  CP      B               ; End of statement?
1470   0DA9 C8                  RET     Z               ; Yes - Exit
1471   0DAA 23                  INC     HL              ; Next byte
1472   0DAB FE 22               CP      '"'             ; Literal string?
1473   0DAD CA A2 0D            JP      Z,NXTSTL        ; Yes - Look for another '"'
1474   0DB0 C3 A5 0D            JP      NXTSTT          ; Keep looking
1475   0DB3             
1476   0DB3 CD 68 12    LET:    CALL    GETVAR          ; Get variable name
1477   0DB6 CD 7B 0A            CALL    CHKSYN          ; Make sure "=" follows
1478   0DB9 B4                  .BYTE      ZEQUAL          ; "=" token
1479   0DBA D5                  PUSH    DE              ; Save address of variable
1480   0DBB 3A AD 82            LD      A,(TYPE)        ; Get data type
1481   0DBE F5                  PUSH    AF              ; Save type
1482   0DBF CD 84 10            CALL    EVAL            ; Evaluate expression
1483   0DC2 F1                  POP     AF              ; Restore type
1484   0DC3 E3                  EX      (SP),HL         ; Save code - Get var addr
1485   0DC4 22 CE 82            LD      (BRKLIN),HL     ; Save address of variable
1486   0DC7 1F                  RRA                     ; Adjust type
1487   0DC8 CD 77 10            CALL    CHKTYP          ; Check types are the same
1488   0DCB CA 06 0E            JP      Z,LETNUM        ; Numeric - Move value
1489   0DCE E5          LETSTR: PUSH    HL              ; Save address of string var
1490   0DCF 2A E4 82            LD      HL,(FPREG)      ; Pointer to string entry
1491   0DD2 E5                  PUSH    HL              ; Save it on stack
1492   0DD3 23                  INC     HL              ; Skip over length
1493   0DD4 23                  INC     HL
1494   0DD5 5E                  LD      E,(HL)          ; LSB of string address
1495   0DD6 23                  INC     HL
1496   0DD7 56                  LD      D,(HL)          ; MSB of string address
1497   0DD8 2A 5E 82            LD      HL,(BASTXT)     ; Point to start of program
1498   0DDB CD 75 0A            CALL    CPDEHL          ; Is string before program?
1499   0DDE D2 F5 0D            JP      NC,CRESTR       ; Yes - Create string entry
1500   0DE1 2A 5A 82            LD      HL,(STRSPC)     ; Point to string space
1501   0DE4 CD 75 0A            CALL    CPDEHL          ; Is string literal in program?
1502   0DE7 D1                  POP     DE              ; Restore address of string
1503   0DE8 D2 FD 0D            JP      NC,MVSTPT       ; Yes - Set up pointer
1504   0DEB 21 BF 82            LD      HL,TMPSTR       ; Temporary string pool
1505   0DEE CD 75 0A            CALL    CPDEHL          ; Is string in temporary pool?
1506   0DF1 D2 FD 0D            JP      NC,MVSTPT       ; No - Set up pointer
1507   0DF4 3E                  .BYTE   3EH             ; Skip "POP DE"
1508   0DF5 D1          CRESTR: POP     DE              ; Restore address of string
1509   0DF6 CD AC 16            CALL    BAKTMP          ; Back to last tmp-str entry
1510   0DF9 EB                  EX      DE,HL           ; Address of string entry
1511   0DFA CD E5 14            CALL    SAVSTR          ; Save string in string area
1512   0DFD CD AC 16    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1513   0E00 E1                  POP     HL              ; Get string pointer
1514   0E01 CD AF 1A            CALL    DETHL4          ; Move string pointer to var
1515   0E04 E1                  POP     HL              ; Restore code string address
1516   0E05 C9                  RET
1517   0E06             
1518   0E06 E5          LETNUM: PUSH    HL              ; Save address of variable
1519   0E07 CD AC 1A            CALL    FPTHL           ; Move value to variable
1520   0E0A D1                  POP     DE              ; Restore address of variable
1521   0E0B E1                  POP     HL              ; Restore code string address
1522   0E0C C9                  RET
1523   0E0D             
1524   0E0D CD D3 17    ON:     CALL    GETINT          ; Get integer 0-255
1525   0E10 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1526   0E11 47                  LD      B,A             ; Save in B
1527   0E12 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1528   0E14 CA 1C 0E            JP      Z,ONGO          ; Yes - Find line number
1529   0E17 CD 7B 0A            CALL    CHKSYN          ; Make sure it's "GOTO"
1530   0E1A 88                  .BYTE   ZGOTO           ; "GOTO" token
1531   0E1B 2B                  DEC     HL              ; Cancel increment
1532   0E1C 4B          ONGO:   LD      C,E             ; Integer of branch value
1533   0E1D 0D          ONGOLP: DEC     C               ; Count branches
1534   0E1E 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1535   0E1F CA ED 0B            JP      Z,ONJMP         ; Go to that line if right one
1536   0E22 CD D2 0C            CALL    GETLN           ; Get line number to DE
1537   0E25 FE 2C               CP      ','             ; Another line number?
1538   0E27 C0                  RET     NZ              ; No - Drop through
1539   0E28 C3 1D 0E            JP      ONGOLP          ; Yes - loop
1540   0E2B             
1541   0E2B CD 84 10    IF:     CALL    EVAL            ; Evaluate expression
1542   0E2E 7E                  LD      A,(HL)          ; Get token
1543   0E2F FE 88               CP      ZGOTO           ; "GOTO" token?
1544   0E31 CA 39 0E            JP      Z,IFGO          ; Yes - Get line
1545   0E34 CD 7B 0A            CALL    CHKSYN          ; Make sure it's "THEN"
1546   0E37 A9                  .BYTE      ZTHEN           ; "THEN" token
1547   0E38 2B                  DEC     HL              ; Cancel increment
1548   0E39 CD 75 10    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1549   0E3C CD 54 1A            CALL    TSTSGN          ; Test state of expression
1550   0E3F CA 9E 0D            JP      Z,REM           ; False - Drop through
1551   0E42 CD 05 0C            CALL    GETCHR          ; Get next character
1552   0E45 DA 59 0D            JP      C,GOTO          ; Number - GOTO that line
1553   0E48 C3 EC 0B            JP      IFJMP           ; Otherwise do statement
1554   0E4B             
1555   0E4B 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1556   0E4C CD 05 0C            CALL    GETCHR          ; Get next character
1557   0E4F CA AD 0E    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1558   0E52 C8          PRNTLP: RET     Z               ; End of list - Exit
1559   0E53 FE A5               CP      ZTAB            ; "TAB(" token?
1560   0E55 CA E0 0E            JP      Z,DOTAB         ; Yes - Do TAB routine
1561   0E58 FE A8               CP      ZSPC            ; "SPC(" token?
1562   0E5A CA E0 0E            JP      Z,DOTAB         ; Yes - Do SPC routine
1563   0E5D E5                  PUSH    HL              ; Save code string address
1564   0E5E FE 2C               CP      ','             ; Comma?
1565   0E60 CA C9 0E            JP      Z,DOCOM         ; Yes - Move to next zone
1566   0E63 FE 3B               CP      59 ;";"         ; Semi-colon?
1567   0E65 CA 03 0F            JP      Z,NEXITM        ; Do semi-colon routine
1568   0E68 C1                  POP     BC              ; Code string address to BC
1569   0E69 CD 84 10            CALL    EVAL            ; Evaluate expression
1570   0E6C E5                  PUSH    HL              ; Save code string address
1571   0E6D 3A AD 82            LD      A,(TYPE)        ; Get variable type
1572   0E70 B7                  OR      A               ; Is it a string variable?
1573   0E71 C2 99 0E            JP      NZ,PRNTST       ; Yes - Output string contents
1574   0E74 CD F9 1B            CALL    NUMASC          ; Convert number to text
1575   0E77 CD 09 15            CALL    CRTST           ; Create temporary string
1576   0E7A 36 20               LD      (HL),' '        ; Followed by a space
1577   0E7C 2A E4 82            LD      HL,(FPREG)      ; Get length of output
1578   0E7F 34                  INC     (HL)            ; Plus 1 for the space
1579   0E80 2A E4 82            LD      HL,(FPREG)      ; < Not needed >
1580   0E83 3A 42 82            LD      A,(LWIDTH)      ; Get width of line
1581   0E86 47                  LD      B,A             ; To B
1582   0E87 04                  INC     B               ; Width 255 (No limit)?
1583   0E88 CA 95 0E            JP      Z,PRNTNB        ; Yes - Output number string
1584   0E8B 04                  INC     B               ; Adjust it
1585   0E8C 3A AB 82            LD      A,(CURPOS)      ; Get cursor position
1586   0E8F 86                  ADD     A,(HL)          ; Add length of string
1587   0E90 3D                  DEC     A               ; Adjust it
1588   0E91 B8                  CP      B               ; Will output fit on this line?
1589   0E92 D4 AD 0E            CALL    NC,PRNTCRLF     ; No - CRLF first
1590   0E95 CD 4E 15    PRNTNB: CALL    PRS1            ; Output string at (HL)
1591   0E98 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1592   0E99 C4 4E 15    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1593   0E9C E1                  POP     HL              ; Restore code string address
1594   0E9D C3 4B 0E            JP      MRPRNT          ; See if more to PRINT
1595   0EA0             
1596   0EA0 3A AB 82    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1597   0EA3 B7                  OR      A               ; Already at start?
1598   0EA4 C8                  RET     Z               ; Yes - Do nothing
1599   0EA5 C3 AD 0E            JP      PRNTCRLF        ; Start a new line
1600   0EA8             
1601   0EA8 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1602   0EAA 21 60 82            LD      HL,BUFFER-1     ; Point to buffer
1603   0EAD 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1604   0EAF CD 86 0A            CALL    OUTC            ; Output character
1605   0EB2 3E 0A               LD      A,LF            ; Load a LF
1606   0EB4 CD 86 0A            CALL    OUTC            ; Output character
1607   0EB7 AF          DONULL: XOR     A               ; Set to position 0
1608   0EB8 32 AB 82            LD      (CURPOS),A      ; Store it
1609   0EBB 3A 41 82            LD      A,(NULLS)       ; Get number of nulls
1610   0EBE 3D          NULLP:  DEC     A               ; Count them
1611   0EBF C8                  RET     Z               ; Return if done
1612   0EC0 F5                  PUSH    AF              ; Save count
1613   0EC1 AF                  XOR     A               ; Load a null
1614   0EC2 CD 86 0A            CALL    OUTC            ; Output it
1615   0EC5 F1                  POP     AF              ; Restore count
1616   0EC6 C3 BE 0E            JP      NULLP           ; Keep counting
1617   0EC9             
1618   0EC9 3A 43 82    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1619   0ECC 47                  LD      B,A             ; Save in B
1620   0ECD 3A AB 82            LD      A,(CURPOS)      ; Get current position
1621   0ED0 B8                  CP      B               ; Within the limit?
1622   0ED1 D4 AD 0E            CALL    NC,PRNTCRLF     ; No - output CRLF
1623   0ED4 D2 03 0F            JP      NC,NEXITM       ; Get next item
1624   0ED7 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1625   0ED9 D2 D7 0E            JP      NC,ZONELP       ; Repeat if more zones
1626   0EDC 2F                  CPL                     ; Number of spaces to output
1627   0EDD C3 F8 0E            JP      ASPCS           ; Output them
1628   0EE0             
1629   0EE0 F5          DOTAB:  PUSH    AF              ; Save token
1630   0EE1 CD D0 17            CALL    FNDNUM          ; Evaluate expression
1631   0EE4 CD 7B 0A            CALL    CHKSYN          ; Make sure ")" follows
1632   0EE7 29                  .BYTE   ")"
1633   0EE8 2B                  DEC     HL              ; Back space on to ")"
1634   0EE9 F1                  POP     AF              ; Restore token
1635   0EEA D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1636   0EEC E5                  PUSH    HL              ; Save code string address
1637   0EED CA F3 0E            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1638   0EF0 3A AB 82            LD      A,(CURPOS)      ; Get current position
1639   0EF3 2F          DOSPC:  CPL                     ; Number of spaces to print to
1640   0EF4 83                  ADD     A,E             ; Total number to print
1641   0EF5 D2 03 0F            JP      NC,NEXITM       ; TAB < Current POS(X)
1642   0EF8 3C          ASPCS:  INC     A               ; Output A spaces
1643   0EF9 47                  LD      B,A             ; Save number to print
1644   0EFA 3E 20               LD      A,' '           ; Space
1645   0EFC CD 86 0A    SPCLP:  CALL    OUTC            ; Output character in A
1646   0EFF 05                  DEC     B               ; Count them
1647   0F00 C2 FC 0E            JP      NZ,SPCLP        ; Repeat if more
1648   0F03 E1          NEXITM: POP     HL              ; Restore code string address
1649   0F04 CD 05 0C            CALL    GETCHR          ; Get next character
1650   0F07 C3 52 0E            JP      PRNTLP          ; More to print
1651   0F0A             
1652   0F0A 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
1652   0F10 66726F6D2073746172740D0A00
1653   0F1D             
1654   0F1D 3A CD 82    BADINP: LD      A,(READFG)      ; READ or INPUT?
1655   0F20 B7                  OR      A
1656   0F21 C2 A7 07            JP      NZ,DATSNR       ; READ - ?SN Error
1657   0F24 C1                  POP     BC              ; Throw away code string addr
1658   0F25 21 0A 0F            LD      HL,REDO         ; "Redo from start" message
1659   0F28 CD 4B 15            CALL    PRS             ; Output string
1660   0F2B C3 F8 08            JP      DOAGN           ; Do last INPUT again
1661   0F2E             
1662   0F2E CD B6 14    INPUT:  CALL    IDTEST          ; Test for illegal direct
1663   0F31 7E                  LD      A,(HL)          ; Get character after "INPUT"
1664   0F32 FE 22               CP      '"'             ; Is there a prompt string?
1665   0F34 3E 00               LD      A,0             ; Clear A and leave flags
1666   0F36 32 45 82            LD      (CTLOFG),A      ; Enable output
1667   0F39 C2 48 0F            JP      NZ,NOPMPT       ; No prompt - get input
1668   0F3C CD 0A 15            CALL    QTSTR           ; Get string terminated by '"'
1669   0F3F CD 7B 0A            CALL    CHKSYN          ; Check for ';' after prompt
1670   0F42 3B                  .BYTE   ';'
1671   0F43 E5                  PUSH    HL              ; Save code string address
1672   0F44 CD 4E 15            CALL    PRS1            ; Output prompt string
1673   0F47 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1674   0F48 E5          NOPMPT: PUSH    HL              ; Save code string address
1675   0F49 CD FC 08            CALL    PROMPT          ; Get input with "? " prompt
1676   0F4C C1                  POP     BC              ; Restore code string address
1677   0F4D DA 54 0C            JP      C,INPBRK        ; Break pressed - Exit
1678   0F50 23                  INC     HL              ; Next byte
1679   0F51 7E                  LD      A,(HL)          ; Get it
1680   0F52 B7                  OR      A               ; End of line?
1681   0F53 2B                  DEC     HL              ; Back again
1682   0F54 C5                  PUSH    BC              ; Re-save code string address
1683   0F55 CA 9B 0D            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1684   0F58 36 2C               LD      (HL),','        ; Store comma as separator
1685   0F5A C3 62 0F            JP      NXTITM          ; Get next item
1686   0F5D             
1687   0F5D E5          READ:   PUSH    HL              ; Save code string address
1688   0F5E 2A DC 82            LD      HL,(NXTDAT)     ; Next DATA statement
1689   0F61 F6                  .BYTE   0F6H            ; Flag "READ"
1690   0F62 AF          NXTITM: XOR     A               ; Flag "INPUT"
1691   0F63 32 CD 82            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1692   0F66 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1693   0F67 C3 6E 0F            JP      GTVLUS          ; Get values
1694   0F6A             
1695   0F6A CD 7B 0A    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1696   0F6D 2C                  .BYTE      ','
1697   0F6E CD 68 12    GTVLUS: CALL    GETVAR          ; Get variable name
1698   0F71 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1699   0F72 D5                  PUSH    DE              ; Save variable address
1700   0F73 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1701   0F74 FE 2C               CP      ','             ; Comma?
1702   0F76 CA 96 0F            JP      Z,ANTVLU        ; Yes - Get another value
1703   0F79 3A CD 82            LD      A,(READFG)      ; Is it READ?
1704   0F7C B7                  OR      A
1705   0F7D C2 03 10            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1706   0F80 3E 3F               LD      A,'?'           ; More INPUT needed
1707   0F82 CD 86 0A            CALL    OUTC            ; Output character
1708   0F85 CD FC 08            CALL    PROMPT          ; Get INPUT with prompt
1709   0F88 D1                  POP     DE              ; Variable address
1710   0F89 C1                  POP     BC              ; Code string address
1711   0F8A DA 54 0C            JP      C,INPBRK        ; Break pressed
1712   0F8D 23                  INC     HL              ; Point to next DATA byte
1713   0F8E 7E                  LD      A,(HL)          ; Get byte
1714   0F8F B7                  OR      A               ; Is it zero (No input) ?
1715   0F90 2B                  DEC     HL              ; Back space INPUT pointer
1716   0F91 C5                  PUSH    BC              ; Save code string address
1717   0F92 CA 9B 0D            JP      Z,NXTDTA        ; Find end of buffer
1718   0F95 D5                  PUSH    DE              ; Save variable address
1719   0F96 3A AD 82    ANTVLU: LD      A,(TYPE)        ; Check data type
1720   0F99 B7                  OR      A               ; Is it numeric?
1721   0F9A CA C0 0F            JP      Z,INPBIN        ; Yes - Convert to binary
1722   0F9D CD 05 0C            CALL    GETCHR          ; Get next character
1723   0FA0 57                  LD      D,A             ; Save input character
1724   0FA1 47                  LD      B,A             ; Again
1725   0FA2 FE 22               CP      '"'             ; Start of literal sting?
1726   0FA4 CA B4 0F            JP      Z,STRENT        ; Yes - Create string entry
1727   0FA7 3A CD 82            LD      A,(READFG)      ; "READ" or "INPUT" ?
1728   0FAA B7                  OR      A
1729   0FAB 57                  LD      D,A             ; Save 00 if "INPUT"
1730   0FAC CA B1 0F            JP      Z,ITMSEP        ; "INPUT" - End with 00
1731   0FAF 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1732   0FB1 06 2C       ITMSEP: LD      B,','           ; Item separator
1733   0FB3 2B                  DEC     HL              ; Back space for DTSTR
1734   0FB4 CD 0D 15    STRENT: CALL    DTSTR           ; Get string terminated by D
1735   0FB7 EB                  EX      DE,HL           ; String address to DE
1736   0FB8 21 CB 0F            LD      HL,LTSTND       ; Where to go after LETSTR
1737   0FBB E3                  EX      (SP),HL         ; Save HL , get input pointer
1738   0FBC D5                  PUSH    DE              ; Save address of string
1739   0FBD C3 CE 0D            JP      LETSTR          ; Assign string to variable
1740   0FC0             
1741   0FC0 CD 05 0C    INPBIN: CALL    GETCHR          ; Get next character
1742   0FC3 CD 5B 1B            CALL    ASCTFP          ; Convert ASCII to FP number
1743   0FC6 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1744   0FC7 CD AC 1A            CALL    FPTHL           ; Move FPREG to variable
1745   0FCA E1                  POP     HL              ; Restore input pointer
1746   0FCB 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1747   0FCC CD 05 0C            CALL    GETCHR          ; Get next character
1748   0FCF CA D7 0F            JP      Z,MORDT         ; End of line - More needed?
1749   0FD2 FE 2C               CP      ','             ; Another value?
1750   0FD4 C2 1D 0F            JP      NZ,BADINP       ; No - Bad input
1751   0FD7 E3          MORDT:  EX      (SP),HL         ; Get code string address
1752   0FD8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1753   0FD9 CD 05 0C            CALL    GETCHR          ; Get next character
1754   0FDC C2 6A 0F            JP      NZ,NEDMOR       ; More needed - Get it
1755   0FDF D1                  POP     DE              ; Restore DATA pointer
1756   0FE0 3A CD 82            LD      A,(READFG)      ; "READ" or "INPUT" ?
1757   0FE3 B7                  OR      A
1758   0FE4 EB                  EX      DE,HL           ; DATA pointer to HL
1759   0FE5 C2 2B 0C            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1760   0FE8 D5                  PUSH    DE              ; Save code string address
1761   0FE9 B6                  OR      (HL)            ; More input given?
1762   0FEA 21 F2 0F            LD      HL,EXTIG        ; "?Extra ignored" message
1763   0FED C4 4B 15            CALL    NZ,PRS          ; Output string if extra given
1764   0FF0 E1                  POP     HL              ; Restore code string address
1765   0FF1 C9                  RET
1766   0FF2             
1767   0FF2 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1767   0FF8 2069676E6F7265640D0A00
1768   1003             
1769   1003 CD 9C 0D    FDTLP:  CALL    DATA            ; Get next statement
1770   1006 B7                  OR      A               ; End of line?
1771   1007 C2 1C 10            JP      NZ,FANDT        ; No - See if DATA statement
1772   100A 23                  INC     HL
1773   100B 7E                  LD      A,(HL)          ; End of program?
1774   100C 23                  INC     HL
1775   100D B6                  OR      (HL)            ; 00 00 Ends program
1776   100E 1E 06               LD      E,OD            ; ?OD Error
1777   1010 CA C1 07            JP      Z,ERROR         ; Yes - Out of DATA
1778   1013 23                  INC     HL
1779   1014 5E                  LD      E,(HL)          ; LSB of line number
1780   1015 23                  INC     HL
1781   1016 56                  LD      D,(HL)          ; MSB of line number
1782   1017 EB                  EX      DE,HL
1783   1018 22 C9 82            LD      (DATLIN),HL     ; Set line of current DATA item
1784   101B EB                  EX      DE,HL
1785   101C CD 05 0C    FANDT:  CALL    GETCHR          ; Get next character
1786   101F FE 83               CP      ZDATA           ; "DATA" token
1787   1021 C2 03 10            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1788   1024 C3 96 0F            JP      ANTVLU          ; Found - Convert input
1789   1027             
1790   1027 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1791   102A C4 68 12    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1792   102D 22 CE 82            LD      (BRKLIN),HL     ; Save code string address
1793   1030 CD 56 07            CALL    BAKSTK          ; Look for "FOR" block
1794   1033 C2 B3 07            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1795   1036 F9                  LD      SP,HL           ; Clear nested loops
1796   1037 D5                  PUSH    DE              ; Save index address
1797   1038 7E                  LD      A,(HL)          ; Get sign of STEP
1798   1039 23                  INC     HL
1799   103A F5                  PUSH    AF              ; Save sign of STEP
1800   103B D5                  PUSH    DE              ; Save index address
1801   103C CD 92 1A            CALL    PHLTFP          ; Move index value to FPREG
1802   103F E3                  EX      (SP),HL         ; Save address of TO value
1803   1040 E5                  PUSH    HL              ; Save address of index
1804   1041 CD FF 17            CALL    ADDPHL          ; Add STEP to index value
1805   1044 E1                  POP     HL              ; Restore address of index
1806   1045 CD AC 1A            CALL    FPTHL           ; Move value to index variable
1807   1048 E1                  POP     HL              ; Restore address of TO value
1808   1049 CD A3 1A            CALL    LOADFP          ; Move TO value to BCDE
1809   104C E5                  PUSH    HL              ; Save address of line of FOR
1810   104D CD CF 1A            CALL    CMPNUM          ; Compare index with TO value
1811   1050 E1                  POP     HL              ; Restore address of line num
1812   1051 C1                  POP     BC              ; Address of sign of STEP
1813   1052 90                  SUB     B               ; Compare with expected sign
1814   1053 CD A3 1A            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1815   1056 CA 62 10            JP      Z,KILFOR        ; Loop finished - Terminate it
1816   1059 EB                  EX      DE,HL           ; Loop statement line number
1817   105A 22 5C 82            LD      (LINEAT),HL     ; Set loop line number
1818   105D 69                  LD      L,C             ; Set code string to loop
1819   105E 60                  LD      H,B
1820   105F C3 C1 0B            JP      PUTFID          ; Put back "FOR" and continue
1821   1062             
1822   1062 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1823   1063 2A CE 82            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1824   1066 7E                  LD      A,(HL)          ; Get next byte in code string
1825   1067 FE 2C               CP      ','             ; More NEXTs ?
1826   1069 C2 C5 0B            JP      NZ,RUNCNT       ; No - Do next statement
1827   106C CD 05 0C            CALL    GETCHR          ; Position to index name
1828   106F CD 2A 10            CALL    NEXT1           ; Re-enter NEXT routine
1829   1072             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1830   1072             
1831   1072 CD 84 10    GETNUM: CALL    EVAL            ; Get a numeric expression
1832   1075 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1833   1076 37          TSTSTR: SCF                     ; Set carry (string)
1834   1077 3A AD 82    CHKTYP: LD      A,(TYPE)        ; Check types match
1835   107A 8F                  ADC     A,A             ; Expected + actual
1836   107B B7                  OR      A               ; Clear carry , set parity
1837   107C E8                  RET     PE              ; Even parity - Types match
1838   107D C3 BF 07            JP      TMERR           ; Different types - Error
1839   1080             
1840   1080 CD 7B 0A    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1841   1083 28                  .BYTE   "("
1842   1084 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1843   1085 16 00               LD      D,0             ; Precedence value
1844   1087 D5          EVAL1:  PUSH    DE              ; Save precedence
1845   1088 0E 01               LD      C,1
1846   108A CD 8A 07            CALL    CHKSTK          ; Check for 1 level of stack
1847   108D CD FB 10            CALL    OPRND           ; Get next expression value
1848   1090 22 D0 82    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1849   1093 2A D0 82    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1850   1096 C1                  POP     BC              ; Precedence value and operator
1851   1097 78                  LD      A,B             ; Get precedence value
1852   1098 FE 78               CP      78H             ; "AND" or "OR" ?
1853   109A D4 75 10            CALL    NC,TSTNUM       ; No - Make sure it's a number
1854   109D 7E                  LD      A,(HL)          ; Get next operator / function
1855   109E 16 00               LD      D,0             ; Clear Last relation
1856   10A0 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1857   10A2 DA BC 10            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1858   10A5 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1859   10A7 D2 BC 10            JP      NC,FOPRND       ; Function - Call it
1860   10AA FE 01               CP      ZEQUAL-ZGTR     ; "="
1861   10AC 17                  RLA                     ; <- Test for legal
1862   10AD AA                  XOR     D               ; <- combinations of < = >
1863   10AE BA                  CP      D               ; <- by combining last token
1864   10AF 57                  LD      D,A             ; <- with current one
1865   10B0 DA AD 07            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1866   10B3 22 C5 82            LD      (CUROPR),HL     ; Save address of current token
1867   10B6 CD 05 0C            CALL    GETCHR          ; Get next character
1868   10B9 C3 A0 10            JP      RLTLP           ; Treat the two as one
1869   10BC             
1870   10BC 7A          FOPRND: LD      A,D             ; < = > found ?
1871   10BD B7                  OR      A
1872   10BE C2 E3 11            JP      NZ,TSTRED       ; Yes - Test for reduction
1873   10C1 7E                  LD      A,(HL)          ; Get operator token
1874   10C2 22 C5 82            LD      (CUROPR),HL     ; Save operator address
1875   10C5 D6 AC               SUB     ZPLUS           ; Operator or function?
1876   10C7 D8                  RET     C               ; Neither - Exit
1877   10C8 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1878   10CA D0                  RET     NC              ; No - Exit
1879   10CB 5F                  LD      E,A             ; Coded operator
1880   10CC 3A AD 82            LD      A,(TYPE)        ; Get data type
1881   10CF 3D                  DEC     A               ; FF = numeric , 00 = string
1882   10D0 B3                  OR      E               ; Combine with coded operator
1883   10D1 7B                  LD      A,E             ; Get coded operator
1884   10D2 CA 41 16            JP      Z,CONCAT        ; String concatenation
1885   10D5 07                  RLCA                    ; Times 2
1886   10D6 83                  ADD     A,E             ; Times 3
1887   10D7 5F                  LD      E,A             ; To DE (D is 0)
1888   10D8 21 9F 06            LD      HL,PRITAB       ; Precedence table
1889   10DB 19                  ADD     HL,DE           ; To the operator concerned
1890   10DC 78                  LD      A,B             ; Last operator precedence
1891   10DD 56                  LD      D,(HL)          ; Get evaluation precedence
1892   10DE BA                  CP      D               ; Compare with eval precedence
1893   10DF D0                  RET     NC              ; Exit if higher precedence
1894   10E0 23                  INC     HL              ; Point to routine address
1895   10E1 CD 75 10            CALL    TSTNUM          ; Make sure it's a number
1896   10E4             
1897   10E4 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1898   10E5 01 93 10            LD      BC,EVAL3        ; Where to go on prec' break
1899   10E8 C5                  PUSH    BC              ; Save on stack for return
1900   10E9 43                  LD      B,E             ; Save operator
1901   10EA 4A                  LD      C,D             ; Save precedence
1902   10EB CD 85 1A            CALL    STAKFP          ; Move value to stack
1903   10EE 58                  LD      E,B             ; Restore operator
1904   10EF 51                  LD      D,C             ; Restore precedence
1905   10F0 4E                  LD      C,(HL)          ; Get LSB of routine address
1906   10F1 23                  INC     HL
1907   10F2 46                  LD      B,(HL)          ; Get MSB of routine address
1908   10F3 23                  INC     HL
1909   10F4 C5                  PUSH    BC              ; Save routine address
1910   10F5 2A C5 82            LD      HL,(CUROPR)     ; Address of current operator
1911   10F8 C3 87 10            JP      EVAL1           ; Loop until prec' break
1912   10FB             
1913   10FB AF          OPRND:  XOR     A               ; Get operand routine
1914   10FC 32 AD 82            LD      (TYPE),A        ; Set numeric expected
1915   10FF CD 05 0C            CALL    GETCHR          ; Get next character
1916   1102 1E 24               LD      E,MO            ; ?MO Error
1917   1104 CA C1 07            JP      Z,ERROR         ; No operand - Error
1918   1107 DA 5B 1B            JP      C,ASCTFP        ; Number - Get value
1919   110A CD A3 0C            CALL    CHKLTR          ; See if a letter
1920   110D D2 62 11            JP      NC,CONVAR       ; Letter - Find variable
1921   1110 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1922   1112 20 12               JR		NZ, NOTAMP
1923   1114 CD 05 0C            CALL    GETCHR          ; Get next character
1924   1117 FE 48               CP      'H'             ; Hex number indicated? [function added]
1925   1119 CA 9F 1F            JP      Z,HEXTFP        ; Convert Hex to FPREG
1926   111C FE 42               CP      'B'             ; Binary number indicated? [function added]
1927   111E CA 0F 20            JP      Z,BINTFP        ; Convert Bin to FPREG
1928   1121 1E 02               LD      E,SN            ; If neither then a ?SN Error
1929   1123 CA C1 07            JP      Z,ERROR         ; 
1930   1126 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1931   1128 CA FB 10            JP      Z,OPRND         ; Yes - Look for operand
1932   112B FE 2E               CP      '.'             ; '.' ?
1933   112D CA 5B 1B            JP      Z,ASCTFP        ; Yes - Create FP number
1934   1130 FE AD               CP      ZMINUS          ; '-' Token ?
1935   1132 CA 51 11            JP      Z,MINUS         ; Yes - Do minus
1936   1135 FE 22               CP      '"'             ; Literal string ?
1937   1137 CA 0A 15            JP      Z,QTSTR         ; Get string terminated by '"'
1938   113A FE AA               CP      ZNOT            ; "NOT" Token ?
1939   113C CA 43 12            JP      Z,EVNOT         ; Yes - Eval NOT expression
1940   113F FE A7               CP      ZFN             ; "FN" Token ?
1941   1141 CA 6E 14            JP      Z,DOFN          ; Yes - Do FN routine
1942   1144 D6 B6               SUB     ZSGN            ; Is it a function?
1943   1146 D2 73 11            JP      NC,FNOFST       ; Yes - Evaluate function
1944   1149 CD 80 10    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1945   114C CD 7B 0A            CALL    CHKSYN          ; Make sure ")" follows
1946   114F 29                  .BYTE   ")"
1947   1150 C9                  RET
1948   1151             
1949   1151 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1950   1153 CD 87 10            CALL    EVAL1           ; Evaluate until prec' break
1951   1156 2A D0 82            LD      HL,(NXTOPR)     ; Get next operator address
1952   1159 E5                  PUSH    HL              ; Save next operator address
1953   115A CD 7D 1A            CALL    INVSGN          ; Negate value
1954   115D CD 75 10    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1955   1160 E1                  POP     HL              ; Restore next operator address
1956   1161 C9                  RET
1957   1162             
1958   1162 CD 68 12    CONVAR: CALL    GETVAR          ; Get variable address to DE
1959   1165 E5          FRMEVL: PUSH    HL              ; Save code string address
1960   1166 EB                  EX      DE,HL           ; Variable address to HL
1961   1167 22 E4 82            LD      (FPREG),HL      ; Save address of variable
1962   116A 3A AD 82            LD      A,(TYPE)        ; Get type
1963   116D B7                  OR      A               ; Numeric?
1964   116E CC 92 1A            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1965   1171 E1                  POP     HL              ; Restore code string address
1966   1172 C9                  RET
1967   1173             
1968   1173 06 00       FNOFST: LD      B,0             ; Get address of function
1969   1175 07                  RLCA                    ; Double function offset
1970   1176 4F                  LD      C,A             ; BC = Offset in function table
1971   1177 C5                  PUSH    BC              ; Save adjusted token value
1972   1178 CD 05 0C            CALL    GETCHR          ; Get next character
1973   117B 79                  LD      A,C             ; Get adjusted token value
1974   117C FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1975   117E DA 9A 11            JP      C,FNVAL         ; No - Do function
1976   1181 CD 80 10            CALL    OPNPAR          ; Evaluate expression  (X,...
1977   1184 CD 7B 0A            CALL    CHKSYN          ; Make sure ',' follows
1978   1187 2C                  .BYTE      ','
1979   1188 CD 76 10            CALL    TSTSTR          ; Make sure it's a string
1980   118B EB                  EX      DE,HL           ; Save code string address
1981   118C 2A E4 82            LD      HL,(FPREG)      ; Get address of string
1982   118F E3                  EX      (SP),HL         ; Save address of string
1983   1190 E5                  PUSH    HL              ; Save adjusted token value
1984   1191 EB                  EX      DE,HL           ; Restore code string address
1985   1192 CD D3 17            CALL    GETINT          ; Get integer 0-255
1986   1195 EB                  EX      DE,HL           ; Save code string address
1987   1196 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1988   1197 C3 A2 11            JP      GOFUNC          ; Jump to string function
1989   119A             
1990   119A CD 49 11    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1991   119D E3                  EX      (SP),HL         ; HL = Adjusted token value
1992   119E 11 5D 11            LD      DE,RETNUM       ; Return number from function
1993   11A1 D5                  PUSH    DE              ; Save on stack
1994   11A2 01 FE 04    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1995   11A5 09                  ADD     HL,BC           ; Point to right address
1996   11A6 4E                  LD      C,(HL)          ; Get LSB of address
1997   11A7 23                  INC     HL              ;
1998   11A8 66                  LD      H,(HL)          ; Get MSB of address
1999   11A9 69                  LD      L,C             ; Address to HL
2000   11AA E9                  JP      (HL)            ; Jump to function
2001   11AB             
2002   11AB 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2003   11AC FE AD               CP      ZMINUS          ; '-' token ?
2004   11AE C8                  RET     Z               ; Yes - Return
2005   11AF FE 2D               CP      '-'             ; '-' ASCII ?
2006   11B1 C8                  RET     Z               ; Yes - Return
2007   11B2 14                  INC     D               ; Inc to flag positive exponent
2008   11B3 FE 2B               CP      '+'             ; '+' ASCII ?
2009   11B5 C8                  RET     Z               ; Yes - Return
2010   11B6 FE AC               CP      ZPLUS           ; '+' token ?
2011   11B8 C8                  RET     Z               ; Yes - Return
2012   11B9 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2013   11BA C9                  RET                     ; Return "NZ"
2014   11BB             
2015   11BB F6          POR:    .BYTE      0F6H            ; Flag "OR"
2016   11BC AF          PAND:   XOR     A               ; Flag "AND"
2017   11BD F5                  PUSH    AF              ; Save "AND" / "OR" flag
2018   11BE CD 75 10            CALL    TSTNUM          ; Make sure it's a number
2019   11C1 CD B7 0C            CALL    DEINT           ; Get integer -32768 to 32767
2020   11C4 F1                  POP     AF              ; Restore "AND" / "OR" flag
2021   11C5 EB                  EX      DE,HL           ; <- Get last
2022   11C6 C1                  POP     BC              ; <-  value
2023   11C7 E3                  EX      (SP),HL         ; <-  from
2024   11C8 EB                  EX      DE,HL           ; <-  stack
2025   11C9 CD 95 1A            CALL    FPBCDE          ; Move last value to FPREG
2026   11CC F5                  PUSH    AF              ; Save "AND" / "OR" flag
2027   11CD CD B7 0C            CALL    DEINT           ; Get integer -32768 to 32767
2028   11D0 F1                  POP     AF              ; Restore "AND" / "OR" flag
2029   11D1 C1                  POP     BC              ; Get value
2030   11D2 79                  LD      A,C             ; Get LSB
2031   11D3 21 2C 14            LD      HL,ACPASS       ; Address of save AC as current
2032   11D6 C2 DE 11            JP      NZ,POR1         ; Jump if OR
2033   11D9 A3                  AND     E               ; "AND" LSBs
2034   11DA 4F                  LD      C,A             ; Save LSB
2035   11DB 78                  LD      A,B             ; Get MBS
2036   11DC A2                  AND     D               ; "AND" MSBs
2037   11DD E9                  JP      (HL)            ; Save AC as current (ACPASS)
2038   11DE             
2039   11DE B3          POR1:   OR      E               ; "OR" LSBs
2040   11DF 4F                  LD      C,A             ; Save LSB
2041   11E0 78                  LD      A,B             ; Get MSB
2042   11E1 B2                  OR      D               ; "OR" MSBs
2043   11E2 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2044   11E3             
2045   11E3 21 F5 11    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2046   11E6 3A AD 82            LD      A,(TYPE)        ; Get data type
2047   11E9 1F                  RRA                     ; Carry set = string
2048   11EA 7A                  LD      A,D             ; Get last precedence value
2049   11EB 17                  RLA                     ; Times 2 plus carry
2050   11EC 5F                  LD      E,A             ; To E
2051   11ED 16 64               LD      D,64H           ; Relational precedence
2052   11EF 78                  LD      A,B             ; Get current precedence
2053   11F0 BA                  CP      D               ; Compare with last
2054   11F1 D0                  RET     NC              ; Eval if last was rel' or log'
2055   11F2 C3 E4 10            JP      STKTHS          ; Stack this one and get next
2056   11F5             
2057   11F5 F7 11       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2058   11F7 79          CMPLG1: LD      A,C             ; Get data type
2059   11F8 B7                  OR      A
2060   11F9 1F                  RRA
2061   11FA C1                  POP     BC              ; Get last expression to BCDE
2062   11FB D1                  POP     DE
2063   11FC F5                  PUSH    AF              ; Save status
2064   11FD CD 77 10            CALL    CHKTYP          ; Check that types match
2065   1200 21 39 12            LD      HL,CMPRES       ; Result to comparison
2066   1203 E5                  PUSH    HL              ; Save for RETurn
2067   1204 CA CF 1A            JP      Z,CMPNUM        ; Compare values if numeric
2068   1207 AF                  XOR     A               ; Compare two strings
2069   1208 32 AD 82            LD      (TYPE),A        ; Set type to numeric
2070   120B D5                  PUSH    DE              ; Save string name
2071   120C CD 8E 16            CALL    GSTRCU          ; Get current string
2072   120F 7E                  LD      A,(HL)          ; Get length of string
2073   1210 23                  INC     HL
2074   1211 23                  INC     HL
2075   1212 4E                  LD      C,(HL)          ; Get LSB of address
2076   1213 23                  INC     HL
2077   1214 46                  LD      B,(HL)          ; Get MSB of address
2078   1215 D1                  POP     DE              ; Restore string name
2079   1216 C5                  PUSH    BC              ; Save address of string
2080   1217 F5                  PUSH    AF              ; Save length of string
2081   1218 CD 92 16            CALL    GSTRDE          ; Get second string
2082   121B CD A3 1A            CALL    LOADFP          ; Get address of second string
2083   121E F1                  POP     AF              ; Restore length of string 1
2084   121F 57                  LD      D,A             ; Length to D
2085   1220 E1                  POP     HL              ; Restore address of string 1
2086   1221 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2087   1222 B2                  OR      D               ; Bytes of string 1 to do
2088   1223 C8                  RET     Z               ; Exit if all bytes compared
2089   1224 7A                  LD      A,D             ; Get bytes of string 1 to do
2090   1225 D6 01               SUB     1
2091   1227 D8                  RET     C               ; Exit if end of string 1
2092   1228 AF                  XOR     A
2093   1229 BB                  CP      E               ; Bytes of string 2 to do
2094   122A 3C                  INC     A
2095   122B D0                  RET     NC              ; Exit if end of string 2
2096   122C 15                  DEC     D               ; Count bytes in string 1
2097   122D 1D                  DEC     E               ; Count bytes in string 2
2098   122E 0A                  LD      A,(BC)          ; Byte in string 2
2099   122F BE                  CP      (HL)            ; Compare to byte in string 1
2100   1230 23                  INC     HL              ; Move up string 1
2101   1231 03                  INC     BC              ; Move up string 2
2102   1232 CA 21 12            JP      Z,CMPSTR        ; Same - Try next bytes
2103   1235 3F                  CCF                     ; Flag difference (">" or "<")
2104   1236 C3 5F 1A            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2105   1239             
2106   1239 3C          CMPRES: INC     A               ; Increment current value
2107   123A 8F                  ADC     A,A             ; Double plus carry
2108   123B C1                  POP     BC              ; Get other value
2109   123C A0                  AND     B               ; Combine them
2110   123D C6 FF               ADD     A,-1            ; Carry set if different
2111   123F 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2112   1240 C3 66 1A            JP      FLGREL          ; Set current value & continue
2113   1243             
2114   1243 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2115   1245 CD 87 10            CALL    EVAL1           ; Eval until precedence break
2116   1248 CD 75 10            CALL    TSTNUM          ; Make sure it's a number
2117   124B CD B7 0C            CALL    DEINT           ; Get integer -32768 - 32767
2118   124E 7B                  LD      A,E             ; Get LSB
2119   124F 2F                  CPL                     ; Invert LSB
2120   1250 4F                  LD      C,A             ; Save "NOT" of LSB
2121   1251 7A                  LD      A,D             ; Get MSB
2122   1252 2F                  CPL                     ; Invert MSB
2123   1253 CD 2C 14            CALL    ACPASS          ; Save AC as current
2124   1256 C1                  POP     BC              ; Clean up stack
2125   1257 C3 93 10            JP      EVAL3           ; Continue evaluation
2126   125A             
2127   125A 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2128   125B CD 05 0C            CALL    GETCHR          ; Get next character
2129   125E C8                  RET     Z               ; End of DIM statement
2130   125F CD 7B 0A            CALL    CHKSYN          ; Make sure ',' follows
2131   1262 2C                  .BYTE      ','
2132   1263 01 5A 12    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2133   1266 C5                  PUSH    BC              ; Save on stack
2134   1267 F6                  .BYTE      0F6H            ; Flag "Create" variable
2135   1268 AF          GETVAR: XOR     A               ; Find variable address,to DE
2136   1269 32 AC 82            LD      (LCRFLG),A      ; Set locate / create flag
2137   126C 46                  LD      B,(HL)          ; Get First byte of name
2138   126D CD A3 0C    GTFNAM: CALL    CHKLTR          ; See if a letter
2139   1270 DA AD 07            JP      C,SNERR         ; ?SN Error if not a letter
2140   1273 AF                  XOR     A
2141   1274 4F                  LD      C,A             ; Clear second byte of name
2142   1275 32 AD 82            LD      (TYPE),A        ; Set type to numeric
2143   1278 CD 05 0C            CALL    GETCHR          ; Get next character
2144   127B DA 84 12            JP      C,SVNAM2        ; Numeric - Save in name
2145   127E CD A3 0C            CALL    CHKLTR          ; See if a letter
2146   1281 DA 91 12            JP      C,CHARTY        ; Not a letter - Check type
2147   1284 4F          SVNAM2: LD      C,A             ; Save second byte of name
2148   1285 CD 05 0C    ENDNAM: CALL    GETCHR          ; Get next character
2149   1288 DA 85 12            JP      C,ENDNAM        ; Numeric - Get another
2150   128B CD A3 0C            CALL    CHKLTR          ; See if a letter
2151   128E D2 85 12            JP      NC,ENDNAM       ; Letter - Get another
2152   1291 D6 24       CHARTY: SUB     '$'             ; String variable?
2153   1293 C2 A0 12            JP      NZ,NOTSTR       ; No - Numeric variable
2154   1296 3C                  INC     A               ; A = 1 (string type)
2155   1297 32 AD 82            LD      (TYPE),A        ; Set type to string
2156   129A 0F                  RRCA                    ; A = 80H , Flag for string
2157   129B 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2158   129C 4F                  LD      C,A             ; Resave second byte on name
2159   129D CD 05 0C            CALL    GETCHR          ; Get next character
2160   12A0 3A CB 82    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2161   12A3 3D                  DEC     A
2162   12A4 CA 4D 13            JP      Z,ARLDSV        ; Yes - Get array name
2163   12A7 F2 B0 12            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2164   12AA 7E                  LD      A,(HL)          ; Get byte again
2165   12AB D6 28               SUB     '('             ; Subscripted variable?
2166   12AD CA 25 13            JP      Z,SBSCPT        ; Yes - Sort out subscript
2167   12B0             
2168   12B0 AF          NSCFOR: XOR     A               ; Simple variable
2169   12B1 32 CB 82            LD      (FORFLG),A      ; Clear "FOR" flag
2170   12B4 E5                  PUSH    HL              ; Save code string address
2171   12B5 50                  LD      D,B             ; DE = Variable name to find
2172   12B6 59                  LD      E,C
2173   12B7 2A DE 82            LD      HL,(FNRGNM)     ; FN argument name
2174   12BA CD 75 0A            CALL    CPDEHL          ; Is it the FN argument?
2175   12BD 11 E0 82            LD      DE,FNARG        ; Point to argument value
2176   12C0 CA 95 19            JP      Z,POPHRT        ; Yes - Return FN argument value
2177   12C3 2A D8 82            LD      HL,(VAREND)     ; End of variables
2178   12C6 EB                  EX      DE,HL           ; Address of end of search
2179   12C7 2A D6 82            LD      HL,(PROGND)     ; Start of variables address
2180   12CA CD 75 0A    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2181   12CD CA E3 12            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2182   12D0 79                  LD      A,C             ; Get second byte of name
2183   12D1 96                  SUB     (HL)            ; Compare with name in list
2184   12D2 23                  INC     HL              ; Move on to first byte
2185   12D3 C2 D8 12            JP      NZ,FNTHR        ; Different - Find another
2186   12D6 78                  LD      A,B             ; Get first byte of name
2187   12D7 96                  SUB     (HL)            ; Compare with name in list
2188   12D8 23          FNTHR:  INC     HL              ; Move on to LSB of value
2189   12D9 CA 17 13            JP      Z,RETADR        ; Found - Return address
2190   12DC 23                  INC     HL              ; <- Skip
2191   12DD 23                  INC     HL              ; <- over
2192   12DE 23                  INC     HL              ; <- F.P.
2193   12DF 23                  INC     HL              ; <- value
2194   12E0 C3 CA 12            JP      FNDVAR          ; Keep looking
2195   12E3             
2196   12E3 E1          CFEVAL: POP     HL              ; Restore code string address
2197   12E4 E3                  EX      (SP),HL         ; Get return address
2198   12E5 D5                  PUSH    DE              ; Save address of variable
2199   12E6 11 65 11            LD      DE,FRMEVL       ; Return address in EVAL
2200   12E9 CD 75 0A            CALL    CPDEHL          ; Called from EVAL ?
2201   12EC D1                  POP     DE              ; Restore address of variable
2202   12ED CA 1A 13            JP      Z,RETNUL        ; Yes - Return null variable
2203   12F0 E3                  EX      (SP),HL         ; Put back return
2204   12F1 E5                  PUSH    HL              ; Save code string address
2205   12F2 C5                  PUSH    BC              ; Save variable name
2206   12F3 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2207   12F6 2A DA 82            LD      HL,(ARREND)     ; End of arrays
2208   12F9 E5                  PUSH    HL              ; Save end of arrays
2209   12FA 09                  ADD     HL,BC           ; Move up 6 bytes
2210   12FB C1                  POP     BC              ; Source address in BC
2211   12FC E5                  PUSH    HL              ; Save new end address
2212   12FD CD 79 07            CALL    MOVUP           ; Move arrays up
2213   1300 E1                  POP     HL              ; Restore new end address
2214   1301 22 DA 82            LD      (ARREND),HL     ; Set new end address
2215   1304 60                  LD      H,B             ; End of variables to HL
2216   1305 69                  LD      L,C
2217   1306 22 D8 82            LD      (VAREND),HL     ; Set new end address
2218   1309             
2219   1309 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2220   130A 36 00               LD      (HL),0          ; Zero byte in variable
2221   130C CD 75 0A            CALL    CPDEHL          ; Done them all?
2222   130F C2 09 13            JP      NZ,ZEROLP       ; No - Keep on going
2223   1312 D1                  POP     DE              ; Get variable name
2224   1313 73                  LD      (HL),E          ; Store second character
2225   1314 23                  INC     HL
2226   1315 72                  LD      (HL),D          ; Store first character
2227   1316 23                  INC     HL
2228   1317 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2229   1318 E1                  POP     HL              ; Restore code string address
2230   1319 C9                  RET
2231   131A             
2232   131A 32 E7 82    RETNUL: LD      (FPEXP),A       ; Set result to zero
2233   131D 21 49 07            LD      HL,ZERBYT       ; Also set a null string
2234   1320 22 E4 82            LD      (FPREG),HL      ; Save for EVAL
2235   1323 E1                  POP     HL              ; Restore code string address
2236   1324 C9                  RET
2237   1325             
2238   1325 E5          SBSCPT: PUSH    HL              ; Save code string address
2239   1326 2A AC 82            LD      HL,(LCRFLG)     ; Locate/Create and Type
2240   1329 E3                  EX      (SP),HL         ; Save and get code string
2241   132A 57                  LD      D,A             ; Zero number of dimensions
2242   132B D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2243   132C C5                  PUSH    BC              ; Save array name
2244   132D CD AB 0C            CALL    FPSINT          ; Get subscript (0-32767)
2245   1330 C1                  POP     BC              ; Restore array name
2246   1331 F1                  POP     AF              ; Get number of dimensions
2247   1332 EB                  EX      DE,HL
2248   1333 E3                  EX      (SP),HL         ; Save subscript value
2249   1334 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2250   1335 EB                  EX      DE,HL
2251   1336 3C                  INC     A               ; Count dimensions
2252   1337 57                  LD      D,A             ; Save in D
2253   1338 7E                  LD      A,(HL)          ; Get next byte in code string
2254   1339 FE 2C               CP      ','             ; Comma (more to come)?
2255   133B CA 2B 13            JP      Z,SCPTLP        ; Yes - More subscripts
2256   133E CD 7B 0A            CALL    CHKSYN          ; Make sure ")" follows
2257   1341 29                  .BYTE      ")"
2258   1342 22 D0 82            LD      (NXTOPR),HL     ; Save code string address
2259   1345 E1                  POP     HL              ; Get LCRFLG and TYPE
2260   1346 22 AC 82            LD      (LCRFLG),HL     ; Restore Locate/create & type
2261   1349 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2262   134B D5                  PUSH    DE              ; Save number of dimensions (D)
2263   134C 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2264   134D             
2265   134D E5          ARLDSV: PUSH    HL              ; Save code string address
2266   134E F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2267   134F 2A D8 82            LD      HL,(VAREND)     ; Start of arrays
2268   1352 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2269   1353 19          FNDARY: ADD     HL,DE           ; Move to next array start
2270   1354 EB                  EX      DE,HL
2271   1355 2A DA 82            LD      HL,(ARREND)     ; End of arrays
2272   1358 EB                  EX      DE,HL           ; Current array pointer
2273   1359 CD 75 0A            CALL    CPDEHL          ; End of arrays found?
2274   135C CA 85 13            JP      Z,CREARY        ; Yes - Create array
2275   135F 7E                  LD      A,(HL)          ; Get second byte of name
2276   1360 B9                  CP      C               ; Compare with name given
2277   1361 23                  INC     HL              ; Move on
2278   1362 C2 67 13            JP      NZ,NXTARY       ; Different - Find next array
2279   1365 7E                  LD      A,(HL)          ; Get first byte of name
2280   1366 B8                  CP      B               ; Compare with name given
2281   1367 23          NXTARY: INC     HL              ; Move on
2282   1368 5E                  LD      E,(HL)          ; Get LSB of next array address
2283   1369 23                  INC     HL
2284   136A 56                  LD      D,(HL)          ; Get MSB of next array address
2285   136B 23                  INC     HL
2286   136C C2 53 13            JP      NZ,FNDARY       ; Not found - Keep looking
2287   136F 3A AC 82            LD      A,(LCRFLG)      ; Found Locate or Create it?
2288   1372 B7                  OR      A
2289   1373 C2 B6 07            JP      NZ,DDERR        ; Create - ?DD Error
2290   1376 F1                  POP     AF              ; Locate - Get number of dim'ns
2291   1377 44                  LD      B,H             ; BC Points to array dim'ns
2292   1378 4D                  LD      C,L
2293   1379 CA 95 19            JP      Z,POPHRT        ; Jump if array load/save
2294   137C 96                  SUB     (HL)            ; Same number of dimensions?
2295   137D CA E3 13            JP      Z,FINDEL        ; Yes - Find element
2296   1380 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2297   1382 C3 C1 07            JP      ERROR           ; Output error
2298   1385             
2299   1385 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2300   1388 F1                  POP     AF              ; Array to save or 0 dim'ns?
2301   1389 CA CC 0C            JP      Z,FCERR         ; Yes - ?FC Error
2302   138C 71                  LD      (HL),C          ; Save second byte of name
2303   138D 23                  INC     HL
2304   138E 70                  LD      (HL),B          ; Save first byte of name
2305   138F 23                  INC     HL
2306   1390 4F                  LD      C,A             ; Number of dimensions to C
2307   1391 CD 8A 07            CALL    CHKSTK          ; Check if enough memory
2308   1394 23                  INC     HL              ; Point to number of dimensions
2309   1395 23                  INC     HL
2310   1396 22 C5 82            LD      (CUROPR),HL     ; Save address of pointer
2311   1399 71                  LD      (HL),C          ; Set number of dimensions
2312   139A 23                  INC     HL
2313   139B 3A AC 82            LD      A,(LCRFLG)      ; Locate of Create?
2314   139E 17                  RLA                     ; Carry set = Create
2315   139F 79                  LD      A,C             ; Get number of dimensions
2316   13A0 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2317   13A3 D2 A8 13            JP      NC,DEFSIZ       ; Locate - Set default size
2318   13A6 C1                  POP     BC              ; Get specified dimension size
2319   13A7 03                  INC     BC              ; Include zero element
2320   13A8 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2321   13A9 23                  INC     HL
2322   13AA 70                  LD      (HL),B          ; Save MSB of dimension size
2323   13AB 23                  INC     HL
2324   13AC F5                  PUSH    AF              ; Save num' of dim'ns an status
2325   13AD E5                  PUSH    HL              ; Save address of dim'n size
2326   13AE CD 40 1B            CALL    MLDEBC          ; Multiply DE by BC to find
2327   13B1 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2328   13B2 E1                  POP     HL              ; Restore address of dimension
2329   13B3 F1                  POP     AF              ; Restore number of dimensions
2330   13B4 3D                  DEC     A               ; Count them
2331   13B5 C2 A0 13            JP      NZ,CRARLP       ; Do next dimension if more
2332   13B8 F5                  PUSH    AF              ; Save locate/create flag
2333   13B9 42                  LD      B,D             ; MSB of memory needed
2334   13BA 4B                  LD      C,E             ; LSB of memory needed
2335   13BB EB                  EX      DE,HL
2336   13BC 19                  ADD     HL,DE           ; Add bytes to array start
2337   13BD DA A2 07            JP      C,OMERR         ; Too big - Error
2338   13C0 CD 93 07            CALL    ENFMEM          ; See if enough memory
2339   13C3 22 DA 82            LD      (ARREND),HL     ; Save new end of array
2340   13C6             
2341   13C6 2B          ZERARY: DEC     HL              ; Back through array data
2342   13C7 36 00               LD      (HL),0          ; Set array element to zero
2343   13C9 CD 75 0A            CALL    CPDEHL          ; All elements zeroed?
2344   13CC C2 C6 13            JP      NZ,ZERARY       ; No - Keep on going
2345   13CF 03                  INC     BC              ; Number of bytes + 1
2346   13D0 57                  LD      D,A             ; A=0
2347   13D1 2A C5 82            LD      HL,(CUROPR)     ; Get address of array
2348   13D4 5E                  LD      E,(HL)          ; Number of dimensions
2349   13D5 EB                  EX      DE,HL           ; To HL
2350   13D6 29                  ADD     HL,HL           ; Two bytes per dimension size
2351   13D7 09                  ADD     HL,BC           ; Add number of bytes
2352   13D8 EB                  EX      DE,HL           ; Bytes needed to DE
2353   13D9 2B                  DEC     HL
2354   13DA 2B                  DEC     HL
2355   13DB 73                  LD      (HL),E          ; Save LSB of bytes needed
2356   13DC 23                  INC     HL
2357   13DD 72                  LD      (HL),D          ; Save MSB of bytes needed
2358   13DE 23                  INC     HL
2359   13DF F1                  POP     AF              ; Locate / Create?
2360   13E0 DA 07 14            JP      C,ENDDIM        ; A is 0 , End if create
2361   13E3 47          FINDEL: LD      B,A             ; Find array element
2362   13E4 4F                  LD      C,A
2363   13E5 7E                  LD      A,(HL)          ; Number of dimensions
2364   13E6 23                  INC     HL
2365   13E7 16                  .BYTE      16H             ; Skip "POP HL"
2366   13E8 E1          FNDELP: POP     HL              ; Address of next dim' size
2367   13E9 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2368   13EA 23                  INC     HL
2369   13EB 56                  LD      D,(HL)          ; Get MSB of dim'n size
2370   13EC 23                  INC     HL
2371   13ED E3                  EX      (SP),HL         ; Save address - Get index
2372   13EE F5                  PUSH    AF              ; Save number of dim'ns
2373   13EF CD 75 0A            CALL    CPDEHL          ; Dimension too large?
2374   13F2 D2 80 13            JP      NC,BSERR        ; Yes - ?BS Error
2375   13F5 E5                  PUSH    HL              ; Save index
2376   13F6 CD 40 1B            CALL    MLDEBC          ; Multiply previous by size
2377   13F9 D1                  POP     DE              ; Index supplied to DE
2378   13FA 19                  ADD     HL,DE           ; Add index to pointer
2379   13FB F1                  POP     AF              ; Number of dimensions
2380   13FC 3D                  DEC     A               ; Count them
2381   13FD 44                  LD      B,H             ; MSB of pointer
2382   13FE 4D                  LD      C,L             ; LSB of pointer
2383   13FF C2 E8 13            JP      NZ,FNDELP       ; More - Keep going
2384   1402 29                  ADD     HL,HL           ; 4 Bytes per element
2385   1403 29                  ADD     HL,HL
2386   1404 C1                  POP     BC              ; Start of array
2387   1405 09                  ADD     HL,BC           ; Point to element
2388   1406 EB                  EX      DE,HL           ; Address of element to DE
2389   1407 2A D0 82    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2390   140A C9                  RET
2391   140B             
2392   140B 2A DA 82    FRE:    LD      HL,(ARREND)     ; Start of free memory
2393   140E EB                  EX      DE,HL           ; To DE
2394   140F 21 00 00            LD      HL,0            ; End of free memory
2395   1412 39                  ADD     HL,SP           ; Current stack value
2396   1413 3A AD 82            LD      A,(TYPE)        ; Dummy argument type
2397   1416 B7                  OR      A
2398   1417 CA 27 14            JP      Z,FRENUM        ; Numeric - Free variable space
2399   141A CD 8E 16            CALL    GSTRCU          ; Current string to pool
2400   141D CD 8E 15            CALL    GARBGE          ; Garbage collection
2401   1420 2A 5A 82            LD      HL,(STRSPC)     ; Bottom of string space in use
2402   1423 EB                  EX      DE,HL           ; To DE
2403   1424 2A C3 82            LD      HL,(STRBOT)     ; Bottom of string space
2404   1427 7D          FRENUM: LD      A,L             ; Get LSB of end
2405   1428 93                  SUB     E               ; Subtract LSB of beginning
2406   1429 4F                  LD      C,A             ; Save difference if C
2407   142A 7C                  LD      A,H             ; Get MSB of end
2408   142B 9A                  SBC     A,D             ; Subtract MSB of beginning
2409   142C 41          ACPASS: LD      B,C             ; Return integer AC
2410   142D 50          ABPASS: LD      D,B             ; Return integer AB
2411   142E 1E 00               LD      E,0
2412   1430 21 AD 82            LD      HL,TYPE         ; Point to type
2413   1433 73                  LD      (HL),E          ; Set type to numeric
2414   1434 06 90               LD      B,80H+16        ; 16 bit integer
2415   1436 C3 6B 1A            JP      RETINT          ; Return the integr
2416   1439             
2417   1439 3A AB 82    POS:    LD      A,(CURPOS)      ; Get cursor position
2418   143C 47          PASSA:  LD      B,A             ; Put A into AB
2419   143D AF                  XOR     A               ; Zero A
2420   143E C3 2D 14            JP      ABPASS          ; Return integer AB
2421   1441             
2422   1441 CD C4 14    DEF:    CALL    CHEKFN          ; Get "FN" and name
2423   1444 CD B6 14            CALL    IDTEST          ; Test for illegal direct
2424   1447 01 9C 0D            LD      BC,DATA         ; To get next statement
2425   144A C5                  PUSH    BC              ; Save address for RETurn
2426   144B D5                  PUSH    DE              ; Save address of function ptr
2427   144C CD 7B 0A            CALL    CHKSYN          ; Make sure "(" follows
2428   144F 28                  .BYTE      "("
2429   1450 CD 68 12            CALL    GETVAR          ; Get argument variable name
2430   1453 E5                  PUSH    HL              ; Save code string address
2431   1454 EB                  EX      DE,HL           ; Argument address to HL
2432   1455 2B                  DEC     HL
2433   1456 56                  LD      D,(HL)          ; Get first byte of arg name
2434   1457 2B                  DEC     HL
2435   1458 5E                  LD      E,(HL)          ; Get second byte of arg name
2436   1459 E1                  POP     HL              ; Restore code string address
2437   145A CD 75 10            CALL    TSTNUM          ; Make sure numeric argument
2438   145D CD 7B 0A            CALL    CHKSYN          ; Make sure ")" follows
2439   1460 29                  .BYTE      ")"
2440   1461 CD 7B 0A            CALL    CHKSYN          ; Make sure "=" follows
2441   1464 B4                  .BYTE      ZEQUAL          ; "=" token
2442   1465 44                  LD      B,H             ; Code string address to BC
2443   1466 4D                  LD      C,L
2444   1467 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2445   1468 71                  LD      (HL),C          ; Save LSB of FN code string
2446   1469 23                  INC     HL
2447   146A 70                  LD      (HL),B          ; Save MSB of FN code string
2448   146B C3 03 15            JP      SVSTAD          ; Save address and do function
2449   146E             
2450   146E CD C4 14    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2451   1471 D5                  PUSH    DE              ; Save function pointer address
2452   1472 CD 49 11            CALL    EVLPAR          ; Evaluate expression in "()"
2453   1475 CD 75 10            CALL    TSTNUM          ; Make sure numeric result
2454   1478 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2455   1479 5E                  LD      E,(HL)          ; Get LSB of FN code string
2456   147A 23                  INC     HL
2457   147B 56                  LD      D,(HL)          ; Get MSB of FN code string
2458   147C 23                  INC     HL
2459   147D 7A                  LD      A,D             ; And function DEFined?
2460   147E B3                  OR      E
2461   147F CA B9 07            JP      Z,UFERR         ; No - ?UF Error
2462   1482 7E                  LD      A,(HL)          ; Get LSB of argument address
2463   1483 23                  INC     HL
2464   1484 66                  LD      H,(HL)          ; Get MSB of argument address
2465   1485 6F                  LD      L,A             ; HL = Arg variable address
2466   1486 E5                  PUSH    HL              ; Save it
2467   1487 2A DE 82            LD      HL,(FNRGNM)     ; Get old argument name
2468   148A E3                  EX      (SP),HL ;       ; Save old , Get new
2469   148B 22 DE 82            LD      (FNRGNM),HL     ; Set new argument name
2470   148E 2A E2 82            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2471   1491 E5                  PUSH    HL              ; Save it
2472   1492 2A E0 82            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2473   1495 E5                  PUSH    HL              ; Save it
2474   1496 21 E0 82            LD      HL,FNARG        ; HL = Value of argument
2475   1499 D5                  PUSH    DE              ; Save FN code string address
2476   149A CD AC 1A            CALL    FPTHL           ; Move FPREG to argument
2477   149D E1                  POP     HL              ; Get FN code string address
2478   149E CD 72 10            CALL    GETNUM          ; Get value from function
2479   14A1 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2480   14A2 CD 05 0C            CALL    GETCHR          ; Get next character
2481   14A5 C2 AD 07            JP      NZ,SNERR        ; Bad character in FN - Error
2482   14A8 E1                  POP     HL              ; Get MSB,EXP of old arg
2483   14A9 22 E0 82            LD      (FNARG),HL      ; Restore it
2484   14AC E1                  POP     HL              ; Get LSB,NLSB of old arg
2485   14AD 22 E2 82            LD      (FNARG+2),HL    ; Restore it
2486   14B0 E1                  POP     HL              ; Get name of old arg
2487   14B1 22 DE 82            LD      (FNRGNM),HL     ; Restore it
2488   14B4 E1                  POP     HL              ; Restore code string address
2489   14B5 C9                  RET
2490   14B6             
2491   14B6 E5          IDTEST: PUSH    HL              ; Save code string address
2492   14B7 2A 5C 82            LD      HL,(LINEAT)     ; Get current line number
2493   14BA 23                  INC     HL              ; -1 means direct statement
2494   14BB 7C                  LD      A,H
2495   14BC B5                  OR      L
2496   14BD E1                  POP     HL              ; Restore code string address
2497   14BE C0                  RET     NZ              ; Return if in program
2498   14BF 1E 16               LD      E,ID            ; ?ID Error
2499   14C1 C3 C1 07            JP      ERROR
2500   14C4             
2501   14C4 CD 7B 0A    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2502   14C7 A7                  .BYTE      ZFN             ; "FN" token
2503   14C8 3E 80               LD      A,80H
2504   14CA 32 CB 82            LD      (FORFLG),A      ; Flag FN name to find
2505   14CD B6                  OR      (HL)            ; FN name has bit 7 set
2506   14CE 47                  LD      B,A             ; in first byte of name
2507   14CF CD 6D 12            CALL    GTFNAM          ; Get FN name
2508   14D2 C3 75 10            JP      TSTNUM          ; Make sure numeric function
2509   14D5             
2510   14D5 CD 75 10    STR:    CALL    TSTNUM          ; Make sure it's a number
2511   14D8 CD F9 1B            CALL    NUMASC          ; Turn number into text
2512   14DB CD 09 15    STR1:   CALL    CRTST           ; Create string entry for it
2513   14DE CD 8E 16            CALL    GSTRCU          ; Current string to pool
2514   14E1 01 E9 16            LD      BC,TOPOOL       ; Save in string pool
2515   14E4 C5                  PUSH    BC              ; Save address on stack
2516   14E5             
2517   14E5 7E          SAVSTR: LD      A,(HL)          ; Get string length
2518   14E6 23                  INC     HL
2519   14E7 23                  INC     HL
2520   14E8 E5                  PUSH    HL              ; Save pointer to string
2521   14E9 CD 64 15            CALL    TESTR           ; See if enough string space
2522   14EC E1                  POP     HL              ; Restore pointer to string
2523   14ED 4E                  LD      C,(HL)          ; Get LSB of address
2524   14EE 23                  INC     HL
2525   14EF 46                  LD      B,(HL)          ; Get MSB of address
2526   14F0 CD FD 14            CALL    CRTMST          ; Create string entry
2527   14F3 E5                  PUSH    HL              ; Save pointer to MSB of addr
2528   14F4 6F                  LD      L,A             ; Length of string
2529   14F5 CD 81 16            CALL    TOSTRA          ; Move to string area
2530   14F8 D1                  POP     DE              ; Restore pointer to MSB
2531   14F9 C9                  RET
2532   14FA             
2533   14FA CD 64 15    MKTMST: CALL    TESTR           ; See if enough string space
2534   14FD 21 BF 82    CRTMST: LD      HL,TMPSTR       ; Temporary string
2535   1500 E5                  PUSH    HL              ; Save it
2536   1501 77                  LD      (HL),A          ; Save length of string
2537   1502 23                  INC     HL
2538   1503 23          SVSTAD: INC     HL
2539   1504 73                  LD      (HL),E          ; Save LSB of address
2540   1505 23                  INC     HL
2541   1506 72                  LD      (HL),D          ; Save MSB of address
2542   1507 E1                  POP     HL              ; Restore pointer
2543   1508 C9                  RET
2544   1509             
2545   1509 2B          CRTST:  DEC     HL              ; DEC - INCed after
2546   150A 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2547   150C 50                  LD      D,B             ; Quote to D
2548   150D E5          DTSTR:  PUSH    HL              ; Save start
2549   150E 0E FF               LD      C,-1            ; Set counter to -1
2550   1510 23          QTSTLP: INC     HL              ; Move on
2551   1511 7E                  LD      A,(HL)          ; Get byte
2552   1512 0C                  INC     C               ; Count bytes
2553   1513 B7                  OR      A               ; End of line?
2554   1514 CA 1F 15            JP      Z,CRTSTE        ; Yes - Create string entry
2555   1517 BA                  CP      D               ; Terminator D found?
2556   1518 CA 1F 15            JP      Z,CRTSTE        ; Yes - Create string entry
2557   151B B8                  CP      B               ; Terminator B found?
2558   151C C2 10 15            JP      NZ,QTSTLP       ; No - Keep looking
2559   151F FE 22       CRTSTE: CP      '"'             ; End with '"'?
2560   1521 CC 05 0C            CALL    Z,GETCHR        ; Yes - Get next character
2561   1524 E3                  EX      (SP),HL         ; Starting quote
2562   1525 23                  INC     HL              ; First byte of string
2563   1526 EB                  EX      DE,HL           ; To DE
2564   1527 79                  LD      A,C             ; Get length
2565   1528 CD FD 14            CALL    CRTMST          ; Create string entry
2566   152B 11 BF 82    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2567   152E 2A B1 82            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2568   1531 22 E4 82            LD      (FPREG),HL      ; Save address of string ptr
2569   1534 3E 01               LD      A,1
2570   1536 32 AD 82            LD      (TYPE),A        ; Set type to string
2571   1539 CD AF 1A            CALL    DETHL4          ; Move string to pool
2572   153C CD 75 0A            CALL    CPDEHL          ; Out of string pool?
2573   153F 22 B1 82            LD      (TMSTPT),HL     ; Save new pointer
2574   1542 E1                  POP     HL              ; Restore code string address
2575   1543 7E                  LD      A,(HL)          ; Get next code byte
2576   1544 C0                  RET     NZ              ; Return if pool OK
2577   1545 1E 1E               LD      E,ST            ; ?ST Error
2578   1547 C3 C1 07            JP      ERROR           ; String pool overflow
2579   154A             
2580   154A 23          PRNUMS: INC     HL              ; Skip leading space
2581   154B CD 09 15    PRS:    CALL    CRTST           ; Create string entry for it
2582   154E CD 8E 16    PRS1:   CALL    GSTRCU          ; Current string to pool
2583   1551 CD A3 1A            CALL    LOADFP          ; Move string block to BCDE
2584   1554 1C                  INC     E               ; Length + 1
2585   1555 1D          PRSLP:  DEC     E               ; Count characters
2586   1556 C8                  RET     Z               ; End of string
2587   1557 0A                  LD      A,(BC)          ; Get byte to output
2588   1558 CD 86 0A            CALL    OUTC            ; Output character in A
2589   155B FE 0D               CP      CR              ; Return?
2590   155D CC B7 0E            CALL    Z,DONULL        ; Yes - Do nulls
2591   1560 03                  INC     BC              ; Next byte in string
2592   1561 C3 55 15            JP      PRSLP           ; More characters to output
2593   1564             
2594   1564 B7          TESTR:  OR      A               ; Test if enough room
2595   1565 0E                  .BYTE      0EH             ; No garbage collection done
2596   1566 F1          GRBDON: POP     AF              ; Garbage collection done
2597   1567 F5                  PUSH    AF              ; Save status
2598   1568 2A 5A 82            LD      HL,(STRSPC)     ; Bottom of string space in use
2599   156B EB                  EX      DE,HL           ; To DE
2600   156C 2A C3 82            LD      HL,(STRBOT)     ; Bottom of string area
2601   156F 2F                  CPL                     ; Negate length (Top down)
2602   1570 4F                  LD      C,A             ; -Length to BC
2603   1571 06 FF               LD      B,-1            ; BC = -ve length of string
2604   1573 09                  ADD     HL,BC           ; Add to bottom of space in use
2605   1574 23                  INC     HL              ; Plus one for 2's complement
2606   1575 CD 75 0A            CALL    CPDEHL          ; Below string RAM area?
2607   1578 DA 82 15            JP      C,TESTOS        ; Tidy up if not done else err
2608   157B 22 C3 82            LD      (STRBOT),HL     ; Save new bottom of area
2609   157E 23                  INC     HL              ; Point to first byte of string
2610   157F EB                  EX      DE,HL           ; Address to DE
2611   1580 F1          POPAF:  POP     AF              ; Throw away status push
2612   1581 C9                  RET
2613   1582             
2614   1582 F1          TESTOS: POP     AF              ; Garbage collect been done?
2615   1583 1E 1A               LD      E,OS            ; ?OS Error
2616   1585 CA C1 07            JP      Z,ERROR         ; Yes - Not enough string apace
2617   1588 BF                  CP      A               ; Flag garbage collect done
2618   1589 F5                  PUSH    AF              ; Save status
2619   158A 01 66 15            LD      BC,GRBDON       ; Garbage collection done
2620   158D C5                  PUSH    BC              ; Save for RETurn
2621   158E 2A AF 82    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2622   1591 22 C3 82    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2623   1594 21 00 00            LD      HL,0
2624   1597 E5                  PUSH    HL              ; Flag no string found
2625   1598 2A 5A 82            LD      HL,(STRSPC)     ; Get bottom of string space
2626   159B E5                  PUSH    HL              ; Save bottom of string space
2627   159C 21 B3 82            LD      HL,TMSTPL       ; Temporary string pool
2628   159F EB          GRBLP:  EX      DE,HL
2629   15A0 2A B1 82            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2630   15A3 EB                  EX      DE,HL
2631   15A4 CD 75 0A            CALL    CPDEHL          ; Temporary string pool done?
2632   15A7 01 9F 15            LD      BC,GRBLP        ; Loop until string pool done
2633   15AA C2 F3 15            JP      NZ,STPOOL       ; No - See if in string area
2634   15AD 2A D6 82            LD      HL,(PROGND)     ; Start of simple variables
2635   15B0 EB          SMPVAR: EX      DE,HL
2636   15B1 2A D8 82            LD      HL,(VAREND)     ; End of simple variables
2637   15B4 EB                  EX      DE,HL
2638   15B5 CD 75 0A            CALL    CPDEHL          ; All simple strings done?
2639   15B8 CA C6 15            JP      Z,ARRLP         ; Yes - Do string arrays
2640   15BB 7E                  LD      A,(HL)          ; Get type of variable
2641   15BC 23                  INC     HL
2642   15BD 23                  INC     HL
2643   15BE B7                  OR      A               ; "S" flag set if string
2644   15BF CD F6 15            CALL    STRADD          ; See if string in string area
2645   15C2 C3 B0 15            JP      SMPVAR          ; Loop until simple ones done
2646   15C5             
2647   15C5 C1          GNXARY: POP     BC              ; Scrap address of this array
2648   15C6 EB          ARRLP:  EX      DE,HL
2649   15C7 2A DA 82            LD      HL,(ARREND)     ; End of string arrays
2650   15CA EB                  EX      DE,HL
2651   15CB CD 75 0A            CALL    CPDEHL          ; All string arrays done?
2652   15CE CA 1C 16            JP      Z,SCNEND        ; Yes - Move string if found
2653   15D1 CD A3 1A            CALL    LOADFP          ; Get array name to BCDE
2654   15D4 7B                  LD      A,E             ; Get type of array     
2655   15D5 E5                  PUSH    HL              ; Save address of num of dim'ns
2656   15D6 09                  ADD     HL,BC           ; Start of next array
2657   15D7 B7                  OR      A               ; Test type of array
2658   15D8 F2 C5 15            JP      P,GNXARY        ; Numeric array - Ignore it
2659   15DB 22 C5 82            LD      (CUROPR),HL     ; Save address of next array
2660   15DE E1                  POP     HL              ; Get address of num of dim'ns
2661   15DF 4E                  LD      C,(HL)          ; BC = Number of dimensions
2662   15E0 06 00               LD      B,0
2663   15E2 09                  ADD     HL,BC           ; Two bytes per dimension size
2664   15E3 09                  ADD     HL,BC
2665   15E4 23                  INC     HL              ; Plus one for number of dim'ns
2666   15E5 EB          GRBARY: EX      DE,HL
2667   15E6 2A C5 82            LD      HL,(CUROPR)     ; Get address of next array
2668   15E9 EB                  EX      DE,HL
2669   15EA CD 75 0A            CALL    CPDEHL          ; Is this array finished?
2670   15ED CA C6 15            JP      Z,ARRLP         ; Yes - Get next one
2671   15F0 01 E5 15            LD      BC,GRBARY       ; Loop until array all done
2672   15F3 C5          STPOOL: PUSH    BC              ; Save return address
2673   15F4 F6 80               OR      80H             ; Flag string type
2674   15F6 7E          STRADD: LD      A,(HL)          ; Get string length
2675   15F7 23                  INC     HL
2676   15F8 23                  INC     HL
2677   15F9 5E                  LD      E,(HL)          ; Get LSB of string address
2678   15FA 23                  INC     HL
2679   15FB 56                  LD      D,(HL)          ; Get MSB of string address
2680   15FC 23                  INC     HL
2681   15FD F0                  RET     P               ; Not a string - Return
2682   15FE B7                  OR      A               ; Set flags on string length
2683   15FF C8                  RET     Z               ; Null string - Return
2684   1600 44                  LD      B,H             ; Save variable pointer
2685   1601 4D                  LD      C,L
2686   1602 2A C3 82            LD      HL,(STRBOT)     ; Bottom of new area
2687   1605 CD 75 0A            CALL    CPDEHL          ; String been done?
2688   1608 60                  LD      H,B             ; Restore variable pointer
2689   1609 69                  LD      L,C
2690   160A D8                  RET     C               ; String done - Ignore
2691   160B E1                  POP     HL              ; Return address
2692   160C E3                  EX      (SP),HL         ; Lowest available string area
2693   160D CD 75 0A            CALL    CPDEHL          ; String within string area?
2694   1610 E3                  EX      (SP),HL         ; Lowest available string area
2695   1611 E5                  PUSH    HL              ; Re-save return address
2696   1612 60                  LD      H,B             ; Restore variable pointer
2697   1613 69                  LD      L,C
2698   1614 D0                  RET     NC              ; Outside string area - Ignore
2699   1615 C1                  POP     BC              ; Get return , Throw 2 away
2700   1616 F1                  POP     AF              ; 
2701   1617 F1                  POP     AF              ; 
2702   1618 E5                  PUSH    HL              ; Save variable pointer
2703   1619 D5                  PUSH    DE              ; Save address of current
2704   161A C5                  PUSH    BC              ; Put back return address
2705   161B C9                  RET                     ; Go to it
2706   161C             
2707   161C D1          SCNEND: POP     DE              ; Addresses of strings
2708   161D E1                  POP     HL              ; 
2709   161E 7D                  LD      A,L             ; HL = 0 if no more to do
2710   161F B4                  OR      H
2711   1620 C8                  RET     Z               ; No more to do - Return
2712   1621 2B                  DEC     HL
2713   1622 46                  LD      B,(HL)          ; MSB of address of string
2714   1623 2B                  DEC     HL
2715   1624 4E                  LD      C,(HL)          ; LSB of address of string
2716   1625 E5                  PUSH    HL              ; Save variable address
2717   1626 2B                  DEC     HL
2718   1627 2B                  DEC     HL
2719   1628 6E                  LD      L,(HL)          ; HL = Length of string
2720   1629 26 00               LD      H,0
2721   162B 09                  ADD     HL,BC           ; Address of end of string+1
2722   162C 50                  LD      D,B             ; String address to DE
2723   162D 59                  LD      E,C
2724   162E 2B                  DEC     HL              ; Last byte in string
2725   162F 44                  LD      B,H             ; Address to BC
2726   1630 4D                  LD      C,L
2727   1631 2A C3 82            LD      HL,(STRBOT)     ; Current bottom of string area
2728   1634 CD 7C 07            CALL    MOVSTR          ; Move string to new address
2729   1637 E1                  POP     HL              ; Restore variable address
2730   1638 71                  LD      (HL),C          ; Save new LSB of address
2731   1639 23                  INC     HL
2732   163A 70                  LD      (HL),B          ; Save new MSB of address
2733   163B 69                  LD      L,C             ; Next string area+1 to HL
2734   163C 60                  LD      H,B
2735   163D 2B                  DEC     HL              ; Next string area address
2736   163E C3 91 15            JP      GARBLP          ; Look for more strings
2737   1641             
2738   1641 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2739   1642 E5                  PUSH    HL              ; 
2740   1643 2A E4 82            LD      HL,(FPREG)      ; Get first string
2741   1646 E3                  EX      (SP),HL         ; Save first string
2742   1647 CD FB 10            CALL    OPRND           ; Get second string
2743   164A E3                  EX      (SP),HL         ; Restore first string
2744   164B CD 76 10            CALL    TSTSTR          ; Make sure it's a string
2745   164E 7E                  LD      A,(HL)          ; Get length of second string
2746   164F E5                  PUSH    HL              ; Save first string
2747   1650 2A E4 82            LD      HL,(FPREG)      ; Get second string
2748   1653 E5                  PUSH    HL              ; Save second string
2749   1654 86                  ADD     A,(HL)          ; Add length of second string
2750   1655 1E 1C               LD      E,LS            ; ?LS Error
2751   1657 DA C1 07            JP      C,ERROR         ; String too long - Error
2752   165A CD FA 14            CALL    MKTMST          ; Make temporary string
2753   165D D1                  POP     DE              ; Get second string to DE
2754   165E CD 92 16            CALL    GSTRDE          ; Move to string pool if needed
2755   1661 E3                  EX      (SP),HL         ; Get first string
2756   1662 CD 91 16            CALL    GSTRHL          ; Move to string pool if needed
2757   1665 E5                  PUSH    HL              ; Save first string
2758   1666 2A C1 82            LD      HL,(TMPSTR+2)   ; Temporary string address
2759   1669 EB                  EX      DE,HL           ; To DE
2760   166A CD 78 16            CALL    SSTSA           ; First string to string area
2761   166D CD 78 16            CALL    SSTSA           ; Second string to string area
2762   1670 21 90 10            LD      HL,EVAL2        ; Return to evaluation loop
2763   1673 E3                  EX      (SP),HL         ; Save return,get code string
2764   1674 E5                  PUSH    HL              ; Save code string address
2765   1675 C3 2B 15            JP      TSTOPL          ; To temporary string to pool
2766   1678             
2767   1678 E1          SSTSA:  POP     HL              ; Return address
2768   1679 E3                  EX      (SP),HL         ; Get string block,save return
2769   167A 7E                  LD      A,(HL)          ; Get length of string
2770   167B 23                  INC     HL
2771   167C 23                  INC     HL
2772   167D 4E                  LD      C,(HL)          ; Get LSB of string address
2773   167E 23                  INC     HL
2774   167F 46                  LD      B,(HL)          ; Get MSB of string address
2775   1680 6F                  LD      L,A             ; Length to L
2776   1681 2C          TOSTRA: INC     L               ; INC - DECed after
2777   1682 2D          TSALP:  DEC     L               ; Count bytes moved
2778   1683 C8                  RET     Z               ; End of string - Return
2779   1684 0A                  LD      A,(BC)          ; Get source
2780   1685 12                  LD      (DE),A          ; Save destination
2781   1686 03                  INC     BC              ; Next source
2782   1687 13                  INC     DE              ; Next destination
2783   1688 C3 82 16            JP      TSALP           ; Loop until string moved
2784   168B             
2785   168B CD 76 10    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2786   168E 2A E4 82    GSTRCU: LD      HL,(FPREG)      ; Get current string
2787   1691 EB          GSTRHL: EX      DE,HL           ; Save DE
2788   1692 CD AC 16    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2789   1695 EB                  EX      DE,HL           ; Restore DE
2790   1696 C0                  RET     NZ              ; No - Return
2791   1697 D5                  PUSH    DE              ; Save string
2792   1698 50                  LD      D,B             ; String block address to DE
2793   1699 59                  LD      E,C
2794   169A 1B                  DEC     DE              ; Point to length
2795   169B 4E                  LD      C,(HL)          ; Get string length
2796   169C 2A C3 82            LD      HL,(STRBOT)     ; Current bottom of string area
2797   169F CD 75 0A            CALL    CPDEHL          ; Last one in string area?
2798   16A2 C2 AA 16            JP      NZ,POPHL        ; No - Return
2799   16A5 47                  LD      B,A             ; Clear B (A=0)
2800   16A6 09                  ADD     HL,BC           ; Remove string from str' area
2801   16A7 22 C3 82            LD      (STRBOT),HL     ; Save new bottom of str' area
2802   16AA E1          POPHL:  POP     HL              ; Restore string
2803   16AB C9                  RET
2804   16AC             
2805   16AC 2A B1 82    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2806   16AF 2B                  DEC     HL              ; Back
2807   16B0 46                  LD      B,(HL)          ; Get MSB of address
2808   16B1 2B                  DEC     HL              ; Back
2809   16B2 4E                  LD      C,(HL)          ; Get LSB of address
2810   16B3 2B                  DEC     HL              ; Back
2811   16B4 2B                  DEC     HL              ; Back
2812   16B5 CD 75 0A            CALL    CPDEHL          ; String last in string pool?
2813   16B8 C0                  RET     NZ              ; Yes - Leave it
2814   16B9 22 B1 82            LD      (TMSTPT),HL     ; Save new string pool top
2815   16BC C9                  RET
2816   16BD             
2817   16BD 01 3C 14    LEN:    LD      BC,PASSA        ; To return integer A
2818   16C0 C5                  PUSH    BC              ; Save address
2819   16C1 CD 8B 16    GETLEN: CALL    GETSTR          ; Get string and its length
2820   16C4 AF                  XOR     A
2821   16C5 57                  LD      D,A             ; Clear D
2822   16C6 32 AD 82            LD      (TYPE),A        ; Set type to numeric
2823   16C9 7E                  LD      A,(HL)          ; Get length of string
2824   16CA B7                  OR      A               ; Set status flags
2825   16CB C9                  RET
2826   16CC             
2827   16CC 01 3C 14    ASC:    LD      BC,PASSA        ; To return integer A
2828   16CF C5                  PUSH    BC              ; Save address
2829   16D0 CD C1 16    GTFLNM: CALL    GETLEN          ; Get length of string
2830   16D3 CA CC 0C            JP      Z,FCERR         ; Null string - Error
2831   16D6 23                  INC     HL
2832   16D7 23                  INC     HL
2833   16D8 5E                  LD      E,(HL)          ; Get LSB of address
2834   16D9 23                  INC     HL
2835   16DA 56                  LD      D,(HL)          ; Get MSB of address
2836   16DB 1A                  LD      A,(DE)          ; Get first byte of string
2837   16DC C9                  RET
2838   16DD             
2839   16DD 3E 01       CHR:    LD      A,1             ; One character string
2840   16DF CD FA 14            CALL    MKTMST          ; Make a temporary string
2841   16E2 CD D6 17            CALL    MAKINT          ; Make it integer A
2842   16E5 2A C1 82            LD      HL,(TMPSTR+2)   ; Get address of string
2843   16E8 73                  LD      (HL),E          ; Save character
2844   16E9 C1          TOPOOL: POP     BC              ; Clean up stack
2845   16EA C3 2B 15            JP      TSTOPL          ; Temporary string to pool
2846   16ED             
2847   16ED CD 86 17    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2848   16F0 AF                  XOR     A               ; Start at first byte in string
2849   16F1 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2850   16F2 4F                  LD      C,A             ; Starting position in string
2851   16F3 E5          MID1:   PUSH    HL              ; Save string block address
2852   16F4 7E                  LD      A,(HL)          ; Get length of string
2853   16F5 B8                  CP      B               ; Compare with number given
2854   16F6 DA FB 16            JP      C,ALLFOL        ; All following bytes required
2855   16F9 78                  LD      A,B             ; Get new length
2856   16FA 11                  .BYTE      11H             ; Skip "LD C,0"
2857   16FB 0E 00       ALLFOL: LD      C,0             ; First byte of string
2858   16FD C5                  PUSH    BC              ; Save position in string
2859   16FE CD 64 15            CALL    TESTR           ; See if enough string space
2860   1701 C1                  POP     BC              ; Get position in string
2861   1702 E1                  POP     HL              ; Restore string block address
2862   1703 E5                  PUSH    HL              ; And re-save it
2863   1704 23                  INC     HL
2864   1705 23                  INC     HL
2865   1706 46                  LD      B,(HL)          ; Get LSB of address
2866   1707 23                  INC     HL
2867   1708 66                  LD      H,(HL)          ; Get MSB of address
2868   1709 68                  LD      L,B             ; HL = address of string
2869   170A 06 00               LD      B,0             ; BC = starting address
2870   170C 09                  ADD     HL,BC           ; Point to that byte
2871   170D 44                  LD      B,H             ; BC = source string
2872   170E 4D                  LD      C,L
2873   170F CD FD 14            CALL    CRTMST          ; Create a string entry
2874   1712 6F                  LD      L,A             ; Length of new string
2875   1713 CD 81 16            CALL    TOSTRA          ; Move string to string area
2876   1716 D1                  POP     DE              ; Clear stack
2877   1717 CD 92 16            CALL    GSTRDE          ; Move to string pool if needed
2878   171A C3 2B 15            JP      TSTOPL          ; Temporary string to pool
2879   171D             
2880   171D CD 86 17    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2881   1720 D1                  POP     DE              ; Get string length
2882   1721 D5                  PUSH    DE              ; And re-save
2883   1722 1A                  LD      A,(DE)          ; Get length
2884   1723 90                  SUB     B               ; Move back N bytes
2885   1724 C3 F1 16            JP      RIGHT1          ; Go and get sub-string
2886   1727             
2887   1727 EB          MID:    EX      DE,HL           ; Get code string address
2888   1728 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2889   1729 CD 8B 17            CALL    MIDNUM          ; Get number supplied
2890   172C 04                  INC     B               ; Is it character zero?
2891   172D 05                  DEC     B
2892   172E CA CC 0C            JP      Z,FCERR         ; Yes - Error
2893   1731 C5                  PUSH    BC              ; Save starting position
2894   1732 1E FF               LD      E,255           ; All of string
2895   1734 FE 29               CP      ')'             ; Any length given?
2896   1736 CA 40 17            JP      Z,RSTSTR        ; No - Rest of string
2897   1739 CD 7B 0A            CALL    CHKSYN          ; Make sure ',' follows
2898   173C 2C                  .BYTE      ','
2899   173D CD D3 17            CALL    GETINT          ; Get integer 0-255
2900   1740 CD 7B 0A    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2901   1743 29                  .BYTE      ")"
2902   1744 F1                  POP     AF              ; Restore starting position
2903   1745 E3                  EX      (SP),HL         ; Get string,8ave code string
2904   1746 01 F3 16            LD      BC,MID1         ; Continuation of MID$ routine
2905   1749 C5                  PUSH    BC              ; Save for return
2906   174A 3D                  DEC     A               ; Starting position-1
2907   174B BE                  CP      (HL)            ; Compare with length
2908   174C 06 00               LD      B,0             ; Zero bytes length
2909   174E D0                  RET     NC              ; Null string if start past end
2910   174F 4F                  LD      C,A             ; Save starting position-1
2911   1750 7E                  LD      A,(HL)          ; Get length of string
2912   1751 91                  SUB     C               ; Subtract start
2913   1752 BB                  CP      E               ; Enough string for it?
2914   1753 47                  LD      B,A             ; Save maximum length available
2915   1754 D8                  RET     C               ; Truncate string if needed
2916   1755 43                  LD      B,E             ; Set specified length
2917   1756 C9                  RET                     ; Go and create string
2918   1757             
2919   1757 CD C1 16    VAL:    CALL    GETLEN          ; Get length of string
2920   175A CA 74 18            JP      Z,RESZER        ; Result zero
2921   175D 5F                  LD      E,A             ; Save length
2922   175E 23                  INC     HL
2923   175F 23                  INC     HL
2924   1760 7E                  LD      A,(HL)          ; Get LSB of address
2925   1761 23                  INC     HL
2926   1762 66                  LD      H,(HL)          ; Get MSB of address
2927   1763 6F                  LD      L,A             ; HL = String address
2928   1764 E5                  PUSH    HL              ; Save string address
2929   1765 19                  ADD     HL,DE
2930   1766 46                  LD      B,(HL)          ; Get end of string+1 byte
2931   1767 72                  LD      (HL),D          ; Zero it to terminate
2932   1768 E3                  EX      (SP),HL         ; Save string end,get start
2933   1769 C5                  PUSH    BC              ; Save end+1 byte
2934   176A 7E                  LD      A,(HL)          ; Get starting byte
2935   176B FE 24           CP	'$'		; Hex number indicated? [function added]
2936   176D C2 75 17        JP	NZ,VAL1
2937   1770 CD 9F 1F        CALL	HEXTFP		; Convert Hex to FPREG
2938   1773 18 0D           JR	VAL3
2939   1775 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2940   1777 C2 7F 17        JP	NZ,VAL2
2941   177A CD 0F 20        CALL	BINTFP		; Convert Bin to FPREG
2942   177D 18 03           JR	VAL3
2943   177F CD 5B 1B    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2944   1782 C1          VAL3:   POP     BC              ; Restore end+1 byte
2945   1783 E1                  POP     HL              ; Restore end+1 address
2946   1784 70                  LD      (HL),B          ; Put back original byte
2947   1785 C9                  RET
2948   1786             
2949   1786 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2950   1787 CD 7B 0A            CALL    CHKSYN          ; Make sure ")" follows
2951   178A 29                  .BYTE      ")"
2952   178B C1          MIDNUM: POP     BC              ; Get return address
2953   178C D1                  POP     DE              ; Get number supplied
2954   178D C5                  PUSH    BC              ; Re-save return address
2955   178E 43                  LD      B,E             ; Number to B
2956   178F C9                  RET
2957   1790             
2958   1790 CD D6 17    INP:    CALL    MAKINT          ; Make it integer A
2959   1793 32 3F 82            LD      (INPORT),A      ; Set input port
2960   1796 CD 3E 82            CALL    INPSUB          ; Get input from port
2961   1799 C3 3C 14            JP      PASSA           ; Return integer A
2962   179C             
2963   179C CD C0 17    POUT:   CALL    SETIO           ; Set up port number
2964   179F C3 06 82            JP      OUTSUB          ; Output data and return
2965   17A2             
2966   17A2 CD C0 17    WAIT:   CALL    SETIO           ; Set up port number
2967   17A5 F5                  PUSH    AF              ; Save AND mask
2968   17A6 1E 00               LD      E,0             ; Assume zero if none given
2969   17A8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2970   17A9 CD 05 0C            CALL    GETCHR          ; Get next character
2971   17AC CA B6 17            JP      Z,NOXOR         ; No XOR byte given
2972   17AF CD 7B 0A            CALL    CHKSYN          ; Make sure ',' follows
2973   17B2 2C                  .BYTE      ','
2974   17B3 CD D3 17            CALL    GETINT          ; Get integer 0-255 to XOR with
2975   17B6 C1          NOXOR:  POP     BC              ; Restore AND mask
2976   17B7 CD 3E 82    WAITLP: CALL    INPSUB          ; Get input
2977   17BA AB                  XOR     E               ; Flip selected bits
2978   17BB A0                  AND     B               ; Result non-zero?
2979   17BC CA B7 17            JP      Z,WAITLP        ; No = keep waiting
2980   17BF C9                  RET
2981   17C0             
2982   17C0 CD D3 17    SETIO:  CALL    GETINT          ; Get integer 0-255
2983   17C3 32 3F 82            LD      (INPORT),A      ; Set input port
2984   17C6 32 07 82            LD      (OTPORT),A      ; Set output port
2985   17C9 CD 7B 0A            CALL    CHKSYN          ; Make sure ',' follows
2986   17CC 2C                  .BYTE      ','
2987   17CD C3 D3 17            JP      GETINT          ; Get integer 0-255 and return
2988   17D0             
2989   17D0 CD 05 0C    FNDNUM: CALL    GETCHR          ; Get next character
2990   17D3 CD 72 10    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2991   17D6 CD B1 0C    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2992   17D9 7A                  LD      A,D             ; Get MSB of number
2993   17DA B7                  OR      A               ; Zero?
2994   17DB C2 CC 0C            JP      NZ,FCERR        ; No - Error
2995   17DE 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2996   17DF CD 05 0C            CALL    GETCHR          ; Get next character
2997   17E2 7B                  LD      A,E             ; Get number to A
2998   17E3 C9                  RET
2999   17E4             
3000   17E4 CD B7 0C    PEEK:   CALL    DEINT           ; Get memory address
3001   17E7 1A                  LD      A,(DE)          ; Get byte in memory
3002   17E8 C3 3C 14            JP      PASSA           ; Return integer A
3003   17EB             
3004   17EB CD 72 10    POKE:   CALL    GETNUM          ; Get memory address
3005   17EE CD B7 0C            CALL    DEINT           ; Get integer -32768 to 3276
3006   17F1 D5                  PUSH    DE              ; Save memory address
3007   17F2 CD 7B 0A            CALL    CHKSYN          ; Make sure ',' follows
3008   17F5 2C                  .BYTE      ','
3009   17F6 CD D3 17            CALL    GETINT          ; Get integer 0-255
3010   17F9 D1                  POP     DE              ; Restore memory address
3011   17FA 12                  LD      (DE),A          ; Load it into memory
3012   17FB C9                  RET
3013   17FC             
3014   17FC 21 D2 1C    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3015   17FF CD A3 1A    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3016   1802 C3 0E 18            JP      FPADD           ; Add BCDE to FPREG
3017   1805             
3018   1805 CD A3 1A    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3019   1808 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3020   1809 C1          PSUB:   POP     BC              ; Get FP number from stack
3021   180A D1                  POP     DE
3022   180B CD 7D 1A    SUBCDE: CALL    INVSGN          ; Negate FPREG
3023   180E 78          FPADD:  LD      A,B             ; Get FP exponent
3024   180F B7                  OR      A               ; Is number zero?
3025   1810 C8                  RET     Z               ; Yes - Nothing to add
3026   1811 3A E7 82            LD      A,(FPEXP)       ; Get FPREG exponent
3027   1814 B7                  OR      A               ; Is this number zero?
3028   1815 CA 95 1A            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3029   1818 90                  SUB     B               ; BCDE number larger?
3030   1819 D2 28 18            JP      NC,NOSWAP       ; No - Don't swap them
3031   181C 2F                  CPL                     ; Two's complement
3032   181D 3C                  INC     A               ;  FP exponent
3033   181E EB                  EX      DE,HL
3034   181F CD 85 1A            CALL    STAKFP          ; Put FPREG on stack
3035   1822 EB                  EX      DE,HL
3036   1823 CD 95 1A            CALL    FPBCDE          ; Move BCDE to FPREG
3037   1826 C1                  POP     BC              ; Restore number from stack
3038   1827 D1                  POP     DE
3039   1828 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3040   182A D0                  RET     NC              ; Yes - First number is result
3041   182B F5                  PUSH    AF              ; Save number of bits to scale
3042   182C CD BA 1A            CALL    SIGNS           ; Set MSBs & sign of result
3043   182F 67                  LD      H,A             ; Save sign of result
3044   1830 F1                  POP     AF              ; Restore scaling factor
3045   1831 CD D3 18            CALL    SCALE           ; Scale BCDE to same exponent
3046   1834 B4                  OR      H               ; Result to be positive?
3047   1835 21 E4 82            LD      HL,FPREG        ; Point to FPREG
3048   1838 F2 4E 18            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3049   183B CD B3 18            CALL    PLUCDE          ; Add FPREG to CDE
3050   183E D2 94 18            JP      NC,RONDUP       ; No overflow - Round it up
3051   1841 23                  INC     HL              ; Point to exponent
3052   1842 34                  INC     (HL)            ; Increment it
3053   1843 CA BC 07            JP      Z,OVERR         ; Number overflowed - Error
3054   1846 2E 01               LD      L,1             ; 1 bit to shift right
3055   1848 CD E9 18            CALL    SHRT1           ; Shift result right
3056   184B C3 94 18            JP      RONDUP          ; Round it up
3057   184E             
3058   184E AF          MINCDE: XOR     A               ; Clear A and carry
3059   184F 90                  SUB     B               ; Negate exponent
3060   1850 47                  LD      B,A             ; Re-save exponent
3061   1851 7E                  LD      A,(HL)          ; Get LSB of FPREG
3062   1852 9B                  SBC     A, E            ; Subtract LSB of BCDE
3063   1853 5F                  LD      E,A             ; Save LSB of BCDE
3064   1854 23                  INC     HL
3065   1855 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3066   1856 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3067   1857 57                  LD      D,A             ; Save NMSB of BCDE
3068   1858 23                  INC     HL
3069   1859 7E                  LD      A,(HL)          ; Get MSB of FPREG
3070   185A 99                  SBC     A,C             ; Subtract MSB of BCDE
3071   185B 4F                  LD      C,A             ; Save MSB of BCDE
3072   185C DC BF 18    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3073   185F             
3074   185F 68          BNORM:  LD      L,B             ; L = Exponent
3075   1860 63                  LD      H,E             ; H = LSB
3076   1861 AF                  XOR     A
3077   1862 47          BNRMLP: LD      B,A             ; Save bit count
3078   1863 79                  LD      A,C             ; Get MSB
3079   1864 B7                  OR      A               ; Is it zero?
3080   1865 C2 81 18            JP      NZ,PNORM        ; No - Do it bit at a time
3081   1868 4A                  LD      C,D             ; MSB = NMSB
3082   1869 54                  LD      D,H             ; NMSB= LSB
3083   186A 65                  LD      H,L             ; LSB = VLSB
3084   186B 6F                  LD      L,A             ; VLSB= 0
3085   186C 78                  LD      A,B             ; Get exponent
3086   186D D6 08               SUB     8               ; Count 8 bits
3087   186F FE E0               CP      -24-8           ; Was number zero?
3088   1871 C2 62 18            JP      NZ,BNRMLP       ; No - Keep normalising
3089   1874 AF          RESZER: XOR     A               ; Result is zero
3090   1875 32 E7 82    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3091   1878 C9                  RET
3092   1879             
3093   1879 05          NORMAL: DEC     B               ; Count bits
3094   187A 29                  ADD     HL,HL           ; Shift HL left
3095   187B 7A                  LD      A,D             ; Get NMSB
3096   187C 17                  RLA                     ; Shift left with last bit
3097   187D 57                  LD      D,A             ; Save NMSB
3098   187E 79                  LD      A,C             ; Get MSB
3099   187F 8F                  ADC     A,A             ; Shift left with last bit
3100   1880 4F                  LD      C,A             ; Save MSB
3101   1881 F2 79 18    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3102   1884 78                  LD      A,B             ; Number of bits shifted
3103   1885 5C                  LD      E,H             ; Save HL in EB
3104   1886 45                  LD      B,L
3105   1887 B7                  OR      A               ; Any shifting done?
3106   1888 CA 94 18            JP      Z,RONDUP        ; No - Round it up
3107   188B 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3108   188E 86                  ADD     A,(HL)          ; Add shifted bits
3109   188F 77                  LD      (HL),A          ; Re-save exponent
3110   1890 D2 74 18            JP      NC,RESZER       ; Underflow - Result is zero
3111   1893 C8                  RET     Z               ; Result is zero
3112   1894 78          RONDUP: LD      A,B             ; Get VLSB of number
3113   1895 21 E7 82    RONDB:  LD      HL,FPEXP        ; Point to exponent
3114   1898 B7                  OR      A               ; Any rounding?
3115   1899 FC A6 18            CALL    M,FPROND        ; Yes - Round number up
3116   189C 46                  LD      B,(HL)          ; B = Exponent
3117   189D 23                  INC     HL
3118   189E 7E                  LD      A,(HL)          ; Get sign of result
3119   189F E6 80               AND     10000000B       ; Only bit 7 needed
3120   18A1 A9                  XOR     C               ; Set correct sign
3121   18A2 4F                  LD      C,A             ; Save correct sign in number
3122   18A3 C3 95 1A            JP      FPBCDE          ; Move BCDE to FPREG
3123   18A6             
3124   18A6 1C          FPROND: INC     E               ; Round LSB
3125   18A7 C0                  RET     NZ              ; Return if ok
3126   18A8 14                  INC     D               ; Round NMSB
3127   18A9 C0                  RET     NZ              ; Return if ok
3128   18AA 0C                  INC     C               ; Round MSB
3129   18AB C0                  RET     NZ              ; Return if ok
3130   18AC 0E 80               LD      C,80H           ; Set normal value
3131   18AE 34                  INC     (HL)            ; Increment exponent
3132   18AF C0                  RET     NZ              ; Return if ok
3133   18B0 C3 BC 07            JP      OVERR           ; Overflow error
3134   18B3             
3135   18B3 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3136   18B4 83                  ADD     A,E             ; Add LSB of BCDE
3137   18B5 5F                  LD      E,A             ; Save LSB of BCDE
3138   18B6 23                  INC     HL
3139   18B7 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3140   18B8 8A                  ADC     A,D             ; Add NMSB of BCDE
3141   18B9 57                  LD      D,A             ; Save NMSB of BCDE
3142   18BA 23                  INC     HL
3143   18BB 7E                  LD      A,(HL)          ; Get MSB of FPREG
3144   18BC 89                  ADC     A,C             ; Add MSB of BCDE
3145   18BD 4F                  LD      C,A             ; Save MSB of BCDE
3146   18BE C9                  RET
3147   18BF             
3148   18BF 21 E8 82    COMPL:  LD      HL,SGNRES       ; Sign of result
3149   18C2 7E                  LD      A,(HL)          ; Get sign of result
3150   18C3 2F                  CPL                     ; Negate it
3151   18C4 77                  LD      (HL),A          ; Put it back
3152   18C5 AF                  XOR     A
3153   18C6 6F                  LD      L,A             ; Set L to zero
3154   18C7 90                  SUB     B               ; Negate exponent,set carry
3155   18C8 47                  LD      B,A             ; Re-save exponent
3156   18C9 7D                  LD      A,L             ; Load zero
3157   18CA 9B                  SBC     A,E             ; Negate LSB
3158   18CB 5F                  LD      E,A             ; Re-save LSB
3159   18CC 7D                  LD      A,L             ; Load zero
3160   18CD 9A                  SBC     A,D             ; Negate NMSB
3161   18CE 57                  LD      D,A             ; Re-save NMSB
3162   18CF 7D                  LD      A,L             ; Load zero
3163   18D0 99                  SBC     A,C             ; Negate MSB
3164   18D1 4F                  LD      C,A             ; Re-save MSB
3165   18D2 C9                  RET
3166   18D3             
3167   18D3 06 00       SCALE:  LD      B,0             ; Clear underflow
3168   18D5 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3169   18D7 DA E2 18            JP      C,SHRITE        ; No - Shift right A bits
3170   18DA 43                  LD      B,E             ; <- Shift
3171   18DB 5A                  LD      E,D             ; <- right
3172   18DC 51                  LD      D,C             ; <- eight
3173   18DD 0E 00               LD      C,0             ; <- bits
3174   18DF C3 D5 18            JP      SCALLP          ; More bits to shift
3175   18E2             
3176   18E2 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3177   18E4 6F                  LD      L,A             ; Save bits to shift
3178   18E5 AF          SHRLP:  XOR     A               ; Flag for all done
3179   18E6 2D                  DEC     L               ; All shifting done?
3180   18E7 C8                  RET     Z               ; Yes - Return
3181   18E8 79                  LD      A,C             ; Get MSB
3182   18E9 1F          SHRT1:  RRA                     ; Shift it right
3183   18EA 4F                  LD      C,A             ; Re-save
3184   18EB 7A                  LD      A,D             ; Get NMSB
3185   18EC 1F                  RRA                     ; Shift right with last bit
3186   18ED 57                  LD      D,A             ; Re-save it
3187   18EE 7B                  LD      A,E             ; Get LSB
3188   18EF 1F                  RRA                     ; Shift right with last bit
3189   18F0 5F                  LD      E,A             ; Re-save it
3190   18F1 78                  LD      A,B             ; Get underflow
3191   18F2 1F                  RRA                     ; Shift right with last bit
3192   18F3 47                  LD      B,A             ; Re-save underflow
3193   18F4 C3 E5 18            JP      SHRLP           ; More bits to do
3194   18F7             
3195   18F7 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3196   18FB             
3197   18FB 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3198   18FC AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3199   1900 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3200   1904 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3201   1908             
3202   1908 CD 54 1A    LOG:    CALL    TSTSGN          ; Test sign of value
3203   190B B7                  OR      A
3204   190C EA CC 0C            JP      PE,FCERR        ; ?FC Error if <= zero
3205   190F 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3206   1912 7E                  LD      A,(HL)          ; Get exponent
3207   1913 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3208   1916 11 F3 04            LD      DE,04F3H
3209   1919 90                  SUB     B               ; Scale value to be < 1
3210   191A F5                  PUSH    AF              ; Save scale factor
3211   191B 70                  LD      (HL),B          ; Save new exponent
3212   191C D5                  PUSH    DE              ; Save SQR(1/2)
3213   191D C5                  PUSH    BC
3214   191E CD 0E 18            CALL    FPADD           ; Add SQR(1/2) to value
3215   1921 C1                  POP     BC              ; Restore SQR(1/2)
3216   1922 D1                  POP     DE
3217   1923 04                  INC     B               ; Make it SQR(2)
3218   1924 CD AA 19            CALL    DVBCDE          ; Divide by SQR(2)
3219   1927 21 F7 18            LD      HL,UNITY        ; Point to 1.
3220   192A CD 05 18            CALL    SUBPHL          ; Subtract FPREG from 1
3221   192D 21 FB 18            LD      HL,LOGTAB       ; Coefficient table
3222   1930 CD 9C 1D            CALL    SUMSER          ; Evaluate sum of series
3223   1933 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3224   1936 11 00 00            LD      DE,0000H
3225   1939 CD 0E 18            CALL    FPADD           ; Subtract 0.5 from FPREG
3226   193C F1                  POP     AF              ; Restore scale factor
3227   193D CD CF 1B            CALL    RSCALE          ; Re-scale number
3228   1940 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3229   1943 11 18 72            LD      DE,7218H
3230   1946 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3231   1947             
3232   1947 C1          MULT:   POP     BC              ; Get number from stack
3233   1948 D1                  POP     DE
3234   1949 CD 54 1A    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3235   194C C8                  RET     Z               ; Return zero if zero
3236   194D 2E 00               LD      L,0             ; Flag add exponents
3237   194F CD 12 1A            CALL    ADDEXP          ; Add exponents
3238   1952 79                  LD      A,C             ; Get MSB of multiplier
3239   1953 32 F6 82            LD      (MULVAL),A      ; Save MSB of multiplier
3240   1956 EB                  EX      DE,HL
3241   1957 22 F7 82            LD      (MULVAL+1),HL   ; Save rest of multiplier
3242   195A 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3243   195D 50                  LD      D,B
3244   195E 58                  LD      E,B
3245   195F 21 5F 18            LD      HL,BNORM        ; Address of normalise
3246   1962 E5                  PUSH    HL              ; Save for return
3247   1963 21 6B 19            LD      HL,MULT8        ; Address of 8 bit multiply
3248   1966 E5                  PUSH    HL              ; Save for NMSB,MSB
3249   1967 E5                  PUSH    HL              ; 
3250   1968 21 E4 82            LD      HL,FPREG        ; Point to number
3251   196B 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3252   196C 23                  INC     HL              ; Point to NMSB
3253   196D B7                  OR      A               ; Test LSB
3254   196E CA 97 19            JP      Z,BYTSFT        ; Zero - shift to next byte
3255   1971 E5                  PUSH    HL              ; Save address of number
3256   1972 2E 08               LD      L,8             ; 8 bits to multiply by
3257   1974 1F          MUL8LP: RRA                     ; Shift LSB right
3258   1975 67                  LD      H,A             ; Save LSB
3259   1976 79                  LD      A,C             ; Get MSB
3260   1977 D2 85 19            JP      NC,NOMADD       ; Bit was zero - Don't add
3261   197A E5                  PUSH    HL              ; Save LSB and count
3262   197B 2A F7 82            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3263   197E 19                  ADD     HL,DE           ; Add NMSB and LSB
3264   197F EB                  EX      DE,HL           ; Leave sum in DE
3265   1980 E1                  POP     HL              ; Restore MSB and count
3266   1981 3A F6 82            LD      A,(MULVAL)      ; Get MSB of multiplier
3267   1984 89                  ADC     A,C             ; Add MSB
3268   1985 1F          NOMADD: RRA                     ; Shift MSB right
3269   1986 4F                  LD      C,A             ; Re-save MSB
3270   1987 7A                  LD      A,D             ; Get NMSB
3271   1988 1F                  RRA                     ; Shift NMSB right
3272   1989 57                  LD      D,A             ; Re-save NMSB
3273   198A 7B                  LD      A,E             ; Get LSB
3274   198B 1F                  RRA                     ; Shift LSB right
3275   198C 5F                  LD      E,A             ; Re-save LSB
3276   198D 78                  LD      A,B             ; Get VLSB
3277   198E 1F                  RRA                     ; Shift VLSB right
3278   198F 47                  LD      B,A             ; Re-save VLSB
3279   1990 2D                  DEC     L               ; Count bits multiplied
3280   1991 7C                  LD      A,H             ; Get LSB of multiplier
3281   1992 C2 74 19            JP      NZ,MUL8LP       ; More - Do it
3282   1995 E1          POPHRT: POP     HL              ; Restore address of number
3283   1996 C9                  RET
3284   1997             
3285   1997 43          BYTSFT: LD      B,E             ; Shift partial product left
3286   1998 5A                  LD      E,D
3287   1999 51                  LD      D,C
3288   199A 4F                  LD      C,A
3289   199B C9                  RET
3290   199C             
3291   199C CD 85 1A    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3292   199F 01 20 84            LD      BC,8420H        ; BCDE = 10.
3293   19A2 11 00 00            LD      DE,0000H
3294   19A5 CD 95 1A            CALL    FPBCDE          ; Move 10 to FPREG
3295   19A8             
3296   19A8 C1          DIV:    POP     BC              ; Get number from stack
3297   19A9 D1                  POP     DE
3298   19AA CD 54 1A    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3299   19AD CA B0 07            JP      Z,DZERR         ; Error if division by zero
3300   19B0 2E FF               LD      L,-1            ; Flag subtract exponents
3301   19B2 CD 12 1A            CALL    ADDEXP          ; Subtract exponents
3302   19B5 34                  INC     (HL)            ; Add 2 to exponent to adjust
3303   19B6 34                  INC     (HL)
3304   19B7 2B                  DEC     HL              ; Point to MSB
3305   19B8 7E                  LD      A,(HL)          ; Get MSB of dividend
3306   19B9 32 12 82            LD      (DIV3),A        ; Save for subtraction
3307   19BC 2B                  DEC     HL
3308   19BD 7E                  LD      A,(HL)          ; Get NMSB of dividend
3309   19BE 32 0E 82            LD      (DIV2),A        ; Save for subtraction
3310   19C1 2B                  DEC     HL
3311   19C2 7E                  LD      A,(HL)          ; Get MSB of dividend
3312   19C3 32 0A 82            LD      (DIV1),A        ; Save for subtraction
3313   19C6 41                  LD      B,C             ; Get MSB
3314   19C7 EB                  EX      DE,HL           ; NMSB,LSB to HL
3315   19C8 AF                  XOR     A
3316   19C9 4F                  LD      C,A             ; Clear MSB of quotient
3317   19CA 57                  LD      D,A             ; Clear NMSB of quotient
3318   19CB 5F                  LD      E,A             ; Clear LSB of quotient
3319   19CC 32 15 82            LD      (DIV4),A        ; Clear overflow count
3320   19CF E5          DIVLP:  PUSH    HL              ; Save divisor
3321   19D0 C5                  PUSH    BC
3322   19D1 7D                  LD      A,L             ; Get LSB of number
3323   19D2 CD 09 82            CALL    DIVSUP          ; Subt' divisor from dividend
3324   19D5 DE 00               SBC     A,0             ; Count for overflows
3325   19D7 3F                  CCF
3326   19D8 D2 E2 19            JP      NC,RESDIV       ; Restore divisor if borrow
3327   19DB 32 15 82            LD      (DIV4),A        ; Re-save overflow count
3328   19DE F1                  POP     AF              ; Scrap divisor
3329   19DF F1                  POP     AF
3330   19E0 37                  SCF                     ; Set carry to
3331   19E1 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3332   19E2             
3333   19E2 C1          RESDIV: POP     BC              ; Restore divisor
3334   19E3 E1                  POP     HL
3335   19E4 79                  LD      A,C             ; Get MSB of quotient
3336   19E5 3C                  INC     A
3337   19E6 3D                  DEC     A
3338   19E7 1F                  RRA                     ; Bit 0 to bit 7
3339   19E8 FA 95 18            JP      M,RONDB         ; Done - Normalise result
3340   19EB 17                  RLA                     ; Restore carry
3341   19EC 7B                  LD      A,E             ; Get LSB of quotient
3342   19ED 17                  RLA                     ; Double it
3343   19EE 5F                  LD      E,A             ; Put it back
3344   19EF 7A                  LD      A,D             ; Get NMSB of quotient
3345   19F0 17                  RLA                     ; Double it
3346   19F1 57                  LD      D,A             ; Put it back
3347   19F2 79                  LD      A,C             ; Get MSB of quotient
3348   19F3 17                  RLA                     ; Double it
3349   19F4 4F                  LD      C,A             ; Put it back
3350   19F5 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3351   19F6 78                  LD      A,B             ; Get MSB of divisor
3352   19F7 17                  RLA                     ; Double it
3353   19F8 47                  LD      B,A             ; Put it back
3354   19F9 3A 15 82            LD      A,(DIV4)        ; Get VLSB of quotient
3355   19FC 17                  RLA                     ; Double it
3356   19FD 32 15 82            LD      (DIV4),A        ; Put it back
3357   1A00 79                  LD      A,C             ; Get MSB of quotient
3358   1A01 B2                  OR      D               ; Merge NMSB
3359   1A02 B3                  OR      E               ; Merge LSB
3360   1A03 C2 CF 19            JP      NZ,DIVLP        ; Not done - Keep dividing
3361   1A06 E5                  PUSH    HL              ; Save divisor
3362   1A07 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3363   1A0A 35                  DEC     (HL)            ; Divide by 2
3364   1A0B E1                  POP     HL              ; Restore divisor
3365   1A0C C2 CF 19            JP      NZ,DIVLP        ; Ok - Keep going
3366   1A0F C3 BC 07            JP      OVERR           ; Overflow error
3367   1A12             
3368   1A12 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3369   1A13 B7                  OR      A               ; Test it
3370   1A14 CA 36 1A            JP      Z,OVTST3        ; Zero - Result zero
3371   1A17 7D                  LD      A,L             ; Get add/subtract flag
3372   1A18 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3373   1A1B AE                  XOR     (HL)            ; Add or subtract it
3374   1A1C 80                  ADD     A,B             ; Add the other exponent
3375   1A1D 47                  LD      B,A             ; Save new exponent
3376   1A1E 1F                  RRA                     ; Test exponent for overflow
3377   1A1F A8                  XOR     B
3378   1A20 78                  LD      A,B             ; Get exponent
3379   1A21 F2 35 1A            JP      P,OVTST2        ; Positive - Test for overflow
3380   1A24 C6 80               ADD     A,80H           ; Add excess 128
3381   1A26 77                  LD      (HL),A          ; Save new exponent
3382   1A27 CA 95 19            JP      Z,POPHRT        ; Zero - Result zero
3383   1A2A CD BA 1A            CALL    SIGNS           ; Set MSBs and sign of result
3384   1A2D 77                  LD      (HL),A          ; Save new exponent
3385   1A2E 2B                  DEC     HL              ; Point to MSB
3386   1A2F C9                  RET
3387   1A30             
3388   1A30 CD 54 1A    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3389   1A33 2F                  CPL                     ; Invert sign
3390   1A34 E1                  POP     HL              ; Clean up stack
3391   1A35 B7          OVTST2: OR      A               ; Test if new exponent zero
3392   1A36 E1          OVTST3: POP     HL              ; Clear off return address
3393   1A37 F2 74 18            JP      P,RESZER        ; Result zero
3394   1A3A C3 BC 07            JP      OVERR           ; Overflow error
3395   1A3D             
3396   1A3D CD A0 1A    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3397   1A40 78                  LD      A,B             ; Get exponent
3398   1A41 B7                  OR      A               ; Is it zero?
3399   1A42 C8                  RET     Z               ; Yes - Result is zero
3400   1A43 C6 02               ADD     A,2             ; Multiply by 4
3401   1A45 DA BC 07            JP      C,OVERR         ; Overflow - ?OV Error
3402   1A48 47                  LD      B,A             ; Re-save exponent
3403   1A49 CD 0E 18            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3404   1A4C 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3405   1A4F 34                  INC     (HL)            ; Double number (Times 10)
3406   1A50 C0                  RET     NZ              ; Ok - Return
3407   1A51 C3 BC 07            JP      OVERR           ; Overflow error
3408   1A54             
3409   1A54 3A E7 82    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3410   1A57 B7                  OR      A
3411   1A58 C8                  RET     Z               ; RETurn if number is zero
3412   1A59 3A E6 82            LD      A,(FPREG+2)     ; Get MSB of FPREG
3413   1A5C FE                  .BYTE      0FEH            ; Test sign
3414   1A5D 2F          RETREL: CPL                     ; Invert sign
3415   1A5E 17                  RLA                     ; Sign bit to carry
3416   1A5F 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3417   1A60 C0                  RET     NZ              ; Return -1 if negative
3418   1A61 3C                  INC     A               ; Bump to +1
3419   1A62 C9                  RET                     ; Positive - Return +1
3420   1A63             
3421   1A63 CD 54 1A    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3422   1A66 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3423   1A68 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3424   1A6B 21 E7 82    RETINT: LD      HL,FPEXP        ; Point to exponent
3425   1A6E 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3426   1A6F 70                  LD      (HL),B          ; Save exponent
3427   1A70 06 00               LD      B,0             ; CDE = integer to normalise
3428   1A72 23                  INC     HL              ; Point to sign of result
3429   1A73 36 80               LD      (HL),80H        ; Set sign of result
3430   1A75 17                  RLA                     ; Carry = sign of integer
3431   1A76 C3 5C 18            JP      CONPOS          ; Set sign of result
3432   1A79             
3433   1A79 CD 54 1A    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3434   1A7C F0                  RET     P               ; Return if positive
3435   1A7D 21 E6 82    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3436   1A80 7E                  LD      A,(HL)          ; Get sign of mantissa
3437   1A81 EE 80               XOR     80H             ; Invert sign of mantissa
3438   1A83 77                  LD      (HL),A          ; Re-save sign of mantissa
3439   1A84 C9                  RET
3440   1A85             
3441   1A85 EB          STAKFP: EX      DE,HL           ; Save code string address
3442   1A86 2A E4 82            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3443   1A89 E3                  EX      (SP),HL         ; Stack them,get return
3444   1A8A E5                  PUSH    HL              ; Re-save return
3445   1A8B 2A E6 82            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3446   1A8E E3                  EX      (SP),HL         ; Stack them,get return
3447   1A8F E5                  PUSH    HL              ; Re-save return
3448   1A90 EB                  EX      DE,HL           ; Restore code string address
3449   1A91 C9                  RET
3450   1A92             
3451   1A92 CD A3 1A    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3452   1A95 EB          FPBCDE: EX      DE,HL           ; Save code string address
3453   1A96 22 E4 82            LD      (FPREG),HL      ; Save LSB,NLSB of number
3454   1A99 60                  LD      H,B             ; Exponent of number
3455   1A9A 69                  LD      L,C             ; MSB of number
3456   1A9B 22 E6 82            LD      (FPREG+2),HL    ; Save MSB and exponent
3457   1A9E EB                  EX      DE,HL           ; Restore code string address
3458   1A9F C9                  RET
3459   1AA0             
3460   1AA0 21 E4 82    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3461   1AA3 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3462   1AA4 23                  INC     HL
3463   1AA5 56                  LD      D,(HL)          ; Get NMSB of number
3464   1AA6 23                  INC     HL
3465   1AA7 4E                  LD      C,(HL)          ; Get MSB of number
3466   1AA8 23                  INC     HL
3467   1AA9 46                  LD      B,(HL)          ; Get exponent of number
3468   1AAA 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3469   1AAB C9                  RET
3470   1AAC             
3471   1AAC 11 E4 82    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3472   1AAF 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3473   1AB1 1A          DETHLB: LD      A,(DE)          ; Get source
3474   1AB2 77                  LD      (HL),A          ; Save destination
3475   1AB3 13                  INC     DE              ; Next source
3476   1AB4 23                  INC     HL              ; Next destination
3477   1AB5 05                  DEC     B               ; Count bytes
3478   1AB6 C2 B1 1A            JP      NZ,DETHLB       ; Loop if more
3479   1AB9 C9                  RET
3480   1ABA             
3481   1ABA 21 E6 82    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3482   1ABD 7E                  LD      A,(HL)          ; Get MSB
3483   1ABE 07                  RLCA                    ; Old sign to carry
3484   1ABF 37                  SCF                     ; Set MSBit
3485   1AC0 1F                  RRA                     ; Set MSBit of MSB
3486   1AC1 77                  LD      (HL),A          ; Save new MSB
3487   1AC2 3F                  CCF                     ; Complement sign
3488   1AC3 1F                  RRA                     ; Old sign to carry
3489   1AC4 23                  INC     HL
3490   1AC5 23                  INC     HL
3491   1AC6 77                  LD      (HL),A          ; Set sign of result
3492   1AC7 79                  LD      A,C             ; Get MSB
3493   1AC8 07                  RLCA                    ; Old sign to carry
3494   1AC9 37                  SCF                     ; Set MSBit
3495   1ACA 1F                  RRA                     ; Set MSBit of MSB
3496   1ACB 4F                  LD      C,A             ; Save MSB
3497   1ACC 1F                  RRA
3498   1ACD AE                  XOR     (HL)            ; New sign of result
3499   1ACE C9                  RET
3500   1ACF             
3501   1ACF 78          CMPNUM: LD      A,B             ; Get exponent of number
3502   1AD0 B7                  OR      A
3503   1AD1 CA 54 1A            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3504   1AD4 21 5D 1A            LD      HL,RETREL       ; Return relation routine
3505   1AD7 E5                  PUSH    HL              ; Save for return
3506   1AD8 CD 54 1A            CALL    TSTSGN          ; Test sign of FPREG
3507   1ADB 79                  LD      A,C             ; Get MSB of number
3508   1ADC C8                  RET     Z               ; FPREG zero - Number's MSB
3509   1ADD 21 E6 82            LD      HL,FPREG+2      ; MSB of FPREG
3510   1AE0 AE                  XOR     (HL)            ; Combine signs
3511   1AE1 79                  LD      A,C             ; Get MSB of number
3512   1AE2 F8                  RET     M               ; Exit if signs different
3513   1AE3 CD E9 1A            CALL    CMPFP           ; Compare FP numbers
3514   1AE6 1F                  RRA                     ; Get carry to sign
3515   1AE7 A9                  XOR     C               ; Combine with MSB of number
3516   1AE8 C9                  RET
3517   1AE9             
3518   1AE9 23          CMPFP:  INC     HL              ; Point to exponent
3519   1AEA 78                  LD      A,B             ; Get exponent
3520   1AEB BE                  CP      (HL)            ; Compare exponents
3521   1AEC C0                  RET     NZ              ; Different
3522   1AED 2B                  DEC     HL              ; Point to MBS
3523   1AEE 79                  LD      A,C             ; Get MSB
3524   1AEF BE                  CP      (HL)            ; Compare MSBs
3525   1AF0 C0                  RET     NZ              ; Different
3526   1AF1 2B                  DEC     HL              ; Point to NMSB
3527   1AF2 7A                  LD      A,D             ; Get NMSB
3528   1AF3 BE                  CP      (HL)            ; Compare NMSBs
3529   1AF4 C0                  RET     NZ              ; Different
3530   1AF5 2B                  DEC     HL              ; Point to LSB
3531   1AF6 7B                  LD      A,E             ; Get LSB
3532   1AF7 96                  SUB     (HL)            ; Compare LSBs
3533   1AF8 C0                  RET     NZ              ; Different
3534   1AF9 E1                  POP     HL              ; Drop RETurn
3535   1AFA E1                  POP     HL              ; Drop another RETurn
3536   1AFB C9                  RET
3537   1AFC             
3538   1AFC 47          FPINT:  LD      B,A             ; <- Move
3539   1AFD 4F                  LD      C,A             ; <- exponent
3540   1AFE 57                  LD      D,A             ; <- to all
3541   1AFF 5F                  LD      E,A             ; <- bits
3542   1B00 B7                  OR      A               ; Test exponent
3543   1B01 C8                  RET     Z               ; Zero - Return zero
3544   1B02 E5                  PUSH    HL              ; Save pointer to number
3545   1B03 CD A0 1A            CALL    BCDEFP          ; Move FPREG to BCDE
3546   1B06 CD BA 1A            CALL    SIGNS           ; Set MSBs & sign of result
3547   1B09 AE                  XOR     (HL)            ; Combine with sign of FPREG
3548   1B0A 67                  LD      H,A             ; Save combined signs
3549   1B0B FC 20 1B            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3550   1B0E 3E 98               LD      A,80H+24        ; 24 bits
3551   1B10 90                  SUB     B               ; Bits to shift
3552   1B11 CD D3 18            CALL    SCALE           ; Shift BCDE
3553   1B14 7C                  LD      A,H             ; Get combined sign
3554   1B15 17                  RLA                     ; Sign to carry
3555   1B16 DC A6 18            CALL    C,FPROND        ; Negative - Round number up
3556   1B19 06 00               LD      B,0             ; Zero exponent
3557   1B1B DC BF 18            CALL    C,COMPL         ; If negative make positive
3558   1B1E E1                  POP     HL              ; Restore pointer to number
3559   1B1F C9                  RET
3560   1B20             
3561   1B20 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3562   1B21 7A                  LD      A,D             ; Test LSBs
3563   1B22 A3                  AND     E
3564   1B23 3C                  INC     A
3565   1B24 C0                  RET     NZ              ; Exit if LSBs not FFFF
3566   1B25 0B                  DEC     BC              ; Decrement MSBs
3567   1B26 C9                  RET
3568   1B27             
3569   1B27 21 E7 82    INT:    LD      HL,FPEXP        ; Point to exponent
3570   1B2A 7E                  LD      A,(HL)          ; Get exponent
3571   1B2B FE 98               CP      80H+24          ; Integer accuracy only?
3572   1B2D 3A E4 82            LD      A,(FPREG)       ; Get LSB
3573   1B30 D0                  RET     NC              ; Yes - Already integer
3574   1B31 7E                  LD      A,(HL)          ; Get exponent
3575   1B32 CD FC 1A            CALL    FPINT           ; F.P to integer
3576   1B35 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3577   1B37 7B                  LD      A,E             ; Get LSB of number
3578   1B38 F5                  PUSH    AF              ; Save LSB
3579   1B39 79                  LD      A,C             ; Get MSB of number
3580   1B3A 17                  RLA                     ; Sign to carry
3581   1B3B CD 5C 18            CALL    CONPOS          ; Set sign of result
3582   1B3E F1                  POP     AF              ; Restore LSB of number
3583   1B3F C9                  RET
3584   1B40             
3585   1B40 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3586   1B43 78                  LD      A,B             ; Test multiplier
3587   1B44 B1                  OR      C
3588   1B45 C8                  RET     Z               ; Return zero if zero
3589   1B46 3E 10               LD      A,16            ; 16 bits
3590   1B48 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3591   1B49 DA 80 13            JP      C,BSERR         ; ?BS Error if overflow
3592   1B4C EB                  EX      DE,HL
3593   1B4D 29                  ADD     HL,HL           ; Shift multiplier left
3594   1B4E EB                  EX      DE,HL
3595   1B4F D2 56 1B            JP      NC,NOMLAD       ; Bit was zero - No add
3596   1B52 09                  ADD     HL,BC           ; Add multiplicand
3597   1B53 DA 80 13            JP      C,BSERR         ; ?BS Error if overflow
3598   1B56 3D          NOMLAD: DEC     A               ; Count bits
3599   1B57 C2 48 1B            JP      NZ,MLDBLP       ; More
3600   1B5A C9                  RET
3601   1B5B             
3602   1B5B FE 2D       ASCTFP: CP      '-'             ; Negative?
3603   1B5D F5                  PUSH    AF              ; Save it and flags
3604   1B5E CA 67 1B            JP      Z,CNVNUM        ; Yes - Convert number
3605   1B61 FE 2B               CP      '+'             ; Positive?
3606   1B63 CA 67 1B            JP      Z,CNVNUM        ; Yes - Convert number
3607   1B66 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3608   1B67 CD 74 18    CNVNUM: CALL    RESZER          ; Set result to zero
3609   1B6A 47                  LD      B,A             ; Digits after point counter
3610   1B6B 57                  LD      D,A             ; Sign of exponent
3611   1B6C 5F                  LD      E,A             ; Exponent of ten
3612   1B6D 2F                  CPL
3613   1B6E 4F                  LD      C,A             ; Before or after point flag
3614   1B6F CD 05 0C    MANLP:  CALL    GETCHR          ; Get next character
3615   1B72 DA B8 1B            JP      C,ADDIG         ; Digit - Add to number
3616   1B75 FE 2E               CP      '.'
3617   1B77 CA 93 1B            JP      Z,DPOINT        ; '.' - Flag point
3618   1B7A FE 45               CP      'E'
3619   1B7C C2 97 1B            JP      NZ,CONEXP       ; Not 'E' - Scale number
3620   1B7F CD 05 0C            CALL    GETCHR          ; Get next character
3621   1B82 CD AB 11            CALL    SGNEXP          ; Get sign of exponent
3622   1B85 CD 05 0C    EXPLP:  CALL    GETCHR          ; Get next character
3623   1B88 DA DA 1B            JP      C,EDIGIT        ; Digit - Add to exponent
3624   1B8B 14                  INC     D               ; Is sign negative?
3625   1B8C C2 97 1B            JP      NZ,CONEXP       ; No - Scale number
3626   1B8F AF                  XOR     A
3627   1B90 93                  SUB     E               ; Negate exponent
3628   1B91 5F                  LD      E,A             ; And re-save it
3629   1B92 0C                  INC     C               ; Flag end of number
3630   1B93 0C          DPOINT: INC     C               ; Flag point passed
3631   1B94 CA 6F 1B            JP      Z,MANLP         ; Zero - Get another digit
3632   1B97 E5          CONEXP: PUSH    HL              ; Save code string address
3633   1B98 7B                  LD      A,E             ; Get exponent
3634   1B99 90                  SUB     B               ; Subtract digits after point
3635   1B9A F4 B0 1B    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3636   1B9D F2 A6 1B            JP      P,ENDCON        ; Positive - All done
3637   1BA0 F5                  PUSH    AF              ; Save number of times to /10
3638   1BA1 CD 9C 19            CALL    DIV10           ; Divide by 10
3639   1BA4 F1                  POP     AF              ; Restore count
3640   1BA5 3C                  INC     A               ; Count divides
3641   1BA6             
3642   1BA6 C2 9A 1B    ENDCON: JP      NZ,SCALMI       ; More to do
3643   1BA9 D1                  POP     DE              ; Restore code string address
3644   1BAA F1                  POP     AF              ; Restore sign of number
3645   1BAB CC 7D 1A            CALL    Z,INVSGN        ; Negative - Negate number
3646   1BAE EB                  EX      DE,HL           ; Code string address to HL
3647   1BAF C9                  RET
3648   1BB0             
3649   1BB0 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3650   1BB1 F5          MULTEN: PUSH    AF              ; Save count
3651   1BB2 CD 3D 1A            CALL    MLSP10          ; Multiply number by 10
3652   1BB5 F1                  POP     AF              ; Restore count
3653   1BB6 3D                  DEC     A               ; Count multiplies
3654   1BB7 C9                  RET
3655   1BB8             
3656   1BB8 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3657   1BB9 57                  LD      D,A             ; Save digit
3658   1BBA 78                  LD      A,B             ; Get digits after point
3659   1BBB 89                  ADC     A,C             ; Add one if after point
3660   1BBC 47                  LD      B,A             ; Re-save counter
3661   1BBD C5                  PUSH    BC              ; Save point flags
3662   1BBE E5                  PUSH    HL              ; Save code string address
3663   1BBF D5                  PUSH    DE              ; Save digit
3664   1BC0 CD 3D 1A            CALL    MLSP10          ; Multiply number by 10
3665   1BC3 F1                  POP     AF              ; Restore digit
3666   1BC4 D6 30               SUB     '0'             ; Make it absolute
3667   1BC6 CD CF 1B            CALL    RSCALE          ; Re-scale number
3668   1BC9 E1                  POP     HL              ; Restore code string address
3669   1BCA C1                  POP     BC              ; Restore point flags
3670   1BCB D1                  POP     DE              ; Restore sign of exponent
3671   1BCC C3 6F 1B            JP      MANLP           ; Get another digit
3672   1BCF             
3673   1BCF CD 85 1A    RSCALE: CALL    STAKFP          ; Put number on stack
3674   1BD2 CD 66 1A            CALL    FLGREL          ; Digit to add to FPREG
3675   1BD5 C1          PADD:   POP     BC              ; Restore number
3676   1BD6 D1                  POP     DE
3677   1BD7 C3 0E 18            JP      FPADD           ; Add BCDE to FPREG and return
3678   1BDA             
3679   1BDA 7B          EDIGIT: LD      A,E             ; Get digit
3680   1BDB 07                  RLCA                    ; Times 2
3681   1BDC 07                  RLCA                    ; Times 4
3682   1BDD 83                  ADD     A,E             ; Times 5
3683   1BDE 07                  RLCA                    ; Times 10
3684   1BDF 86                  ADD     A,(HL)          ; Add next digit
3685   1BE0 D6 30               SUB     '0'             ; Make it absolute
3686   1BE2 5F                  LD      E,A             ; Save new digit
3687   1BE3 C3 85 1B            JP      EXPLP           ; Look for another digit
3688   1BE6             
3689   1BE6 E5          LINEIN: PUSH    HL              ; Save code string address
3690   1BE7 21 45 07            LD      HL,INMSG        ; Output " in "
3691   1BEA CD 4B 15            CALL    PRS             ; Output string at HL
3692   1BED E1                  POP     HL              ; Restore code string address
3693   1BEE EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3694   1BEF AF                  XOR     A
3695   1BF0 06 98               LD      B,80H+24        ; 24 bits
3696   1BF2 CD 6B 1A            CALL    RETINT          ; Return the integer
3697   1BF5 21 4A 15            LD      HL,PRNUMS       ; Print number string
3698   1BF8 E5                  PUSH    HL              ; Save for return
3699   1BF9 21 E9 82    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3700   1BFC E5                  PUSH    HL              ; Save for return
3701   1BFD CD 54 1A            CALL    TSTSGN          ; Test sign of FPREG
3702   1C00 36 20               LD      (HL),' '        ; Space at start
3703   1C02 F2 07 1C            JP      P,SPCFST        ; Positive - Space to start
3704   1C05 36 2D               LD      (HL),'-'        ; '-' sign at start
3705   1C07 23          SPCFST: INC     HL              ; First byte of number
3706   1C08 36 30               LD      (HL),'0'        ; '0' if zero
3707   1C0A CA BD 1C            JP      Z,JSTZER        ; Return '0' if zero
3708   1C0D E5                  PUSH    HL              ; Save buffer address
3709   1C0E FC 7D 1A            CALL    M,INVSGN        ; Negate FPREG if negative
3710   1C11 AF                  XOR     A               ; Zero A
3711   1C12 F5                  PUSH    AF              ; Save it
3712   1C13 CD C3 1C            CALL    RNGTST          ; Test number is in range
3713   1C16 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3714   1C19 11 F8 4F            LD      DE,4FF8H
3715   1C1C CD CF 1A            CALL    CMPNUM          ; Compare numbers
3716   1C1F B7                  OR      A
3717   1C20 E2 34 1C            JP      PO,INRNG        ; > 99999.9 - Sort it out
3718   1C23 F1                  POP     AF              ; Restore count
3719   1C24 CD B1 1B            CALL    MULTEN          ; Multiply by ten
3720   1C27 F5                  PUSH    AF              ; Re-save count
3721   1C28 C3 16 1C            JP      SIXDIG          ; Test it again
3722   1C2B             
3723   1C2B CD 9C 19    GTSIXD: CALL    DIV10           ; Divide by 10
3724   1C2E F1                  POP     AF              ; Get count
3725   1C2F 3C                  INC     A               ; Count divides
3726   1C30 F5                  PUSH    AF              ; Re-save count
3727   1C31 CD C3 1C            CALL    RNGTST          ; Test number is in range
3728   1C34 CD FC 17    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3729   1C37 3C                  INC     A
3730   1C38 CD FC 1A            CALL    FPINT           ; F.P to integer
3731   1C3B CD 95 1A            CALL    FPBCDE          ; Move BCDE to FPREG
3732   1C3E 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3733   1C41 F1                  POP     AF              ; Restore count
3734   1C42 81                  ADD     A,C             ; 6 digits before point
3735   1C43 3C                  INC     A               ; Add one
3736   1C44 FA 50 1C            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3737   1C47 FE 08               CP      6+1+1           ; More than 999999 ?
3738   1C49 D2 50 1C            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3739   1C4C 3C                  INC     A               ; Adjust for exponent
3740   1C4D 47                  LD      B,A             ; Exponent of number
3741   1C4E 3E 02               LD      A,2             ; Make it zero after
3742   1C50             
3743   1C50 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3744   1C51 3D                  DEC     A
3745   1C52 E1                  POP     HL              ; Restore buffer address
3746   1C53 F5                  PUSH    AF              ; Save count
3747   1C54 11 D6 1C            LD      DE,POWERS       ; Powers of ten
3748   1C57 05                  DEC     B               ; Count digits before point
3749   1C58 C2 61 1C            JP      NZ,DIGTXT       ; Not zero - Do number
3750   1C5B 36 2E               LD      (HL),'.'        ; Save point
3751   1C5D 23                  INC     HL              ; Move on
3752   1C5E 36 30               LD      (HL),'0'        ; Save zero
3753   1C60 23                  INC     HL              ; Move on
3754   1C61 05          DIGTXT: DEC     B               ; Count digits before point
3755   1C62 36 2E               LD      (HL),'.'        ; Save point in case
3756   1C64 CC AA 1A            CALL    Z,INCHL         ; Last digit - move on
3757   1C67 C5                  PUSH    BC              ; Save digits before point
3758   1C68 E5                  PUSH    HL              ; Save buffer address
3759   1C69 D5                  PUSH    DE              ; Save powers of ten
3760   1C6A CD A0 1A            CALL    BCDEFP          ; Move FPREG to BCDE
3761   1C6D E1                  POP     HL              ; Powers of ten table
3762   1C6E 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3763   1C70 04          TRYAGN: INC     B               ; Count subtractions
3764   1C71 7B                  LD      A,E             ; Get LSB
3765   1C72 96                  SUB     (HL)            ; Subtract LSB
3766   1C73 5F                  LD      E,A             ; Save LSB
3767   1C74 23                  INC     HL
3768   1C75 7A                  LD      A,D             ; Get NMSB
3769   1C76 9E                  SBC     A,(HL)          ; Subtract NMSB
3770   1C77 57                  LD      D,A             ; Save NMSB
3771   1C78 23                  INC     HL
3772   1C79 79                  LD      A,C             ; Get MSB
3773   1C7A 9E                  SBC     A,(HL)          ; Subtract MSB
3774   1C7B 4F                  LD      C,A             ; Save MSB
3775   1C7C 2B                  DEC     HL              ; Point back to start
3776   1C7D 2B                  DEC     HL
3777   1C7E D2 70 1C            JP      NC,TRYAGN       ; No overflow - Try again
3778   1C81 CD B3 18            CALL    PLUCDE          ; Restore number
3779   1C84 23                  INC     HL              ; Start of next number
3780   1C85 CD 95 1A            CALL    FPBCDE          ; Move BCDE to FPREG
3781   1C88 EB                  EX      DE,HL           ; Save point in table
3782   1C89 E1                  POP     HL              ; Restore buffer address
3783   1C8A 70                  LD      (HL),B          ; Save digit in buffer
3784   1C8B 23                  INC     HL              ; And move on
3785   1C8C C1                  POP     BC              ; Restore digit count
3786   1C8D 0D                  DEC     C               ; Count digits
3787   1C8E C2 61 1C            JP      NZ,DIGTXT       ; More - Do them
3788   1C91 05                  DEC     B               ; Any decimal part?
3789   1C92 CA A1 1C            JP      Z,DOEBIT        ; No - Do 'E' bit
3790   1C95 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3791   1C96 7E                  LD      A,(HL)          ; Get character
3792   1C97 FE 30               CP      '0'             ; '0' character?
3793   1C99 CA 95 1C            JP      Z,SUPTLZ        ; Yes - Look back for more
3794   1C9C FE 2E               CP      '.'             ; A decimal point?
3795   1C9E C4 AA 1A            CALL    NZ,INCHL        ; Move back over digit
3796   1CA1             
3797   1CA1 F1          DOEBIT: POP     AF              ; Get 'E' flag
3798   1CA2 CA C0 1C            JP      Z,NOENED        ; No 'E' needed - End buffer
3799   1CA5 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3800   1CA7 23                  INC     HL              ; And move on
3801   1CA8 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3802   1CAA F2 B1 1C            JP      P,OUTEXP        ; Positive - Output exponent
3803   1CAD 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3804   1CAF 2F                  CPL                     ; Negate exponent
3805   1CB0 3C                  INC     A
3806   1CB1 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3807   1CB3 04          EXPTEN: INC     B               ; Count subtractions
3808   1CB4 D6 0A               SUB     10              ; Tens digit
3809   1CB6 D2 B3 1C            JP      NC,EXPTEN       ; More to do
3810   1CB9 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3811   1CBB 23                  INC     HL              ; Move on
3812   1CBC 70                  LD      (HL),B          ; Save MSB of exponent
3813   1CBD 23          JSTZER: INC     HL              ;
3814   1CBE 77                  LD      (HL),A          ; Save LSB of exponent
3815   1CBF 23                  INC     HL
3816   1CC0 71          NOENED: LD      (HL),C          ; Mark end of buffer
3817   1CC1 E1                  POP     HL              ; Restore code string address
3818   1CC2 C9                  RET
3819   1CC3             
3820   1CC3 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3821   1CC6 11 F7 23            LD      DE,23F7H
3822   1CC9 CD CF 1A            CALL    CMPNUM          ; Compare numbers
3823   1CCC B7                  OR      A
3824   1CCD E1                  POP     HL              ; Return address to HL
3825   1CCE E2 2B 1C            JP      PO,GTSIXD       ; Too big - Divide by ten
3826   1CD1 E9                  JP      (HL)            ; Otherwise return to caller
3827   1CD2             
3828   1CD2 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3829   1CD6             
3830   1CD6 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3831   1CD9 10 27 00            .BYTE      010H,027H,000H  ;  10000
3832   1CDC E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3833   1CDF 64 00 00            .BYTE      064H,000H,000H  ;    100
3834   1CE2 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3835   1CE5 01 00 00            .BYTE      001H,000H,000H  ;      1
3836   1CE8             
3837   1CE8 21 7D 1A    NEGAFT: LD  HL,INVSGN           ; Negate result
3838   1CEB E3                  EX      (SP),HL         ; To be done after caller
3839   1CEC E9                  JP      (HL)            ; Return to caller
3840   1CED             
3841   1CED CD 85 1A    SQR:    CALL    STAKFP          ; Put value on stack
3842   1CF0 21 D2 1C            LD      HL,HALF         ; Set power to 1/2
3843   1CF3 CD 92 1A            CALL    PHLTFP          ; Move 1/2 to FPREG
3844   1CF6             
3845   1CF6 C1          POWER:  POP     BC              ; Get base
3846   1CF7 D1                  POP     DE
3847   1CF8 CD 54 1A            CALL    TSTSGN          ; Test sign of power
3848   1CFB 78                  LD      A,B             ; Get exponent of base
3849   1CFC CA 3B 1D            JP      Z,EXP           ; Make result 1 if zero
3850   1CFF F2 06 1D            JP      P,POWER1        ; Positive base - Ok
3851   1D02 B7                  OR      A               ; Zero to negative power?
3852   1D03 CA B0 07            JP      Z,DZERR         ; Yes - ?/0 Error
3853   1D06 B7          POWER1: OR      A               ; Base zero?
3854   1D07 CA 75 18            JP      Z,SAVEXP        ; Yes - Return zero
3855   1D0A D5                  PUSH    DE              ; Save base
3856   1D0B C5                  PUSH    BC
3857   1D0C 79                  LD      A,C             ; Get MSB of base
3858   1D0D F6 7F               OR      01111111B       ; Get sign status
3859   1D0F CD A0 1A            CALL    BCDEFP          ; Move power to BCDE
3860   1D12 F2 23 1D            JP      P,POWER2        ; Positive base - Ok
3861   1D15 D5                  PUSH    DE              ; Save power
3862   1D16 C5                  PUSH    BC
3863   1D17 CD 27 1B            CALL    INT             ; Get integer of power
3864   1D1A C1                  POP     BC              ; Restore power
3865   1D1B D1                  POP     DE
3866   1D1C F5                  PUSH    AF              ; MSB of base
3867   1D1D CD CF 1A            CALL    CMPNUM          ; Power an integer?
3868   1D20 E1                  POP     HL              ; Restore MSB of base
3869   1D21 7C                  LD      A,H             ; but don't affect flags
3870   1D22 1F                  RRA                     ; Exponent odd or even?
3871   1D23 E1          POWER2: POP     HL              ; Restore MSB and exponent
3872   1D24 22 E6 82            LD      (FPREG+2),HL    ; Save base in FPREG
3873   1D27 E1                  POP     HL              ; LSBs of base
3874   1D28 22 E4 82            LD      (FPREG),HL      ; Save in FPREG
3875   1D2B DC E8 1C            CALL    C,NEGAFT        ; Odd power - Negate result
3876   1D2E CC 7D 1A            CALL    Z,INVSGN        ; Negative base - Negate it
3877   1D31 D5                  PUSH    DE              ; Save power
3878   1D32 C5                  PUSH    BC
3879   1D33 CD 08 19            CALL    LOG             ; Get LOG of base
3880   1D36 C1                  POP     BC              ; Restore power
3881   1D37 D1                  POP     DE
3882   1D38 CD 49 19            CALL    FPMULT          ; Multiply LOG by power
3883   1D3B             
3884   1D3B CD 85 1A    EXP:    CALL    STAKFP          ; Put value on stack
3885   1D3E 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3886   1D41 11 3B AA            LD      DE,0AA3BH
3887   1D44 CD 49 19            CALL    FPMULT          ; Multiply value by 1/LN(2)
3888   1D47 3A E7 82            LD      A,(FPEXP)       ; Get exponent
3889   1D4A FE 88               CP      80H+8           ; Is it in range?
3890   1D4C D2 30 1A            JP      NC,OVTST1       ; No - Test for overflow
3891   1D4F CD 27 1B            CALL    INT             ; Get INT of FPREG
3892   1D52 C6 80               ADD     A,80H           ; For excess 128
3893   1D54 C6 02               ADD     A,2             ; Exponent > 126?
3894   1D56 DA 30 1A            JP      C,OVTST1        ; Yes - Test for overflow
3895   1D59 F5                  PUSH    AF              ; Save scaling factor
3896   1D5A 21 F7 18            LD      HL,UNITY        ; Point to 1.
3897   1D5D CD FF 17            CALL    ADDPHL          ; Add 1 to FPREG
3898   1D60 CD 40 19            CALL    MULLN2          ; Multiply by LN(2)
3899   1D63 F1                  POP     AF              ; Restore scaling factor
3900   1D64 C1                  POP     BC              ; Restore exponent
3901   1D65 D1                  POP     DE
3902   1D66 F5                  PUSH    AF              ; Save scaling factor
3903   1D67 CD 0B 18            CALL    SUBCDE          ; Subtract exponent from FPREG
3904   1D6A CD 7D 1A            CALL    INVSGN          ; Negate result
3905   1D6D 21 7B 1D            LD      HL,EXPTAB       ; Coefficient table
3906   1D70 CD AB 1D            CALL    SMSER1          ; Sum the series
3907   1D73 11 00 00            LD      DE,0            ; Zero LSBs
3908   1D76 C1                  POP     BC              ; Scaling factor
3909   1D77 4A                  LD      C,D             ; Zero MSB
3910   1D78 C3 49 19            JP      FPMULT          ; Scale result to correct value
3911   1D7B             
3912   1D7B 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3913   1D7C 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3914   1D80 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3915   1D84 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3916   1D88 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3917   1D8C 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3918   1D90 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3919   1D94 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3920   1D98 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3921   1D9C             
3922   1D9C CD 85 1A    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3923   1D9F 11 47 19            LD      DE,MULT         ; Multiply by "X"
3924   1DA2 D5                  PUSH    DE              ; To be done after
3925   1DA3 E5                  PUSH    HL              ; Save address of table
3926   1DA4 CD A0 1A            CALL    BCDEFP          ; Move FPREG to BCDE
3927   1DA7 CD 49 19            CALL    FPMULT          ; Square the value
3928   1DAA E1                  POP     HL              ; Restore address of table
3929   1DAB CD 85 1A    SMSER1: CALL    STAKFP          ; Put value on stack
3930   1DAE 7E                  LD      A,(HL)          ; Get number of coefficients
3931   1DAF 23                  INC     HL              ; Point to start of table
3932   1DB0 CD 92 1A            CALL    PHLTFP          ; Move coefficient to FPREG
3933   1DB3 06                  .BYTE      06H             ; Skip "POP AF"
3934   1DB4 F1          SUMLP:  POP     AF              ; Restore count
3935   1DB5 C1                  POP     BC              ; Restore number
3936   1DB6 D1                  POP     DE
3937   1DB7 3D                  DEC     A               ; Cont coefficients
3938   1DB8 C8                  RET     Z               ; All done
3939   1DB9 D5                  PUSH    DE              ; Save number
3940   1DBA C5                  PUSH    BC
3941   1DBB F5                  PUSH    AF              ; Save count
3942   1DBC E5                  PUSH    HL              ; Save address in table
3943   1DBD CD 49 19            CALL    FPMULT          ; Multiply FPREG by BCDE
3944   1DC0 E1                  POP     HL              ; Restore address in table
3945   1DC1 CD A3 1A            CALL    LOADFP          ; Number at HL to BCDE
3946   1DC4 E5                  PUSH    HL              ; Save address in table
3947   1DC5 CD 0E 18            CALL    FPADD           ; Add coefficient to FPREG
3948   1DC8 E1                  POP     HL              ; Restore address in table
3949   1DC9 C3 B4 1D            JP      SUMLP           ; More coefficients
3950   1DCC             
3951   1DCC CD 54 1A    RND:    CALL    TSTSGN          ; Test sign of FPREG
3952   1DCF 21 19 82            LD      HL,SEED+2       ; Random number seed
3953   1DD2 FA 2D 1E            JP      M,RESEED        ; Negative - Re-seed
3954   1DD5 21 3A 82            LD      HL,LSTRND       ; Last random number
3955   1DD8 CD 92 1A            CALL    PHLTFP          ; Move last RND to FPREG
3956   1DDB 21 19 82            LD      HL,SEED+2       ; Random number seed
3957   1DDE C8                  RET     Z               ; Return if RND(0)
3958   1DDF 86                  ADD     A,(HL)          ; Add (SEED)+2)
3959   1DE0 E6 07               AND     00000111B       ; 0 to 7
3960   1DE2 06 00               LD      B,0
3961   1DE4 77                  LD      (HL),A          ; Re-save seed
3962   1DE5 23                  INC     HL              ; Move to coefficient table
3963   1DE6 87                  ADD     A,A             ; 4 bytes
3964   1DE7 87                  ADD     A,A             ; per entry
3965   1DE8 4F                  LD      C,A             ; BC = Offset into table
3966   1DE9 09                  ADD     HL,BC           ; Point to coefficient
3967   1DEA CD A3 1A            CALL    LOADFP          ; Coefficient to BCDE
3968   1DED CD 49 19            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3969   1DF0 3A 18 82            LD      A,(SEED+1)      ; Get (SEED+1)
3970   1DF3 3C                  INC     A               ; Add 1
3971   1DF4 E6 03               AND     00000011B       ; 0 to 3
3972   1DF6 06 00               LD      B,0
3973   1DF8 FE 01               CP      1               ; Is it zero?
3974   1DFA 88                  ADC     A,B             ; Yes - Make it 1
3975   1DFB 32 18 82            LD      (SEED+1),A      ; Re-save seed
3976   1DFE 21 31 1E            LD      HL,RNDTAB-4     ; Addition table
3977   1E01 87                  ADD     A,A             ; 4 bytes
3978   1E02 87                  ADD     A,A             ; per entry
3979   1E03 4F                  LD      C,A             ; BC = Offset into table
3980   1E04 09                  ADD     HL,BC           ; Point to value
3981   1E05 CD FF 17            CALL    ADDPHL          ; Add value to FPREG
3982   1E08 CD A0 1A    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3983   1E0B 7B                  LD      A,E             ; Get LSB
3984   1E0C 59                  LD      E,C             ; LSB = MSB
3985   1E0D EE 4F               XOR     01001111B       ; Fiddle around
3986   1E0F 4F                  LD      C,A             ; New MSB
3987   1E10 36 80               LD      (HL),80H        ; Set exponent
3988   1E12 2B                  DEC     HL              ; Point to MSB
3989   1E13 46                  LD      B,(HL)          ; Get MSB
3990   1E14 36 80               LD      (HL),80H        ; Make value -0.5
3991   1E16 21 17 82            LD      HL,SEED         ; Random number seed
3992   1E19 34                  INC     (HL)            ; Count seed
3993   1E1A 7E                  LD      A,(HL)          ; Get seed
3994   1E1B D6 AB               SUB     171             ; Do it modulo 171
3995   1E1D C2 24 1E            JP      NZ,RND2         ; Non-zero - Ok
3996   1E20 77                  LD      (HL),A          ; Zero seed
3997   1E21 0C                  INC     C               ; Fillde about
3998   1E22 15                  DEC     D               ; with the
3999   1E23 1C                  INC     E               ; number
4000   1E24 CD 5F 18    RND2:   CALL    BNORM           ; Normalise number
4001   1E27 21 3A 82            LD      HL,LSTRND       ; Save random number
4002   1E2A C3 AC 1A            JP      FPTHL           ; Move FPREG to last and return
4003   1E2D             
4004   1E2D 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4005   1E2E 2B                  DEC     HL
4006   1E2F 77                  LD      (HL),A
4007   1E30 2B                  DEC     HL
4008   1E31 77                  LD      (HL),A
4009   1E32 C3 08 1E            JP      RND1            ; Return RND seed
4010   1E35             
4011   1E35 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4012   1E39 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4013   1E3D 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4014   1E41             
4015   1E41 21 8B 1E    COS:    LD      HL,HALFPI       ; Point to PI/2
4016   1E44 CD FF 17            CALL    ADDPHL          ; Add it to PPREG
4017   1E47 CD 85 1A    SIN:    CALL    STAKFP          ; Put angle on stack
4018   1E4A 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4019   1E4D 11 DB 0F            LD      DE,0FDBH
4020   1E50 CD 95 1A            CALL    FPBCDE          ; Move 2 PI to FPREG
4021   1E53 C1                  POP     BC              ; Restore angle
4022   1E54 D1                  POP     DE
4023   1E55 CD AA 19            CALL    DVBCDE          ; Divide angle by 2 PI
4024   1E58 CD 85 1A            CALL    STAKFP          ; Put it on stack
4025   1E5B CD 27 1B            CALL    INT             ; Get INT of result
4026   1E5E C1                  POP     BC              ; Restore number
4027   1E5F D1                  POP     DE
4028   1E60 CD 0B 18            CALL    SUBCDE          ; Make it 0 <= value < 1
4029   1E63 21 8F 1E            LD      HL,QUARTR       ; Point to 0.25
4030   1E66 CD 05 18            CALL    SUBPHL          ; Subtract value from 0.25
4031   1E69 CD 54 1A            CALL    TSTSGN          ; Test sign of value
4032   1E6C 37                  SCF                     ; Flag positive
4033   1E6D F2 77 1E            JP      P,SIN1          ; Positive - Ok
4034   1E70 CD FC 17            CALL    ROUND           ; Add 0.5 to value
4035   1E73 CD 54 1A            CALL    TSTSGN          ; Test sign of value
4036   1E76 B7                  OR      A               ; Flag negative
4037   1E77 F5          SIN1:   PUSH    AF              ; Save sign
4038   1E78 F4 7D 1A            CALL    P,INVSGN        ; Negate value if positive
4039   1E7B 21 8F 1E            LD      HL,QUARTR       ; Point to 0.25
4040   1E7E CD FF 17            CALL    ADDPHL          ; Add 0.25 to value
4041   1E81 F1                  POP     AF              ; Restore sign
4042   1E82 D4 7D 1A            CALL    NC,INVSGN       ; Negative - Make positive
4043   1E85 21 93 1E            LD      HL,SINTAB       ; Coefficient table
4044   1E88 C3 9C 1D            JP      SUMSER          ; Evaluate sum of series
4045   1E8B             
4046   1E8B DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4047   1E8F             
4048   1E8F 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4049   1E93             
4050   1E93 05          SINTAB: .BYTE   5                       ; Table used by SIN
4051   1E94 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4052   1E98 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4053   1E9C 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4054   1EA0 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4055   1EA4 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4056   1EA8             
4057   1EA8 CD 85 1A    TAN:    CALL    STAKFP          ; Put angle on stack
4058   1EAB CD 47 1E            CALL    SIN             ; Get SIN of angle
4059   1EAE C1                  POP     BC              ; Restore angle
4060   1EAF E1                  POP     HL
4061   1EB0 CD 85 1A            CALL    STAKFP          ; Save SIN of angle
4062   1EB3 EB                  EX      DE,HL           ; BCDE = Angle
4063   1EB4 CD 95 1A            CALL    FPBCDE          ; Angle to FPREG
4064   1EB7 CD 41 1E            CALL    COS             ; Get COS of angle
4065   1EBA C3 A8 19            JP      DIV             ; TAN = SIN / COS
4066   1EBD             
4067   1EBD CD 54 1A    ATN:    CALL    TSTSGN          ; Test sign of value
4068   1EC0 FC E8 1C            CALL    M,NEGAFT        ; Negate result after if -ve
4069   1EC3 FC 7D 1A            CALL    M,INVSGN        ; Negate value if -ve
4070   1EC6 3A E7 82            LD      A,(FPEXP)       ; Get exponent
4071   1EC9 FE 81               CP      81H             ; Number less than 1?
4072   1ECB DA DA 1E            JP      C,ATN1          ; Yes - Get arc tangnt
4073   1ECE 01 00 81            LD      BC,8100H        ; BCDE = 1
4074   1ED1 51                  LD      D,C
4075   1ED2 59                  LD      E,C
4076   1ED3 CD AA 19            CALL    DVBCDE          ; Get reciprocal of number
4077   1ED6 21 05 18            LD      HL,SUBPHL       ; Sub angle from PI/2
4078   1ED9 E5                  PUSH    HL              ; Save for angle > 1
4079   1EDA 21 E4 1E    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4080   1EDD CD 9C 1D            CALL    SUMSER          ; Evaluate sum of series
4081   1EE0 21 8B 1E            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4082   1EE3 C9                  RET                     ; Number > 1 - Sub from PI/2
4083   1EE4             
4084   1EE4 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4085   1EE5 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4086   1EE9 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4087   1EED FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4088   1EF1 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4089   1EF5 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4090   1EF9 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4091   1EFD E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4092   1F01 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4093   1F05 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4094   1F09             
4095   1F09             
4096   1F09 C9          ARET:   RET                     ; A RETurn instruction
4097   1F0A             
4098   1F0A D7          GETINP: RST	    10H             ;input a character
4099   1F0B C9                  RET
4100   1F0C             
4101   1F0C             CLS: 
4102   1F0C 3E 0C               LD      A,CS            ; ASCII Clear screen
4103   1F0E C3 46 20            JP      MONOUT          ; Output character
4104   1F11             
4105   1F11 CD D3 17    WIDTH:  CALL    GETINT          ; Get integer 0-255
4106   1F14 7B                  LD      A,E             ; Width to A
4107   1F15 32 42 82            LD      (LWIDTH),A      ; Set width
4108   1F18 C9                  RET
4109   1F19             
4110   1F19 CD 72 10    LINES:  CALL    GETNUM          ; Get a number
4111   1F1C CD B7 0C            CALL    DEINT           ; Get integer -32768 to 32767
4112   1F1F ED 53 46 82         LD      (LINESC),DE     ; Set lines counter
4113   1F23 ED 53 48 82         LD      (LINESN),DE     ; Set lines number
4114   1F27 C9                  RET
4115   1F28             
4116   1F28 CD B7 0C    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4117   1F2B D5                  PUSH    DE              ; Save number
4118   1F2C E1                  POP     HL              ; Number to HL
4119   1F2D 46                  LD      B,(HL)          ; Get LSB of contents
4120   1F2E 23                  INC     HL
4121   1F2F 7E                  LD      A,(HL)          ; Get MSB of contents
4122   1F30 C3 2D 14            JP      ABPASS          ; Return integer AB
4123   1F33             
4124   1F33 CD 72 10    DOKE:   CALL    GETNUM          ; Get a number
4125   1F36 CD B7 0C            CALL    DEINT           ; Get integer -32768 to 32767
4126   1F39 D5                  PUSH    DE              ; Save address
4127   1F3A CD 7B 0A            CALL    CHKSYN          ; Make sure ',' follows
4128   1F3D 2C                  .BYTE      ','
4129   1F3E CD 72 10            CALL    GETNUM          ; Get a number
4130   1F41 CD B7 0C            CALL    DEINT           ; Get integer -32768 to 32767
4131   1F44 E3                  EX      (SP),HL         ; Save value,get address
4132   1F45 73                  LD      (HL),E          ; Save LSB of value
4133   1F46 23                  INC     HL
4134   1F47 72                  LD      (HL),D          ; Save MSB of value
4135   1F48 E1                  POP     HL              ; Restore code string address
4136   1F49 C9                  RET
4137   1F4A             
4138   1F4A             
4139   1F4A             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4140   1F4A             
4141   1F4A CD 75 10    HEX: 	CALL	TSTNUM          ; Verify it's a number
4142   1F4D CD B7 0C            CALL	DEINT           ; Get integer -32768 to 32767
4143   1F50 C5                  PUSH	BC              ; Save contents of BC
4144   1F51 21 E9 82            LD	    HL,PBUFF
4145   1F54 7A                  LD	    A,D             ; Get high order into A
4146   1F55 FE 00               CP      $0
4147   1F57 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4148   1F59 CD 82 1F            CALL    BYT2ASC         ; Convert D to ASCII
4149   1F5C 78          		LD      A,B
4150   1F5D FE 30       		CP      '0'
4151   1F5F 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4152   1F61 70                  LD	    (HL),B          ; Store it to PBUFF
4153   1F62 23                  INC	    HL              ; Next location
4154   1F63 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4155   1F64 23                  INC     HL              ; Next location
4156   1F65 7B          HEX2:   LD	    A,E             ; Get lower byte
4157   1F66 CD 82 1F            CALL    BYT2ASC         ; Convert E to ASCII
4158   1F69 7A          		LD      A,D
4159   1F6A FE 00               CP      $0
4160   1F6C 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4161   1F6E 78          		LD      A,B
4162   1F6F FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4163   1F71 28 02       		JR      Z,HEX4
4164   1F73 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4165   1F74 23                  INC     HL              ; Next location
4166   1F75 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4167   1F76 23                  INC     HL              ; PBUFF+4 to zero
4168   1F77 AF                  XOR     A               ; Terminating character
4169   1F78 77                  LD      (HL),A          ; Store zero to terminate
4170   1F79 23                  INC     HL              ; Make sure PBUFF is terminated
4171   1F7A 77                  LD      (HL),A          ; Store the double zero there
4172   1F7B C1                  POP     BC              ; Get BC back
4173   1F7C 21 E9 82            LD      HL,PBUFF        ; Reset to start of PBUFF
4174   1F7F C3 DB 14            JP      STR1            ; Convert the PBUFF to a string and return it
4175   1F82             
4176   1F82 47          BYT2ASC	LD      B,A             ; Save original value
4177   1F83 E6 0F               AND     $0F             ; Strip off upper nybble
4178   1F85 FE 0A               CP      $0A             ; 0-9?
4179   1F87 38 02               JR      C,ADD30         ; If A-F, add 7 more
4180   1F89 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4181   1F8B C6 30       ADD30	ADD     A,$30           ; And make ASCII
4182   1F8D 4F                  LD      C,A             ; Save converted char to C
4183   1F8E 78                  LD      A,B             ; Retrieve original value
4184   1F8F 0F                  RRCA                    ; and Rotate it right
4185   1F90 0F                  RRCA
4186   1F91 0F                  RRCA
4187   1F92 0F                  RRCA
4188   1F93 E6 0F               AND     $0F             ; Mask off upper nybble
4189   1F95 FE 0A               CP      $0A             ; 0-9? < A hex?
4190   1F97 38 02               JR      C,ADD301        ; Skip Add 7
4191   1F99 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4192   1F9B C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4193   1F9D 47                  LD      B,A             ; Store high order byte
4194   1F9E C9                  RET	
4195   1F9F             
4196   1F9F             ; Convert "&Hnnnn" to FPREG
4197   1F9F             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4198   1F9F             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4199   1F9F EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4200   1FA0 21 00 00            LD      HL,$0000        ; Zero out the value
4201   1FA3 CD B8 1F            CALL    GETHEX          ; Check the number for valid hex
4202   1FA6 DA D8 1F            JP      C,HXERR         ; First value wasn't hex, HX error
4203   1FA9 18 05               JR      HEXLP1          ; Convert first character
4204   1FAB CD B8 1F    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4205   1FAE 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4206   1FB0 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4207   1FB1 29                  ADD     HL,HL
4208   1FB2 29                  ADD     HL,HL
4209   1FB3 29                  ADD     HL,HL
4210   1FB4 B5                  OR      L               ; Add in D0-D3 into L
4211   1FB5 6F                  LD      L,A             ; Save new value
4212   1FB6 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4213   1FB8             
4214   1FB8 13          GETHEX  INC     DE              ; Next location
4215   1FB9 1A                  LD      A,(DE)          ; Load character at pointer
4216   1FBA FE 20               CP      ' '
4217   1FBC CA B8 1F            JP      Z,GETHEX        ; Skip spaces
4218   1FBF D6 30               SUB     $30             ; Get absolute value
4219   1FC1 D8                  RET     C               ; < "0", error
4220   1FC2 FE 0A               CP      $0A
4221   1FC4 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4222   1FC6 D6 07               SUB     $07             ; Reduce to A-F
4223   1FC8 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4224   1FCA D8                  RET     C               ; CY set if was :            ; < = > ? @
4225   1FCB FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4226   1FCD 3F                  CCF
4227   1FCE C9                  RET                     ; CY set if it wasn't valid hex
4228   1FCF                 
4229   1FCF EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4230   1FD0 7A                  LD      A,D             ; Load DE into AC
4231   1FD1 4B                  LD      C,E             ; For prep to 
4232   1FD2 E5                  PUSH    HL
4233   1FD3 CD 2C 14            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4234   1FD6 E1                  POP     HL
4235   1FD7 C9                  RET
4236   1FD8             
4237   1FD8 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4238   1FDA C3 C1 07            JP      ERROR
4239   1FDD             
4240   1FDD             ; BIN$(NN) Convert integer to a 1-16 char binary string
4241   1FDD CD 75 10    BIN:    CALL    TSTNUM          ; Verify it's a number
4242   1FE0 CD B7 0C            CALL    DEINT           ; Get integer -32768 to 32767
4243   1FE3 C5          BIN2:   PUSH    BC              ; Save contents of BC
4244   1FE4 21 E9 82            LD      HL,PBUFF
4245   1FE7 06 11               LD      B,17            ; One higher than max char count
4246   1FE9             ZEROSUP:                        ; Suppress leading zeros
4247   1FE9 05                  DEC     B               ; Max 16 chars
4248   1FEA 78                  LD      A,B
4249   1FEB FE 01               CP      $01
4250   1FED 28 08               JR      Z,BITOUT        ; Always output at least one character
4251   1FEF CB 13               RL      E
4252   1FF1 CB 12               RL      D
4253   1FF3 30 F4               JR      NC,ZEROSUP
4254   1FF5 18 04               JR      BITOUT2
4255   1FF7             BITOUT:      
4256   1FF7 CB 13               RL      E
4257   1FF9 CB 12               RL      D               ; Top bit now in carry
4258   1FFB             BITOUT2:
4259   1FFB 3E 30               LD      A,'0'           ; Char for '0'
4260   1FFD CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4261   1FFF 77                  LD      (HL),A
4262   2000 23                  INC     HL
4263   2001 05                  DEC     B
4264   2002 20 F3               JR      NZ,BITOUT
4265   2004 AF                  XOR     A               ; Terminating character
4266   2005 77                  LD      (HL),A          ; Store zero to terminate
4267   2006 23                  INC     HL              ; Make sure PBUFF is terminated
4268   2007 77                  LD      (HL),A          ; Store the double zero there
4269   2008 C1                  POP     BC
4270   2009 21 E9 82            LD      HL,PBUFF
4271   200C C3 DB 14            JP      STR1
4272   200F             
4273   200F             ; Convert "&Bnnnn" to FPREG
4274   200F             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4275   200F EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4276   2010 21 00 00            LD      HL,$0000        ; Zero out the value
4277   2013 CD 2C 20            CALL    CHKBIN          ; Check the number for valid bin
4278   2016 DA 3A 20            JP      C,BINERR        ; First value wasn't bin, HX error
4279   2019 D6 30       BINIT:  SUB     '0'
4280   201B 29                  ADD     HL,HL           ; Rotate HL left
4281   201C B5                  OR      L
4282   201D 6F                  LD      L,A
4283   201E CD 2C 20            CALL    CHKBIN          ; Get second and addtional characters
4284   2021 30 F6               JR      NC,BINIT        ; Process if a bin character
4285   2023 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4286   2024 7A                  LD      A,D             ; Load DE into AC
4287   2025 4B                  LD      C,E             ; For prep to 
4288   2026 E5                  PUSH    HL
4289   2027 CD 2C 14            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4290   202A E1                  POP     HL
4291   202B C9                  RET
4292   202C             
4293   202C             ; Char is in A, NC if char is 0 or 1
4294   202C 13          CHKBIN: INC     DE
4295   202D 1A                  LD      A,(DE)
4296   202E FE 20               CP      ' '
4297   2030 CA 2C 20            JP      Z,CHKBIN        ; Skip spaces
4298   2033 FE 30               CP      '0'             ; Set C if < '0'
4299   2035 D8                  RET     C
4300   2036 FE 32               CP      '2'
4301   2038 3F                  CCF                     ; Set C if > '1'
4302   2039 C9                  RET
4303   203A             
4304   203A 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4305   203C C3 C1 07            JP      ERROR
4306   203F             
4307   203F             
4308   203F             JJUMP1: 
4309   203F DD 21 FF FF         LD      IX,-1           ; Flag cold start
4310   2043 C3 11 04            JP      CSTART          ; Go and initialise
4311   2046             
4312   2046             MONOUT: 
4313   2046 C3 08 00            JP      $0008           ; output a char
4314   2049             
4315   2049             
4316   2049             MONITR: 
4317   2049 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4318   204C             
4319   204C             
4320   204C 3E 00       INITST: LD      A,0             ; Clear break flag
4321   204E 32 4D 82            LD      (BRKFLG),A
4322   2051 C3 18 04            JP      INIT
4323   2054             
4324   2054 ED 45       ARETN:  RETN                    ; Return from NMI
4325   2056             
4326   2056             
4327   2056 F5          TSTBIT: PUSH    AF              ; Save bit mask
4328   2057 A0                  AND     B               ; Get common bits
4329   2058 C1                  POP     BC              ; Restore bit mask
4330   2059 B8                  CP      B               ; Same bit set?
4331   205A 3E 00               LD      A,0             ; Return 0 in A
4332   205C C9                  RET
4333   205D             
4334   205D CD 86 0A    OUTNCR: CALL    OUTC            ; Output character in A
4335   2060 C3 AD 0E            JP      PRNTCRLF        ; Output CRLF
4336   2063             
4337   2063             .end
4338   2063             
tasm: Number of errors = 0
