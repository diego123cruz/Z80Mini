              	; --------------------------------------
              	; zasm: assemble "bootV2.asm"
              	; date: 2023-08-30 17:27:42
              	; --------------------------------------


              	; Diego Cruz - Nov 2022
              	; 
              	; bootV2: 
              	;         - CPU Z80@4Mhz
              	;         - Lcd Grafico 128x64
              	;         - Keyboard 40 keys + Shift
              	;         - Rom 32k 0000h - 7FFFh
              	;         - Ram 32k 8000h - FFFFh
              	;         
              	;
              	;         - Ports:
              	;               - Keyboard: 40H
              	;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
              	;               - User IN/OUT: C0H
              	;               - Leds: 00H (Red B0-B3, Green B4-B7)
              	;
              	;
              	;         Compiler: https://k1.spdns.de/Develop/Projects/zasm/Distributions/
              	;         Command line: 
              	;
              	;
              	; -----------------------------------------------------------------------------
              	; PORTS
              	; -----------------------------------------------------------------------------
0070:         	LCDCTRL	    .EQU    70H
0071:         	LCDDATA     .EQU    71H
0040:         	KEY_IN      .EQU    40H
0040:         	KEY_OUT     .EQU    40H
              	
              	; -----------------------------------------------------------------------------
              	; CONTROL KEYS
              	; -----------------------------------------------------------------------------
0003:         	CTRLC       .EQU    03H             ; Control "C"
0007:         	CTRLG       .EQU    07H             ; Control "G"
0008:         	BKSP        .EQU    08H             ; Back space
000A:         	LF          .EQU    0AH             ; Line feed
000B:         	VT          .equ    0BH             ; 
000C:         	CS          .EQU    0CH             ; Clear screen
000D:         	CR          .EQU    0DH             ; Carriage return [Enter]
000F:         	CTRLO       .EQU    0FH             ; Control "O"
0011:         	CTRLQ	    .EQU    11H		    ; Control "Q"
0012:         	CTRLR       .EQU    12H             ; Control "R"
0013:         	CTRLS       .EQU    13H             ; Control "S"
0015:         	CTRLU       .EQU    15H             ; Control "U"
001B:         	ESC         .EQU    1BH             ; Escape
007F:         	DEL         .EQU    7FH             ; Delete
              	
              	; -----------------------------------------------------------------------------
              	; KEYS MAP
              	; -----------------------------------------------------------------------------
00B4:         	KLEFT       .EQU    $B4             ; Key Left
00B7:         	KRIGHT      .EQU    $B7             ; Key Right
00B5:         	KUP         .EQU    $B5             ; Key Up
00B6:         	KDOWN       .EQU    $B6             ; Key Down
0080:         	KF1         .EQU    $80             ; Key F1
0081:         	KF2         .EQU    $81             ; Key F2
0082:         	KF3         .EQU    $82             ; Key F3
0083:         	KF4         .EQU    $83             ; Key F4
0084:         	KF5         .EQU    $84             ; Key F5 (SHIFT)
0085:         	KF6         .EQU    $85             ; Key F6 (SHIFT)
0086:         	KF7         .EQU    $86             ; Key F7 (SHIFT)
0087:         	KF8         .EQU    $87             ; Key F8 (SHIFT)
              	
              	; -----------------------------------------------------------------------------
              	; H_Delay CONFIG
              	; -----------------------------------------------------------------------------
3D0900:         	kCPUClock:  .EQU 4000000       ;CPU clock speed in Hz
0024:         	kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
001A:         	kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
0FA0:         	kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
0F7C:         	kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
0098:         	kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop
              	
              	; -----------------------------------------------------------------------------
              	; MS BASIC ENTRY POINT
              	; -----------------------------------------------------------------------------
6000:         	BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
6002:         	BASIC_W     .EQU    BASIC+2
              	
              	; -----------------------------------------------------------------------------
              	; SOFTWARE SERIAL
              	; -----------------------------------------------------------------------------
              	;
              	; BAUD RATE CONSTANTS
              	;
0220:         	B300:	.EQU	0220H	;300 BAUD
0080:         	B1200:	.EQU	0080H	;1200 BAUD
003F:         	B2400:	.EQU	003FH	;2400 BAUD
001B:         	B4800:	.EQU	001BH	;4800 BAUD
000B:         	B9600:	.EQU	000BH	;9600 BAUD
              	
00C0:         	SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
00C0:         	SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
              	
              	; -----------------------------------------------------------------------------
              	; SYSTEM SETTINGS
              	; -----------------------------------------------------------------------------
FFF0:         	SYSTEM:	.EQU 	$FFF0	;INITIAL STACK POINTER
              	
              	; -----------------------------------------------------------------------------
              	; I2C SETTINGS
              	; -----------------------------------------------------------------------------
00AE:         	I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
2710:         	TIMEOUT:    .EQU 10000          ;Timeout loop counter
              	
              	; -----------------------------------------------------------------------------
              	; LCD CONSTANTS
              	; -----------------------------------------------------------------------------
              	    ; LCD TEXT MODE
0080:         	LCD_LINE1   .EQU    80H
0090:         	LCD_LINE2   .EQU    90H
0088:         	LCD_LINE3   .EQU    88H
0098:         	LCD_LINE4   .EQU    98H
              	
              	; -----------------------------------------------------------------------------
              	; MEMORY MAP
              	; -----------------------------------------------------------------------------
              	; $0000 - 7FFF ROM (Monitor)
              	; $8000 - EFFF USER RAM
              	; $F000 - FFFF SYSTEM MONITOR
              	
F000:         	DISPLAY             .EQU    $F000   ; 1024 bytes - Display buffer
F401:         	MSGBUF:             .EQU    $F401   ; 32 bytes - STRING HANDLING AREA
F420:         	DATABYTE:           .EQU    $F420   ; 1 byte - THE DATA
F421:         	I2C_RAMCPY:         .EQU    $F421   ; 1 byte - RAM copy of output port
F422:         	I2C_ADDR            .EQU    $F422   ; 1 byte - device address
F423:         	I2C_RR              .EQU    $F423   ; 1 byte - register
F424:         	I2C_DD              .EQU    $F424   ; 1 byte - data
F425:         	ADDR:               .EQU    $F425   ; 2 bytes - THE ADDRESS
F427:         	ADDR_FROM           .EQU    $F427   ; 2 bytes - THE ADDRESS FROM
F429:         	ADDR_TO             .EQU    $F429   ; 2 bytes - THE ADDRESS TO
F42B:         	ADDR_SIZE           .EQU    $F42B   ; 2 bytes - THE ADDRESS SIZE
F42D:         	PORT_SET            .EQU    $F42D   ; 1 byte - Define port (input/output) Default 0xC0(onboard)
F42E:         	PORT_OUT_VAL        .EQU    $F42E   ; 1 byte - save value out port
F42F:         	LCD_DATA            .EQU    $F42F   ; 1 byte
F430:         	BAUD:	            .EQU    $F430   ;2 bytes - BAUD RATE
F432:         	PUTCH:              .EQU    $F432   ;2 bytes - OUTPUT A CHARACTER TO SERIAL
F434:         	GETCH:              .EQU    $F434   ;2 bytes - WAIT FOR A CHARACTER FROM SERIAL
F435:         	LCD_CHAR            .EQU    $F435   ; 1 byte char ex: 'A'
F436:         	LCD_CHAR_POINT      .EQU    $F436   ; 2 bytes ponteiro para o mapa de caracteres
F438:         	LCD_TXT_X           .EQU    $F438   ; 1 byte  0-20 (21 col)
F439:         	LCD_TXT_Y           .EQU    $F439   ; 1 byte  0-7  (8 row)
F43A:         	LCD_BYTE_INDEX      .EQU    $F43A   ; 2 bytes pointer pixel(8)
F43C:         	LCD_BIT_INDEX       .EQU    $F43C   ; 1 byte pointer pixel(1)
F43D:         	LCD_TXT_X_TMP       .EQU    $F43D   ; 2 bytes = LCD_TXT_X * 6
F43F:         	LCD_TXT_Y_TMP       .EQU    $F43F   ; 2 bytes = LCD_TXT_Y * 128
F441:         	LCD_CHAR_H          .EQU    $F441   ; 1 byte altura do char
F442:         	LCD_CHAR_W          .EQU    $F442   ; 1 byte largura do char
F443:         	LCD_TMP_POINT       .EQU    $F443   ; 2 bytes ponteiro do pixel altural do print
F445:         	LCD_DELETE_CHAR     .EQU    $F445   ; 1 byte, 0 n√£o, ff delete proximo char
F446:         	LCD_AUTO_X          .EQU    $F446   ; 1 byte, 0 sim, ff nao
F447:         	LCD_TEMP            .EQU    $F447   ; 1 byte
F448:         	LCD_COOX            .EQU    $F448   ; 1 byte, local onde vai printar
F449:         	LCD_COOY            .EQU    $F449   ; 1 byte
F44A:         	LCD_PRINT_H         .EQU    $F44A   ; 1 byte, tamanho do que vai printar
F44B:         	LCD_PRINT_W         .EQU    $F44B   ; 1 byte
F44C:         	LCD_PRINT_IMAGE     .EQU    $F44C   ; 2 bytes
              	
              	
0000:         	        .ORG 0
0000: F3      	RST00	DI
0001: C3860D  	        JP  START_MONITOR
              							
0004: FFFFFFFF	        .ORG     0008H
0008: C36803  	RST08   JP  PRINTCHAR
              	
000B: FFFFFFFF	        .ORG 0010H
000F: FF      	
0010: C35A02  	RST10   JP KEYREADINIT
              	
0013: FFFFFFFF	        .ORG 0018H ; check break
0017: FF      	
0018: C34502  	RST18   JP CHKKEY
              	
001B: FFFFFFFF	RST20   .ORG 0020H
001F: FF      	
0020: C9      	        RET
              	
0021: FFFFFFFF	RST28   .ORG 0028H
0025: FFFFFF  	
0028: C9      	        RET
              	
0029: FFFFFFFF	        .ORG 0030H
002D: FFFFFF  	
0030: C34201  	RST30   JP APIHandler
              	
0033: FFFFFFFF	RST38   .ORG 0038H ; INT - MASKABLE INTERRUPT MODE-1
0037: FF      	
0038: ED4D    	        RETI
              	
003A: FFFFFFFF	RST66   .ORG 0066H ; NMI - Non¬≠maskable Interrupt 
003E: FF...   	
0066: ED45    	        RETN
              	
              	
              	; N√£o remover daqui...
0068:         	KEYMAP:
0068: 31323334	.BYTE   "12345",KF1,"67890"
006C: 35803637	
0070: 383930  	
0073: 81515745	.BYTE   KF2,"QWERT",KF3,"YUIOP"
0077: 52548259	
007B: 55494F50	
007F: 83415344	.BYTE   KF4,"ASDFG",KLEFT,"HJKL", CR
0083: 4647B448	
0087: 4A4B4C0D	
008B: B6035A58	.BYTE   KDOWN,CTRLC, "ZXCV",KRIGHT,"BNM ", DEL, KUP
008F: 4356B742	
0093: 4E4D207F	
0097: B5      	
              	
0098:         	SHIFTKEYMAP:
0098: 21402324	.BYTE   "!@#$%",KF5,"^&*()"
009C: 25845E26	
00A0: 2A2829  	
00A3: 85607E2D	.BYTE   KF6,"`~-_=",KF7,"+;:'" 
00A7: 5F3D862B	
00AB: 3B3A27  	
00AE: 22      	.BYTE   22h
00AF: 877B7D5B	.BYTE   KF8,"{}[]|",KLEFT,$5C,"<>?", CR
00B3: 5D7CB45C	
00B7: 3C3E3F0D	
00BB: B61B2F2C	.BYTE   KDOWN,ESC,"/,. ",KRIGHT,"    ", DEL, KUP
00BF: 2E20B720	
00C3: 2020207F	
00C7: B5      	
              	
              	
00C8: FFFFFFFF	API     .ORG 0100H ; API POINTER
00CC: FF...   	
              	#include "API.asm" ; manter essa ordem...
              	; **********************************************************************
              	; **  API - Public functions                                          **
              	; **********************************************************************
              	
              	; API: CALLs
              	; Copy by APITable!
0100: C38001  	    JP  SysReset           ; 0x00 = System reset
0103: C38301  	    JP  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
0106: C38601  	    JP  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
0109: C38901  	    JP  OutLcdNewLine      ; 0x03 = Output new line LCD
010C: C3EF12  	    JP  H_Delay            ; 0x04 = Delay in milliseconds (DE in millis)
010F: C38E01  	    JP  PrtSet             ; 0x05 = Set Port (Default C0)
0112: C39201  	    JP  PrtOWr             ; 0x06 = Write to output port
0115: C39E01  	    JP  PrtORd             ; 0x07 = Read from output port
0118: C3A201  	    JP  PrtIRd             ; 0x08 = Read from input port
011B: C37A03  	    JP  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
011E: C3A901  	    JP  DisplayImage128x64 ; 0x0A = Print image to buffer and LCD (Pointer in DE), 128x64, 1024 bytes
0121: C3C101  	    JP  ClearDisplayBuffer ; 0x0B = Clear display buffer (A=$00 without show LCD, A > $00 show to LCD)
0124: C3D301  	    JP  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
0127: C3E501  	    JP  LcdSetCXY          ; 0x0D = LCD Cursor X (0-20), Y (0-7) value in D(X) E(Y)
012A: C3B601  	    JP  BufferImage128x64  ; 0x0E = Print image to buffer without LCD, (Pointer in DE), 128x64, 1024 bytes
012D: C38001  	    JP  SysReset           ; 0x0F = Reserved
0130: C3D901  	    JP  I2COpen            ; 0x10 = Start i2c (Device address in A)
0133: C3DC01  	    JP  I2CClose           ; 0x11 = Close i2c 
0136: C3DF01  	    JP  I2CRead            ; 0x12 = I2C Read
0139: C3E201  	    JP  I2CWrite           ; 0x13 = I2C Write
013C: C38606  	    JP  Print8x8           ; 0x14 = Print image 8x8 bits in buffer, A = Y[7b-4b] X[3b-0b], DE = Image pointer
013F: C35C06  	    JP  Clear8x8           ; 0x15 = Print image 8x8bits with 0 in buffer, A = Y[7b-4b] X[3b-0b]
              	
              	
              	
              	
              	; API: Main entry point
              	;   On entry: C = Function number
              	;             A, DE = Parameters (as specified by function)
              	;   On exit:  AF,BC,DE,HL = Return values (as specified by function)
              	;             IX IY I AF' BC' DE' HL' preserved
              	; This handler modifies: F, B, HL but preserves A, C, DE
              	; Other registers depend on API function called
0142: 215401  	APIHandler: LD   HL,APITable    ;Start of function address table
0145: 47      	            LD   B,A            ;Preserve A
0146: 79      	            LD   A,C            ;Get function number
0147: FE16    	            CP   kAPILast+1     ;Supported function?
0149: D0      	            RET  NC             ;No, so abort
014A: 78      	            LD   A,B            ;Restore A
014B: 0600    	            LD   B,0
014D: 09      	            ADD  HL,BC          ;Calculate table pointer..
014E: 09      	            ADD  HL,BC
014F: 46      	            LD   B,(HL)         ;Read function address from table..
0150: 23      	            INC  HL
0151: 66      	            LD   H,(HL)
0152: 68      	            LD   L,B
0153: E9      	            JP   (HL)           ;Jump to function address
              	
              	
              	
              	; API: Function address table (function in C)
              	; This table contains a list of addresses, one for each API function. 
              	; Each is the address of the subroutine for the relevant function.
0154: 8001    	APITable:   .DW  SysReset           ; 0x00 = System reset
0156: 8301    	            .DW  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
0158: 8601    	            .DW  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
015A: 8901    	            .DW  OutLcdNewLine      ; 0x03 = Output new line LCD
015C: EF12    	            .DW  H_Delay            ; 0x04 = Delay in milliseconds (DE in millis)
015E: 8E01    	            .DW  PrtSet             ; 0x05 = Set Port (Default C0)
0160: 9201    	            .DW  PrtOWr             ; 0x06 = Write to output port
0162: 9E01    	            .DW  PrtORd             ; 0x07 = Read from output port
0164: A201    	            .DW  PrtIRd             ; 0x08 = Read from input port
0166: 7A03    	            .DW  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
0168: A901    	            .DW  DisplayImage128x64 ; 0x0A = Print image (Pointer in DE), 128x64, 1024 bytes
016A: C101    	            .DW  ClearDisplayBuffer ; 0x0B = Clear display buffer (A=$00 without show LCD, A > $00 show to LCD)
016C: D301    	            .DW  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
016E: E501    	            .DW  LcdSetCXY          ; 0x0D = LCD Cursor X (0-20), Y (0-7) value in D(X) E(Y)
0170: B601    	            .DW  BufferImage128x64  ; 0x0E = Print image to buffer without LCD, (Pointer in DE), 128x64, 1024 bytes
0172: 8001    	            .DW  SysReset           ; 0x0F = Reserved
0174: D901    	            .DW  I2COpen            ; 0x10 = Start i2c (Device address in A)
0176: DC01    	            .DW  I2CClose           ; 0x11 = Close i2c 
0178: DF01    	            .DW  I2CRead            ; 0x12 = I2C Read
017A: E201    	            .DW  I2CWrite           ; 0x13 = I2C Write
017C: 8606    	            .DW  Print8x8           ; 0x14 = Print image 8x8 bits in buffer, A = Y[7b-4b] X[3b-0b], DE = Image pointer
017E: 5C06    	            .DW  Clear8x8           ; 0x15 = Print image 8x8bits with 0 in buffer, A = Y[7b-4b] X[3b-0b]
0015:         	kAPILast:   .EQU $15                ;Last API function number
              	
              	
              	
              	
              	
              	
0180:         	SysReset:
0180: C3AE0D  	    JP RESET_WARM
              	
0183:         	InputCharKey:
0183: C35A02  	    JP KEYREADINIT
              	
0186:         	OutLcdChar:
0186: C36803  	    JP PRINTCHAR
              	
0189:         	OutLcdNewLine:
0189: 3E0D    	    LD A, CR
018B: C36803  	    JP PRINTCHAR
              	
018E:         	PrtSet:
018E: 322DF4  	    LD (PORT_SET), A ; define a porta padr√£o de entrada e saida
0191: C9      	    RET
              	
0192:         	PrtOWr:
0192: 47      	    LD B, A
0193: 3A2DF4  	    LD A, (PORT_SET)
0196: 4F      	    LD C, A
0197: 78      	    LD A, B
0198: 322EF4  	    LD (PORT_OUT_VAL), A
019B: ED79    	    out (C), A
019D: C9      	    RET
              	
019E:         	PrtORd: ; Return value from output port
019E: 3A2EF4  	    LD A, (PORT_OUT_VAL)
01A1: C9      	    RET
              	
01A2:         	PrtIRd: ; Return value from input
01A2: 3A2DF4  	    LD A, (PORT_SET)
01A5: 4F      	    LD C, A
01A6: ED78    	    in A, (C)
01A8: C9      	    RET
              	
01A9:         	DisplayImage128x64:
              	    ; copy to buffer
01A9: 62      	    LD H, D   ; FROM
01AA: 6B      	    LD L, E
01AB: 1100F0  	    LD DE, DISPLAY  ; TO
01AE: 010004  	    LD BC, $0400    ; 1024 bytes to copy
01B1: EDB0    	    LDIR            ; Start copy
01B3: C3D301  	    JP ShowBufferDisplay
              	
01B6:         	BufferImage128x64:
              	    ; copy (DE) to buffer
01B6: 62      	    LD H, D   ; FROM
01B7: 6B      	    LD L, E
01B8: 1100F0  	    LD DE, DISPLAY  ; TO
01BB: 010004  	    LD BC, $0400    ; 1024 bytes to copy
01BE: EDB0    	    LDIR            ; Start copy
01C0: C9      	    RET
              	
01C1:         	ClearDisplayBuffer:
01C1: F5      	    PUSH AF
01C2: CD4E05  	    CALL lcd_clear
01C5: F1      	    POP AF
01C6: B7      	    OR A
01C7: FE00    	    CP $00
01C9: CAD201  	    JP Z, ClearDisplayBufferEnd
01CC: 2100F0  	    LD HL, DISPLAY
01CF: C37905  	    JP print_image
01D2:         	ClearDisplayBufferEnd:
01D2: C9      	    RET
              	
01D3:         	ShowBufferDisplay:
01D3: 2100F0  	    LD HL, DISPLAY
01D6: C37905  	    JP print_image
              	
01D9:         	I2COpen:
01D9: C3660B  	    JP I2C_Open
              	
01DC:         	I2CClose:
01DC: C36D0B  	    JP I2C_Close
              	
01DF:         	I2CRead:
01DF: C3AD0B  	    JP I2C_Read
              	
01E2:         	I2CWrite:
01E2: C3700B  	    JP I2C_Write
              	
01E5:         	LcdSetCXY:
01E5: F5      	    PUSH AF
01E6: 7A      	    LD A, D
01E7: 3238F4  	    LD (LCD_TXT_X), A
              	
01EA: 7B      	    LD A, E
01EB: 3239F4  	    LD (LCD_TXT_Y), A
01EE: F1      	    POP AF
01EF: C9      	    RET
              	#include "Keyboard.asm"
              	
              	
              	
              	;-----------------------------
              	; GET A BYTE FROM KEYBOARD
              	;-----------------------------
01F0: CD5A02  	GETCHR_KEYBOARD: CALL KEYREADINIT ; read key
01F3: FE1B    	       CP    ESC
01F5: 2831    	       JR    Z,GETOUT
01F7: FE03    	       CP    CTRLC  ; key BK (reset)
01F9: CAAE0D  	       JP    Z, RESET_WARM
01FC: 47      	       LD    B,A                ;SAVE TO ECHO      
01FD: CD2A02  	       CALL  ASC2HEX
0200: 30EE    	       JR    NC,GETCHR_KEYBOARD          ;REJECT NON HEX CHARS    
0202: 2120F4  	       LD    HL, DATABYTE
0205: 77      	       LD    (HL), A 
0206: 78      	       LD    A,B         
0207: CD6803  	       CALL  PRINTCHAR             ;ECHO VALID HEX
              	       
020A: CD5A02  	GETNYB: CALL  KEYREADINIT
020D: FE1B    	       CP    ESC
020F: 2817    	       JR    Z,GETOUT
0211: FE03    	       CP    CTRLC  ; key BK (reset)
0213: CAAE0D  	       JP    Z, RESET_WARM
0216: 47      	       LD    B,A               ;SAVE TO ECHO
0217: CD2A02  	       CALL  ASC2HEX
021A: 30EE    	       JR    NC,GETNYB         ;REJECT NON HEX CHARS
021C: ED6F    	       RLD
021E: 78      	       LD    A,B
021F: CD6803  	       CALL  PRINTCHAR             ;ECHO VALID HEX
0222: 7E      	       LD    A,(HL)
0223: CD2802  	       CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
0226: 3F      	       CCF                    ;AND THEN COMPLEMENTING IT
0227: C9      	       RET   
0228: 37      	GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
0229: C9      	       RET
              	    
              	
              	;----------------------------------------
              	; CONVERT ASCII CHARACTER INTO HEX NYBBLE
              	;----------------------------------------
              	; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
              	; ENTRY OTHER THAN HEXADECIMAL KEYS
              	;
              	;CONVERTS ASCII 0-9,A-F INTO HEX LSN
              	;ENTRY : A= ASCII 0-9,A-F
              	;EXIT  : CARRY =  1
              	;          A= HEX 0-F IN LSN    
              	;      : CARRY = 0
              	;          A= OUT OF RANGE CHARACTER & 7FH
              	; A AND F REGISTERS MODIFIED
              	;
022A: E67F    	ASC2HEX: AND   7FH        ;STRIP OUT PARITY
022C: FE30    	       CP    30H
022E: 3812    	       JR    C,AC2HEX3    ;LESS THAN 0
0230: FE3A    	       CP    3AH
0232: 3002    	       JR    NC,AC2HEX2   ;MORE THAN 9
0234: 37      	AC2HEX1: SCF               ;SET THE CARRY - IS HEX
0235: C9      	       RET
              	;     
0236: FE41    	AC2HEX2: CP    41H
0238: 3808    	       JR    C,AC2HEX3    ;LESS THAN A
023A: FE47    	       CP    47H
023C: 3004    	       JR    NC,AC2HEX3   ;MORE THAN F
023E: D607    	       SUB   07H        ;CONVERT TO NYBBLE
0240: 18F2    	       JR    AC2HEX1  
0242: E6FF    	AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
0244: C9      	       RET
              	
              	
              	; -----------------------------------------------------------------------------
              	;   Check break key (Basic)
              	; -----------------------------------------------------------------------------
0245: 3E40    	CHKKEY: LD  A, $40
0247: D340    		OUT (KEY_OUT), A ; line 4
0249: DB40    		IN  A, (KEY_IN)
024B: FE01    		CP  1
024D: C25502  		JP  NZ, GRET
0250: 3E03    		LD  A, CTRLC
0252: FE00    		CP	0
0254: C9      		RET
0255:         	GRET:
0255: 3E00    		LD  A, 0
0257: FE00    		CP 0
0259: C9      		RET
              	
              	
              	
              	; -----------------------------------------------------------------------------
              	;   KEYREAD - KEY In A
              	; -----------------------------------------------------------------------------
025A:         	KEYREADINIT:
025A: C5      	    PUSH    BC
025B: D5      		PUSH	DE
025C: E5      		PUSH    HL
025D: 1E00    		LD      E, 0                    ; E will be the last pressed key
025F:         	READKEY:        
025F: 2601    	    LD      H, 1                    ; H is the line register, start with second
0261: 0600    		LD      B, 0                    ; Count lines for later multiplication	
0263: 1600    		LD      D, 0                    ; DE will be the adress for mask
              							
0265:         	NEXTKEY:        
0265: 7C      	    LD      A, H						
0266: FE00    	    CP      0                       ; All lines tried? 
0268: CAA302  	    JP      Z, KEYOUT               ; Then check if there was a key pressed
026B: D340    		OUT     (KEY_OUT), A		    ; Put current line to register
026D: DB40    		IN      A, (KEY_IN)		        ; Input Keys
026F: E63F    		AND     $3F                     ; only 6 bits
0271: CB24    		SLA     H                       ; Next line
0273: 04      	    INC     B
0274: FE00    	    CP      0                       ; Was key zero?
0276: CA6502  	    JP      Z, NEXTKEY              ; Then try again with next lines
0279: 1600    	    LD      D, 0                    ; In D will be the number of the key
027B:         	LOGARITHM:      
027B: 14      	    INC     D	                    ; Add one per shift
027C: CB3F    	    SRL     A                       ; Shift key right
027E: C27B02  	    JP      NZ, LOGARITHM		    ; If not zero shift again
0281: 15      	    DEC     D                       ; Was too much
0282: DB40    		IN      A, (KEY_IN)
0284: E680    	    AND     $80                     ; Check if first bit set (shift key pressed)
0286: C28F02  	    JP      NZ, LOADSHIFT		    ; Then jump to read with shift
0289: 7A      	    LD      A, D                    ; Put read key into accu
028A: C668    	    ADD     A, KEYMAP               ; Add base of key map array
028C: C39202  	    JP      ADDOFFSET               ; Jump to load key
028F:         	LOADSHIFT:
028F: 7A      	    LD      A, D
0290: C698    	    ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
0292:         	ADDOFFSET:
0292: C606    	    ADD     A, 6                    ; Add 6 for every line
0294: 10FC    	    DJNZ    ADDOFFSET               ; Jump back (do while loop)
0296: D606    		SUB     6                       ; Since do while is one too much
0298:         	TRANSKEY:
0298: A8      	    XOR     B                       ; Empty B
0299: 4F      		LD      C, A                    ; A will be address in BC
029A: 0A      		LD      A, (BC)	                ; Load key
029B: BB      		CP      E                       ; Same key?
029C: CA5F02  		JP      Z, READKEY              ; Then from beginning
029F: 5F      		LD      E, A                    ; Otherwise save new key
02A0: C35F02  		JP      READKEY	                ; And restart
02A3:         	KEYOUT:
02A3: 7B      	    LD      A, E
02A4: 1E00    	    LD      E, 0                    ; empty it
02A6: B7      	    OR      A	                    ; Was a key read?
02A7: CA5F02  	    JP      Z, READKEY              ; If not restart
02AA: E1      	    POP     HL
02AB: D1      	    POP     DE
02AC: C1      	    POP     BC
02AD: C9      	    RET
              	#include "LCDGraphic.asm"
              	; -----------------------------------------------------------------------------
              	;   LCD DRIVER
              	; -----------------------------------------------------------------------------
              	; INIT_LCD - Inicia o lcd em mode texto
              	; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
              	; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
              	; lcd_clear - Limpa buffer do lcd
              	; enable_grafic - Coloca o LCD em modo grafico
              	; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
              	; cls_TXT - Limpa LCD mode text
              	; cls_GRAPHIC - Limpa LCD modo grafico
              	
02AE:         	INIT_LCD:
              	    ;Initialisation
02AE: 3E30    		ld a, 30H
02B0: CDE305  		call lcd_send_command
              	
02B3: 3E20    		ld a, 0b00100000
02B5: CDE305  		call lcd_send_command
              	
02B8: 3E30    		ld a, 30H
02BA: CDE305  		call lcd_send_command
              	
02BD: 3E0C    		ld a, 0CH
02BF: CDE305  		call lcd_send_command
              	
02C2: 3E01    		ld a, 01H
02C4: CDED05  		call lcd_send_command_clear ;; clear
              	
02C7: 3E02    		ld a, 02H
02C9: CDE305  		call lcd_send_command
02CC: C9      	    RET
              	
              	
              	
02CD:         	INIT_TXT_LCD:
02CD: 3E00    	    ld a, 0
02CF: 3238F4  	    ld (LCD_TXT_X), a
02D2: 3239F4  	    ld (LCD_TXT_Y), a
02D5: 3245F4  	    ld (LCD_DELETE_CHAR), a
02D8: 3246F4  	    ld (LCD_AUTO_X), a
02DB: 210000  	    ld hl, 0
02DE: 223DF4  	    ld (LCD_TXT_X_TMP), hl
02E1: 23      	    inc hl
02E2: 223FF4  	    ld (LCD_TXT_Y_TMP), hl
02E5: C9      	    RET
              	
              	
02E6:         	DISPLAY_SCROLL_UP:
              	    ; cada linha tem 128 bytes
              	    ; temos 8 linhas
              	    ; total 1024 bytes
              	
              	    ; display lines 0 to 7
              	    ; move line 1 to 0
02E6: 2180F0  	    ld hl, DISPLAY+128
02E9: 1100F0  	    ld de, DISPLAY
02EC: 017F00  	    ld bc, 127
02EF: EDB0    	    ldir
              	
              	    ; move line 2 to 1
02F1: 2100F1  	    ld hl, DISPLAY+256
02F4: 1180F0  	    ld de, DISPLAY+128
02F7: 017F00  	    ld bc, 127
02FA: EDB0    	    ldir
              	
              	    ; move line 3 to 2
02FC: 2180F1  	    ld hl, DISPLAY+384
02FF: 1100F1  	    ld de, DISPLAY+256
0302: 017F00  	    ld bc, 127
0305: EDB0    	    ldir
              	
              	    ; move line 4 to 3
0307: 2100F2  	    ld hl, DISPLAY+512
030A: 1180F1  	    ld de, DISPLAY+384
030D: 017F00  	    ld bc, 127
0310: EDB0    	    ldir
              	
              	    ; move line 5 to 4
0312: 2180F2  	    ld hl, DISPLAY+640
0315: 1100F2  	    ld de, DISPLAY+512
0318: 017F00  	    ld bc, 127
031B: EDB0    	    ldir
              	
              	    ; move line 6 to 5
031D: 2100F3  	    ld hl, DISPLAY+768
0320: 1180F2  	    ld de, DISPLAY+640
0323: 017F00  	    ld bc, 127
0326: EDB0    	    ldir
              	
              	    ; move line 7 to 6
0328: 2180F3  	    ld hl, DISPLAY+896
032B: 1100F3  	    ld de, DISPLAY+768
032E: 017F00  	    ld bc, 127
0331: EDB0    	    ldir
              	
              	    ; clear line 7
              	    ; 896 to 1024
0333: 2180F3  	    ld hl, DISPLAY+896
0336: 5D      	    ld e,l
0337: 54      	    ld d,h
0338: 13      	    inc de
0339: 3600    	    ld (hl), 0
033B: 017F00  	    ld bc, 127
033E: EDB0    	    ldir
0340: C9      	    RET
              	
              	;---------------
              	; OUTPUT A SPACE
              	;---------------
0341: 3E20    	OUTSP:  LD    A, ' '
0343: CD6803  	       CALL  PRINTCHAR
0346: C9      	       RET
              	
              	;-------------      
              	; OUTPUT CRLF (NEW LINE)
              	;------------
0347: 3E0D    	TXCRLF: LD   A,CR
0349: CD6803  	       CALL PRINTCHAR   
034C: C9      	       RET
              	       
              	
034D:         	DELETE_CHAR:
034D: E1      	    POP HL ; retorno do call
034E: 3E00    	    LD A, 0
0350: 3245F4  	    LD (LCD_DELETE_CHAR), A
0353: 3A38F4  	    LD A, (LCD_TXT_X)
0356: 3D      	    DEC A
0357: 3238F4  	    LD (LCD_TXT_X), A
              	
035A: 3EFF    	    LD A, $FF
035C: 3246F4  	    LD (LCD_AUTO_X), A
              	
035F: F1      	    POP AF
0360: 3E20    	    LD A, ' '
0362: 3235F4  	    LD (LCD_CHAR), A
0365: F5      	    PUSH AF
0366: E5      	    PUSH HL ; call
0367: C9      	    RET
              	
              	
              	; Print char in buffer and show to lcd
              	; char in A
0368:         	PRINTCHAR:
0368: F5      	    PUSH AF
0369: C5      	    PUSH BC
036A: D5      	    PUSH DE
036B: E5      	    PUSH HL
036C: CD7A03  	    CALL PrintBufferChar
036F: 2100F0  	    LD HL, DISPLAY
0372: CD7905  	    CALL print_image
0375: E1      	    POP HL
0376: D1      	    POP DE
0377: C1      	    POP BC
0378: F1      	    POP AF
0379: C9      	    RET
              	
              	
              	; Print char in buffer lcd (without show to lcd)
              	; char in A
037A:         	PrintBufferChar:
037A: 3235F4  	    LD (LCD_CHAR), A ; save char to print
              	
037D: F5      	    PUSH AF
037E: C5      	    PUSH BC
037F: D5      	    PUSH DE
0380: E5      	    PUSH HL
              	
0381: F5      	    PUSH AF
0382: 3E00    	    LD A, $0
0384: 3246F4  	    LD (LCD_AUTO_X), A
0387: F1      	    POP AF
              	
              	
0388:         	ver_delete:
0388: F5      	    PUSH AF
0389: 3A45F4  	    LD A, (LCD_DELETE_CHAR)
038C: B7      	    or a
038D: FEFF    	    CP $FF
038F: CC4D03  	    call z, DELETE_CHAR
0392: F1      	    POP AF
0393: B7      	    or a
0394: FE00    	    CP $0
0396: 2008    	    jr nz, ver_enter
0398: 3EFF    	    LD A, $FF ; delete proximo char
039A: 3245F4  	    LD (LCD_DELETE_CHAR), A
039D: C3C504  	    jp print_char_fim
              	
              	    ; Verificar Enter, clear, etc... SEM PERDER O reg. A
03A0:         	ver_enter:       
              	
              	                ; trata dados para o lcd
03A0: FE0D    	                CP      CR                     ; compara com ENTER
03A2: 201A    	                jr      nz, ver_limpa
              	
03A4: 3E00    	                LD A,0
03A6: 3238F4  	                LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
              	
03A9: 3A39F4  	                LD A, (LCD_TXT_Y)
03AC: 3C      	                inc a
03AD: FE08    	                cp 8
03AF: C2B803  	                jp nz, ver_enter_incYOK
              	                
03B2: CDE602  	                CALL DISPLAY_SCROLL_UP
              	                ;ld hl, DISPLAY
              	                ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
              	                
03B5: C3C504  	                jp print_char_fim
              	
03B8:         	ver_enter_incYOK:
03B8: 3239F4  	                ld (LCD_TXT_Y), a
03BB: C3C504  	                jp print_char_fim
              	
              	
03BE:         	ver_limpa:
03BE: FE0C    	                CP      $0C                     ; compara com limpar tela
03C0: 200E    	                jr      NZ, ver_line
              	                
              	                ;call    clear_lcd_screen
              	                ;call    show_lcd_screen
03C2: CD4E05  	                call lcd_clear
              	                ;ld hl, DISPLAY
              	                ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
03C5: 3E00    	                LD A, 0
03C7: 3238F4  	                LD (LCD_TXT_X), A
03CA: 3239F4  	                LD (LCD_TXT_Y), A
              	
03CD: C3C504  	                JP print_char_fim
              	
03D0:         	ver_line:
03D0: FE0A    	                CP      LF                     ; retorna come√ßo da linha
03D2: 2003    	                jr      NZ, print_lcd      
              	
              	                    ;----- verificar se precisa add algo aqui
              	                ;call    shift_lcd_up
              	                ;call    show_lcd_screen
03D4: C3C504  	                JP print_char_fim
              	
03D7:         	print_lcd:
              	    ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
03D7: 2600    	    ld H, 0
03D9: 6F      	    ld L, A
03DA: 29      	    ADD HL, HL ; hl x 8
03DB: 29      	    ADD HL, HL
03DC: 29      	    ADD HL, HL
              	
03DD: 54      	    LD D, H
03DE: 5D      	    LD E, L
03DF: 21B306  	    ld hl, TABLE
03E2: 19      	    add hl, de
03E3: 2236F4  	    ld (LCD_CHAR_POINT), HL ; table
              	
              	
              	    ; ajusta X
03E6: 0606    	    ld b, 6
03E8: 3A38F4  	    ld a, (LCD_TXT_X)
03EB: B7      	    or A
03EC: CAF603  	    jp z, ajustX
03EF: 4F      	    ld c, a
03F0: CD0413  	    call multiplication
03F3: C3F903  	    jp ajustXOK
              	    
03F6:         	ajustX:
03F6: 210000  	    ld hl, 0
03F9:         	ajustXOK:
03F9: 223DF4  	    ld (LCD_TXT_X_TMP), HL 
              	
              	
              	
              	    ; ajuste Y
03FC: 1604    	    ld d, 4
03FE: 1E00    	    ld e, 0 ; = 128x8 proxima linha
0400: 2A3FF4  	    ld hl, (LCD_TXT_Y_TMP)
0403: 3A39F4  	    ld a, (LCD_TXT_Y)
0406: B7      	    or a
0407: CA1704  	    JP Z, multYfim
040A: 210000  	    ld hl, 0
040D: 47      	    ld b, a
040E:         	multY:
040E: 19      	    add hl, de
040F: 10FD    	    DJNZ multY
              	
0411: 223FF4  	    ld (LCD_TXT_Y_TMP), HL
0414: C31D04  	    jp multYfimok
              	
0417:         	multYfim:
0417: 210000  	    ld hl, 0
041A: 223FF4  	    ld (LCD_TXT_Y_TMP), HL
              	
041D:         	multYfimok:
              	
041D: 2A3FF4  	    ld hl, (LCD_TXT_Y_TMP)
0420: ED5B3DF4	    ld de, (LCD_TXT_X_TMP)
              	
0424: 19      	    add hl, de  ; hl tem pos do pix 0-8191
              	
0425: 2243F4  	    ld (LCD_TMP_POINT), hl
              	
              	
0428: 3E08    	    ld a, 8 ; altura do caracter
042A: 3241F4  	    ld (LCD_CHAR_H), a
042D:         	printchar_loopH:
042D: 2A36F4  	    ld hl, (LCD_CHAR_POINT)
0430: 7E      	    ld a, (HL)
0431: 3247F4  	    ld (LCD_TEMP), a
              	
0434: 3E06    	    ld a, 6 ; largura do caracter
0436: 3242F4  	    ld (LCD_CHAR_W), a
0439:         	printchar_loopW:
0439: 3A47F4  	    ld a, (LCD_TEMP)
043C: E680    	    and 128
043E: FE00    	    cp 0
0440: CA4C04  	    jp z, printchar_loopWC
0443: 2A43F4  	    ld hl, (LCD_TMP_POINT)
0446: CDD904  	    call lcd_setPixel
0449: C35204  	    JP printchar_loopWE
              	
044C:         	printchar_loopWC:
044C: 2A43F4  	    ld hl, (LCD_TMP_POINT)
044F: CD1205  	    call lcd_clearPixel
              	
0452:         	printchar_loopWE:
0452: 3A47F4  	    ld a, (LCD_TEMP)
0455: CB27    	    sla a
0457: 3247F4  	    ld (LCD_TEMP), a
              	    
045A: 2A43F4  	    ld hl, (LCD_TMP_POINT)
045D: 23      	    inc hl
045E: 2243F4  	    ld (LCD_TMP_POINT), hl
              	
0461: 3A42F4  	    ld a, (LCD_CHAR_W)
0464: 3D      	    dec A
0465: 3242F4  	    ld (LCD_CHAR_W), a
0468: FE00    	    cp 0
046A: C23904  	    JP NZ, printchar_loopW
              	
              	
046D: 2A43F4  	    ld hl, (LCD_TMP_POINT)
0470: 2B      	    dec hl
0471: 2B      	    dec hl
0472: 2B      	    dec hl
0473: 2B      	    dec hl
0474: 2B      	    dec hl
0475: 2B      	    dec hl
              	
0476: 1600    	    ld d, 0
0478: 1E80    	    ld e, 128
047A: 19      	    add hl, de
047B: 2243F4  	    ld (LCD_TMP_POINT), HL
              	
047E: 2A36F4  	    ld hl, (LCD_CHAR_POINT)
0481: 23      	    inc hl
0482: 2236F4  	    ld (LCD_CHAR_POINT), hl
              	
              	
0485: 3A41F4  	    ld a, (LCD_CHAR_H)
0488: 3D      	    dec A
0489: 3241F4  	    ld (LCD_CHAR_H), a
048C: FE00    	    cp 0
048E: C22D04  	    jp NZ, printchar_loopH
              	
              	    ;ld hl, DISPLAY
              	    ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
              	
              	
              	    ; check auto x
0491: 3A46F4  	    LD A, (LCD_AUTO_X)
0494: B7      	    OR A
0495: FEFF    	    CP $FF
0497: CAC504  	    JP Z, print_char_fim
              	
              	    ; increment X, Y
049A: 3A38F4  	    ld a, (LCD_TXT_X)
049D: 3C      	    inc a
049E: FE15    	    cp 21
04A0: C2C204  	    jp nz, incXOK
04A3: 3E00    	    ld a, 0
04A5: 3238F4  	    ld (LCD_TXT_X), a
04A8: 3A39F4  	    ld a, (LCD_TXT_Y)
04AB: 3C      	    inc a
04AC: FE08    	    cp 8
04AE: C2BC04  	    jp nz, incYOK
04B1: CDE602  	    CALL DISPLAY_SCROLL_UP
              	    ;ld hl, DISPLAY
              	    ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
04B4: 3E00    	    ld a, 0
04B6: 3238F4  	    ld (LCD_TXT_X), a
04B9: C3C504  	    jp print_char_fim
              	
04BC:         	incYOK:
04BC: 3239F4  	    ld (LCD_TXT_Y), a
04BF: C3C504  	    jp print_char_fim
              	
04C2:         	incXOK:
04C2: 3238F4  	    ld (LCD_TXT_X), a
              	
04C5:         	print_char_fim:
              	    ;ld hl, DISPLAY
              	    ;CALL print_image
04C5: E1      	    POP HL
04C6: D1      	    POP DE
04C7: C1      	    POP BC
04C8: F1      	    POP AF
04C9: C9      	    RET
              	;-------- FIM PRINTCHAR ------------------
              	
              	
              	
              	
              	; =========================================================
              	; Delay
              	; =========================================================
04CA:         	delay:
04CA: C5      		push bc                       ; 2.75 us
04CB: 0601    	    ld b, 1                     ; 1.75 us
04CD:         	delay_loop_b:
04CD: 0EFF    		ld c, 255                     ; 1.75 us
04CF:         	delay_loop:
04CF: 0D      		dec c                         ; 1 us
04D0: C2CF04  	    jp nz, delay_loop             ; true = 3 us, false 1.75 us
04D3: 05      	    dec b                         ; 1 us
04D4: C2CD04  	    jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
04D7: C1      	    pop bc                        ; 2.50 us
04D8: C9      	    ret   
              	
              	
              	
              	
              	; pixel index in HL
04D9:         	lcd_setPixel:
04D9: E5      	    push hl
04DA: C5      	    push bc
04DB: D5      	    push de
04DC: F5      	    push af
04DD: AF      	    xor A
04DE: 323CF4  	    ld (LCD_BIT_INDEX), A
04E1: 323AF4  	    ld (LCD_BYTE_INDEX), A
              	
04E4: 1608    	    ld d, 8
04E6: CD1113  	    call Div_HL_D
04E9: 323CF4  	    ld (LCD_BIT_INDEX), A
04EC: 223AF4  	    ld (LCD_BYTE_INDEX), HL
04EF: ED4B3AF4	    ld BC, (LCD_BYTE_INDEX)
04F3: 2100F0  	    ld hl, DISPLAY
04F6: 09      	    add hl, bc
              	    
04F7: 0680    	    ld b, 128 ; 1000 0000
04F9: 3A3CF4  	    ld a, (LCD_BIT_INDEX) ;
04FC: FE00    	    cp 0
04FE: CA0A05  	    jp z, lcd_setPixel_fim
0501:         	lcd_setPixel_bit:
0501: CB38    	    srl B
0503: 3D      	    dec A
0504: CA0A05  	    jp z, lcd_setPixel_fim
              	    
0507: C30105  	    jp lcd_setPixel_bit
050A:         	lcd_setPixel_fim
050A: 7E      	    ld a, (hl)
050B: B0      	    or b
050C: 77      	    ld (hl), a
              	
050D: F1      	    pop af
050E: C1      	    pop bc
050F: D1      	    pop de
0510: E1      	    pop hl
0511: C9      	    ret
              	
              	;===============================
              	; pixel index in HL
0512:         	lcd_clearPixel:
0512: E5      	    push hl
0513: C5      	    push bc
0514: D5      	    push de
0515: F5      	    push af
0516: AF      	    xor A
0517: 323CF4  	    ld (LCD_BIT_INDEX), A
051A: 323AF4  	    ld (LCD_BYTE_INDEX), A
051D: 1608    	    ld d, 8
051F: CD1113  	    call Div_HL_D
0522: 323CF4  	    ld (LCD_BIT_INDEX), A
0525: 223AF4  	    ld (LCD_BYTE_INDEX), HL
0528: ED4B3AF4	    ld BC, (LCD_BYTE_INDEX)
052C: 2100F0  	    ld hl, DISPLAY
052F: 09      	    add hl, bc
              	    
0530: 0680    	    ld b, 128 ; 1000 0000
0532: 3A3CF4  	    ld a, (LCD_BIT_INDEX) ;
0535: FE00    	    cp 0
0537: CA4305  	    jp z, lcd_clearPixel_fim
053A:         	lcd_clearPixel_bit:
053A: CB38    	    srl B
053C: 3D      	    dec A
053D: CA4305  	    jp z, lcd_clearPixel_fim
              	    
0540: C33A05  	    jp lcd_clearPixel_bit
0543:         	lcd_clearPixel_fim
0543: 78      	    ld a, b
0544: 2F      	    cpl     ; NOT B
0545: 47      	    ld b, a
              	
0546: 7E      	    ld a, (hl)
0547: A0      	    and b
0548: 77      	    ld (hl), a
              	
0549: F1      	    pop af
054A: C1      	    pop bc
054B: D1      	    pop de
054C: E1      	    pop hl
054D: C9      	    ret
              	
              	
              	;;--------------------------------------------------
054E:         	lcd_clear:
054E: E5      	    PUSH HL
054F: D5      	    PUSH DE
              	    ;; HL = start address of block
0550: 2100F0  	    ld hl, DISPLAY
              	
              	    ;; DE = HL + 1
0553: 5D      	    ld e,l
0554: 54      	    ld d,h
0555: 13      	    inc de
              	
              	    ;; initialise first byte of block
              	    ;; with data byte (&00)
0556: 3600    	    ld (hl), 0
              	        
              	    ;; BC = length of block in bytes
              	    ;; HL+BC-1 = end address of block
              	
0558: 010004  	    ld bc, 1024
              	
              	    ;; fill memory
055B: EDB0    	    ldir
055D: D1      	    POP DE
055E: E1      	    POP HL
055F: C9      	    ret
              	
              	
              	;===================
              	
              	; grafic mode - enable
0560:         	enable_grafic:
0560: 3E30    		ld a, 30H
0562: CDE305  		call lcd_send_command
0565: CD1606  		call delayLCD
              		
0568: 3E34    		ld a, 34H
056A: CDE305  		call lcd_send_command
056D: CD1606  		call delayLCD
              		
0570: 3E36    		ld a, 36H
0572: CDE305  		call lcd_send_command
0575: CD1606  		call delayLCD
0578: C9      	    ret
              	
              	
              	;==========================
0579:         	print_image:
0579: F5      	        PUSH AF
057A: C5      	        PUSH BC
057B: D5      	        PUSH DE
057C: E5      	        PUSH HL
057D:         	PLOT_TO_LCD:	
              	        ;LD HL, DISPLAY
057D: 0E80    	        LD C, 80H
057F:         	PLOT_ROW:	
057F: 79      	        LD A, C
0580: E69F    	        AND 9FH
0582: D370    	        OUT (LCDCTRL), A ;Vertical
0584: CDA905  	        CALL DELAY_US
0587: 3E80    	        LD A, 80H
0589: CB69    	        BIT 5, C
058B: 2802    	        JR Z, $ + 4
058D: F608    	        OR 08H
058F: D370    	        OUT (LCDCTRL), A ;Horizontal
0591: CDA905  	        CALL DELAY_US
              	        
0594: 0610    	        LD B, 10H 		;send eight double bytes (16 bytes)
0596:         	PLOT_COLUMN:	
0596: 7E      	        LD A, (HL)
0597: D371    	        OUT (LCDDATA), A ;Byte 1
0599: CDA905  	        CALL DELAY_US
059C: 23      	        INC HL
059D: 10F7    	        DJNZ PLOT_COLUMN
059F: 0C      	        INC C
05A0: CB71    	        BIT 6, C 		;Is Row = 64?
05A2: 28DB    	        JR Z, PLOT_ROW
              	
05A4: E1      	        POP HL
05A5: D1      	        POP DE
05A6: C1      	        POP BC
05A7: F1      	        POP AF
05A8: C9      	        RET
              	        
              	
              	; Delay for LCD write
05A9:         	DELAY_US:	
05A9: 110400  	        LD DE, $0004 ;DELAY BETWEEN, was 0010H
05AC:         	DELAY_MS:	
05AC: 1B      	        DEC DE 			;EACH BYTE
05AD: 7A      	        LD A, D 		;AS PER
05AE: B3      	        OR E 			;LCD MANUFACTER'S
05AF: 20FB    	        JR NZ, DELAY_MS ;INSTRUCTIONS
05B1: C9      	        RET
              	
              	
              	; ======================
05B2:         	cls_TXT:
              		; # CLEAR DISPLAY IN TEXT MODE # 
05B2: 3E01    		ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
05B4: CDED05  		call lcd_send_command_clear		; CLEAR DISPLAY	
              	
              	    ; # CLEAR DISPLAY IN TEXT MODE # 
05B7: 3E01    		ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
05B9: CDED05  		call lcd_send_command_clear		; CLEAR DISPLAY	
05BC: C9      	    ret
              	
              	; ========================
              	
05BD:         	cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
              						;	Graphic RAM (GDRAM) use :
              						;	1. Set vertical address (Y) for GDRAM
              						;	2. Set horizontal address (X) for GDRAM
              						;	3. Write D15~D8 to GDRAM (first byte)
              						;	4. Write D7~D0 to GDRAM (second byte)
05BD: C5      		push bc
05BE: D5      		push de
              	
05BF: 1E20    		ld e,$20						; e = 32 
05C1: 1600    		ld d,$0							; d = 0
05C3:         	Boucle32X:
05C3: 7A      			ld a,d
05C4: F680    			OR $80
05C6: CDE305  			call lcd_send_command
              			
05C9: 3E80    			ld a,$80					; Set horizontal addressÔºàXÔºâ for GDRAM = 0 ($80)
05CB: CDE305  			call lcd_send_command
              			
05CE: AF      			xor a							 	
05CF: 0610    			ld b,$10							; b = 17
              			
05D1:         	Boucle16X:	 
05D1: CDF705  				call lcd_send_data 			; Write D15„ÄúD8 to GDRAM (first byte)
05D4: CDF705  				call lcd_send_data 			; Write D7„ÄúD0 to GDRAM (second byte)
              												; Address counter will automatically increase by one for the next two-byte data												
05D7: 10F8    				djnz Boucle16X					; b = b -1 ; jump to label if b not 0
              			
05D9: 1D      			dec e 
05DA: 14      			inc d
05DB: AF      			xor a							; a = 0
05DC: B3      			or e
05DD: C2C305  			jp nz,Boucle32X
              	
05E0: D1      		pop de
05E1: C1      		pop bc
              		
05E2: C9      	    ret
              	
              	
              	
              	;******************
              	;Send a command byte to the LCD
              	;Entry: A= command byte
              	;Exit: All preserved
              	;******************
05E3:         	lcd_send_command:
05E3: C5      		push bc				;Preserve
05E4: 0E70    		ld c, LCDCTRL   	;Command port
              		
05E6: CD1606  		call delayLCD
              		
05E9: ED79    		out (c),a			;Send command
05EB: C1      		pop bc				;Restore
05EC: C9      		ret
              	
              	
              	;******************
              	;Send a command byte to the LCD
              	;Entry: A= command byte
              	;Exit: All preserved
              	;******************
05ED:         	lcd_send_command_clear:
05ED: C5      		push bc				;Preserve
              		
05EE: CD2406  		call delayLCDclear
              		
05F1: 0E70    	    ld c, LCDCTRL   	;Command port
05F3: ED79    		out (c),a			;Send command
05F5: C1      		pop bc				;Restore
05F6: C9      		ret
              		
              	;******************
              	;Send a data byte to the LCD
              	;Entry: A= data byte
              	;Exit: All preserved
              	;******************
05F7:         	lcd_send_data:
05F7: C5      		push bc				;Preserve
              		
              	    ;Busy wait
05F8: CD1606  		call delayLCD
              	
05FB: 0E71    		ld c, LCDDATA	;Data port $71
05FD: ED79    		out (c),a			;Send data
05FF: C1      		pop bc				;Restore
0600: C9      		ret
              	
              	
              	
              	
              	;******************
              	;Send an asciiz string to the LCD
              	;Entry: HL=address of string
              	;Exit: HL=address of ending zero of the string. All others preserved
              	;******************
0601:         	lcd_send_asciiz:
0601: F5      		push af
0602: C5      		push bc				;Preserve
0603:         	lcd_asciiz_char_loop:
0603: 0E70    		ld c, LCDCTRL   	;Command port
              		
0605:         	lcd_asciiz_wait_loop:	;Busy wait
0605: CD1606  		call delayLCD
              		
0608: 7E      		ld a,(hl)			;Get character
0609: A7      		and a				;Is it zero?
060A: 2807    		jr z,lcd_asciiz_done	;If so, we're done
              		
060C: 0E71    		ld c, LCDDATA	;Data port
060E: ED79    		out (c),a			;Send data
0610: 23      		inc hl				;Next char
0611: 18F0    		jr lcd_asciiz_char_loop
              		
0613:         	lcd_asciiz_done:
0613: C1      		pop bc				;Restore
0614: F1      		pop af
0615: C9      		ret
              	
              	; =========================================================
              	; Delay LCD
              	; =========================================================
0616:         	delayLCD:
0616: 00      		NOP
0617: 00      		NOP
0618: 00      		NOP
0619: 00      		NOP
061A: 00      		NOP
061B: 00      		NOP
061C: 00      		NOP
061D: 00      		NOP
061E: 00      	    NOP
061F: 00      	    NOP
0620: 00      	    NOP
0621: 00      	    NOP
0622: 00      	    NOP
0623: C9      	    ret
              	
0624:         	delayLCDclear:
0624: 00      		NOP
0625: 00      		NOP
0626: 00      		NOP
0627: 00      		NOP
0628: 00      		NOP
0629: 00      		NOP
062A: 00      		NOP
062B: 00      		NOP
062C: 00      		NOP
062D: 00      		NOP
062E: 00      		NOP
062F: 00      		NOP
0630: 00      	    NOP
0631: 00      	    NOP
0632: 00      	    NOP
0633: 00      	    NOP
0634: 00      	    NOP
0635: 00      	    NOP
0636: 00      	    NOP
0637: 00      	    NOP
0638: 00      	    NOP
0639: C9      	    ret
              	
              	;-----------------------------------------
              	; SEND AN ASCII STRING OUT LCD
              	;-----------------------------------------
              	; 
              	; SENDS A ZERO TERMINATED STRING OR 
              	; 128 CHARACTERS MAX. OUT LCD
              	;
              	;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
              	;      EXIT  : NONE
              	;
              	;       MODIFIES : A,B,C
              	;          
063A:         	SNDLCDMSG:
063A: 0680    	    LD    B,128         ;128 CHARS MAX
063C: 7E      	SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
063D: FE00    	    CP    00H          ;ZERO TERMINATOR?
063F: 2806    	    JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
0641: CD7A03  	    CALL PrintBufferChar         ;TRANSMIT THE CHAR
0644: 23      	    INC   HL
0645: 10F5    	    DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
0647:         	SDLCDMSG2: 
0647: 2100F0  	    LD HL, DISPLAY
064A: CD7905  	    CALL print_image
064D: C9      	    RET
              	
              	
              	;-----------------------------------------
              	; SEND AN ASCII STRING TO BUFFER
              	;-----------------------------------------
              	; 
              	; SENDS A ZERO TERMINATED STRING OR 
              	; 128 CHARACTERS MAX. TO BUFFER (NOT SHOW LCD)
              	;
              	;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
              	;      EXIT  : NONE
              	;
              	;       MODIFIES : A,B,C
              	;          
064E:         	SNDBUFFERMSG:
064E: 0680    	    LD    B,128         ;128 CHARS MAX
0650: 7E      	SDBUFFERMSG1: LD    A,(HL)        ;GET THE CHAR
0651: FE00    	    CP    00H          ;ZERO TERMINATOR?
0653: 2806    	    JR    Z,SDBUFFERMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
0655: CD7A03  	    CALL PrintBufferChar         ;TRANSMIT THE CHAR
0658: 23      	    INC   HL
0659: 10F5    	    DJNZ  SDBUFFERMSG1        ;128 CHARS MAX!    
065B:         	SDBUFFERMSG2: 
065B: C9      	    RET
              	
              	
              	; Fill 8x8 with zero
              	; Print in buffer only
              	; A = X Y
065C:         	Clear8x8:
065C: F5      	    PUSH AF ; save A
              	    ; GET X
065D: E60F    	    AND $0F
065F: 0600    	    LD B, 0
0661: 4F      	    LD C, A
0662: 2100F0  	    LD HL, DISPLAY
0665: 09      	    ADD HL, BC
              	    ; GET Y
0666: F1      	    POP AF ; recupera A
0667: 1F      	    RRA
0668: 1F      	    RRA
0669: 1F      	    RRA
066A: 1F      	    RRA
066B: E60F    	    AND $0F
066D: CA7706  	    JP Z, clear8x8_Y_OK
0670: 47      	    LD B, A
0671: 118000  	    LD DE, $0080
0674:         	clear8x8_Y:
0674: 19      	    ADD HL, DE
0675: 10FD    	    DJNZ clear8x8_Y
              	; Start print
0677:         	clear8x8_Y_OK:
0677: 3E00    	    LD A, $00 ; byte to clear
0679: 77      	    LD (HL), A
067A: 0607    	    LD B, 7
067C:         	clear8x8_loop:
067C: 111000  	    LD DE, $0010 ; soma 16 bytes
067F: 19      	    ADD HL, DE ; next line
0680: 3E00    	    LD A, $00 ; byte to clear
0682: 77      	    LD (HL), A
0683: 10F7    	    DJNZ clear8x8_loop
0685: C9      	    RET
              	
              	
              	
              	; Print 8x8 bits in buffer
              	; A = Y[7b-4b] X[3b-0b]
              	; DE = Image pointer
0686:         	Print8x8:
0686: D5      	    PUSH DE ; save image pointer DE
0687: F5      	    PUSH AF ; save A
              	    ; GET X
0688: E60F    	    AND $0F
068A: 0600    	    LD B, 0
068C: 4F      	    LD C, A
068D: 2100F0  	    LD HL, DISPLAY
0690: 09      	    ADD HL, BC
              	    ; GET Y
0691: F1      	    POP AF ; recupera A
0692: 1F      	    RRA
0693: 1F      	    RRA
0694: 1F      	    RRA
0695: 1F      	    RRA
0696: E60F    	    AND $0F
0698: CAA206  	    JP Z, print8x8_Y_OK
069B: 47      	    LD B, A
069C: 118000  	    LD DE, $0080
069F:         	print8x8_Y:
069F: 19      	    ADD HL, DE
06A0: 10FD    	    DJNZ print8x8_Y
              	; Start print
06A2:         	print8x8_Y_OK:
06A2: D1      	    POP DE
06A3: 1A      	    LD A, (DE)
06A4: 77      	    LD (HL), A
06A5: 0607    	    LD B, 7
06A7:         	print8x8_loop:
06A7: D5      	    PUSH DE
06A8: 111000  	    LD DE, $0010 ; soma 16 bytes
06AB: 19      	    ADD HL, DE ; next line
06AC: D1      	    POP DE
06AD: 13      	    INC DE ; next byte
06AE: 1A      	    LD A, (DE)
06AF: 77      	    LD (HL), A
06B0: 10F5    	    DJNZ print8x8_loop
              	    ;CALL show_lcd
06B2: C9      	    RET
              	
              	
              	
              	
              	
              	
              	
              	
06B3:         	TABLE:
06B3: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
06B7: 00000000	
06BB: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
06BF: 00000000	
06C3: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
06C7: 00000000	
06CB: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
06CF: 00000000	
06D3: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
06D7: 00000000	
06DB: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
06DF: 00000000	
06E3: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
06E7: 00000000	
06EB: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
06EF: 00000000	
06F3: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
06F7: 00000000	
06FB: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
06FF: 00000000	
0703: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0707: 00000000	
070B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
070F: 00000000	
0713: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0717: 00000000	
071B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
071F: 00000000	
0723: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0727: 00000000	
072B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
072F: 00000000	
0733: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0737: 00000000	
073B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
073F: 00000000	
0743: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0747: 00000000	
074B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
074F: 00000000	
0753: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0757: 00000000	
075B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
075F: 00000000	
0763: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0767: 00000000	
076B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
076F: 00000000	
0773: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0777: 00000000	
077B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
077F: 00000000	
0783: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0787: 00000000	
078B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
078F: 00000000	
0793: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0797: 00000000	
079B: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
079F: 00000000	
07A3: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
07A7: 00000000	
07AB: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
07AF: 00000000	
              	
              	; DEC 32
07B3: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
07B7: 00000000	
07BB: 20202020	.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
07BF: 20002000	
07C3: 50505000	.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
07C7: 00000000	
07CB: 5050F850	.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
07CF: F8505000	
07D3: 2078A070	.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
07D7: 28F02000	
07DB: C0C81020	.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
07DF: 40981800	
07E3: 6090A040	.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
07E7: A8906800	
07EB: 20202000	.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
07EF: 00000000	
07F3: 10204040	.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
07F7: 40201000	
07FB: 40201010	.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
07FF: 10204000	
0803: 0020A870	.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0807: A8200000	
080B: 002020F8	.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
080F: 20200000	
0813: 00000000	.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0817: 60204000	
081B: 000000F8	.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
081F: 00000000	
0823: 00000000	.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0827: 00606000	
082B: 00000810	.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
082F: 20408000	
0833: 708898A8	.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0837: C8887000	
083B: 20602020	.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
083F: 20207000	
0843: 70880810	.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0847: 2040F800	
084B: F8102010	.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
084F: 08887000	
0853: 10305090	.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0857: F8101000	
085B: F880F008	.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
085F: 08887000	
0863: 304080F0	.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0867: 88887000	
086B: F8081020	.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
086F: 40404000	
0873: 70888870	.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0877: 88887000	
087B: 70888878	.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
087F: 08106000	
0883: 00003030	.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0887: 00303000	
088B: 00303000	.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
088F: 30102000	
0893: 10204080	.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0897: 40201000	
089B: 0000F800	.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
089F: F8000000	
08A3: 40201008	.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
08A7: 10204000	
08AB: 30480810	.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
08AF: 20002000	
08B3: 70880868	.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
08B7: A8A87000	
              	
              	; DEC 65 Maiusculas
08BB: 20508888	.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
08BF: F8888800	
08C3: F08888F0	.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
08C7: 8888F000	
08CB: 70888080	.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
08CF: 80887000	
08D3: E0908888	.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
08D7: 8890E000	
08DB: F88080F0	.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
08DF: 8080F800	
08E3: F88080F0	.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
08E7: 80808000	
08EB: 70888080	.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
08EF: B8887000	
08F3: 888888F8	.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
08F7: 88888800	
08FB: 70202020	.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
08FF: 20207000	
0903: 08080808	.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0907: 88887000	
090B: 8890A0C0	.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
090F: A0908800	
0913: 80808080	.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0917: 8080F800	
091B: 88D8A888	.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
091F: 88888800	
0923: 8888C8A8	.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0927: 98888800	
092B: 70888888	.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
092F: 88887000	
0933: F08888F0	.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0937: 80808000	
093B: 70888888	.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
093F: A8987000	
0943: F08888F0	.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0947: 88888800	
094B: 70888070	.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
094F: 08887000	
0953: F8202020	.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0957: 20202000	
095B: 88888888	.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
095F: 88887000	
0963: 88888888	.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0967: 88502000	
096B: 88888888	.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
096F: A8D88800	
0973: 88885020	.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0977: 50888800	
097B: 88885020	.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
097F: 20202000	
0983: F8081020	.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0987: 4080F800	
              	
              	; DEC 91
098B: 30202020	.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
098F: 20203000	
0993: 00804020	.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0997: 10080000	
099B: 60202020	.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
099F: 20206000	
09A3: 20508800	.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
09A7: 00000000	
09AB: 00000000	.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
09AF: 0000F800	
09B3: 40201000	.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
09B7: 00000000	
              	
              	; DEC 97 "Minusculas"
09BB: 20508888	.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
09BF: F8888800	
09C3: F08888F0	.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
09C7: 8888F000	
09CB: 70888080	.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
09CF: 80887000	
09D3: E0908888	.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
09D7: 8890E000	
09DB: F88080F0	.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
09DF: 8080F800	
09E3: F88080F0	.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
09E7: 80808000	
09EB: 70888080	.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
09EF: B8887000	
09F3: 888888F8	.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
09F7: 88888800	
09FB: 70202020	.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
09FF: 20207000	
0A03: 08080808	.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0A07: 88887000	
0A0B: 8890A0C0	.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0A0F: A0908800	
0A13: 80808080	.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0A17: 8080F800	
0A1B: 88D8A888	.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0A1F: 88888800	
0A23: 8888C8A8	.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0A27: 98888800	
0A2B: 70888888	.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0A2F: 88887000	
0A33: F08888F0	.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0A37: 80808000	
0A3B: 70888888	.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0A3F: A8987000	
0A43: F08888F0	.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0A47: 88888800	
0A4B: 70888070	.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0A4F: 08887000	
0A53: F8202020	.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0A57: 20202000	
0A5B: 88888888	.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0A5F: 88887000	
0A63: 88888888	.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0A67: 88502000	
0A6B: 88888888	.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0A6F: A8D88800	
0A73: 88885020	.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0A77: 50888800	
0A7B: 88885020	.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0A7F: 20202000	
0A83: F8081020	.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0A87: 4080F800	
              	
              	; DEC 123
0A8B: 10202040	.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0A8F: 20201000	
0A93: 20202020	.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0A97: 20202000	
0A9B: 40202010	.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0A9F: 20204000	
0AA3: 000050A0	.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0AA7: 00000000	
0AAB: 00000000	.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0AAF: 00000000	
              	#include "LoaderIntel.asm"
              	;-----------------------
              	; RECEIVE INTEL HEX FILE
              	;-----------------------       
0AB3:         	INTHEX: 
0AB3: 216C15  	       LD HL, MSG_ILOAD
0AB6: CD3A06  	       CALL  SNDLCDMSG
              	
0AB9: 216C15  	       LD HL, MSG_ILOAD
0ABC: CD070D  	       CALL  SNDMSG
              	       
              	
0ABF: CDDE0A  	       CALL  INTELH
0AC2: 200D    	       JR    NZ,ITHEX1      
              	
0AC4: 218215  	       LD    HL,FILEOK
0AC7: CD3A06  	       CALL  SNDLCDMSG   ;GOT FILE OK LCD
0ACA: 218215  	       LD    HL,FILEOK
0ACD: CD070D  	       CALL  SNDMSG      ;GOT FILE OK Serial
              	       
0AD0: C9      	       RET
0AD1: 219415  	ITHEX1: LD    HL,CSUMERR
0AD4: CD3A06  	       CALL  SNDLCDMSG
              	
0AD7: 219415  	       LD    HL,CSUMERR
0ADA: CD070D  	       CALL  SNDMSG      ;CHECKSUM ERROR
              	       
0ADD: C9      	       RET  
              	
              	
              	
              	
              	
              	;-----------------------
              	; RECEIVE INTEL HEX FILE
              	;-----------------------
0ADE: DD21F0FF	INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
              	;
              	; WAIT FOR RECORD MARK
              	;
0AE2: AF      	INTEL1:	XOR	A
0AE3: DD7703  		LD	(IX+3),A	;CLEAR CHECKSUM
0AE6: CD4C0D  		CALL	RXDATA	;WAIT FOR THE RECORD MARK
0AE9: FE3A    		CP	':'	;TO BE TRANSMITTED
0AEB: 20F5    		JR	NZ,INTEL1	;NOT RECORD MARK
              	;
              	; GET RECORD LENGTH
              	;
0AED: CD3A0B  		CALL	GETBYT
0AF0: DD7700  		LD	(IX+0),A	;NUMBER OF DATA BYTES
              	;
              	; GET ADDRESS FIELD
              	;
0AF3: CD3A0B  		CALL	GETBYT
0AF6: DD7702  		LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
0AF9: CD3A0B  		CALL	GETBYT
0AFC: DD7701  		LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
              	;
              	; GET RECORD TYPE
              	;
0AFF: CD3A0B  		CALL	GETBYT
0B02: 2024    		JR	NZ,INTEL4	;END OF FILE RECORD
              	;
              	; READ IN THE DATA
              	;
0B04: DD4600  		LD	B,(IX+0)	;NUMBER OF DATA BYTES
0B07: DD6602  		LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
0B0A: DD6E01  		LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
              	
0B0D: CD3A0B  	INTEL2:	CALL	GETBYT	;GET DATA BYTE
0B10: 77      		LD	(HL),A	;STORE DATA BYTE
0B11: 23      		INC	HL
0B12: 10F9    		DJNZ	INTEL2	;LOAD MORE BYTES
              	;
              	; GET CHECKSUM AND COMPARE
              	;
0B14: DD7E03  		LD	A,(IX+3)	;CONVERT CHECKSUM TO
0B17: ED44    		NEG		;TWO'S COMPLEMENT
0B19: DD7704  		LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
0B1C: CD3A0B  		CALL	GETBYT
0B1F: DD7703  		LD	(IX+3),A	;SAVE RECORD CHECKSUM
0B22: DDBE04  		CP	(IX+4)	;COMPARE CHECKSUM
0B25: 28BB    		JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
0B27: C9      	    RET             ;NZ=CHECKSUM ERROR
              	;
              	; END OF FILE RECORD
              	;
0B28: DD7E03  	INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
0B2B: ED44    		NEG		;TWO'S COMPLEMENT
0B2D: DD7704  		LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
0B30: CD3A0B  		CALL	GETBYT
0B33: DD7703  		LD	(IX+3),A	;SAVE EOF CHECKSUM
0B36: DDBE04  		CP	(IX+4)	;COMPARE CHECKSUM
0B39: C9      		RET  	    ;NZ=CHECKSUM ERROR
              	;--------------------------
              	; GET BYTE FROM SERIAL PORT
              	;--------------------------
0B3A: C5      	GETBYT:	PUSH	BC
0B3B: CD4C0D  		CALL	RXDATA
0B3E: CB77    		BIT	6,A
0B40: 2802    		JR	Z,GETBT1
0B42: C609    		ADD	A,09H
0B44: E60F    	GETBT1:	AND	0FH
0B46: CB27    		SLA 	A
0B48: CB27    		SLA	A
0B4A: CB27    		SLA	A
0B4C: CB27    		SLA	A
0B4E: 4F      		LD	C,A
              	;
              	; GET LOW NYBBLE
              	;
0B4F: CD4C0D  		CALL	RXDATA
0B52: CB77    		BIT	6,A
0B54: 2802    		JR	Z,GETBT2
0B56: C609    		ADD	A,09H
0B58: E60F    	GETBT2:	AND	0FH
0B5A: B1      		OR	C
0B5B: 47      		LD	B,A
0B5C: DD8603  		ADD	A,(IX+3)
0B5F: DD7703  		LD	(IX+3),A	;ADD TO CHECKSUM
0B62: 78      		LD	A,B
0B63: A7      		AND	A	;CLEAR CARRY
0B64: C1      	    POP	BC
0B65: C9      		RET
              	#include "I2C.asm"
              	; **********************************************************************
              	; I2C support functions
              	
              	; I2C bus open device
              	;   On entry: A = Device address (bit zero is read flag)
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             BC DE HL IX IY preserved
0B66: F5      	I2C_Open:   PUSH AF
0B67: CDDA0B  	            CALL I2C_Start      ;Output start condition
0B6A: F1      	            POP  AF
0B6B: 1803    	            JR   I2C_Write      ;Write data byte
              	
              	
              	; I2C bus close device
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A=0 and Z flagged
              	;             If unsuccessfully A=Error and NZ flagged
              	;             SCL = hi, SDA = hi
              	;             BC DE HL IX IY preserved
0B6D: C3E50B  	I2C_Close:  JP   I2C_Stop       ;Output stop condition
              	
              	
              	; **********************************************************************
              	; **********************************************************************
              	; I2C bus master driver
              	; **********************************************************************
              	; **********************************************************************
              	
              	; Functions provided are:
              	;     I2C_Start
              	;     I2C_Stop
              	;     I2C_Read
              	;     I2C_Write
              	;
              	; This code has delays between all I/O operations to ensure it works
              	; with the slowest I2C devices
              	;
              	; I2C transfer sequence
              	;   +-------+  +---------+  +---------+     +---------+  +-------+
              	;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
              	;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
              	;   +-------+  +---------+  +---------+     +---------+  +-------+
              	;
              	;
              	; Start condition                     Stop condition
              	; Output by master device             Output by master device
              	;       ----+                                      +----
              	; SDA       |                         SDA          |
              	;           +-------                        -------+
              	;       -------+                                +-------
              	; SCL          |                      SCL       |
              	;              +----                        ----+
              	;
              	;
              	; Address frame
              	; Clock and data output from master device
              	; Receiving device outputs acknowledge 
              	;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
              	; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
              	;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
              	;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
              	; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
              	;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
              	;
              	;
              	; Data frame 
              	; Clock output by master device
              	; Data output by transmitting device
              	; Receiving device outputs acknowledge 
              	;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
              	; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
              	;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
              	;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
              	; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
              	;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
              	;
              	
              	
              	; **********************************************************************
              	; I2C constants
              	
              	
              	; I2C bus master interface
              	; The default device option is for SC126 or compatible
              	
0021:         	I2C_PORT:   .EQU $21           ;Host I2C port address
0007:         	I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
0007:         	I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
0000:         	I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
0000:         	I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
0081:         	I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
              	
              	
              	; I2C support constants
0000:         	ERR_NONE:   .EQU 0              ;Error = None
0001:         	ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
0002:         	ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
0003:         	ERR_TOUT:   .EQU 3              ;Error = Timeout
              	
              	
              	; **********************************************************************
              	; Hardware dependent I2C bus functions
              	
              	
              	; I2C bus transmit frame (address or data)
              	;   On entry: A = Data byte, or
              	;                 Address byte (bit zero is read flag)
              	;             SCL = low, SDA = low
              	;   On exit:  If successful A=0 and Z flagged
              	;                SCL = lo, SDA = lo
              	;             If unsuccessful A=Error and NZ flagged
              	;                SCL = high, SDA = high, I2C closed
              	;             BC DE HL IX IY preserved
0B70: C5      	I2C_Write:  PUSH BC             ;Preserve registers
0B71: D5      	            PUSH DE
0B72: 57      	            LD   D,A            ;Store byte to be written
0B73: 0608    	            LD   B,8            ;8 data bits, bit 7 first
0B75: CB12    	I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
0B77: 3805    	            JR   C,I2C_WriteBit_Hi      ;High, so skip
0B79: CD0C0C  	            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
0B7C: 1803    	            JR   I2C_WriteBit_Clk
0B7E: CD050C  	I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
0B81: CDF70B  	I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
0B84: CDFE0B  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
0B87: 10EC    	            DJNZ I2C_WriteWr_Loop
              	; Test for acknowledge from slave (receiver)
              	; On arriving here, SCL = lo, SDA = data bit
0B89: CD050C  	            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
0B8C: CDF70B  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
0B8F: CD1D0C  	            CALL I2C_RdPort     ;Read SDA input
0B92: 47      	            LD   B,A
0B93: CDFE0B  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
0B96: CB78    	            BIT  I2C_SDA_RD,B
0B98: 2004    	            JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
0B9A: D1      	            POP  DE             ;Restore registers
0B9B: C1      	            POP  BC
0B9C: AF      	            XOR  A              ;Return success A=0 and Z flagged
0B9D: C9      	            RET
              	; I2C STOP required as no acknowledge
              	; On arriving here, SCL = lo, SDA = hi
0B9E: CD0C0C  	I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
0BA1: CDF70B  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
0BA4: CD050C  	            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
0BA7: D1      	            POP  DE             ;Restore registers
0BA8: C1      	            POP  BC
0BA9: 3E02    	            LD   A,ERR_NOACK    ;Return error = No Acknowledge
0BAB: B7      	            OR   A              ;  and NZ flagged
0BAC: C9      	            RET
              	
              	
              	; I2C bus receive frame (data)
              	;   On entry: A = Acknowledge flag
              	;               If A != 0 the read is acknowledged
              	;             SCL low, SDA low
              	;   On exit:  If successful A = data byte and Z flagged
              	;               SCL = low, SDA = low
              	;             If unsuccessul* A = Error and NZ flagged
              	;               SCL = low, SDA = low
              	;             BC DE HL IX IY preserved
              	; *This function always returns successful
0BAD: C5      	I2C_Read:   PUSH BC             ;Preserve registers
0BAE: D5      	            PUSH DE
0BAF: 5F      	            LD   E,A            ;Store acknowledge flag
0BB0: 0608    	            LD   B,8            ;8 data bits, 7 first
0BB2: CD050C  	            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
0BB5: CDF70B  	I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
0BB8: CD1D0C  	            CALL I2C_RdPort     ;Read SDA input bit
0BBB: 37      	            SCF                 ;Set carry flag
0BBC: CB7F    	            BIT  I2C_SDA_RD,A   ;SDA input high?
0BBE: 2001    	            JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
0BC0: 3F      	            CCF                 ;Clear carry flag
0BC1: CB12    	I2C_ReadRotate:    RL   D              ;Rotate result into D
0BC3: CDFE0B  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
0BC6: 10ED    	            DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
              	; Acknowledge input byte
              	; On arriving here, SCL = lo, SDA = hi/input
0BC8: 7B      	            LD   A,E            ;Get acknowledge flag
0BC9: B7      	            OR   A              ;A = 0? (indicates no acknowledge)
0BCA: 2803    	            JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
0BCC: CD0C0C  	            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
0BCF: CDF70B  	I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
0BD2: CDFE0B  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
0BD5: 7A      	            LD   A,D            ;Get data byte received
0BD6: D1      	            POP  DE             ;Restore registers
0BD7: C1      	            POP  BC
0BD8: BF      	            CP   A              ;Return success Z flagged
0BD9: C9      	            RET
              	
              	
              	; I2C bus start
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  SCL = low, SDA = low
              	;             A = 0 and Z flagged as we always succeed
              	;             BC DE HL IX IY preserved
              	; First ensure SDA and SCL are high
0BDA: CDF30B  	I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
              	;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
              	;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
              	; Generate I2C start condition
0BDD: CD0C0C  	            CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
0BE0: CDFE0B  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
0BE3: AF      	            XOR  A              ;Return success A=0 and Z flagged
0BE4: C9      	            RET
              	
              	
              	; I2C bus stop 
              	;   On entry: SCL = unknown, SDA = unknown
              	;   On exit:  SCL = high, SDA = high
              	;             A = 0 and Z flagged as we always succeed
              	;             BC DE HL IX IY preserved
              	; First ensure SDA and SCL are low
0BE5: CD0C0C  	I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
0BE8: CDFE0B  	            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
              	; Generate stop condition
0BEB: CDF70B  	            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
0BEE: CD050C  	            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
0BF1: AF      	            XOR  A              ;Return success A=0 and Z flagged
0BF2: C9      	            RET
              	
              	
              	; **********************************************************************
              	; I2C bus simple I/O functions
              	;   On entry: No parameters required
              	;   On exit:  BC DE HL IX IY preserved
              	
0BF3: 3E81    	I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
0BF5: 181A    	            JR   I2C_WrPort
              	
0BF7: 3A21F4  	I2C_SCL_HI: LD   A,(I2C_RAMCPY)
0BFA: CBC7    	            SET  I2C_SCL_WR,A
0BFC: 1813    	            JR   I2C_WrPort
              	
0BFE: 3A21F4  	I2C_SCL_LO: LD   A,(I2C_RAMCPY)
0C01: CB87    	            RES  I2C_SCL_WR,A
0C03: 180C    	            JR   I2C_WrPort
              	
0C05: 3A21F4  	I2C_SDA_HI: LD   A,(I2C_RAMCPY)
0C08: CBFF    	            SET  I2C_SDA_WR,A
0C0A: 1805    	            JR   I2C_WrPort
              	
0C0C: 3A21F4  	I2C_SDA_LO: LD   A,(I2C_RAMCPY)
0C0F: CBBF    	            RES  I2C_SDA_WR,A
              	
0C11: C5      	I2C_WrPort: PUSH BC             ;Preserve registers
0C12: 0600    	            LD   B,0            ;Set up BC for 16-bit
0C14: 0E21    	            LD   C,I2C_PORT     ;  I/O address of I2C port
0C16: ED79    	            OUT  (C),A          ;Write A to I2C I/O port
0C18: 3221F4  	            LD   (I2C_RAMCPY),A ;Write A to RAM copy
0C1B: C1      	            POP  BC             ;Restore registers
0C1C: C9      	            RET
              	
0C1D: C5      	I2C_RdPort: PUSH BC             ;Preserve registers
0C1E: 0600    	            LD   B,0            ;Set up BC for 16-bit
0C20: 0E21    	            LD   C,I2C_PORT     ;  I/O address of I2C port
0C22: ED78    	            IN   A,(C)          ;Read A from I/O port
0C24: C1      	            POP  BC             ;Restore registers
0C25: C9      	            RET
              	
              	
              	
              	;==============================================================================
              	;==============================================================================
              	;==============================================================================
              	;===================       FUNCTIONS    =======================================
              	;==============================================================================
              	;==============================================================================
              	
              	
              	
              	
              	; **********************************************************************
              	; List devices found on the I2C bus
              	;
              	; Test each I2C device address and reports any that acknowledge
              	
0C26: 116C14  	I2CLIST:       LD   DE,LISTMsg        ;Address of message string
0C29: CDE312  	            CALL StrOut         ;Output string
0C2C: 1600    	            LD   D,0            ;First I2C device address to test
0C2E: D5      	LISTLOOP:      PUSH DE             ;Preserve DE
0C2F: 7A      	            LD   A,D            ;Get device address to be tested
0C30: CD470C  	            CALL LISTTEST          ;Test if device is present
0C33: D1      	            POP  DE             ;Restore DE
0C34: 2007    	            JR   NZ,LISTNEXT       ;Skip if no acknowledge
0C36: 7A      	            LD   A,D            ;Get address of device tested
0C37: CDBB0C  	            CALL HexOut         ;Output as two character hex 
0C3A: CDDA12  	            CALL SpaceOut       ;Output space character
0C3D: 14      	LISTNEXT:      INC  D              ;Get next write address
0C3E: 14      	            INC  D
0C3F: 7A      	            LD   A,D            ;Address of next device to test
0C40: B7      	            OR   A              ;Have we tested all addresses?
0C41: 20EB    	            JR   NZ,LISTLOOP       ;No, so loop again
0C43: CDDE12  	            CALL LineOut        ;Output new line
0C46: C9      	            RET
              	
              	; Test if device at I2C address A acknowledges
              	;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
              	;   On exit:  Z flagged if device acknowledges
              	;             NZ flagged if devices does not acknowledge
0C47: CD660B  	LISTTEST:      CALL I2C_Open       ;Open I2C device for write
0C4A: C0      	            RET  NZ             ;Abort if failed to open
0C4B: CD6D0B  	            CALL I2C_Close      ;Close I2C device 
0C4E: AF      	            XOR  A              ;Return with Z flagged
0C4F: C9      	            RET
              	
              	
              	
              	
              	; Copy a block from I2C memory to CPU memory
              	;   On entry: DE = First address in I2C memory
              	;             HL = First address in CPU memory
              	;             BC = Number of bytes to be copied
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             IX IY preserved
0C50: C5      	I2C_MemRd:  PUSH BC
0C51: 011027  	            LD   BC,TIMEOUT     ;Timeout loop counter
0C54: 3EAE    	I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
0C56: CD660B  	            CALL I2C_Open       ;Open for write
0C59: 280A    	            JR   Z,I2C_MemRdReady       ;If open okay then skip on
0C5B: 0B      	            DEC  BC
0C5C: 78      	            LD   A,B
0C5D: B1      	            OR   C              ;Timeout?
0C5E: 20F4    	            JR   NZ,I2C_MemRdRepeat     ;No, so go try again
0C60: C1      	            POP  BC
0C61: 3E03    	            LD   A,ERR_TOUT     ;Error code
0C63: B7      	            OR   A              ;Error, so NZ flagged
0C64: C9      	            RET                 ;Return with error
              	; Device opened okay
0C65: C1      	I2C_MemRdReady:     POP  BC             ;Restore byte counter
0C66: 7A      	            LD   A,D            ;Address (hi) in I2C memory
0C67: CD700B  	            CALL I2C_Write      ;Write address
0C6A: 7B      	            LD   A,E            ;Address (lo) in I2C memory
0C6B: CD700B  	            CALL I2C_Write      ;Write address
0C6E: 3EAF    	            LD   A,I2CA_BLOCK+1 ;I2C device to be read from
0C70: CD660B  	            CALL I2C_Open       ;Open for read
0C73: C0      	            RET  NZ             ;Abort if error
0C74: 0B      	I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
0C75: 78      	            LD   A,B
0C76: B1      	            OR   C              ;Last byte to be read?
0C77: CDAD0B  	            CALL I2C_Read       ;Read byte with no ack on last byte
0C7A: 77      	            LD   (HL),A         ;Write byte in CPU memory
0C7B: 23      	            INC  HL             ;Increment CPU memory pointer
0C7C: 78      	            LD   A,B
0C7D: B1      	            OR   C              ;Finished?
0C7E: 20F4    	            JR   NZ,I2C_MemRdRead       ;No, so go read next byte
0C80: CDE50B  	            CALL I2C_Stop       ;Generate I2C stop
0C83: AF      	            XOR  A              ;Return with success (Z flagged)
0C84: C9      	            RET
              	
              	
              	; Copy a block from CPU memory to I2C memory
              	;   On entry: DE = First address in I2C memory
              	;             HL = First address in CPU memory
              	;             BC = Number of bytes to be copied
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             IX IY preserved
              	; The 24LC64 requires blocks of data to be written in 64 byte (or less)
              	; pages.
0C85: C5      	I2C_MemWr:  PUSH BC
0C86: 011027  	            LD   BC,TIMEOUT     ;Timeout loop counter
0C89: 3EAE    	I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
0C8B: CD660B  	            CALL I2C_Open       ;Open for write
0C8E: 280A    	            JR   Z,I2C_MemWrReady       ;If open okay then skip on
0C90: 0B      	            DEC  BC
0C91: 78      	            LD   A,B
0C92: B1      	            OR   C              ;Timeout?
0C93: 20F4    	            JR   NZ,I2C_MemWrRepeat     ;No, so go try again
0C95: C1      	            POP  BC
0C96: 3E03    	            LD   A,ERR_TOUT     ;Error code
0C98: B7      	            OR   A              ;Error, so NZ flagged
0C99: C9      	            RET                 ;Return with error
              	; Device opened okay
0C9A: C1      	I2C_MemWrReady:     POP  BC             ;Restore byte counter
0C9B: 7A      	I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
0C9C: CD700B  	            CALL I2C_Write      ;Write address
0C9F: 7B      	            LD   A,E            ;Address (lo) in I2C memory
0CA0: CD700B  	            CALL I2C_Write      ;Write address
0CA3: 7E      	I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
0CA4: CD700B  	            CALL I2C_Write      ;Read byte from I2C memory
0CA7: 23      	            INC  HL             ;Increment CPU memory pointer
0CA8: 13      	            INC  DE             ;Increment I2C memory pointer
0CA9: 0B      	            DEC  BC             ;Decrement byte counter
0CAA: 78      	            LD   A,B
0CAB: B1      	            OR   C              ;Finished?
0CAC: 2805    	            JR   Z,I2C_MemWrStore       ;Yes, so go store this page
0CAE: 7B      	            LD   A,E            ;Get address in I2C memory (lo byte)
0CAF: E63F    	            AND  63             ;64 byte page boundary?
0CB1: 20F0    	            JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
0CB3: CDE50B  	I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
0CB6: 78      	            LD   A,B
0CB7: B1      	            OR   C              ;Finished?
0CB8: 20CB    	            JR   NZ,I2C_MemWr   ;No, so go write some more
0CBA: C9      	            RET   
              	
              	
              	; Hex byte output to console
              	;   On entry: A = Byte to be output in hex
              	;   On exit:  BC DE HL IX IY preserved
0CBB: F5      	HexOut:     PUSH AF             ;Preserve byte to be output
0CBC: 1F      	            RRA                 ;Shift top nibble to
0CBD: 1F      	            RRA                 ;  botom four bits..
0CBE: 1F      	            RRA
0CBF: 1F      	            RRA
0CC0: E60F    	            AND  $0F           ;Mask off unwanted bits
0CC2: CDC80C  	            CALL HexOutHex           ;Output hi nibble
0CC5: F1      	            POP  AF             ;Restore byte to be output
0CC6: E60F    	            AND  $0F           ;Mask off unwanted bits
              	; Output nibble as ascii character
0CC8: FE0A    	HexOutHex:       CP   $0A           ;Nibble > 10 ?
0CCA: 3802    	            JR   C,HexOutSkip        ;No, so skip
0CCC: C607    	            ADD  A,7            ;Yes, so add 7
0CCE: C630    	HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
0CD0: CD0800  	            CALL $0008       ;Write character
0CD3: C9      	            RET
              	
              	#include "SoftSerial.asm"
              	
              	
0CD4:         	INIT_SOFTSERIAL:
              	    ; init serial
              	    ; CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0CD4: 21210D  	    LD    HL,TXDATA
0CD7: 2232F4  	    LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0CDA: 214C0D  	    LD    HL,RXDATA
0CDD: 2234F4  	    LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
              	    
0CE0: 211B00  	    LD	HL,B4800
0CE3: 2230F4  		LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
              	
0CE6: 3EFF    	    LD A, $FF
0CE8: D3C0    	    OUT (SERIAL_TX_PORT), A
              	
0CEA: 212013  	    LD HL, WELLCOME
0CED: CD070D  	    CALL SNDMSG
0CF0: C9      	    RET
              	
              	;-----------------
              	; ONE SECOND DELAY
              	;-----------------
              	;
              	; ENTRY : NONE
              	; EXIT : FLAG REGISTER MODIFIED
              	;
0CF1: C5      	DELONE:	PUSH	BC
0CF2: D5      		PUSH	DE
0CF3: E5      		PUSH	HL
0CF4: 110100  		LD	DE,0001H
0CF7: 217008  		LD	HL,0870H
0CFA: 0692    	DELON1:	LD	B,92H
0CFC: 10FE    	DELON2:	DJNZ	DELON2	;INNER LOOP
0CFE: ED52    		SBC	HL,DE
0D00: D2FA0C  		JP	NC,DELON1	;OUTER LOOP
0D03: E1      		POP	HL
0D04: D1      		POP	DE
0D05: C1      		POP	BC
0D06: C9      		RET
              	
              	;-----------------------------------------
              	; SEND AN ASCII STRING OUT THE SERIAL PORT
              	;-----------------------------------------
              	; 
              	; SENDS A ZERO TERMINATED STRING OR 
              	; 128 CHARACTERS MAX. OUT THE SERIAL PORT
              	;
              	;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
              	;      EXIT  : NONE
              	;
              	;       MODIFIES : A,B,C
              	;          
0D07: 0680    	SNDMSG: LD    B,128         ;128 CHARS MAX
0D09: 7E      	SDMSG1: LD    A,(HL)        ;GET THE CHAR
0D0A: FE00    	       CP    00H          ;ZERO TERMINATOR?
0D0C: 2806    	       JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
0D0E: CD150D  	       CALL  OUTCH         ;TRANSMIT THE CHAR
0D11: 23      	       INC   HL
0D12: 10F5    	       DJNZ  SDMSG1        ;128 CHARS MAX!    
0D14: C9      	SDMSG2: RET
              	
              	
              	
              	;-----------------------------------
              	; OUTPUT A CHARACTER TO THE TERMINAL
              	;-----------------------------------       
0D15: DD2A32F4	OUTCH:  LD   IX,(PUTCH)
0D19: DDE9    	       JP   (IX)
              	;------------------------------------
              	; INPUT A CHARACTER FROM THE TERMINAL
              	;------------------------------------
0D1B: DD2A34F4	INCH:  LD   IX,(GETCH)
0D1F: DDE9    	      JP   (IX)
              	
              	
              	
              	;------------------------
              	; SERIAL TRANSMIT ROUTINE
              	;------------------------
              	;TRANSMIT BYTE SERIALLY ON DOUT
              	;
              	; ENTRY : A = BYTE TO TRANSMIT
              	;  EXIT : NO REGISTERS MODIFIED
              	;
0D21: F5      	TXDATA:	PUSH	AF
0D22: C5      		PUSH	BC
0D23: E5      		PUSH	HL
0D24: 2A30F4  		LD	HL,(BAUD)
0D27: 4F      		LD	C,A
              	;
              	; TRANSMIT START BIT
              	;
0D28: AF      		XOR	A
0D29: D3C0    		OUT	(SERIAL_TX_PORT),A
0D2B: CD790D  		CALL	BITIME
              	;
              	; TRANSMIT DATA
              	;
0D2E: 0608    		LD	B,08H
0D30: CB09    		RRC	C
0D32: CB09    	NXTBIT:	RRC	C	;SHIFT BITS TO D6,
0D34: 79      		LD	A,C	;LSB FIRST AND OUTPUT
0D35: E640    		AND	40H	;THEM FOR ONE BIT TIME.
0D37: D3C0    		OUT	(SERIAL_TX_PORT),A
0D39: CD790D  		CALL	BITIME
0D3C: 10F4    		DJNZ	NXTBIT
              	;
              	; SEND STOP BITS
              	;
0D3E: 3E40    		LD	A,40H
0D40: D3C0    		OUT	(SERIAL_TX_PORT),A
0D42: CD790D  		CALL	BITIME
0D45: CD790D  		CALL	BITIME
0D48: E1      		POP	HL
0D49: C1      		POP	BC
0D4A: F1      		POP	AF
0D4B: C9      		RET
              	;-----------------------
              	; SERIAL RECEIVE ROUTINE
              	;-----------------------
              	;RECEIVE SERIAL BYTE FROM DIN
              	;
              	; ENTRY : NONE
              	;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
              	;
              	; REGISTERS MODIFIED A AND F
              	;
0D4C: C5      	RXDATA:	PUSH	BC
0D4D: E5      		PUSH	HL
              	;
              	; WAIT FOR START BIT 
              	;
0D4E: DBC0    	RXDAT1: IN	A,(SERIAL_RX_PORT)
0D50: CB7F    		    BIT	7,A
0D52: 20FA    		    JR	NZ,RXDAT1	;NO START BIT
              	;
              	; DETECTED START BIT
              	;
0D54: 2A30F4  		LD	HL,(BAUD)
0D57: CB3C    		SRL	H
0D59: CB1D    		RR	L 	;DELAY FOR HALF BIT TIME
0D5B: CD790D  		CALL 	BITIME
0D5E: DBC0    		IN	A,(SERIAL_RX_PORT)
0D60: CB7F    		BIT	7,A
0D62: 20EA    		JR	NZ,RXDAT1	;START BIT NOT VALID
              	;
              	; DETECTED VALID START BIT,READ IN DATA
              	;
0D64: 0608    		LD	B,08H
0D66: 2A30F4  	RXDAT2:	LD	HL,(BAUD)
0D69: CD790D  		CALL	BITIME	;DELAY ONE BIT TIME
0D6C: DBC0    		IN	A,(SERIAL_RX_PORT)
0D6E: CB17    		RL	A
0D70: CB19    		RR	C	;SHIFT BIT INTO DATA REG
0D72: 10F2    		DJNZ	RXDAT2
0D74: 79      		LD	A,C
0D75: B7      		OR	A	;CLEAR CARRY FLAG
0D76: E1      	    POP	HL
0D77: C1      		POP	BC
0D78: C9      		RET
              	;---------------
              	; BIT TIME DELAY
              	;---------------
              	;DELAY FOR ONE SERIAL BIT TIME
              	;ENTRY : HL = DELAY TIME
              	; NO REGISTERS MODIFIED
              	;
0D79: E5      	BITIME:	PUSH	HL
0D7A: D5      		PUSH	DE
0D7B: 110100  		LD	DE,0001H
0D7E: ED52    	BITIM1:	SBC	HL,DE
0D80: D27E0D  		JP	NC,BITIM1
0D83: D1      		POP	DE
0D84: E1      		POP	HL
0D85: C9      		RET
              	#include "Monitor.asm"
              	; -----------------------------------------------------------------------------
              	;   START_MONITOR
              	; -----------------------------------------------------------------------------
0D86:         	START_MONITOR:
0D86: 31F0FF  	    LD  SP, SYSTEM  ; Set stack point
              	
0D89: 3E00    	    LD A, 0
0D8B: 322EF4  	    LD (PORT_OUT_VAL), A ; Set default value to port
              	
0D8E: 3EC0    	    LD A, $c0
0D90: 322DF4  	    LD (PORT_SET), A
              	
0D93: CDD40C  	    CALL INIT_SOFTSERIAL ; Initialize software serial
              	
              	    ; Init LCD hardware
0D96: CDAE02  	    CALL INIT_LCD
0D99: CDCA04  	    call delay
              	
0D9C: CDB205  	    call cls_TXT
0D9F: CDCA04  	    call delay
              	
0DA2: CD6005  	    CALL enable_grafic
0DA5: CDCA04  	    call delay
              	
0DA8: CDBD05  	    call cls_GRAPHIC
0DAB: CDCA04  	    call delay
              	
0DAE:         	RESET_WARM:
0DAE: CD4E05  	    call lcd_clear
              	
              	    ; Init LCD logical
0DB1: CDCD02  	    call INIT_TXT_LCD ; set cursor X Y to 0
              	
0DB4: 213813  	    LD HL, MSG_MONITOR
0DB7: CD3A06  	    CALL SNDLCDMSG
              	
0DBA: 3E3E    	    LD A, '>'
0DBC: CD6803  	    CALL PRINTCHAR
              	
0DBF:         	KEY:
0DBF: CD5A02  	    CALL KEYREADINIT
              	
0DC2: FE48    	    CP 'H'
0DC4: CCA011  	    CALL Z, SHOWHELP
              	
0DC7: FE80    	    CP KF1
0DC9: CA0080  	    JP Z, $8000
              	
0DCC: FE81    	    CP KF2
0DCE: CA8511  	    JP Z, INTEL_HEX
              	
0DD1: FE42    	    CP 'B'
0DD3: CA240E  	    JP Z, START_BASIC
              	
0DD6: FE47    	    CP 'G'
0DD8: CC9D12  	    CALL Z, GOJUMP
              	
0DDB: FE4D    	    CP 'M'
0DDD: CC3B12  	    CALL Z, MODIFY
              	
0DE0: FE44    	    CP 'D'
0DE2: CC420F  	    CALL Z, DSPLAY
              	
0DE5: FE4F    	    CP 'O'
0DE7: CCC00F  	    CALL Z, OUTPORT
              	
0DEA: FE49    	    CP 'I'
0DEC: CCD70F  	    CALL Z, INPORT_MON
              	
0DEF: FE31    	    CP '1'
0DF1: CC260C  	    CALL Z, I2CLIST
              	
0DF4: FE32    	    CP '2'
0DF6: CCFA10  	    CALL Z, I2CCPUTOMEM
              	
0DF9: FE33    	    CP '3'
0DFB: CCD210  	    CALL Z, I2CMEMTOCPU
              	
0DFE: FE34    	    CP '4'
0E00: CCF30F  	    CALL Z, I2C_WR_DD
              	
0E03: FE35    	    CP '5'
0E05: CC1610  	    CALL Z, I2C_WR_RR_DD
              	
0E08: FE36    	    CP '6'
0E0A: CC4210  	    CALL Z, I2C_RD
              	
0E0D: FE37    	    CP '7'
0E0F: CC7310  	    CALL Z, I2C_RD_RR
              	
0E12: FE38    	    CP '8'
0E14: CC3F0E  	    CALL Z, READ_MEM_FILES
              	
              	
              	
              	
              	
              	
              	
0E17: 3E0D    	    LD A, CR 
0E19: CD6803  	    CALL PRINTCHAR
0E1C: 3E3E    	    LD A, '>' 
0E1E: CD6803  	    CALL PRINTCHAR
              	
0E21: C3BF0D  	    JP  KEY
              	
              	
              	
              	;--------------------------
              	; Start basic
              	;--------------------------
0E24:         	START_BASIC:
0E24: 3E0C    	    LD A, CS
0E26: CD6803  	    CALL PRINTCHAR
              	
0E29: 215815  	    LD HL, MSG_BASIC
0E2C: CD3A06  	    CALL SNDLCDMSG
0E2F:         	START_BASIC_KEY:
0E2F: CD5A02  	    CALL KEYREADINIT ; read key
0E32: FE43    	    CP    'C' ; Cold
0E34: CA0060  	    JP    Z, BASIC
0E37: FE57    	    CP    'W'  ; Warm
0E39: CA0260  	    JP    Z, BASIC_W
0E3C: C32F0E  	    JP START_BASIC_KEY
              	
              	
              	
              	;--------------------------
              	; Read memory
              	;--------------------------
0E3F:         	READ_MEM_FILES:
0E3F: 110000  	    LD DE, $0000 ; start "D"
0E42:         	READ_MEM_NEXT:
0E42: CD210F  	    CALL READ_IIC_DE
0E45: B7      	    OR A
0E46: FE44    	    CP 'D'
0E48: CC4C0E  	    CALL Z, READ_FILE
              	
0E4B: C9      	    RET
              	
0E4C:         	READ_FILE:
0E4C: 3E0D    	    LD A, CR
0E4E: CD6803  	    CALL PRINTCHAR ; new line
0E51: 3E0D    	    LD A, CR
0E53: CD6803  	    CALL PRINTCHAR ; new line
0E56: 0610    	    LD B, 16
0E58:         	READ_NAME:
0E58: 13      	    INC DE
0E59: CD210F  	    CALL READ_IIC_DE
0E5C: B7      	    OR A
0E5D: FE00    	    CP 0
0E5F: C46803  	    CALL NZ, PRINTCHAR
0E62: 05      	    DEC B
0E63: C2580E  	    JP NZ, READ_NAME
              	
0E66:         	READ_MEM_KEY:
              	
              	    ; Show commands
0E66: D5      	    PUSH DE
0E67: 13      	    INC DE
0E68: CD210F  	    CALL READ_IIC_DE
0E6B: B7      	    OR A
0E6C: FE00    	    CP 0
0E6E: CC0C0F  	    CALL Z, SHOW_MSG_EXE
0E71: FE01    	    CP 1
0E73: CC130F  	    CALL Z, SHOW_MSG_IMG
0E76: FE02    	    CP 2
0E78: CC1A0F  	    CALL Z, SHOW_MSG_TXT
0E7B: D1      	    POP DE
              	
              	    ; wait command
0E7C: CD5A02  	    CALL KEYREADINIT ; read key
0E7F: FE03    	    CP    CTRLC ; key BK, read next
0E81: CA9E0E  	    JP    Z, READ_MEM_STEP
0E84: FE0D    	    CP    CR  ; key Enter, execute
0E86: C2660E  	    JP    NZ, READ_MEM_KEY
              	
              	    ;read type
0E89: 13      	    INC DE
0E8A: CD210F  	    CALL READ_IIC_DE
0E8D: B7      	    OR A
0E8E: FE00    	    CP 0
0E90: CAB50E  	    JP Z, READ_FILE_EXE
0E93: FE01    	    CP 1
0E95: CACB0E  	    JP Z, READ_FILE_IMG
0E98: FE02    	    CP 2
0E9A: CAEC0E  	    JP Z, READ_FILE_TXT
0E9D: C9      	    RET
              	
0E9E:         	READ_MEM_STEP:
0E9E: 13      	    INC DE ; type
              	
0E9F: 13      	    INC DE ; size H
0EA0: CD210F  	    CALL READ_IIC_DE
0EA3: 67      	    LD H, A
              	
0EA4: 13      	    INC DE ; size L
0EA5: CD210F  	    CALL READ_IIC_DE
0EA8: 6F      	    LD L, A
              	
0EA9:         	READ_MEM_STEP_L:
0EA9: 13      	    INC DE ; step file
0EAA: 2B      	    DEC HL
0EAB: 7C      	    LD A, H
0EAC: B5      	    OR L
0EAD: C2A90E  	    JP NZ, READ_MEM_STEP_L
0EB0: 13      	    INC DE ; end
0EB1: 13      	    INC DE ; nex start
0EB2: C3420E  	    JP READ_MEM_NEXT
              	
              	
              	
              	
              	
0EB5:         	READ_FILE_EXE:
              	    ; read size H
0EB5: 13      	    INC DE
0EB6: CD210F  	    CALL READ_IIC_DE
0EB9: 47      	    LD B, A
              	
              	    ; read size L
0EBA: 13      	    INC DE
0EBB: CD210F  	    CALL READ_IIC_DE
0EBE: 4F      	    LD C, A
              	
0EBF: 13      	    INC DE ; first byte file
0EC0: 210080  	    LD HL, $8000 ; memory user
              	
0EC3: CD500C  	    CALL I2C_MemRd
0EC6: E1      	    POP HL ; return
0EC7: C30080  	    JP $8000
              	
0ECA: C9      	    RET
              	
0ECB:         	READ_FILE_IMG:
              	    ; read size H
0ECB: 13      	    INC DE
0ECC: CD210F  	    CALL READ_IIC_DE
0ECF: 47      	    LD B, A
              	
              	    ; read size L
0ED0: 13      	    INC DE
0ED1: CD210F  	    CALL READ_IIC_DE
0ED4: 4F      	    LD C, A
              	
0ED5: 13      	    INC DE ; first byte file
0ED6: 210080  	    LD HL, $8000 ; memory user
              	
0ED9: CD500C  	    CALL I2C_MemRd
              	
0EDC: 2680    	    LD H, $80
0EDE: 2E00    	    LD L, $00
0EE0: CD7905  	    CALL print_image
              	
0EE3:         	READ_FILE_IMG_K:
0EE3: CD5A02  	    CALL KEYREADINIT ; read key
0EE6: FE03    	    CP    CTRLC ; key BK, read next
0EE8: C2E30E  	    JP    NZ, READ_FILE_IMG_K
              	
0EEB: C9      	    RET
              	
0EEC:         	READ_FILE_TXT:
0EEC: 3E0C    	    LD A, $0C ; clear screen
0EEE: CD6803  	    CALL PRINTCHAR
              	
              	    ; read size H
0EF1: 13      	    INC DE
0EF2: CD210F  	    CALL READ_IIC_DE
0EF5: 47      	    LD B, A
              	
              	    ; read size L
0EF6: 13      	    INC DE
0EF7: CD210F  	    CALL READ_IIC_DE
0EFA: 4F      	    LD C, A
              	
0EFB: 13      	    INC DE ; first byte file
              	
0EFC:         	READ_FILE_TXT_L:
0EFC: CD210F  	    CALL READ_IIC_DE
0EFF: CD6803  	    CALL PRINTCHAR
0F02: 13      	    INC DE ; step file
0F03: 0B      	    DEC BC
0F04: 78      	    LD A, B
0F05: B1      	    OR C
0F06: C2FC0E  	    JP NZ, READ_FILE_TXT_L
0F09: 13      	    INC DE ; end
0F0A: 13      	    INC DE ; nex start    
0F0B: C9      	    RET
              	
              	
0F0C:         	SHOW_MSG_EXE:
0F0C: 215D14  	    LD HL, MSG_READFILE_EXE
0F0F: CD3A06  	    CALL SNDLCDMSG
0F12: C9      	    RET
              	
0F13:         	SHOW_MSG_IMG:
0F13: 216214  	    LD HL, MSG_READFILE_IMG
0F16: CD3A06  	    CALL SNDLCDMSG
0F19: C9      	    RET
              	
0F1A:         	SHOW_MSG_TXT:
0F1A: 216714  	    LD HL, MSG_READFILE_TXT
0F1D: CD3A06  	    CALL SNDLCDMSG
0F20: C9      	    RET
              	
              	
              	
              	
              	; Read byte in i2c, address in DE, return byte in A
0F21:         	READ_IIC_DE:
0F21: C5      	    PUSH BC
0F22: D5      	    PUSH DE
0F23: E5      	    PUSH HL
0F24: 3EAE    	    LD   A, I2CA_BLOCK   ;I2C address to write to
0F26: CD660B  	    CALL I2C_Open
0F29: 7A      	    LD   A, D           ;Address (hi) in I2C memory
0F2A: CD700B  	    CALL I2C_Write      ;Write address
0F2D: 7B      	    LD   A,E            ;Address (lo) in I2C memory
0F2E: CD700B  	    CALL I2C_Write      ;Write address
0F31: 3EAF    	    LD   A,I2CA_BLOCK+1 ;I2C device to be read from
0F33: CD660B  	    CALL I2C_Open       ;Open for read
0F36: CDAD0B  	    CALL I2C_Read
0F39: F5      	    PUSH AF
0F3A: CDE50B  	    CALL I2C_Stop       ;Generate I2C stop
0F3D: F1      	    POP AF
0F3E: E1      	    POP HL
0F3F: D1      	    POP DE
0F40: C1      	    POP BC
0F41: C9      	    RET
              	
              	
              	
              	
              	
              	
              	
              	;--------------------------
              	; D DISPLAY MEMORY LOCATION
              	;--------------------------
0F42: 3E44    	DSPLAY: LD A, 'D'
0F44: CD6803  	        CALL PRINTCHAR
0F47: CD4103  	        CALL  OUTSP       ;A SPACE
0F4A: CDF001  	       CALL  GETCHR_KEYBOARD
0F4D: D8      	       RET   C         
0F4E: 3226F4  	       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0F51: CDF001  	       CALL  GETCHR_KEYBOARD
0F54: D8      	       RET   C
0F55: 3225F4  	       LD    (ADDR),A    ;SAVE ADDRESS LOW 
              	;
              	; WAIT FOR CR OR ESC
              	;
0F58: CD5A02  	DPLAY1: CALL  KEYREADINIT
0F5B: FE1B    	       CP    ESC
0F5D: C8      	       RET   Z
0F5E: FE0D    	       CP    CR
0F60: 20F6    	       JR    NZ,DPLAY1          
0F62: CD4703  	       CALL  TXCRLF      ;NEWLINE
              	;
              	; DISPLAY THE LINE
              	;
0F65: CD7A0F  	DPLAY2: CALL  DPLINE
0F68: ED5325F4	       LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
              	;
              	; DISPLAY MORE LINES OR EXIT
              	;       
0F6C: CD5A02  	DPLAY3: CALL  KEYREADINIT
0F6F: 38FB    	       JR    C,DPLAY3   
0F71: FE0D    	       CP    CR        ;ENTER DISPLAYS THE NEXT LINE
0F73: 28F0    	       JR    Z,DPLAY2
0F75: FE1B    	       CP    ESC         ;ESC EXITS (SHIFT + C)
0F77: 20F3    	       JR    NZ,DPLAY3     
0F79: C9      	       RET   
              	;-------------------------
              	; DISPLAY A LINE OF MEMORY
              	;-------------------------      
0F7A: ED5B25F4	DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
0F7E: 2101F4  	       LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
              	;
              	; DISPLAY THE ADDRESS
              	;         
0F81: CD2212  	       CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
0F84: CDBA0F  	       CALL  SPCBUF        
              	;
              	; DISPLAY 4 BYTES
              	;
0F87: 0604    	       LD    B,4 ;16
0F89: 1A      	DLINE1: LD    A,(DE)
0F8A: CD2712  	       CALL  BYTASC
0F8D: CDBA0F  	       CALL  SPCBUF
0F90: 13      	       INC   DE        
0F91: 10F6    	       DJNZ  DLINE1
              	       ;CALL  SPCBUF
              	;
              	; NOW DISPLAY THE ASCII CHARACTER
              	; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
              	; BE DIFFERENT BETWEEN THE TWO PASSES!
              	;
0F93: ED5B25F4	       LD    DE,(ADDR)    
0F97: 0604    	       LD    B,4 ; 4 bytes
0F99: 1A      	DLINE2: LD    A,(DE)   
0F9A: FE20    	       CP    20H
0F9C: 3807    	       JR    C,DOT
0F9E: FE7F    	       CP    7FH
0FA0: 3003    	       JR    NC,DOT
0FA2: C3A70F  	       JP    NDOT
0FA5: 3E2E    	DOT:    LD    A,'.'
0FA7: CDBC0F  	NDOT:   CALL  INBUF
0FAA: 13      	       INC   DE       
0FAB: 10EC    	       DJNZ  DLINE2
              	;         
              	;TERMINATE AND DISPLAY STRING
              	;       
0FAD: CDBF0F  	       CALL  BCRLF
0FB0: 3E00    	       LD    A,00H
0FB2: 77      	       LD    (HL),A
0FB3: 2101F4  	       LD    HL,MSGBUF
0FB6: CD3A06  	       CALL  SNDLCDMSG
0FB9: C9      	       RET
              	
              	
              	;
              	; PUT A SPACE IN THE BUFFER
              	;
0FBA: 3E08    	SPCBUF: LD    A, 8 ;20H(32dec)
0FBC: 77      	INBUF:  LD    (HL),A
0FBD: 23      	       INC   HL
0FBE: C9      	       RET
              	;
              	; PUT A CR LF IN THE BUFFER
              	;        
0FBF:         	BCRLF:  ;LD    A,CR  
              	       ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
0FBF: C9      	       RET
              	
              	
              	
              	;----------------------------------------------
              	; Output value to port
              	; O AA DD - Port address in AA, Data to out in DD
              	;----------------------------------------------
0FC0:         	OUTPORT:
0FC0: 3E4F    	    LD A, 'O'
0FC2: CD7A03  	    CALL PrintBufferChar
0FC5: CD4103  	    CALL OUTSP ; space and show lcd
              	
0FC8: CDF001  	    CALL  GETCHR_KEYBOARD 
0FCB: D8      	    RET   C
0FCC: 4F      	    LD C, A
              	
0FCD: CD4103  	    CALL OUTSP
              	
0FD0: CDF001  	    CALL  GETCHR_KEYBOARD 
0FD3: D8      	    RET   C
0FD4: ED79    	    OUT (C), A
0FD6: C9      	    RET
              	
              	
              	;----------------------------------------------
              	; Read input port and show value to LCD
              	; I AA - Port address in AA
              	;----------------------------------------------
0FD7:         	INPORT_MON:
0FD7: 3E49    	    LD A, 'I'
0FD9: CD7A03  	    CALL PrintBufferChar
0FDC: CD4103  	    CALL OUTSP ; space and show lcd
              	
0FDF: CDF001  	    CALL  GETCHR_KEYBOARD 
0FE2: D8      	    RET   C
0FE3: 4F      	    LD C, A
              	
0FE4: ED78    	    IN A, (C)
              	
0FE6: 47      	    LD B, A
0FE7: C5      	    PUSH BC
0FE8: 3E0D    	    LD A, CR
0FEA: CD6803  	    CALL PRINTCHAR
0FED: C1      	    POP BC
0FEE: 78      	    LD A, B
              	
0FEF: CDC512  	    CALL CONV_A_HEX
0FF2: C9      	    RET
              	
              	
              	; --------------------------------------
              	; I2C - Write one byte
              	; --------------------------------------
0FF3:         	I2C_WR_DD:
0FF3: 3E0C    	    LD A, $0C ; limpar tela
0FF5: CD6803  	    CALL PRINTCHAR
              	
              	    ; Show msg func
0FF8: 21AF14  	    LD HL, MSG_I2C_WR_DD
0FFB: CD3A06  	    CALL SNDLCDMSG
              	
              	    ; Device Address
0FFE: CDA810  	    CALL GET_DEV_ADDR ; get address
              	
1001:         	I2C_WR_DD_LOOP:
              	    ; Get Data
1001: CDB610  	    CALL GET_DEV_DD   ; get data
              	
              	    ; Send
1004: 3A22F4  	    LD A, (I2C_ADDR) ; Open
1007: CD660B  	    CALL I2C_Open
              	
100A: 3A24F4  	    LD A, (I2C_DD)  ; Data
100D: CD700B  	    CALL I2C_Write
              	 
1010: CD6D0B  	    CALL I2C_Close  ; Close
              	
1013: 18EC    	    JR I2C_WR_DD_LOOP
              	
1015: C9      	    RET
              	
              	
              	
              	; --------------------------------------
              	; I2C - Write register one byte
              	; --------------------------------------
1016:         	I2C_WR_RR_DD:
1016: 3E0C    	    LD A, $0C ; limpar tela
1018: CD6803  	    CALL PRINTCHAR
              	
              	    ; Show msg func
101B: 21C014  	    LD HL, MSG_I2C_WR_RR_DD
101E: CD3A06  	    CALL SNDLCDMSG
              	
              	    ; Device Address
1021: CDA810  	    CALL GET_DEV_ADDR ; get address
              	
1024:         	I2C_WR_RR_DD_LOOP:
              	    ; Get register
1024: CDC410  	    CALL GET_DEV_RR ; get address
              	
              	    ; Get Data
1027: CDB610  	    CALL GET_DEV_DD   ; get data
              	
              	    ; Send
102A: 3A22F4  	    LD A, (I2C_ADDR) ; Open
102D: CD660B  	    CALL I2C_Open
              	
1030: 3A23F4  	    LD A, (I2C_RR)  ; register
1033: CD700B  	    CALL I2C_Write
              	
1036: 3A24F4  	    LD A, (I2C_DD)  ; Data
1039: CD700B  	    CALL I2C_Write
              	
103C: CD6D0B  	    CALL I2C_Close  ; Close
              	
103F: 18E3    	    JR I2C_WR_RR_DD_LOOP
              	
1041: C9      	    RET
              	
              	
              	; --------------------------------------
              	; I2C - Read one byte
              	; --------------------------------------
1042:         	I2C_RD:
1042: 3E0C    	    LD A, $0C ; limpar tela
1044: CD6803  	    CALL PRINTCHAR
              	
              	    ; Show msg func
1047: 21D514  	    LD HL, MSG_I2C_RD
104A: CD3A06  	    CALL SNDLCDMSG
              	
              	    ; Device Address
104D: CDA810  	    CALL GET_DEV_ADDR ; get address
1050: CD4703  	    CALL TXCRLF ; new line
              	
1053:         	I2C_RD_LOOP:
              	    ; Send
1053: 3A22F4  	    LD A, (I2C_ADDR) ; Open
1056: 3C      	    INC A ; To read address + 1 (flag)
1057: CD660B  	    CALL I2C_Open
              	
105A: CDAD0B  	    CALL I2C_Read      ; Read
105D: F5      	    PUSH AF
              	
105E: CD6D0B  	    CALL I2C_Close     ; Close
              	
              	    ; Show
1061: F1      	    POP AF
1062: CDC512  	    CALL CONV_A_HEX ; Show A to (HEX) LCD
1065: CD4703  	    CALL TXCRLF ; new line
              	
1068: CD5A02  	    CALL KEYREADINIT
106B: FE03    	    CP CTRLC
106D: CAAE0D  	    JP Z, RESET_WARM
              	
1070: 18E1    	    JR I2C_RD_LOOP
1072: C9      	    RET
              	
              	
              	; --------------------------------------
              	; I2C - Read register one byte
              	; --------------------------------------
1073:         	I2C_RD_RR:
1073: 3E0C    	    LD A, $0C ; limpar tela
1075: CD6803  	    CALL PRINTCHAR
              	
              	    ; Show msg func
1078: 21E514  	    LD HL, MSG_I2C_RD_RR
107B: CD3A06  	    CALL SNDLCDMSG
              	
              	    ; Device Address
107E: CDA810  	    CALL GET_DEV_ADDR ; get address
              	
1081:         	I2C_RD_RR_LOOP:
              	    ; Get register
1081: CDC410  	    CALL GET_DEV_RR ; get address
1084: CD4703  	    CALL TXCRLF ; new line
              	
              	    ; Send
1087: 3A22F4  	    LD A, (I2C_ADDR) ; Open
108A: CD660B  	    CALL I2C_Open
              	
108D: 3A23F4  	    LD A, (I2C_RR)
1090: CD700B  	    CALL I2C_Write ; Register to read
              	
1093: 3A22F4  	    LD A, (I2C_ADDR) ; Open
1096: 3C      	    INC A ; To read address + 1 (flag)
1097: CD660B  	    CALL I2C_Open
              	
109A: CDAD0B  	    CALL I2C_Read ; Read register
109D: F5      	    PUSH AF
              	
109E: CD6D0B  	    CALL I2C_Close ; Close
              	
              	    ; Show
10A1: F1      	    POP AF
10A2: CDC512  	    CALL CONV_A_HEX ; Show A to (HEX) LCD
              	
10A5: 18DA    	    JR I2C_RD_RR_LOOP
10A7: C9      	    RET
              	
              	
10A8:         	GET_DEV_ADDR:
10A8: 212915  	    LD HL, MSG_DEV_ADDR
10AB: CD3A06  	    CALL SNDLCDMSG
10AE: CDF001  	    CALL  GETCHR_KEYBOARD 
10B1: D8      	    RET   C
10B2: 3222F4  	    LD (I2C_ADDR), A
10B5: C9      	    RET
              	
10B6:         	GET_DEV_DD:
10B6: 214C15  	    LD HL, MSG_DEV_DATA
10B9: CD3A06  	    CALL SNDLCDMSG
              	
10BC: CDF001  	    CALL  GETCHR_KEYBOARD 
10BF: D8      	    RET   C
10C0: 3224F4  	    LD (I2C_DD), A
10C3: C9      	    RET
              	
10C4:         	GET_DEV_RR:
10C4: 213C15  	    LD HL, MSG_DEV_REG
10C7: CD3A06  	    CALL SNDLCDMSG
              	
10CA: CDF001  	    CALL  GETCHR_KEYBOARD 
10CD: D8      	    RET   C
10CE: 3223F4  	    LD (I2C_RR), A
10D1: C9      	    RET
              	
              	
              	
              	
10D2:         	I2CMEMTOCPU:
              	    ; Get parameters to copy a block from I2C memory to CPU memory
              	;   On entry: DE = First address in I2C memory
              	;             HL = First address in CPU memory
              	;             BC = Number of bytes to be copied
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             IX IY preserved
              	
10D2: 218314  	    LD HL, MSG_MEM2CPU
10D5: CD3A06  	    CALL SNDLCDMSG
              	
10D8: CD2211  	    CALL GET_FROM_TO_SIZE
              	
              	;    DE = First address in I2C memory
              	;    HL = First address in CPU memory
              	;    BC = Number of bytes to be copied
              	
10DB: ED5B27F4	    LD DE, (ADDR_FROM)
10DF: 2A29F4  	    LD HL, (ADDR_TO)
10E2: ED4B2BF4	    LD BC, (ADDR_SIZE)
10E6: CD500C  	    CALL I2C_MemRd  
              	
10E9: CAF310  	    JP Z, I2CMEMTOCPU_OK
10EC: 211E15  	    LD HL, MSG_COPYFAIL
10EF: CD3A06  	    CALL SNDLCDMSG
10F2: C9      	    RET
10F3:         	I2CMEMTOCPU_OK:
10F3: 211515  	    LD HL, MSG_COPYOK
10F6: CD3A06  	    CALL SNDLCDMSG
10F9: C9      	    RET
              	
              	
10FA:         	I2CCPUTOMEM:
              	; Get parameters to copy a block from CPU memory to I2C memory
              	;   On entry: DE = First address in I2C memory
              	;             HL = First address in CPU memory
              	;             BC = Number of bytes to be copied
              	;             SCL = unknown, SDA = unknown
              	;   On exit:  If successfully A = 0 and Z flagged
              	;             If unsuccessfully A = Error and NZ flagged
              	;             IX IY preserved
              	; The 24LC64 requires blocks of data to be written in 64 byte (or less)
              	; pages.
10FA: 219914  	    LD HL, MSG_CPU2MEM
10FD: CD3A06  	    CALL SNDLCDMSG
              	
1100: CD2211  	    CALL GET_FROM_TO_SIZE
              	
              	;    DE = First address in I2C memory
              	;    HL = First address in CPU memory
              	;    BC = Number of bytes to be copied
              	
1103: 2A27F4  	    LD HL, (ADDR_FROM)
1106: ED5B29F4	    LD DE, (ADDR_TO)
110A: ED4B2BF4	    LD BC, (ADDR_SIZE)
110E: CD850C  	    CALL I2C_MemWr
              	    
1111: CA1B11  	    JP Z, I2CCPUTOMEM_OK
1114: 211E15  	    LD HL, MSG_COPYFAIL
1117: CD3A06  	    CALL SNDLCDMSG
111A: C9      	    RET
111B:         	I2CCPUTOMEM_OK:
111B: 211515  	    LD HL, MSG_COPYOK
111E: CD3A06  	    CALL SNDLCDMSG
1121: C9      	    RET
              	
              	
              	
              	
              	
              	
1122:         	GET_FROM_TO_SIZE:
              	    ; FROM
1122: 21F914  	    LD HL, MSG_FROM
1125: CD3A06  	    CALL SNDLCDMSG
              	    ;
              	    ;GET THE ADDRESS  FROM
              	    ;
1128: CDF001  	    CALL  GETCHR_KEYBOARD 
112B: D8      	    RET   C        
112C: 3228F4  	    LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
112F: CDF001  	    CALL  GETCHR_KEYBOARD
1132: D8      	    RET   C
1133: 3227F4  	    LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW
              	
1136: CD5A02  	    CALL  KEYREADINIT
1139: FE1B    	    CP    ESC         ;ESC KEY?
113B: C8      	    RET   Z
113C: FE0D    	    CP    CR
113E: 2808    	    JR Z, GET_FROM_TO_SIZE_TO
1140: 3E0D    	    LD A, CR
1142: CD6803  	    CALL PRINTCHAR
1145: C32211  	    JP GET_FROM_TO_SIZE
              	
1148:         	GET_FROM_TO_SIZE_TO:
              	    ; TO
1148: 210015  	    LD HL, MSG_TO
114B: CD3A06  	    CALL SNDLCDMSG
              	    ;
              	    ;GET THE ADDRESS  TO
              	    ;
114E: CDF001  	    CALL  GETCHR_KEYBOARD 
1151: D8      	    RET   C        
1152: 322AF4  	    LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
1155: CDF001  	    CALL  GETCHR_KEYBOARD
1158: D8      	    RET   C
1159: 3229F4  	    LD    (ADDR_TO),A    ;SAVE ADDRESS LOW
              	
115C: CD5A02  	    CALL  KEYREADINIT
115F: FE1B    	    CP    ESC         ;ESC KEY?
1161: C8      	    RET   Z
1162: FE0D    	    CP    CR
1164: 20E2    	    JR NZ, GET_FROM_TO_SIZE_TO
              	
1166:         	GET_FROM_TO_SIZE_SIZE:
              	    ; SIZE
1166: 210615  	    LD HL, MSG_SIZE
1169: CD3A06  	    CALL SNDLCDMSG
              	    ;
              	    ;GET THE SIZE
              	    ;
116C: CDF001  	    CALL  GETCHR_KEYBOARD 
116F: D8      	    RET   C        
1170: 322CF4  	    LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
1173: CDF001  	    CALL  GETCHR_KEYBOARD
1176: D8      	    RET   C
1177: 322BF4  	    LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW
              	
117A: CD5A02  	    CALL  KEYREADINIT
117D: FE1B    	    CP    ESC         ;ESC KEY?
117F: C8      	    RET   Z
1180: FE0D    	    CP    CR
1182: 20E2    	    JR NZ, GET_FROM_TO_SIZE_SIZE
1184: C9      	    RET
              	
              	
1185:         	INTEL_HEX:
1185: CDB30A  	    CALL INTHEX
1188: CDCA04  	    CALL delay
118B: CDCA04  	    CALL delay
118E: C3860D  	    JP START_MONITOR
              	
              	
              	
1191:         	BREAK_CONTINUE:
1191: 215114  	    LD HL, MSG_MENU_CONTINUE
1194: CD3A06  	    CALL SNDLCDMSG
1197:         	BREAK_CONTINUE_LOOP:
1197: CD5A02  	    CALL  KEYREADINIT
119A: FE0D    	    CP    CR         ;ENTER KEY?
119C: C29711  	    JP   NZ, BREAK_CONTINUE_LOOP
119F: C9      	    RET
              	
              	
11A0:         	SHOWHELP:
11A0: 3E0C    	    LD A, $0C ; limpar tela
11A2: CD6803  	    CALL PRINTCHAR
              	
11A5: 214D13  	    LD HL, MSG_MENU0
11A8: CD3A06  	    CALL SNDLCDMSG
              	
11AB: 216013  	    LD HL, MSG_MENU1
11AE: CD3A06  	    CALL SNDLCDMSG
              	
11B1: 217513  	    LD HL, MSG_MENU2
11B4: CD3A06  	    CALL SNDLCDMSG
              	
11B7: 218013  	    LD HL, MSG_MENU3
11BA: CD3A06  	    CALL SNDLCDMSG
              	
11BD: 219213  	    LD HL, MSG_MENU4
11C0: CD3A06  	    CALL SNDLCDMSG
              	
11C3: 21A313  	    LD HL, MSG_MENU5
11C6: CD3A06  	    CALL SNDLCDMSG
              	
11C9: 21B313  	    LD HL, MSG_MENU6
11CC: CD3A06  	    CALL SNDLCDMSG
              	
11CF: CD9111  	    CALL BREAK_CONTINUE ; <------------
11D2: 3E0C    	    LD A, $0C ; limpar tela
11D4: CD6803  	    CALL PRINTCHAR
              	
11D7: 21C013  	    LD HL, MSG_MENU7
11DA: CD3A06  	    CALL SNDLCDMSG
              	
11DD: 21C913  	    LD HL, MSG_MENU8
11E0: CD3A06  	    CALL SNDLCDMSG
              	
11E3: 21D513  	    LD HL, MSG_MENU9
11E6: CD3A06  	    CALL SNDLCDMSG
              	
11E9: 21E613  	    LD HL, MSG_MENU10
11EC: CD3A06  	    CALL SNDLCDMSG
              	
11EF: 21F713  	    LD HL, MSG_MENU11
11F2: CD3A06  	    CALL SNDLCDMSG
              	
11F5: 210714  	    LD HL, MSG_MENU12
11F8: CD3A06  	    CALL SNDLCDMSG
              	
11FB: 211A14  	    LD HL, MSG_MENU13
11FE: CD3A06  	    CALL SNDLCDMSG
              	
1201: CD9111  	    CALL BREAK_CONTINUE ; <------------
1204: 3E0C    	    LD A, $0C ; limpar tela
1206: CD6803  	    CALL PRINTCHAR
              	
1209: 212F14  	    LD HL, MSG_MENU14
120C: CD3A06  	    CALL SNDLCDMSG
              	
120F: 214314  	    LD HL, MSG_MENU15
1212: CD3A06  	    CALL SNDLCDMSG
              	
1215: C9      	    RET
              	
              	
              	
              	;----------------------     
              	; SEND ASCII HEX VALUES        
              	;----------------------
              	;
              	; OUTPUT THE 4 BYTE, WRDOUT
              	; THE 2 BYTE, BYTOUT
              	; OR THE SINGLE BYTE, NYBOUT
              	; ASCII STRING AT HL TO THE SERIAL PORT
              	;
1216: CD1912  	WRDOUT: CALL  BYTOUT
1219: CD1C12  	BYTOUT: CALL  NYBOUT
121C: 7E      	NYBOUT: LD    A,(HL)
121D: CD6803  	       CALL  PRINTCHAR
1220: 23      	       INC   HL
1221: C9      	       RET       
              	
              	
              	
              	;----------------
              	;CONVERT TO ASCII 
              	;----------------
              	;
              	; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
              	;
              	;         ENTRY :  A = BINARY TO CONVERT
              	;                  HL = CHARACTER BUFFER ADDRESS   
              	;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
              	;   
              	;        MODIFIES : DE
              	
1222: 7A      	WRDASC: LD    A,D         ;CONVERT AND
1223: CD2712  	       CALL  BYTASC      ;OUTPUT D
1226: 7B      	       LD    A,E         ;THEN E
              	;
              	;CONVERT A BYTE TO ASCII 
              	;
1227: F5      	BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
1228: 0F      	       RRCA              ;SHIFT HIGH NYBBLE ACROSS
1229: 0F      	       RRCA
122A: 0F      	       RRCA
122B: 0F      	       RRCA
122C: CD3012  	       CALL NYBASC       ;CALL NYBBLE CONVERTER 
122F: F1      	       POP AF            ;RESTORE LOW NYBBLE
              	;           
              	; CONVERT A NYBBLE TO ASCII
              	;
1230: E60F    	NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
1232: C690    	       ADD   A,90H       ;CONVERT TO
1234: 27      	       DAA               ;ASCII
1235: CE40    	       ADC   A,40H
1237: 27      	       DAA
              	;            
              	; SAVE IN STRING
              	;
1238: 77      	INSBUF: LD    (HL),A
1239: 23      	       INC   HL 
123A: C9      	       RET 
              	
              	
              	
              	
              	;----------------------------
              	; M DISPLAY AND MODIFY MEMORY
              	;----------------------------
123B: 3E4D    	MODIFY: LD A, 'M'
123D: CD6803  	        CALL PRINTCHAR
1240: CD4103  	     CALL  OUTSP
              	;
              	;GET THE ADDRESS        
              	;
1243: CDF001  	       CALL  GETCHR_KEYBOARD 
1246: D8      	       RET   C        
1247: 3226F4  	       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
124A: CDF001  	       CALL  GETCHR_KEYBOARD
124D: D8      	       RET   C
124E: 3225F4  	       LD    (ADDR),A    ;SAVE ADDRESS LOW 
              	;
              	; DISPLAY ON A NEW LINE
              	;       
1251: CD4703  	MDIFY1: CALL  TXCRLF       
1254: ED5B25F4	       LD    DE,(ADDR)    
1258: 2101F4  	       LD    HL,MSGBUF   
125B: CD2212  	       CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
125E: 2101F4  	       LD    HL,MSGBUF
1261: CD1612  	       CALL  WRDOUT      ;OUTPUT THE ADDRESS
1264: CD4103  	       CALL  OUTSP    
              	;      
              	;GET THE DATA AT THE ADDRESS        
              	;
1267: 2A25F4  	        LD   HL,(ADDR)       
126A: 7E      	        LD   A,(HL)
              	;
              	; DISPLAY THE DATA
              	;        
126B: 2101F4  	       LD    HL,MSGBUF
126E: CD2712  	       CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
1271: 2101F4  	       LD    HL,MSGBUF
1274: CD1912  	       CALL  BYTOUT      ;OUTPUT THE BYTE
1277: CD4103  	       CALL  OUTSP
              	;
              	; GET NEW DATA,EXIT OR CONTINUE
              	;
127A: CDF001  	       CALL  GETCHR_KEYBOARD
127D: D8      	       RET   C
127E: 47      	       LD    B,A         ;SAVE IT FOR LATER
127F: 2A25F4  	       LD    HL,(ADDR)
1282: 77      	       LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
1283: 78      	       LD    A,B
1284: BE      	       CP    (HL)
1285: 2805    	       JR    Z,MDIFY2
1287: 3E3F    	       LD    A,'?'
1289: CD6803  	       CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
              	;
              	; INCREMENT THE ADDRESS
              	;
128C: 23      	MDIFY2: INC   HL
128D: 2225F4  	       LD    (ADDR),HL
1290: C35112  	       JP    MDIFY1
              	
              	
              	
              	;------------------------------
              	; GO <ADDR>
              	; TRANSFERS EXECUTION TO <ADDR>
              	;------------------------------
1293:         	GOJUMP_new:
1293: 3E0D    	    LD A, CR
1295: CD6803  	    CALL PRINTCHAR
              	
1298: 3E3E    	    LD A, '>'
129A: CD6803  	    CALL PRINTCHAR
              	
129D: 3E47    	GOJUMP: LD A, 'G'
129F: CD6803  	        CALL PRINTCHAR
12A2: CD4103  	       CALL  OUTSP       
12A5: CDF001  	       CALL  GETCHR_KEYBOARD      ;GET ADDRESS HIGH BYTE
12A8: D8      	       RET   C
12A9: 3226F4  	       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
12AC: CDF001  	       CALL  GETCHR_KEYBOARD      ;GET ADDRESS LOW BYTE
12AF: D8      	       RET   C
12B0: 3225F4  	       LD    (ADDR),A    ;SAVE ADDRESS LOW 
              	;
              	; WAIT FOR A CR OR ESC
              	;       
12B3: CD5A02  	GOJMP1: CALL  KEYREADINIT
12B6: FE1B    	       CP    ESC         ;ESC KEY?
12B8: C8      	       RET   Z
12B9: FE0D    	       CP    CR
              	       ;JR    NZ,GOJMP1
12BB: 20D6    	       JR NZ, GOJUMP_new
12BD: CD4703  	       CALL  TXCRLF
12C0: E1      	       POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
12C1: 2A25F4  	       LD    HL,(ADDR)
12C4: E9      	       JP    (HL)        ;GOOD LUCK WITH THAT!
              	#include "Utils.asm"
              	;----------------
              	;CONVERT A TO ASCII (HEX) AND SHOW LCD
              	;----------------
              	;
              	;CONVERT REG A BYTE TO ASCII 
              	;
12C5: F5      	CONV_A_HEX: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
12C6: 0F      	       RRCA              ;SHIFT HIGH NYBBLE ACROSS
12C7: 0F      	       RRCA
12C8: 0F      	       RRCA
12C9: 0F      	       RRCA
12CA: CDCE12  	       CALL CONV_A_HEX_NYBASC       ;CALL NYBBLE CONVERTER 
12CD: F1      	       POP AF            ;RESTORE LOW NYBBLE
              	;           
              	; CONVERT A NYBBLE TO ASCII
              	;
12CE: E60F    	CONV_A_HEX_NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
12D0: C690    	       ADD   A,90H       ;CONVERT TO
12D2: 27      	       DAA               ;ASCII
12D3: CE40    	       ADC   A,40H
12D5: 27      	       DAA
              	;            
              	; Print inlcd
              	;
12D6: CD6803  	    CALL PRINTCHAR
12D9: C9      	    RET 
              	
              	
              	; Space character ouput to console
              	;   On entry: No parameters required
              	;   On exit:  BC DE HL IX IY preserved
12DA:         	SpaceOut:   
12DA: 3E20    	            LD   A,$20
12DC: CF      	            RST $08 ; output chat to lcd
12DD: C9      	            RET
              	
              	; New line output to console device
              	;   On entry: No parameters required
              	;   On exit:  BC DE HL IX IY preserved
12DE: F5      	LineOut:    PUSH AF
12DF: 3E0D    	            LD A, CR ; enter char
12E1: CF      	            RST $08
12E2: C9      	            RET
              	
              	
              	; String output to console device
              	;   On entry: DE = Address of string
              	;   On exit:  BC DE HL IX IY preserved
12E3: C5      	StrOut:     PUSH BC             ;Preserve registers
12E4: D5      	            PUSH DE
12E5: E5      	            PUSH HL
12E6: 62      	            LD H, D
12E7: 6B      	            LD L, E
12E8: CD3A06  	            CALL SNDLCDMSG
12EB: E1      	            POP  HL             ;Restore registers
12EC: D1      	            POP  DE
12ED: C1      	            POP  BC
12EE: C9      	            RET
              	
              	            
              	
              	; **********************************************************************
              	; Delay by DE milliseconds
              	;   On entry: DE = Delay time in milliseconds
              	;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
12EF: F5      	H_Delay:    PUSH AF
12F0: C5      	            PUSH BC
12F1: D5      	            PUSH DE
              	; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
12F2: 019800  	LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
              	; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
12F5: 0B      	LoopBC:    DEC  BC             ;[6]     [4]
12F6: 79      	            LD   A,C            ;[4]     [4]
12F7: B0      	            OR   B              ;[4]     [4]
12F8: C2F512  	            JP   NZ,LoopBC     ;[12/7]  [8/6] 
              	; Have we looped once for each millisecond requested?
12FB: 1B      	            DEC  DE             ;[6]     [4]
12FC: 7B      	            LD   A,E            ;[4]     [4]
12FD: B2      	            OR   D              ;[4]     [4]
12FE: 20F2    	            JR   NZ, LoopDE     ;[12/7]  [8/6]
1300: D1      	            POP  DE
1301: C1      	            POP  BC
1302: F1      	            POP  AF
1303: C9      	            RET
              	
              	
              	; ----------------------------------
              	; INPUT: THE VALUES IN REGISTER B EN C
              	; OUTPUT: HL = B * C
              	; CHANGES: AF,DE,HL,B
              	;
1304:         	multiplication:
1304: 210000  		LD HL,0
1307: 78      		LD A,B
1308: B7      		OR A
1309: C8      		RET Z
130A: 1600    		LD D,0
130C: 59      		LD E,C
130D: 19      	multiplicationLOOP:	ADD HL,DE
130E: 10FD    		DJNZ multiplicationLOOP
1310: C9      		RET 
              	
              	;-----------------------------------
              	; Div_HL_D
              	;Inputs:
              	;   HL and D
              	;Outputs:
              	;   HL is the quotient (HL/D)
              	;   A is the remainder
              	;   B is 0
              	;   C,D,E are preserved
1311:         	Div_HL_D:
1311: AF      	    xor a         ; Clear upper eight bits of AHL
1312: 0610    	    ld b,16       ; Sixteen bits in dividend
1314:         	_loop:
1314: 29      	    add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
1315: 17      	    rla           ; This moves the upper bits of the dividend into A
1316: 3803    	    jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
1318: BA      	    cp d          ; Check if we can subtract the divisor
1319: 3802    	    jr c,_skip    ; Carry means A < D
131B:         	_overflow:
131B: 92      	    sub d         ; Do subtraction for real this time
131C: 2C      	    inc l         ; Set the next bit of the quotient (currently bit 0)
131D:         	_skip:
131D: 10F5    	    djnz _loop
131F: C9      	    ret
              	#include "Strings.asm"
1320: 0C0D0D0A	WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
1324: 5A383020	
1328: 4D696E69	
132C: 20496E69	
1330: 63696164	
1334: 6F0D0A00	
1338: 5A383020	MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H
133C: 4D494E49	
1340: 2C204820	
1344: 544F2048	
1348: 454C500D	
134C: 00      	
              	
134D: 46312052	MSG_MENU0  .db "F1 RUN (JP $8000)",CR, 00H
1351: 554E2028	
1355: 4A502024	
1359: 38303030	
135D: 290D00  	
1360: 46322049	MSG_MENU1  .db "F2 Intel hex loader",CR, 00H
1364: 6E74656C	
1368: 20686578	
136C: 206C6F61	
1370: 6465720D	
1374: 00      	
1375: 42202D20	MSG_MENU2  .db "B - Basic",CR, 00H
1379: 42617369	
137D: 630D00  	
1380: 44204141	MSG_MENU3  .db "D AAAA - DISPLAY",CR,00H
1384: 4141202D	
1388: 20444953	
138C: 504C4159	
1390: 0D00    	
1392: 4D204141	MSG_MENU4  .db "M AAAA - MODIFY",CR,00H
1396: 4141202D	
139A: 204D4F44	
139E: 4946590D	
13A2: 00      	
13A3: 47204141	MSG_MENU5  .db "G AAAA - GO TO",CR, 00H
13A7: 4141202D	
13AB: 20474F20	
13AF: 544F0D00	
13B3: 4F204F75	MSG_MENU6  .db "O Out AA DD",CR, 00H
13B7: 74204141	
13BB: 2044440D	
13BF: 00      	
13C0: 4920496E	MSG_MENU7  .db "I In AA",CR, 00H
13C4: 2041410D	
13C8: 00      	
13C9: 31204932	MSG_MENU8  .db "1 I2C Scan",CR, 00H
13CD: 43205363	
13D1: 616E0D00	
13D5: 32204932	MSG_MENU9  .db "2 I2C PC -> MEM",CR, 00H
13D9: 43205043	
13DD: 202D3E20	
13E1: 4D454D0D	
13E5: 00      	
13E6: 33204932	MSG_MENU10 .db "3 I2C MEM -> PC",CR, 00H
13EA: 43204D45	
13EE: 4D202D3E	
13F2: 2050430D	
13F6: 00      	
13F7: 34204932	MSG_MENU11 .db "4 I2C WRITE DD",CR, 00H
13FB: 43205752	
13FF: 49544520	
1403: 44440D00	
1407: 35204932	MSG_MENU12 .db "5 I2C WRITE RR DD",CR, 00H
140B: 43205752	
140F: 49544520	
1413: 52522044	
1417: 440D00  	
141A: 36204932	MSG_MENU13 .db "6 I2C READ ONE BYTE",CR, 00H
141E: 43205245	
1422: 4144204F	
1426: 4E452042	
142A: 5954450D	
142E: 00      	
142F: 37204932	MSG_MENU14 .db "7 I2C READ RR BYTE", CR, 00H 
1433: 43205245	
1437: 41442052	
143B: 52204259	
143F: 54450D00	
1443: 38205265	MSG_MENU15 .db "8 Read Memory", 00H ; ultimo n√£o tem CR (nova linha)
1447: 6164204D	
144B: 656D6F72	
144F: 7900    	
              	
1451: 434F4E54	MSG_MENU_CONTINUE .db "CONTINUE...", 00H
1455: 494E5545	
1459: 2E2E2E00	
              	
              	
145D: 5F455845	MSG_READFILE_EXE .db "_EXE", 00H
1461: 00      	
1462: 5F494D47	MSG_READFILE_IMG .db "_IMG", 00H
1466: 00      	
1467: 5F545854	MSG_READFILE_TXT .db "_TXT", 00H
146B: 00      	
              	
146C: 0C493243	LISTMsg:    .DB  CS,"I2C device found at:",CR,0
1470: 20646576	
1474: 69636520	
1478: 666F756E	
147C: 64206174	
1480: 3A0D00  	
1483: 0C434F50	MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
1487: 59204932	
148B: 43204D45	
148F: 4D20544F	
1493: 20435055	
1497: 0D00    	
1499: 0C434F50	MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H
149D: 59204350	
14A1: 5520544F	
14A5: 20493243	
14A9: 204D454D	
14AD: 0D00    	
              	
14AF: 0C575249	MSG_I2C_WR_DD    .db CS,"WRITE ONE BYTE",CR, 00H
14B3: 5445204F	
14B7: 4E452042	
14BB: 5954450D	
14BF: 00      	
14C0: 0C575249	MSG_I2C_WR_RR_DD .db CS,"WRITE REG ONE BYTE",CR, 00H
14C4: 54452052	
14C8: 4547204F	
14CC: 4E452042	
14D0: 5954450D	
14D4: 00      	
14D5: 0C524541	MSG_I2C_RD       .db CS,"READ ONE BYTE",CR, 00H
14D9: 44204F4E	
14DD: 45204259	
14E1: 54450D00	
14E5: 0C524541	MSG_I2C_RD_RR    .db CS,"READ REG ONE BYTE",CR, 00H
14E9: 44205245	
14ED: 47204F4E	
14F1: 45204259	
14F5: 54450D00	
              	
14F9: 46524F4D	MSG_FROM    .db "FROM: ", 00H
14FD: 3A2000  	
1500: 0D544F3A	MSG_TO      .db CR,"TO: ", 00H
1504: 2000    	
1506: 0D53495A	MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
150A: 45284259	
150E: 54455329	
1512: 3A2000  	
1515: 0D434F50	MSG_COPYOK  .db CR,"COPY OK", 00H
1519: 59204F4B	
151D: 00      	
151E: 0D434F50	MSG_COPYFAIL  .db CR,"COPY FAIL", 00H
1522: 59204641	
1526: 494C00  	
              	
1529: 0D444556	MSG_DEV_ADDR  .db CR,"DEVICE ADDR(AA): ", 00H
152D: 49434520	
1531: 41444452	
1535: 28414129	
1539: 3A2000  	
153C: 0D524547	MSG_DEV_REG   .db CR,"REGISTER(RR): ", 00H
1540: 49535445	
1544: 52285252	
1548: 293A2000	
154C: 0D444154	MSG_DEV_DATA  .db CR,"DATA(DD): ", 00H
1550: 41284444	
1554: 293A2000	
              	
1558: 2843296F	MSG_BASIC .db "(C)old or (w)arm ?",CR, 00H
155C: 6C64206F	
1560: 72202877	
1564: 2961726D	
1568: 203F0D00	
              	
156C: 0C496E74	MSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
1570: 656C2048	
1574: 4558206C	
1578: 6F616465	
157C: 722E2E2E	
1580: 0D00    	
1582: 46494C45	FILEOK    .DB      "FILE RECEIVED OK",CR,00H
1586: 20524543	
158A: 45495645	
158E: 44204F4B	
1592: 0D00    	
1594: 43484543	CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
1598: 4B53554D	
159C: 20455252	
15A0: 4F520D00	
              	#include "basicV2.asm"
              	;==================================================================================
              	; The updates to the original BASIC within this file are copyright Grant Searle
              	;
              	; You have permission to use this for NON COMMERCIAL USE ONLY
              	; If you wish to use it elsewhere, please include an acknowledgement to myself.
              	;
              	; http://searle.hostei.com/grant/index.html
              	;
              	; eMail: home.micros01@btinternet.com
              	;
              	; If the above don't work, please perform an Internet search to see if I have
              	; updated the web page hosting service.
              	;
              	;==================================================================================
              	
              	; GENERAL EQUATES
              	
0003:         	CTRLC   .EQU    03H             ; Control "C"
0007:         	CTRLG   .EQU    07H             ; Control "G"
0008:         	BKSP    .EQU    08H             ; Back space
000A:         	LF      .EQU    0AH             ; Line feed
000C:         	CS      .EQU    0CH             ; Clear screen
000D:         	CR      .EQU    0DH             ; Carriage return
000F:         	CTRLO   .EQU    0FH             ; Control "O"
0011:         	CTRLQ	.EQU	11H		        ; Control "Q"
0012:         	CTRLR   .EQU    12H             ; Control "R"
0013:         	CTRLS   .EQU    13H             ; Control "S"
0015:         	CTRLU   .EQU    15H             ; Control "U"
001B:         	ESC     .EQU    1BH             ; Escape
007F:         	DEL     .EQU    7FH             ; Delete
              	
              	
              	; BASIC WORK SPACE LOCATIONS
              	
8000:         	WRKSPC  .EQU    8000H             ; BASIC Work space |32768|
8003:         	USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
8006:         	OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
8007:         	OTPORT  .EQU    WRKSPC+7H           ; Port (p)
8009:         	DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
800A:         	DIV1    .EQU    WRKSPC+0AH           ; <- Values
800E:         	DIV2    .EQU    WRKSPC+0EH           ; <-   to
8012:         	DIV3    .EQU    WRKSPC+12H           ; <-   be
8015:         	DIV4    .EQU    WRKSPC+15H           ; <-inserted
8017:         	SEED    .EQU    WRKSPC+17H           ; Random number seed
803A:         	LSTRND  .EQU    WRKSPC+3AH           ; Last random number
803E:         	INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
803F:         	INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
8041:         	NULLS   .EQU    WRKSPC+41H           ; Number of nulls
8042:         	LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
8043:         	COMMAN  .EQU    WRKSPC+43H           ; Width for commas
8044:         	NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
8045:         	CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
8046:         	LINESC  .EQU    WRKSPC+46H           ; Lines counter
8048:         	LINESN  .EQU    WRKSPC+48H           ; Lines number
804A:         	CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
804C:         	NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
804D:         	BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
804E:         	RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
8051:         	POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
8054:         	PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
8057:         	RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
805A:         	STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
805C:         	LINEAT  .EQU    WRKSPC+5CH           ; Current line number
805E:         	BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
8061:         	BUFFER  .EQU    WRKSPC+61H           ; Input buffer
8066:         	STACK   .EQU    WRKSPC+66H           ; Initial stack
80AB:         	CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
80AC:         	LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
80AD:         	TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
80AE:         	DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
80AF:         	LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
80B1:         	TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
80B3:         	TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
80BF:         	TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
80C3:         	STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
80C5:         	CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
80C7:         	LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
80C9:         	DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
80CB:         	FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
80CC:         	LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
80CD:         	READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
80CE:         	BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
80D0:         	NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
80D2:         	ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
80D4:         	CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
80D6:         	PROGND  .EQU    WRKSPC+0D6H          ; End of program
80D8:         	VAREND  .EQU    WRKSPC+0D8H          ; End of variables
80DA:         	ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
80DC:         	NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
80DE:         	FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
80E0:         	FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
80E4:         	FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
80E7:         	FPEXP   .EQU    FPREG+3         ; Floating point exponent
80E8:         	SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
80E9:         	PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
80F6:         	MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
80F9:         	PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area |33280 + 249 = 33529|
815D:         	STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	
0000:         	NF      .EQU    00H             ; NEXT without FOR
0002:         	SN      .EQU    02H             ; Syntax error
0004:         	RG      .EQU    04H             ; RETURN without GOSUB
0006:         	OD      .EQU    06H             ; Out of DATA
0008:         	FC      .EQU    08H             ; Function call error
000A:         	OV      .EQU    0AH             ; Overflow
000C:         	OM      .EQU    0CH             ; Out of memory
000E:         	UL      .EQU    0EH             ; Undefined line number
0010:         	BS      .EQU    10H             ; Bad subscript
0012:         	DD      .EQU    12H             ; Re-DIMensioned array
0014:         	DZ      .EQU    14H             ; Division by zero (/0)
0016:         	ID      .EQU    16H             ; Illegal direct
0018:         	TM      .EQU    18H             ; Type miss-match
001A:         	OS      .EQU    1AH             ; Out of string space
001C:         	LS      .EQU    1CH             ; String too long
001E:         	ST      .EQU    1EH             ; String formula too complex
0020:         	CN      .EQU    20H             ; Can't CONTinue
0022:         	UF      .EQU    22H             ; UnDEFined FN function
0024:         	MO      .EQU    24H             ; Missing operand
0026:         	HX      .EQU    26H             ; HEX error
0028:         	BN      .EQU    28H             ; BIN error
              	
15A4: FFFFFFFF	        .ORG    $6000
15A8: FF...   	
              	
6000: C30660  	COLD:   JP      STARTB          ; Jump for cold start
6003: C3A460  	WARM:   JP      WARMST          ; Jump for warm start
6006:         	STARTB: 
6006: DD210000	        LD      IX,0            ; Flag cold start
600A: C31160  	        JP      CSTART          ; Jump to initialise
              	
600D: B768    	        .WORD   DEINT           ; Get integer -32768 to 32767
600F: 2D70    	        .WORD   ABPASS          ; Return integer in AB
              	
              	
6011: 210080  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
6014: F9      	        LD      SP,HL           ; Set up a temporary stack
6015: C34C7C  	        JP      INITST          ; Go to initialise
              	
6018: 11DE62  	INIT:   LD      DE,INITAB       ; Initialise workspace
601B: 0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
601D: 210080  	        LD      HL,WRKSPC       ; Into workspace RAM
6020: 1A      	COPY:   LD      A,(DE)          ; Get source
6021: 77      	        LD      (HL),A          ; To destination
6022: 23      	        INC     HL              ; Next destination
6023: 13      	        INC     DE              ; Next source
6024: 05      	        DEC     B               ; Count bytes
6025: C22060  	        JP      NZ,COPY         ; More to move
6028: F9      	        LD      SP,HL           ; Temporary stack
6029: CDDF64  	        CALL    CLREG           ; Clear registers and stack
602C: CDAD6A  	        CALL    PRNTCRLF        ; Output CRLF
602F: 32AA80  	        LD      (BUFFER+72+1),A ; Mark end of buffer
6032: 32F980  	        LD      (PROGST),A      ; Initialise program area
6035: 21F360  	MSIZE:  LD      HL,MEMMSG       ; Point to message
6038: CD4B71  	        CALL    PRS             ; Output "Memory size"
603B: CDFC64  	        CALL    PROMPT          ; Get input with '?'
603E: CD0568  	        CALL    GETCHR          ; Get next character
6041: B7      	        OR      A               ; Set flags
6042: C25A60  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
6045: 215D81  	        LD      HL,STLOOK       ; Point to start of RAM
6048: 23      	MLOOP:  INC     HL              ; Next byte
6049: 7C      	        LD      A,H             ; Above address FFFF ?
604A: B5      	        OR      L
604B: CA6C60  	        JP      Z,SETTOP        ; Yes - 64K RAM
604E: 7E      	        LD      A,(HL)          ; Get contents
604F: 47      	        LD      B,A             ; Save it
6050: 2F      	        CPL                     ; Flip all bits
6051: 77      	        LD      (HL),A          ; Put it back
6052: BE      	        CP      (HL)            ; RAM there if same
6053: 70      	        LD      (HL),B          ; Restore old contents
6054: CA4860  	        JP      Z,MLOOP         ; If RAM - test next byte
6057: C36C60  	        JP      SETTOP          ; Top of RAM found
              	
605A: CDD168  	TSTMEM: CALL    ATOH            ; Get high memory into DE
605D: B7      	        OR      A               ; Set flags on last byte
605E: C2AD63  	        JP      NZ,SNERR        ; ?SN Error if bad character
6061: EB      	        EX      DE,HL           ; Address into HL
6062: 2B      	        DEC     HL              ; Back one byte
6063: 3ED9    	        LD      A,11011001B     ; Test byte
6065: 46      	        LD      B,(HL)          ; Get old contents
6066: 77      	        LD      (HL),A          ; Load test byte
6067: BE      	        CP      (HL)            ; RAM there if same
6068: 70      	        LD      (HL),B          ; Restore old contents
6069: C23560  	        JP      NZ,MSIZE        ; Ask again if no RAM
              	
606C: 2B      	SETTOP: DEC     HL              ; Back one byte
606D: 115C81  	        LD      DE,STLOOK-1     ; See if enough RAM
6070: CD7566  	        CALL    CPDEHL          ; Compare DE with HL
6073: DA3560  	        JP      C,MSIZE         ; Ask again if not enough RAM
6076: 11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
6079: 22AF80  	        LD      (LSTRAM),HL     ; Save last available RAM
607C: 19      	        ADD     HL,DE           ; Allocate string space
607D: 225A80  	        LD      (STRSPC),HL     ; Save string space
6080: CDBA64  	        CALL    CLRPTR          ; Clear program area
6083: 2A5A80  	        LD      HL,(STRSPC)     ; Get end of memory
6086: 11EFFF  	        LD      DE,0-17         ; Offset for free bytes
6089: 19      	        ADD     HL,DE           ; Adjust HL
608A: 11F980  	        LD      DE,PROGST       ; Start of program text
608D: 7D      	        LD      A,L             ; Get LSB
608E: 93      	        SUB     E               ; Adjust it
608F: 6F      	        LD      L,A             ; Re-save
6090: 7C      	        LD      A,H             ; Get MSB
6091: 9A      	        SBC     A,D             ; Adjust it
6092: 67      	        LD      H,A             ; Re-save
6093: E5      	        PUSH    HL              ; Save bytes free
6094: 21BC60  	        LD      HL,SIGNON       ; Sign-on message
6097: CD4B71  	        CALL    PRS             ; Output string
609A: E1      	        POP     HL              ; Get bytes free back
609B: CDEE77  	        CALL    PRNTHL          ; Output amount of free memory
609E: 21AD60  	        LD      HL,BFREE        ; " Bytes free" message
60A1: CD4B71  	        CALL    PRS             ; Output string
              	
60A4: 316680  	WARMST: LD      SP,STACK        ; Temporary stack
60A7: CDDF64  	BRKRET: CALL    CLREG           ; Clear registers and stack
60AA: C3F863  	        JP      PRNTOK          ; Go to get command line
              	
60AD: 20427974	BFREE:  .BYTE   " Bytes free",CR,LF,0,0
60B1: 65732066	
60B5: 7265650D	
60B9: 0A0000  	
              	
60BC: 5A383020	SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
60C0: 42415349	
60C4: 43205665	
60C8: 7220342E	
60CC: 37620D0A	
60D0: 436F7079	        .BYTE   "Copyright ",40,"C",41
60D4: 72696768	
60D8: 74202843	
60DC: 29      	
60DD: 20313937	        .BYTE   " 1978 by Microsoft",CR,LF,0,0
60E1: 38206279	
60E5: 204D6963	
60E9: 726F736F	
60ED: 66740D0A	
60F1: 0000    	
              	
60F3: 4D656D6F	MEMMSG: .BYTE   "Memory top",0
60F7: 72792074	
60FB: 6F7000  	
              	
              	; FUNCTION ADDRESS TABLE
              	
60FE: 6376    	FNCTAB: .WORD   SGN
6100: 2777    	        .WORD   INT
6102: 7976    	        .WORD   ABS
6104: 0380    	        .WORD   USR
6106: 0B70    	        .WORD   FRE
6108: 9073    	        .WORD   INP
610A: 3970    	        .WORD   POS
610C: ED78    	        .WORD   SQR
610E: CC79    	        .WORD   RND
6110: 0875    	        .WORD   LOG
6112: 3B79    	        .WORD   EXP
6114: 417A    	        .WORD   COS
6116: 477A    	        .WORD   SIN
6118: A87A    	        .WORD   TAN
611A: BD7A    	        .WORD   ATN
611C: E473    	        .WORD   PEEK
611E: 287B    	        .WORD   DEEK
6120: 5180    	        .WORD   POINT
6122: BD72    	        .WORD   LEN
6124: D570    	        .WORD   STR
6126: 5773    	        .WORD   VAL
6128: CC72    	        .WORD   ASC
612A: DD72    	        .WORD   CHR
612C: 4A7B    	        .WORD   HEX
612E: DD7B    	        .WORD   BIN
6130: ED72    	        .WORD   LEFT
6132: 1D73    	        .WORD   RIGHT
6134: 2773    	        .WORD   MID
              	
              	; RESERVED WORD LIST
              	
6136: C54E44  	WORDS:  .BYTE   'E'+80H,"ND"
6139: C64F52  	        .BYTE   'F'+80H,"OR"
613C: CE455854	        .BYTE   'N'+80H,"EXT"
6140: C4415441	        .BYTE   'D'+80H,"ATA"
6144: C94E5055	        .BYTE   'I'+80H,"NPUT"
6148: 54      	
6149: C4494D  	        .BYTE   'D'+80H,"IM"
614C: D2454144	        .BYTE   'R'+80H,"EAD"
6150: CC4554  	        .BYTE   'L'+80H,"ET"
6153: C74F544F	        .BYTE   'G'+80H,"OTO"
6157: D2554E  	        .BYTE   'R'+80H,"UN"
615A: C946    	        .BYTE   'I'+80H,"F"
615C: D2455354	        .BYTE   'R'+80H,"ESTORE"
6160: 4F5245  	
6163: C74F5355	        .BYTE   'G'+80H,"OSUB"
6167: 42      	
6168: D2455455	        .BYTE   'R'+80H,"ETURN"
616C: 524E    	
616E: D2454D  	        .BYTE   'R'+80H,"EM"
6171: D3544F50	        .BYTE   'S'+80H,"TOP"
6175: CF5554  	        .BYTE   'O'+80H,"UT"
6178: CF4E    	        .BYTE   'O'+80H,"N"
617A: CE554C4C	        .BYTE   'N'+80H,"ULL"
617E: D7414954	        .BYTE   'W'+80H,"AIT"
6182: C44546  	        .BYTE   'D'+80H,"EF"
6185: D04F4B45	        .BYTE   'P'+80H,"OKE"
6189: C44F4B45	        .BYTE   'D'+80H,"OKE"
618D: D3435245	        .BYTE   'S'+80H,"CREEN"
6191: 454E    	
6193: CC494E45	        .BYTE   'L'+80H,"INES"
6197: 53      	
6198: C34C53  	        .BYTE   'C'+80H,"LS"
619B: D7494454	        .BYTE   'W'+80H,"IDTH"
619F: 48      	
61A0: CD4F4E49	        .BYTE   'M'+80H,"ONITOR"
61A4: 544F52  	
61A7: D34554  	        .BYTE   'S'+80H,"ET"
61AA: D2455345	        .BYTE   'R'+80H,"ESET"
61AE: 54      	
61AF: D052494E	        .BYTE   'P'+80H,"RINT"
61B3: 54      	
61B4: C34F4E54	        .BYTE   'C'+80H,"ONT"
61B8: CC495354	        .BYTE   'L'+80H,"IST"
61BC: C34C4541	        .BYTE   'C'+80H,"LEAR"
61C0: 52      	
61C1: C34C4F41	        .BYTE   'C'+80H,"LOAD"
61C5: 44      	
61C6: C3534156	        .BYTE   'C'+80H,"SAVE"
61CA: 45      	
61CB: CE4557  	        .BYTE   'N'+80H,"EW"
              	
61CE: D4414228	        .BYTE   'T'+80H,"AB("
61D2: D44F    	        .BYTE   'T'+80H,"O"
61D4: C64E    	        .BYTE   'F'+80H,"N"
61D6: D3504328	        .BYTE   'S'+80H,"PC("
61DA: D448454E	        .BYTE   'T'+80H,"HEN"
61DE: CE4F54  	        .BYTE   'N'+80H,"OT"
61E1: D3544550	        .BYTE   'S'+80H,"TEP"
              	
61E5: AB      	        .BYTE   '+'+80H
61E6: AD      	        .BYTE   '-'+80H
61E7: AA      	        .BYTE   '*'+80H
61E8: AF      	        .BYTE   '/'+80H
61E9: DE      	        .BYTE   '^'+80H
61EA: C14E44  	        .BYTE   'A'+80H,"ND"
61ED: CF52    	        .BYTE   'O'+80H,"R"
61EF: BE      	        .BYTE   '>'+80H
61F0: BD      	        .BYTE   '='+80H
61F1: BC      	        .BYTE   '<'+80H
              	
61F2: D3474E  	        .BYTE   'S'+80H,"GN"
61F5: C94E54  	        .BYTE   'I'+80H,"NT"
61F8: C14253  	        .BYTE   'A'+80H,"BS"
61FB: D55352  	        .BYTE   'U'+80H,"SR"
61FE: C65245  	        .BYTE   'F'+80H,"RE"
6201: C94E50  	        .BYTE   'I'+80H,"NP"
6204: D04F53  	        .BYTE   'P'+80H,"OS"
6207: D35152  	        .BYTE   'S'+80H,"QR"
620A: D24E44  	        .BYTE   'R'+80H,"ND"
620D: CC4F47  	        .BYTE   'L'+80H,"OG"
6210: C55850  	        .BYTE   'E'+80H,"XP"
6213: C34F53  	        .BYTE   'C'+80H,"OS"
6216: D3494E  	        .BYTE   'S'+80H,"IN"
6219: D4414E  	        .BYTE   'T'+80H,"AN"
621C: C1544E  	        .BYTE   'A'+80H,"TN"
621F: D045454B	        .BYTE   'P'+80H,"EEK"
6223: C445454B	        .BYTE   'D'+80H,"EEK"
6227: D04F494E	        .BYTE   'P'+80H,"OINT"
622B: 54      	
622C: CC454E  	        .BYTE   'L'+80H,"EN"
622F: D3545224	        .BYTE   'S'+80H,"TR$"
6233: D6414C  	        .BYTE   'V'+80H,"AL"
6236: C15343  	        .BYTE   'A'+80H,"SC"
6239: C3485224	        .BYTE   'C'+80H,"HR$"
623D: C8455824	        .BYTE   'H'+80H,"EX$"
6241: C2494E24	        .BYTE   'B'+80H,"IN$"
6245: CC454654	        .BYTE   'L'+80H,"EFT$"
6249: 24      	
624A: D2494748	        .BYTE   'R'+80H,"IGHT$"
624E: 5424    	
6250: CD494424	        .BYTE   'M'+80H,"ID$"
6254: 80      	        .BYTE   80H             ; End of list marker
              	
              	; KEYWORD ADDRESS TABLE
              	
6255: 4F68    	WORDTB: .WORD   PEND
6257: 4C67    	        .WORD   FOR
6259: 276C    	        .WORD   NEXT
625B: 9C69    	        .WORD   DATA
625D: 2E6B    	        .WORD   INPUT
625F: 636E    	        .WORD   DIM
6261: 5D6B    	        .WORD   READ
6263: B369    	        .WORD   LET
6265: 5969    	        .WORD   GOTO
6267: 3C69    	        .WORD   RUN
6269: 2B6A    	        .WORD   IF
626B: 1568    	        .WORD   RESTOR
626D: 4869    	        .WORD   GOSUB
626F: 7769    	        .WORD   RETURN
6271: 9E69    	        .WORD   REM
6273: 4D68    	        .WORD   STOP
6275: 9C73    	        .WORD   POUT
6277: 0D6A    	        .WORD   ON
6279: 8E68    	        .WORD   NULL
627B: A273    	        .WORD   WAIT
627D: 4170    	        .WORD   DEF
627F: EB73    	        .WORD   POKE
6281: 337B    	        .WORD   DOKE
6283: 9E69    	        .WORD   REM
6285: 197B    	        .WORD   LINES
6287: 0C7B    	        .WORD   CLS
6289: 117B    	        .WORD   WIDTH
628B: 497C    	        .WORD   MONITR
628D: 5480    	        .WORD   PSET
628F: 5780    	        .WORD   RESET
6291: 4F6A    	        .WORD   PRINT
6293: 7B68    	        .WORD   CONT
6295: C166    	        .WORD   LIST
6297: F668    	        .WORD   CLEAR
6299: 9E69    	        .WORD   REM
629B: 9E69    	        .WORD   REM
629D: B964    	        .WORD   NEW
              	
              	; RESERVED WORD TOKEN VALUES
              	
0080:         	ZEND    .EQU    080H            ; END
0081:         	ZFOR    .EQU    081H            ; FOR
0083:         	ZDATA   .EQU    083H            ; DATA
0088:         	ZGOTO   .EQU    088H            ; GOTO
008C:         	ZGOSUB  .EQU    08CH            ; GOSUB
008E:         	ZREM    .EQU    08EH            ; REM
009E:         	ZPRINT  .EQU    09EH            ; PRINT
00A4:         	ZNEW    .EQU    0A4H            ; NEW
              	
00A5:         	ZTAB    .EQU    0A5H            ; TAB
00A6:         	ZTO     .EQU    0A6H            ; TO
00A7:         	ZFN     .EQU    0A7H            ; FN
00A8:         	ZSPC    .EQU    0A8H            ; SPC
00A9:         	ZTHEN   .EQU    0A9H            ; THEN
00AA:         	ZNOT    .EQU    0AAH            ; NOT
00AB:         	ZSTEP   .EQU    0ABH            ; STEP
              	
00AC:         	ZPLUS   .EQU    0ACH            ; +
00AD:         	ZMINUS  .EQU    0ADH            ; -
00AE:         	ZTIMES  .EQU    0AEH            ; *
00AF:         	ZDIV    .EQU    0AFH            ; /
00B2:         	ZOR     .EQU    0B2H            ; OR
00B3:         	ZGTR    .EQU    0B3H            ; >
00B4:         	ZEQUAL  .EQU    0B4H            ; M
00B5:         	ZLTH    .EQU    0B5H            ; <
00B6:         	ZSGN    .EQU    0B6H            ; SGN
00C7:         	ZPOINT  .EQU    0C7H            ; POINT
00CF:         	ZLEFT   .EQU    0CDH +2         ; LEFT$
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	
629F: 79      	PRITAB: .BYTE   79H             ; Precedence value
62A0: D577    	        .WORD   PADD            ; FPREG = <last> + FPREG
              	
62A2: 79      	        .BYTE   79H             ; Precedence value
62A3: 0974    	        .WORD   PSUB            ; FPREG = <last> - FPREG
              	
62A5: 7C      	        .BYTE   7CH             ; Precedence value
62A6: 4775    	        .WORD   MULT            ; PPREG = <last> * FPREG
              	
62A8: 7C      	        .BYTE   7CH             ; Precedence value
62A9: A875    	        .WORD   DIV             ; FPREG = <last> / FPREG
              	
62AB: 7F      	        .BYTE   7FH             ; Precedence value
62AC: F678    	        .WORD   POWER           ; FPREG = <last> ^ FPREG
              	
62AE: 50      	        .BYTE   50H             ; Precedence value
62AF: BC6D    	        .WORD   PAND            ; FPREG = <last> AND FPREG
              	
62B1: 46      	        .BYTE   46H             ; Precedence value
62B2: BB6D    	        .WORD   POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
62B4: 4E46    	ERRORS: .BYTE   "NF"            ; NEXT without FOR
62B6: 534E    	        .BYTE   "SN"            ; Syntax error
62B8: 5247    	        .BYTE   "RG"            ; RETURN without GOSUB
62BA: 4F44    	        .BYTE   "OD"            ; Out of DATA
62BC: 4643    	        .BYTE   "FC"            ; Illegal function call
62BE: 4F56    	        .BYTE   "OV"            ; Overflow error
62C0: 4F4D    	        .BYTE   "OM"            ; Out of memory
62C2: 554C    	        .BYTE   "UL"            ; Undefined line
62C4: 4253    	        .BYTE   "BS"            ; Bad subscript
62C6: 4444    	        .BYTE   "DD"            ; Re-DIMensioned array
62C8: 2F30    	        .BYTE   "/0"            ; Division by zero
62CA: 4944    	        .BYTE   "ID"            ; Illegal direct
62CC: 544D    	        .BYTE   "TM"            ; Type mis-match
62CE: 4F53    	        .BYTE   "OS"            ; Out of string space
62D0: 4C53    	        .BYTE   "LS"            ; String too long
62D2: 5354    	        .BYTE   "ST"            ; String formula too complex
62D4: 434E    	        .BYTE   "CN"            ; Can't CONTinue
62D6: 5546    	        .BYTE   "UF"            ; Undefined FN function
62D8: 4D4F    	        .BYTE   "MO"            ; Missing operand
62DA: 4858    	        .BYTE   "HX"            ; HEX error
62DC: 424E    	        .BYTE   "BN"            ; BIN error
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	
62DE: C3A460  	INITAB: JP      WARMST          ; Warm start jump
62E1: C3CC68  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
62E4: D300    	        OUT     (0),A           ; "OUT p,n" skeleton
62E6: C9      	        RET
62E7: D600    	        SUB     0               ; Division support routine
62E9: 6F      	        LD      L,A
62EA: 7C      	        LD      A,H
62EB: DE00    	        SBC     A,0
62ED: 67      	        LD      H,A
62EE: 78      	        LD      A,B
62EF: DE00    	        SBC     A,0
62F1: 47      	        LD      B,A
62F2: 3E00    	        LD      A,0
62F4: C9      	        RET
62F5: 000000  	        .BYTE   0,0,0                   ; Random number seed table used by RND
62F8: 354ACA99	        .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
62FC: 391C7698	        .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
6300: 2295B398	        .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
6304: 0ADD4798	        .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
6308: 53D19999	        .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
630C: 0A1A9F98	        .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
6310: 65BCCD98	        .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
6314: D6773E98	        .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
6318: 52C74F80	        .BYTE   052H,0C7H,04FH,080H     ; Last random number
631C: DB00    	        IN      A,(0)           ; INP (x) skeleton
631E: C9      	        RET
631F: 01      	        .BYTE   1               ; POS (x) number (1)
6320: FF      	        .BYTE   255             ; Terminal width (255 = no auto CRLF)
6321: 1C      	        .BYTE   28              ; Width for commas (3 columns)
6322: 00      	        .BYTE   0               ; No nulls after input bytes
6323: 00      	        .BYTE   0               ; Output enabled (^O off)
6324: 1400    	        .WORD   20              ; Initial lines counter
6326: 1400    	        .WORD   20              ; Initial lines number
6328: 0000    	        .WORD   0               ; Array load/save check sum
632A: 00      	        .BYTE   0               ; Break not by NMI
632B: 00      	        .BYTE   0               ; Break flag
632C: C3F265  	        JP      TTYLIN          ; Input reflection (set to TTY)
632F: C30000  	        JP      $0000           ; POINT reflection unused
6332: C30000  	        JP      $0000           ; SET reflection
6335: C30000  	        JP      $0000          	; RESET reflection
6338: 5D81    	        .WORD   STLOOK          ; Temp string space
633A: FEFF    	        .WORD   -2              ; Current line number (cold)
633C: FA80    	        .WORD   PROGST+1        ; Start of program text
633E:         	INITBE:                         
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
633E: 20457272	ERRMSG: .BYTE   " Error",0
6342: 6F7200  	
6345: 20696E20	INMSG:  .BYTE   " in ",0
6349: 00      	
6349:         	ZERBYT  .EQU    $-1             ; A zero byte
634A: 4F6B0D0A	OKMSG:  .BYTE   "Ok",CR,LF,0,0
634E: 0000    	
6350: 42726561	BRKMSG: .BYTE   "Break",0
6354: 6B00    	
              	
6356: 210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
6359: 39      	        ADD     HL,SP           ; same index as specified
635A: 7E      	LOKFOR: LD      A,(HL)          ; Get block ID
635B: 23      	        INC     HL              ; Point to index address
635C: FE81    	        CP      ZFOR            ; Is it a "FOR" token
635E: C0      	        RET     NZ              ; No - exit
635F: 4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
6360: 23      	        INC     HL
6361: 46      	        LD      B,(HL)
6362: 23      	        INC     HL              ; Point to sign of STEP
6363: E5      	        PUSH    HL              ; Save pointer to sign
6364: 69      	        LD      L,C             ; HL = address of "FOR" index
6365: 60      	        LD      H,B
6366: 7A      	        LD      A,D             ; See if an index was specified
6367: B3      	        OR      E               ; DE = 0 if no index specified
6368: EB      	        EX      DE,HL           ; Specified index into HL
6369: CA7063  	        JP      Z,INDFND        ; Skip if no index given
636C: EB      	        EX      DE,HL           ; Index back into DE
636D: CD7566  	        CALL    CPDEHL          ; Compare index with one given
6370: 010D00  	INDFND: LD      BC,16-3         ; Offset to next block
6373: E1      	        POP     HL              ; Restore pointer to sign
6374: C8      	        RET     Z               ; Return if block found
6375: 09      	        ADD     HL,BC           ; Point to next block
6376: C35A63  	        JP      LOKFOR          ; Keep on looking
              	
6379: CD9363  	MOVUP:  CALL    ENFMEM          ; See if enough memory
637C: C5      	MOVSTR: PUSH    BC              ; Save end of source
637D: E3      	        EX      (SP),HL         ; Swap source and dest" end
637E: C1      	        POP     BC              ; Get end of destination
637F: CD7566  	MOVLP:  CALL    CPDEHL          ; See if list moved
6382: 7E      	        LD      A,(HL)          ; Get byte
6383: 02      	        LD      (BC),A          ; Move it
6384: C8      	        RET     Z               ; Exit if all done
6385: 0B      	        DEC     BC              ; Next byte to move to
6386: 2B      	        DEC     HL              ; Next byte to move
6387: C37F63  	        JP      MOVLP           ; Loop until all bytes moved
              	
638A: E5      	CHKSTK: PUSH    HL              ; Save code string address
638B: 2ADA80  	        LD      HL,(ARREND)     ; Lowest free memory
638E: 0600    	        LD      B,0             ; BC = Number of levels to test
6390: 09      	        ADD     HL,BC           ; 2 Bytes for each level
6391: 09      	        ADD     HL,BC
6392: 3E      	        .BYTE   3EH             ; Skip "PUSH HL"
6393: E5      	ENFMEM: PUSH    HL              ; Save code string address
6394: 3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
6396: 95      	        SUB     L
6397: 6F      	        LD      L,A
6398: 3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
639A: 9C      	        SBC     A,H
639B: DAA263  	        JP      C,OMERR         ; Not enough - ?OM Error
639E: 67      	        LD      H,A
639F: 39      	        ADD     HL,SP           ; Test if stack is overflowed
63A0: E1      	        POP     HL              ; Restore code string address
63A1: D8      	        RET     C               ; Return if enough mmory
63A2: 1E0C    	OMERR:  LD      E,OM            ; ?OM Error
63A4: C3C163  	        JP      ERROR
              	
63A7: 2AC980  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
63AA: 225C80  	        LD      (LINEAT),HL     ; Save as current line
63AD: 1E02    	SNERR:  LD      E,SN            ; ?SN Error
63AF: 01      	        .BYTE   01H             ; Skip "LD E,DZ"
63B0: 1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
63B2: 01      	        .BYTE   01H             ; Skip "LD E,NF"
63B3: 1E00    	NFERR:  LD      E,NF            ; ?NF Error
63B5: 01      	        .BYTE   01H             ; Skip "LD E,DD"
63B6: 1E12    	DDERR:  LD      E,DD            ; ?DD Error
63B8: 01      	        .BYTE   01H             ; Skip "LD E,UF"
63B9: 1E22    	UFERR:  LD      E,UF            ; ?UF Error
63BB: 01      	        .BYTE   01H             ; Skip "LD E,OV
63BC: 1E0A    	OVERR:  LD      E,OV            ; ?OV Error
63BE: 01      	        .BYTE   01H             ; Skip "LD E,TM"
63BF: 1E18    	TMERR:  LD      E,TM            ; ?TM Error
              	
63C1:         	ERROR:  
63C1: CDDF64  	        CALL    CLREG           ; Clear registers and stack
63C4: 324580  	        LD      (CTLOFG),A      ; Enable output (A is 0)
63C7: CDA06A  	        CALL    STTLIN          ; Start new line
63CA: 21B462  	        LD      HL,ERRORS       ; Point to error codes
63CD: 57      	        LD      D,A             ; D = 0 (A is 0)
63CE: 3E3F    	        LD      A,'?'
63D0: CD8666  	        CALL    OUTC            ; Output '?'
63D3: 19      	        ADD     HL,DE           ; Offset to correct error code
63D4: 7E      	        LD      A,(HL)          ; First character
63D5: CD8666  	        CALL    OUTC            ; Output it
63D8: CD0568  	        CALL    GETCHR          ; Get next character
63DB: CD8666  	        CALL    OUTC            ; Output it
63DE: 213E63  	        LD      HL,ERRMSG       ; "Error" message
63E1: CD4B71  	ERRIN:  CALL    PRS             ; Output message
63E4: 2A5C80  	        LD      HL,(LINEAT)     ; Get line of error
63E7: 11FEFF  	        LD      DE,-2           ; Cold start error if -2
63EA: CD7566  	        CALL    CPDEHL          ; See if cold start error
63ED: CA1160  	        JP      Z,CSTART        ; Cold start error - Restart
63F0: 7C      	        LD      A,H             ; Was it a direct error?
63F1: A5      	        AND     L               ; Line = -1 if direct error
63F2: 3C      	        INC     A
63F3: C4E677  	        CALL    NZ,LINEIN       ; No - output line of error
63F6: 3E      	        .BYTE   3EH             ; Skip "POP BC"
63F7: C1      	POPNOK: POP     BC              ; Drop address in input buffer
              	
63F8:         	PRNTOK: 
63F8: AF      	        XOR     A               ; Output "Ok" and get command
63F9: 324580  	        LD      (CTLOFG),A      ; Enable output
63FC: CDA06A  	        CALL    STTLIN          ; Start new line
63FF: 214A63  	        LD      HL,OKMSG        ; "Ok" message
6402: CD4B71  	        CALL    PRS             ; Output "Ok"
6405: 21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
6408: 225C80  	        LD      (LINEAT),HL     ; Save as current line
640B: CDF265  	        CALL    GETLIN          ; Get an input line
640E: DA0564  	        JP      C,GETCMD        ; Get line again if break
6411: CD0568  	        CALL    GETCHR          ; Get first character
6414: 3C      	        INC     A               ; Test if end of line
6415: 3D      	        DEC     A               ; Without affecting Carry
6416: CA0564  	        JP      Z,GETCMD        ; Nothing entered - Get another
6419: F5      	        PUSH    AF              ; Save Carry status
641A: CDD168  	        CALL    ATOH            ; Get line number into DE
641D: D5      	        PUSH    DE              ; Save line number
641E: CD0965  	        CALL    CRUNCH          ; Tokenise rest of line
6421: 47      	        LD      B,A             ; Length of tokenised line
6422: D1      	        POP     DE              ; Restore line number
6423: F1      	        POP     AF              ; Restore Carry
6424: D2E567  	        JP      NC,EXCUTE       ; No line number - Direct mode
6427: D5      	        PUSH    DE              ; Save line number
6428: C5      	        PUSH    BC              ; Save length of tokenised line
6429: AF      	        XOR     A
642A: 32CC80  	        LD      (LSTBIN),A      ; Clear last byte input
642D: CD0568  	        CALL    GETCHR          ; Get next character
6430: B7      	        OR      A               ; Set flags
6431: F5      	        PUSH    AF              ; And save them
6432: CD9964  	        CALL    SRCHLN          ; Search for line number in DE
6435: DA3E64  	        JP      C,LINFND        ; Jump if line found
6438: F1      	        POP     AF              ; Get status
6439: F5      	        PUSH    AF              ; And re-save
643A: CA7269  	        JP      Z,ULERR         ; Nothing after number - Error
643D: B7      	        OR      A               ; Clear Carry
643E: C5      	LINFND: PUSH    BC              ; Save address of line in prog
643F: D25564  	        JP      NC,INEWLN       ; Line not found - Insert new
6442: EB      	        EX      DE,HL           ; Next line address in DE
6443: 2AD680  	        LD      HL,(PROGND)     ; End of program
6446: 1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
6447: 02      	        LD      (BC),A
6448: 03      	        INC     BC              ; Next destination
6449: 13      	        INC     DE              ; Next source
644A: CD7566  	        CALL    CPDEHL          ; All done?
644D: C24664  	        JP      NZ,SFTPRG       ; More to do
6450: 60      	        LD      H,B             ; HL - New end of program
6451: 69      	        LD      L,C
6452: 22D680  	        LD      (PROGND),HL     ; Update end of program
              	
6455: D1      	INEWLN: POP     DE              ; Get address of line,
6456: F1      	        POP     AF              ; Get status
6457: CA7C64  	        JP      Z,SETPTR        ; No text - Set up pointers
645A: 2AD680  	        LD      HL,(PROGND)     ; Get end of program
645D: E3      	        EX      (SP),HL         ; Get length of input line
645E: C1      	        POP     BC              ; End of program to BC
645F: 09      	        ADD     HL,BC           ; Find new end
6460: E5      	        PUSH    HL              ; Save new end
6461: CD7963  	        CALL    MOVUP           ; Make space for line
6464: E1      	        POP     HL              ; Restore new end
6465: 22D680  	        LD      (PROGND),HL     ; Update end of program pointer
6468: EB      	        EX      DE,HL           ; Get line to move up in HL
6469: 74      	        LD      (HL),H          ; Save MSB
646A: D1      	        POP     DE              ; Get new line number
646B: 23      	        INC     HL              ; Skip pointer
646C: 23      	        INC     HL
646D: 73      	        LD      (HL),E          ; Save LSB of line number
646E: 23      	        INC     HL
646F: 72      	        LD      (HL),D          ; Save MSB of line number
6470: 23      	        INC     HL              ; To first byte in line
6471: 116180  	        LD      DE,BUFFER       ; Copy buffer to program
6474: 1A      	MOVBUF: LD      A,(DE)          ; Get source
6475: 77      	        LD      (HL),A          ; Save destinations
6476: 23      	        INC     HL              ; Next source
6477: 13      	        INC     DE              ; Next destination
6478: B7      	        OR      A               ; Done?
6479: C27464  	        JP      NZ,MOVBUF       ; No - Repeat
647C: CDC564  	SETPTR: CALL    RUNFST          ; Set line pointers
647F: 23      	        INC     HL              ; To LSB of pointer
6480: EB      	        EX      DE,HL           ; Address to DE
6481: 62      	PTRLP:  LD      H,D             ; Address to HL
6482: 6B      	        LD      L,E
6483: 7E      	        LD      A,(HL)          ; Get LSB of pointer
6484: 23      	        INC     HL              ; To MSB of pointer
6485: B6      	        OR      (HL)            ; Compare with MSB pointer
6486: CA0564  	        JP      Z,GETCMD        ; Get command line if end
6489: 23      	        INC     HL              ; To LSB of line number
648A: 23      	        INC     HL              ; Skip line number
648B: 23      	        INC     HL              ; Point to first byte in line
648C: AF      	        XOR     A               ; Looking for 00 byte
648D: BE      	FNDEND: CP      (HL)            ; Found end of line?
648E: 23      	        INC     HL              ; Move to next byte
648F: C28D64  	        JP      NZ,FNDEND       ; No - Keep looking
6492: EB      	        EX      DE,HL           ; Next line address to HL
6493: 73      	        LD      (HL),E          ; Save LSB of pointer
6494: 23      	        INC     HL
6495: 72      	        LD      (HL),D          ; Save MSB of pointer
6496: C38164  	        JP      PTRLP           ; Do next line
              	
6499: 2A5E80  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
649C: 44      	SRCHLP: LD      B,H             ; BC = Address to look at
649D: 4D      	        LD      C,L
649E: 7E      	        LD      A,(HL)          ; Get address of next line
649F: 23      	        INC     HL
64A0: B6      	        OR      (HL)            ; End of program found?
64A1: 2B      	        DEC     HL
64A2: C8      	        RET     Z               ; Yes - Line not found
64A3: 23      	        INC     HL
64A4: 23      	        INC     HL
64A5: 7E      	        LD      A,(HL)          ; Get LSB of line number
64A6: 23      	        INC     HL
64A7: 66      	        LD      H,(HL)          ; Get MSB of line number
64A8: 6F      	        LD      L,A
64A9: CD7566  	        CALL    CPDEHL          ; Compare with line in DE
64AC: 60      	        LD      H,B             ; HL = Start of this line
64AD: 69      	        LD      L,C
64AE: 7E      	        LD      A,(HL)          ; Get LSB of next line address
64AF: 23      	        INC     HL
64B0: 66      	        LD      H,(HL)          ; Get MSB of next line address
64B1: 6F      	        LD      L,A             ; Next line to HL
64B2: 3F      	        CCF
64B3: C8      	        RET     Z               ; Lines found - Exit
64B4: 3F      	        CCF
64B5: D0      	        RET     NC              ; Line not found,at line after
64B6: C39C64  	        JP      SRCHLP          ; Keep looking
              	
64B9: C0      	NEW:    RET     NZ              ; Return if any more on line
64BA: 2A5E80  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
64BD: AF      	        XOR     A               ; Set program area to empty
64BE: 77      	        LD      (HL),A          ; Save LSB = 00
64BF: 23      	        INC     HL
64C0: 77      	        LD      (HL),A          ; Save MSB = 00
64C1: 23      	        INC     HL
64C2: 22D680  	        LD      (PROGND),HL     ; Set program end
              	
64C5: 2A5E80  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
64C8: 2B      	        DEC     HL
              	
64C9: 22CE80  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
64CC: 2AAF80  	        LD      HL,(LSTRAM)     ; Get end of RAM
64CF: 22C380  	        LD      (STRBOT),HL     ; Clear string space
64D2: AF      	        XOR     A
64D3: CD1568  	        CALL    RESTOR          ; Reset DATA pointers
64D6: 2AD680  	        LD      HL,(PROGND)     ; Get end of program
64D9: 22D880  	        LD      (VAREND),HL     ; Clear variables
64DC: 22DA80  	        LD      (ARREND),HL     ; Clear arrays
              	
64DF: C1      	CLREG:  POP     BC              ; Save return address
64E0: 2A5A80  	        LD      HL,(STRSPC)     ; Get end of working RAN
64E3: F9      	        LD      SP,HL           ; Set stack
64E4: 21B380  	        LD      HL,TMSTPL       ; Temporary string pool
64E7: 22B180  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
64EA: AF      	        XOR     A               ; A = 00
64EB: 6F      	        LD      L,A             ; HL = 0000
64EC: 67      	        LD      H,A
64ED: 22D480  	        LD      (CONTAD),HL     ; No CONTinue
64F0: 32CB80  	        LD      (FORFLG),A      ; Clear FOR flag
64F3: 22DE80  	        LD      (FNRGNM),HL     ; Clear FN argument
64F6: E5      	        PUSH    HL              ; HL = 0000
64F7: C5      	        PUSH    BC              ; Put back return
64F8: 2ACE80  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
64FB: C9      	        RET                     ; Return to execution driver
              	
64FC: 3E3F    	PROMPT: LD      A,'?'           ; '?'
64FE: CD8666  	        CALL    OUTC            ; Output character
6501: 3E20    	        LD      A,' '           ; Space
6503: CD8666  	        CALL    OUTC            ; Output character
6506: C34E80  	        JP      RINPUT          ; Get input line
              	
6509: AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
650A: 32AE80  	        LD      (DATFLG),A      ; Reset literal flag
650D: 0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
650F: 116180  	        LD      DE,BUFFER       ; Start of input buffer
6512: 7E      	CRNCLP: LD      A,(HL)          ; Get byte
6513: FE20    	        CP      ' '             ; Is it a space?
6515: CA9165  	        JP      Z,MOVDIR        ; Yes - Copy direct
6518: 47      	        LD      B,A             ; Save character
6519: FE22    	        CP      '"'             ; Is it a quote?
651B: CAB165  	        JP      Z,CPYLIT        ; Yes - Copy literal string
651E: B7      	        OR      A               ; Is it end of buffer?
651F: CAB865  	        JP      Z,ENDBUF        ; Yes - End buffer
6522: 3AAE80  	        LD      A,(DATFLG)      ; Get data type
6525: B7      	        OR      A               ; Literal?
6526: 7E      	        LD      A,(HL)          ; Get byte to copy
6527: C29165  	        JP      NZ,MOVDIR       ; Literal - Copy direct
652A: FE3F    	        CP      '?'             ; Is it '?' short for PRINT
652C: 3E9E    	        LD      A,ZPRINT        ; "PRINT" token
652E: CA9165  	        JP      Z,MOVDIR        ; Yes - replace it
6531: 7E      	        LD      A,(HL)          ; Get byte again
6532: FE30    	        CP      '0'             ; Is it less than '0'
6534: DA3C65  	        JP      C,FNDWRD        ; Yes - Look for reserved words
6537: FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
6539: DA9165  	        JP      C,MOVDIR        ; Yes - copy it direct
653C: D5      	FNDWRD: PUSH    DE              ; Look for reserved words
653D: 113561  	        LD      DE,WORDS-1      ; Point to table
6540: C5      	        PUSH    BC              ; Save count
6541: 018D65  	        LD      BC,RETNAD       ; Where to return to
6544: C5      	        PUSH    BC              ; Save return address
6545: 067F    	        LD      B,ZEND-1        ; First token value -1
6547: 7E      	        LD      A,(HL)          ; Get byte
6548: FE61    	        CP      'a'             ; Less than 'a' ?
654A: DA5565  	        JP      C,SEARCH        ; Yes - search for words
654D: FE7B    	        CP      'z'+1           ; Greater than 'z' ?
654F: D25565  	        JP      NC,SEARCH       ; Yes - search for words
6552: E65F    	        AND     01011111B       ; Force upper case
6554: 77      	        LD      (HL),A          ; Replace byte
6555: 4E      	SEARCH: LD      C,(HL)          ; Search for a word
6556: EB      	        EX      DE,HL
6557: 23      	GETNXT: INC     HL              ; Get next reserved word
6558: B6      	        OR      (HL)            ; Start of word?
6559: F25765  	        JP      P,GETNXT        ; No - move on
655C: 04      	        INC     B               ; Increment token value
655D: 7E      	        LD      A, (HL)         ; Get byte from table
655E: E67F    	        AND     01111111B       ; Strip bit 7
6560: C8      	        RET     Z               ; Return if end of list
6561: B9      	        CP      C               ; Same character as in buffer?
6562: C25765  	        JP      NZ,GETNXT       ; No - get next word
6565: EB      	        EX      DE,HL
6566: E5      	        PUSH    HL              ; Save start of word
              	
6567: 13      	NXTBYT: INC     DE              ; Look through rest of word
6568: 1A      	        LD      A,(DE)          ; Get byte from table
6569: B7      	        OR      A               ; End of word ?
656A: FA8965  	        JP      M,MATCH         ; Yes - Match found
656D: 4F      	        LD      C,A             ; Save it
656E: 78      	        LD      A,B             ; Get token value
656F: FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
6571: C27865  	        JP      NZ,NOSPC        ; No - Don't allow spaces
6574: CD0568  	        CALL    GETCHR          ; Get next character
6577: 2B      	        DEC     HL              ; Cancel increment from GETCHR
6578: 23      	NOSPC:  INC     HL              ; Next byte
6579: 7E      	        LD      A,(HL)          ; Get byte
657A: FE61    	        CP      'a'             ; Less than 'a' ?
657C: DA8165  	        JP      C,NOCHNG        ; Yes - don't change
657F: E65F    	        AND     01011111B       ; Make upper case
6581: B9      	NOCHNG: CP      C               ; Same as in buffer ?
6582: CA6765  	        JP      Z,NXTBYT        ; Yes - keep testing
6585: E1      	        POP     HL              ; Get back start of word
6586: C35565  	        JP      SEARCH          ; Look at next word
              	
6589: 48      	MATCH:  LD      C,B             ; Word found - Save token value
658A: F1      	        POP     AF              ; Throw away return
658B: EB      	        EX      DE,HL
658C: C9      	        RET                     ; Return to "RETNAD"
658D: EB      	RETNAD: EX      DE,HL           ; Get address in string
658E: 79      	        LD      A,C             ; Get token value
658F: C1      	        POP     BC              ; Restore buffer length
6590: D1      	        POP     DE              ; Get destination address
6591: 23      	MOVDIR: INC     HL              ; Next source in buffer
6592: 12      	        LD      (DE),A          ; Put byte in buffer
6593: 13      	        INC     DE              ; Move up buffer
6594: 0C      	        INC     C               ; Increment length of buffer
6595: D63A    	        SUB     ':'             ; End of statement?
6597: CA9F65  	        JP      Z,SETLIT        ; Jump if multi-statement line
659A: FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
659C: C2A265  	        JP      NZ,TSTREM       ; No - see if REM
659F: 32AE80  	SETLIT: LD      (DATFLG),A      ; Set literal flag
65A2: D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
65A4: C21265  	        JP      NZ,CRNCLP       ; No - Leave flag
65A7: 47      	        LD      B,A             ; Copy rest of buffer
65A8: 7E      	NXTCHR: LD      A,(HL)          ; Get byte
65A9: B7      	        OR      A               ; End of line ?
65AA: CAB865  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
65AD: B8      	        CP      B               ; End of statement ?
65AE: CA9165  	        JP      Z,MOVDIR        ; Yes - Get next one
65B1: 23      	CPYLIT: INC     HL              ; Move up source string
65B2: 12      	        LD      (DE),A          ; Save in destination
65B3: 0C      	        INC     C               ; Increment length
65B4: 13      	        INC     DE              ; Move up destination
65B5: C3A865  	        JP      NXTCHR          ; Repeat
              	
65B8: 216080  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
65BB: 12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
65BC: 13      	        INC     DE
65BD: 12      	        LD      (DE),A          ; A = 00
65BE: 13      	        INC     DE
65BF: 12      	        LD      (DE),A          ; A = 00
65C0: C9      	        RET
              	
65C1: 3A4480  	DODEL:  LD      A,(NULFLG)      ; Get null flag status
65C4: B7      	        OR      A               ; Is it zero?
65C5: 3E00    	        LD      A,0             ; Zero A - Leave flags
65C7: 324480  	        LD      (NULFLG),A      ; Zero null flag
65CA: C2D565  	        JP      NZ,ECHDEL       ; Set - Echo it
65CD: 05      	        DEC     B               ; Decrement length
65CE: CAF265  	        JP      Z,GETLIN        ; Get line again if empty
65D1: CD8666  	        CALL    OUTC            ; Output null character
65D4: 3E      	        .BYTE   3EH             ; Skip "DEC B"
65D5: 05      	ECHDEL: DEC     B               ; Count bytes in buffer
65D6: 2B      	        DEC     HL              ; Back space buffer
65D7: CAE965  	        JP      Z,OTKLN         ; No buffer - Try again
65DA: 7E      	        LD      A,(HL)          ; Get deleted byte
65DB: CD8666  	        CALL    OUTC            ; Echo it
65DE: C3FB65  	        JP      MORINP          ; Get more input
              	
65E1: 05      	DELCHR: DEC     B               ; Count bytes in buffer
65E2: 2B      	        DEC     HL              ; Back space buffer
65E3: CD8666  	        CALL    OUTC            ; Output character in A
65E6: C2FB65  	        JP      NZ,MORINP       ; Not end - Get more
65E9: CD8666  	OTKLN:  CALL    OUTC            ; Output character in A
65EC: CDAD6A  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
65EF: C3F265  	        JP      TTYLIN          ; Get line again
              	
65F2:         	GETLIN:
65F2: 216180  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
65F5: 0601    	        LD      B,1             ; Set buffer as empty
65F7: AF      	        XOR     A
65F8: 324480  	        LD      (NULFLG),A      ; Clear null flag
65FB: CDB066  	MORINP: CALL    CLOTST          ; Get character and test ^O
65FE: 4F      	        LD      C,A             ; Save character in C
65FF: FE7F    	        CP      DEL             ; Delete character?
6601: CAC165  	        JP      Z,DODEL         ; Yes - Process it
6604: 3A4480  	        LD      A,(NULFLG)      ; Get null flag
6607: B7      	        OR      A               ; Test null flag status
6608: CA1466  	        JP      Z,PROCES        ; Reset - Process character
660B: 3E00    	        LD      A,0             ; Set a null
660D: CD8666  	        CALL    OUTC            ; Output null
6610: AF      	        XOR     A               ; Clear A
6611: 324480  	        LD      (NULFLG),A      ; Reset null flag
6614: 79      	PROCES: LD      A,C             ; Get character
6615: FE07    	        CP      CTRLG           ; Bell?
6617: CA5866  	        JP      Z,PUTCTL        ; Yes - Save it
661A: FE03    	        CP      CTRLC           ; Is it control "C"?
661C: CCAD6A  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
661F: 37      	        SCF                     ; Flag break
6620: C8      	        RET     Z               ; Return if control "C"
6621: FE0D    	        CP      CR              ; Is it enter?
6623: CAA86A  	        JP      Z,ENDINP        ; Yes - Terminate input
6626: FE15    	        CP      CTRLU           ; Is it control "U"?
6628: CAEC65  	        JP      Z,KILIN         ; Yes - Get another line
662B: FE40    	        CP      '@'             ; Is it "kill line"?
662D: CAE965  	        JP      Z,OTKLN         ; Yes - Kill line
6630: FE5F    	        CP      '_'             ; Is it delete?
6632: CAE165  	        JP      Z,DELCHR        ; Yes - Delete character
6635: FE08    	        CP      BKSP            ; Is it backspace?
6637: CAE165  	        JP      Z,DELCHR        ; Yes - Delete character
663A: FE12    	        CP      CTRLR           ; Is it control "R"?
663C: C25366  	        JP      NZ,PUTBUF       ; No - Put in buffer
663F: C5      	        PUSH    BC              ; Save buffer length
6640: D5      	        PUSH    DE              ; Save DE
6641: E5      	        PUSH    HL              ; Save buffer address
6642: 3600    	        LD      (HL),0          ; Mark end of buffer
6644: CD5D7C  	        CALL    OUTNCR          ; Output and do CRLF
6647: 216180  	        LD      HL,BUFFER       ; Point to buffer start
664A: CD4B71  	        CALL    PRS             ; Output buffer
664D: E1      	        POP     HL              ; Restore buffer address
664E: D1      	        POP     DE              ; Restore DE
664F: C1      	        POP     BC              ; Restore buffer length
6650: C3FB65  	        JP      MORINP          ; Get another character
              	
6653: FE20    	PUTBUF: CP      ' '             ; Is it a control code?
6655: DAFB65  	        JP      C,MORINP        ; Yes - Ignore
6658: 78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
6659: FE49    	        CP      72+1            ; Test for line overflow
665B: 3E07    	        LD      A,CTRLG         ; Set a bell
665D: D26D66  	        JP      NC,OUTNBS       ; Ring bell if buffer full
6660: 79      	        LD      A,C             ; Get character
6661: 71      	        LD      (HL),C          ; Save in buffer
6662: 32CC80  	        LD      (LSTBIN),A      ; Save last input byte
6665: 23      	        INC     HL              ; Move up buffer
6666: 04      	        INC     B               ; Increment length
6667: CD8666  	OUTIT:  CALL    OUTC            ; Output the character entered
666A: C3FB65  	        JP      MORINP          ; Get another character
              	
666D: CD8666  	OUTNBS: CALL    OUTC            ; Output bell and back over it
6670: 3E08    	        LD      A,BKSP          ; Set back space
6672: C36766  	        JP      OUTIT           ; Output it and get more
              	
6675: 7C      	CPDEHL: LD      A,H             ; Get H
6676: 92      	        SUB     D               ; Compare with D
6677: C0      	        RET     NZ              ; Different - Exit
6678: 7D      	        LD      A,L             ; Get L
6679: 93      	        SUB     E               ; Compare with E
667A: C9      	        RET                     ; Return status
              	
667B: 7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
667C: E3      	        EX      (SP),HL         ; Address of test byte
667D: BE      	        CP      (HL)            ; Same as in code string?
667E: 23      	        INC     HL              ; Return address
667F: E3      	        EX      (SP),HL         ; Put it back
6680: CA0568  	        JP      Z,GETCHR        ; Yes - Get next character
6683: C3AD63  	        JP      SNERR           ; Different - ?SN Error
              	
6686: F5      	OUTC:   PUSH    AF              ; Save character
6687: 3A4580  	        LD      A,(CTLOFG)      ; Get control "O" flag
668A: B7      	        OR      A               ; Is it set?
668B: C28071  	        JP      NZ,POPAF        ; Yes - don't output
668E: F1      	        POP     AF              ; Restore character
668F: C5      	        PUSH    BC              ; Save buffer length
6690: F5      	        PUSH    AF              ; Save character
6691: FE20    	        CP      ' '             ; Is it a control code?
6693: DAAA66  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
6696: 3A4280  	        LD      A,(LWIDTH)      ; Get line width
6699: 47      	        LD      B,A             ; To B
669A: 3AAB80  	        LD      A,(CURPOS)      ; Get cursor position
669D: 04      	        INC     B               ; Width 255?
669E: CAA666  	        JP      Z,INCLEN        ; Yes - No width limit
66A1: 05      	        DEC     B               ; Restore width
66A2: B8      	        CP      B               ; At end of line?
66A3: CCAD6A  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
66A6: 3C      	INCLEN: INC     A               ; Move on one character
66A7: 32AB80  	        LD      (CURPOS),A      ; Save new position
66AA: F1      	DINPOS: POP     AF              ; Restore character
66AB: C1      	        POP     BC              ; Restore buffer length
66AC: CD467C  	        CALL    MONOUT          ; Send it
66AF: C9      	        RET
              	
66B0: CD0A7B  	CLOTST: CALL    GETINP          ; Get input character
66B3: E67F    	        AND     01111111B       ; Strip bit 7
66B5: FE0F    	        CP      CTRLO           ; Is it control "O"?
66B7: C0      	        RET     NZ              ; No don't flip flag
66B8: 3A4580  	        LD      A,(CTLOFG)      ; Get flag
66BB: 2F      	        CPL                     ; Flip it
66BC: 324580  	        LD      (CTLOFG),A      ; Put it back
66BF: AF      	        XOR     A               ; Null character
66C0: C9      	        RET
              	
66C1: CDD168  	LIST:   CALL    ATOH            ; ASCII number to DE
66C4: C0      	        RET     NZ              ; Return if anything extra
66C5: C1      	        POP     BC              ; Rubbish - Not needed
66C6: CD9964  	        CALL    SRCHLN          ; Search for line number in DE
66C9: C5      	        PUSH    BC              ; Save address of line
66CA: CD1767  	        CALL    SETLIN          ; Set up lines counter
66CD: E1      	LISTLP: POP     HL              ; Restore address of line
66CE: 4E      	        LD      C,(HL)          ; Get LSB of next line
66CF: 23      	        INC     HL
66D0: 46      	        LD      B,(HL)          ; Get MSB of next line
66D1: 23      	        INC     HL
66D2: 78      	        LD      A,B             ; BC = 0 (End of program)?
66D3: B1      	        OR      C
66D4: CAF863  	        JP      Z,PRNTOK        ; Yes - Go to command mode
66D7: CD2067  	        CALL    COUNT           ; Count lines
66DA: CD3068  	        CALL    TSTBRK          ; Test for break key
66DD: C5      	        PUSH    BC              ; Save address of next line
66DE: CDAD6A  	        CALL    PRNTCRLF        ; Output CRLF
66E1: 5E      	        LD      E,(HL)          ; Get LSB of line number
66E2: 23      	        INC     HL
66E3: 56      	        LD      D,(HL)          ; Get MSB of line number
66E4: 23      	        INC     HL
66E5: E5      	        PUSH    HL              ; Save address of line start
66E6: EB      	        EX      DE,HL           ; Line number to HL
66E7: CDEE77  	        CALL    PRNTHL          ; Output line number in decimal
66EA: 3E20    	        LD      A,' '           ; Space after line number
66EC: E1      	        POP     HL              ; Restore start of line address
66ED: CD8666  	LSTLP2: CALL    OUTC            ; Output character in A
66F0: 7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
66F1: B7      	        OR      A               ; End of line?
66F2: 23      	        INC     HL              ; To next byte in line
66F3: CACD66  	        JP      Z,LISTLP        ; Yes - get next line
66F6: F2ED66  	        JP      P,LSTLP2        ; No token - output it
66F9: D67F    	        SUB     ZEND-1          ; Find and output word
66FB: 4F      	        LD      C,A             ; Token offset+1 to C
66FC: 113661  	        LD      DE,WORDS        ; Reserved word list
66FF: 1A      	FNDTOK: LD      A,(DE)          ; Get character in list
6700: 13      	        INC     DE              ; Move on to next
6701: B7      	        OR      A               ; Is it start of word?
6702: F2FF66  	        JP      P,FNDTOK        ; No - Keep looking for word
6705: 0D      	        DEC     C               ; Count words
6706: C2FF66  	        JP      NZ,FNDTOK       ; Not there - keep looking
6709: E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
670B: CD8666  	        CALL    OUTC            ; Output first character
670E: 1A      	        LD      A,(DE)          ; Get next character
670F: 13      	        INC     DE              ; Move on to next
6710: B7      	        OR      A               ; Is it end of word?
6711: F20967  	        JP      P,OUTWRD        ; No - output the rest
6714: C3F066  	        JP      LSTLP3          ; Next byte in line
              	
6717: E5      	SETLIN: PUSH    HL              ; Set up LINES counter
6718: 2A4880  	        LD      HL,(LINESN)     ; Get LINES number
671B: 224680  	        LD      (LINESC),HL     ; Save in LINES counter
671E: E1      	        POP     HL
671F: C9      	        RET
              	
6720: E5      	COUNT:  PUSH    HL              ; Save code string address
6721: D5      	        PUSH    DE
6722: 2A4680  	        LD      HL,(LINESC)     ; Get LINES counter
6725: 11FFFF  	        LD      DE,-1
6728: ED5A    	        ADC     HL,DE           ; Decrement
672A: 224680  	        LD      (LINESC),HL     ; Put it back
672D: D1      	        POP     DE
672E: E1      	        POP     HL              ; Restore code string address
672F: F0      	        RET     P               ; Return if more lines to go
6730: E5      	        PUSH    HL              ; Save code string address
6731: 2A4880  	        LD      HL,(LINESN)     ; Get LINES number
6734: 224680  	        LD      (LINESC),HL     ; Reset LINES counter
6737: CD0A7B  	        CALL    GETINP          ; Get input character
673A: FE03    	        CP      CTRLC           ; Is it control "C"?
673C: CA4367  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
673F: E1      	        POP     HL              ; Restore code string address
6740: C32067  	        JP      COUNT           ; Keep on counting
              	
6743: 2A4880  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
6746: 224680  	        LD      (LINESC),HL     ; Reset LINES counter
6749: C3A760  	        JP      BRKRET          ; Go and output "Break"
              	
674C: 3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
674E: 32CB80  	        LD      (FORFLG),A      ; Save "FOR" flag
6751: CDB369  	        CALL    LET             ; Set up initial index
6754: C1      	        POP     BC              ; Drop RETurn address
6755: E5      	        PUSH    HL              ; Save code string address
6756: CD9C69  	        CALL    DATA            ; Get next statement address
6759: 22C780  	        LD      (LOOPST),HL     ; Save it for start of loop
675C: 210200  	        LD      HL,2            ; Offset for "FOR" block
675F: 39      	        ADD     HL,SP           ; Point to it
6760: CD5A63  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
6763: D1      	        POP     DE              ; Get code string address
6764: C27C67  	        JP      NZ,FORFND       ; No nesting found
6767: 09      	        ADD     HL,BC           ; Move into "FOR" block
6768: D5      	        PUSH    DE              ; Save code string address
6769: 2B      	        DEC     HL
676A: 56      	        LD      D,(HL)          ; Get MSB of loop statement
676B: 2B      	        DEC     HL
676C: 5E      	        LD      E,(HL)          ; Get LSB of loop statement
676D: 23      	        INC     HL
676E: 23      	        INC     HL
676F: E5      	        PUSH    HL              ; Save block address
6770: 2AC780  	        LD      HL,(LOOPST)     ; Get address of loop statement
6773: CD7566  	        CALL    CPDEHL          ; Compare the FOR loops
6776: E1      	        POP     HL              ; Restore block address
6777: C26067  	        JP      NZ,FORSLP       ; Different FORs - Find another
677A: D1      	        POP     DE              ; Restore code string address
677B: F9      	        LD      SP,HL           ; Remove all nested loops
              	
677C: EB      	FORFND: EX      DE,HL           ; Code string address to HL
677D: 0E08    	        LD      C,8
677F: CD8A63  	        CALL    CHKSTK          ; Check for 8 levels of stack
6782: E5      	        PUSH    HL              ; Save code string address
6783: 2AC780  	        LD      HL,(LOOPST)     ; Get first statement of loop
6786: E3      	        EX      (SP),HL         ; Save and restore code string
6787: E5      	        PUSH    HL              ; Re-save code string address
6788: 2A5C80  	        LD      HL,(LINEAT)     ; Get current line number
678B: E3      	        EX      (SP),HL         ; Save and restore code string
678C: CD756C  	        CALL    TSTNUM          ; Make sure it's a number
678F: CD7B66  	        CALL    CHKSYN          ; Make sure "TO" is next
6792: A6      	        .BYTE   ZTO          ; "TO" token
6793: CD726C  	        CALL    GETNUM          ; Get "TO" expression value
6796: E5      	        PUSH    HL              ; Save code string address
6797: CDA076  	        CALL    BCDEFP          ; Move "TO" value to BCDE
679A: E1      	        POP     HL              ; Restore code string address
679B: C5      	        PUSH    BC              ; Save "TO" value in block
679C: D5      	        PUSH    DE
679D: 010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
67A0: 51      	        LD      D,C             ; C=0
67A1: 5A      	        LD      E,D             ; D=0
67A2: 7E      	        LD      A,(HL)          ; Get next byte in code string
67A3: FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
67A5: 3E01    	        LD      A,1             ; Sign of step = 1
67A7: C2B867  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
67AA: CD0568  	        CALL    GETCHR          ; Jump over "STEP" token
67AD: CD726C  	        CALL    GETNUM          ; Get step value
67B0: E5      	        PUSH    HL              ; Save code string address
67B1: CDA076  	        CALL    BCDEFP          ; Move STEP to BCDE
67B4: CD5476  	        CALL    TSTSGN          ; Test sign of FPREG
67B7: E1      	        POP     HL              ; Restore code string address
67B8: C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
67B9: D5      	        PUSH    DE
67BA: F5      	        PUSH    AF              ; Save sign of STEP
67BB: 33      	        INC     SP              ; Don't save flags
67BC: E5      	        PUSH    HL              ; Save code string address
67BD: 2ACE80  	        LD      HL,(BRKLIN)     ; Get address of index variable
67C0: E3      	        EX      (SP),HL         ; Save and restore code string
67C1: 0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
67C3: C5      	        PUSH    BC              ; Save it
67C4: 33      	        INC     SP              ; Don't save C
              	
67C5: CD3068  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
67C8: 22CE80  	        LD      (BRKLIN),HL     ; Save code address for break
67CB: 7E      	        LD      A,(HL)          ; Get next byte in code string
67CC: FE3A    	        CP      ':'             ; Multi statement line?
67CE: CAE567  	        JP      Z,EXCUTE        ; Yes - Execute it
67D1: B7      	        OR      A               ; End of line?
67D2: C2AD63  	        JP      NZ,SNERR        ; No - Syntax error
67D5: 23      	        INC     HL              ; Point to address of next line
67D6: 7E      	        LD      A,(HL)          ; Get LSB of line pointer
67D7: 23      	        INC     HL
67D8: B6      	        OR      (HL)            ; Is it zero (End of prog)?
67D9: CA5768  	        JP      Z,ENDPRG        ; Yes - Terminate execution
67DC: 23      	        INC     HL              ; Point to line number
67DD: 5E      	        LD      E,(HL)          ; Get LSB of line number
67DE: 23      	        INC     HL
67DF: 56      	        LD      D,(HL)          ; Get MSB of line number
67E0: EB      	        EX      DE,HL           ; Line number to HL
67E1: 225C80  	        LD      (LINEAT),HL     ; Save as current line number
67E4: EB      	        EX      DE,HL           ; Line number back to DE
67E5: CD0568  	EXCUTE: CALL    GETCHR          ; Get key word
67E8: 11C567  	        LD      DE,RUNCNT       ; Where to RETurn to
67EB: D5      	        PUSH    DE              ; Save for RETurn
67EC: C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
67ED: D680    	ONJMP:  SUB     ZEND            ; Is it a token?
67EF: DAB369  	        JP      C,LET           ; No - try to assign it
67F2: FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
67F4: D2AD63  	        JP      NC,SNERR        ; Not a key word - ?SN Error
67F7: 07      	        RLCA                    ; Double it
67F8: 4F      	        LD      C,A             ; BC = Offset into table
67F9: 0600    	        LD      B,0
67FB: EB      	        EX      DE,HL           ; Save code string address
67FC: 215562  	        LD      HL,WORDTB       ; Keyword address table
67FF: 09      	        ADD     HL,BC           ; Point to routine address
6800: 4E      	        LD      C,(HL)          ; Get LSB of routine address
6801: 23      	        INC     HL
6802: 46      	        LD      B,(HL)          ; Get MSB of routine address
6803: C5      	        PUSH    BC              ; Save routine address
6804: EB      	        EX      DE,HL           ; Restore code string address
              	
6805: 23      	GETCHR: INC     HL              ; Point to next character
6806: 7E      	        LD      A,(HL)          ; Get next code string byte
6807: FE3A    	        CP      ':'             ; Z if ':'
6809: D0      	        RET     NC              ; NC if > "9"
680A: FE20    	        CP      ' '
680C: CA0568  	        JP      Z,GETCHR        ; Skip over spaces
680F: FE30    	        CP      '0'
6811: 3F      	        CCF                     ; NC if < '0'
6812: 3C      	        INC     A               ; Test for zero - Leave carry
6813: 3D      	        DEC     A               ; Z if Null
6814: C9      	        RET
              	
6815: EB      	RESTOR: EX      DE,HL           ; Save code string address
6816: 2A5E80  	        LD      HL,(BASTXT)     ; Point to start of program
6819: CA2A68  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
681C: EB      	        EX      DE,HL           ; Restore code string address
681D: CDD168  	        CALL    ATOH            ; Get line number to DE
6820: E5      	        PUSH    HL              ; Save code string address
6821: CD9964  	        CALL    SRCHLN          ; Search for line number in DE
6824: 60      	        LD      H,B             ; HL = Address of line
6825: 69      	        LD      L,C
6826: D1      	        POP     DE              ; Restore code string address
6827: D27269  	        JP      NC,ULERR        ; ?UL Error if not found
682A: 2B      	RESTNL: DEC     HL              ; Byte before DATA statement
682B: 22DC80  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
682E: EB      	        EX      DE,HL           ; Restore code string address
682F: C9      	        RET
              	
              	
6830: DF      	TSTBRK: RST     18H             ; Check input status
6831: C8      	        RET     Z               ; No key, go back
6832: D7      	        RST     10H             ; Get the key into A
6833: FE1B    	        CP      ESC             ; Escape key?
6835: 2811    	        JR      Z,BRK           ; Yes, break
6837: FE03    	        CP      CTRLC           ; <Ctrl-C>
6839: 280D    	        JR      Z,BRK           ; Yes, break
683B: FE13    	        CP      CTRLS           ; Stop scrolling?
683D: C0      	        RET     NZ              ; Other key, ignore
              	
              	
683E: D7      	STALL:  RST     10H             ; Wait for key
683F: FE11    	        CP      CTRLQ           ; Resume scrolling?
6841: C8      	        RET      Z              ; Release the chokehold
6842: FE03    	        CP      CTRLC           ; Second break?
6844: 2807    	        JR      Z,STOP          ; Break during hold exits prog
6846: 18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
6848: 3EFF    	BRK     LD      A,$FF           ; Set BRKFLG
684A: 324D80  	        LD      (BRKFLG),A      ; Store it
              	
              	
684D: C0      	STOP:   RET     NZ              ; Exit if anything else
684E: F6      	        .BYTE   0F6H            ; Flag "STOP"
684F: C0      	PEND:   RET     NZ              ; Exit if anything else
6850: 22CE80  	        LD      (BRKLIN),HL     ; Save point of break
6853: 21      	        .BYTE   21H             ; Skip "OR 11111111B"
6854: F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
6856: C1      	        POP     BC              ; Return not needed and more
6857: 2A5C80  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
685A: F5      	        PUSH    AF              ; Save STOP / END status
685B: 7D      	        LD      A,L             ; Is it direct break?
685C: A4      	        AND     H
685D: 3C      	        INC     A               ; Line is -1 if direct break
685E: CA6A68  	        JP      Z,NOLIN         ; Yes - No line number
6861: 22D280  	        LD      (ERRLIN),HL     ; Save line of break
6864: 2ACE80  	        LD      HL,(BRKLIN)     ; Get point of break
6867: 22D480  	        LD      (CONTAD),HL     ; Save point to CONTinue
686A: AF      	NOLIN:  XOR     A
686B: 324580  	        LD      (CTLOFG),A      ; Enable output
686E: CDA06A  	        CALL    STTLIN          ; Start a new line
6871: F1      	        POP     AF              ; Restore STOP / END status
6872: 215063  	        LD      HL,BRKMSG       ; "Break" message
6875: C2E163  	        JP      NZ,ERRIN        ; "in line" wanted?
6878: C3F863  	        JP      PRNTOK          ; Go to command mode
              	
687B: 2AD480  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
687E: 7C      	        LD      A,H             ; Is it zero?
687F: B5      	        OR      L
6880: 1E20    	        LD      E,CN            ; ?CN Error
6882: CAC163  	        JP      Z,ERROR         ; Yes - output "?CN Error"
6885: EB      	        EX      DE,HL           ; Save code string address
6886: 2AD280  	        LD      HL,(ERRLIN)     ; Get line of last break
6889: 225C80  	        LD      (LINEAT),HL     ; Set up current line number
688C: EB      	        EX      DE,HL           ; Restore code string address
688D: C9      	        RET                     ; CONTinue where left off
              	
688E: CDD373  	NULL:   CALL    GETINT          ; Get integer 0-255
6891: C0      	        RET     NZ              ; Return if bad value
6892: 324180  	        LD      (NULLS),A       ; Set nulls number
6895: C9      	        RET
              	
              	
6896: E5      	ACCSUM: PUSH    HL              ; Save address in array
6897: 2A4A80  	        LD      HL,(CHKSUM)     ; Get check sum
689A: 0600    	        LD      B,0             ; BC - Value of byte
689C: 4F      	        LD      C,A
689D: 09      	        ADD     HL,BC           ; Add byte to check sum
689E: 224A80  	        LD      (CHKSUM),HL     ; Re-save check sum
68A1: E1      	        POP     HL              ; Restore address in array
68A2: C9      	        RET
              	
68A3: 7E      	CHKLTR: LD      A,(HL)          ; Get byte
68A4: FE41    	        CP      'A'             ; < 'a' ?
68A6: D8      	        RET     C               ; Carry set if not letter
68A7: FE5B    	        CP      'Z'+1           ; > 'z' ?
68A9: 3F      	        CCF
68AA: C9      	        RET                     ; Carry set if not letter
              	
68AB: CD0568  	FPSINT: CALL    GETCHR          ; Get next character
68AE: CD726C  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
68B1: CD5476  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
68B4: FACC68  	        JP      M,FCERR         ; Negative - ?FC Error
68B7: 3AE780  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
68BA: FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
68BC: DAFC76  	        JP      C,FPINT         ; Yes - convert it
68BF: 018090  	        LD      BC,9080H        ; BCDE = -32768
68C2: 110000  	        LD      DE,0000
68C5: E5      	        PUSH    HL              ; Save code string address
68C6: CDCF76  	        CALL    CMPNUM          ; Compare FPREG with BCDE
68C9: E1      	        POP     HL              ; Restore code string address
68CA: 51      	        LD      D,C             ; MSB to D
68CB: C8      	        RET     Z               ; Return if in range
68CC: 1E08    	FCERR:  LD      E,FC            ; ?FC Error
68CE: C3C163  	        JP      ERROR           ; Output error-
              	
68D1: 2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
68D2: 110000  	GETLN:  LD      DE,0            ; Get number to DE
68D5: CD0568  	GTLNLP: CALL    GETCHR          ; Get next character
68D8: D0      	        RET     NC              ; Exit if not a digit
68D9: E5      	        PUSH    HL              ; Save code string address
68DA: F5      	        PUSH    AF              ; Save digit
68DB: 219819  	        LD      HL,65529/10     ; Largest number 65529
68DE: CD7566  	        CALL    CPDEHL          ; Number in range?
68E1: DAAD63  	        JP      C,SNERR         ; No - ?SN Error
68E4: 62      	        LD      H,D             ; HL = Number
68E5: 6B      	        LD      L,E
68E6: 19      	        ADD     HL,DE           ; Times 2
68E7: 29      	        ADD     HL,HL           ; Times 4
68E8: 19      	        ADD     HL,DE           ; Times 5
68E9: 29      	        ADD     HL,HL           ; Times 10
68EA: F1      	        POP     AF              ; Restore digit
68EB: D630    	        SUB     '0'             ; Make it 0 to 9
68ED: 5F      	        LD      E,A             ; DE = Value of digit
68EE: 1600    	        LD      D,0
68F0: 19      	        ADD     HL,DE           ; Add to number
68F1: EB      	        EX      DE,HL           ; Number to DE
68F2: E1      	        POP     HL              ; Restore code string address
68F3: C3D568  	        JP      GTLNLP          ; Go to next character
              	
68F6: CAC964  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
68F9: CDAE68  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
68FC: 2B      	        DEC     HL              ; Cancel increment
68FD: CD0568  	        CALL    GETCHR          ; Get next character
6900: E5      	        PUSH    HL              ; Save code string address
6901: 2AAF80  	        LD      HL,(LSTRAM)     ; Get end of RAM
6904: CA1969  	        JP      Z,STORED        ; No value given - Use stored
6907: E1      	        POP     HL              ; Restore code string address
6908: CD7B66  	        CALL    CHKSYN          ; Check for comma
690B: 2C      	        .BYTE      ','
690C: D5      	        PUSH    DE              ; Save number
690D: CDAE68  	        CALL    POSINT          ; Get integer 0 to 32767
6910: 2B      	        DEC     HL              ; Cancel increment
6911: CD0568  	        CALL    GETCHR          ; Get next character
6914: C2AD63  	        JP      NZ,SNERR        ; ?SN Error if more on line
6917: E3      	        EX      (SP),HL         ; Save code string address
6918: EB      	        EX      DE,HL           ; Number to DE
6919: 7D      	STORED: LD      A,L             ; Get LSB of new RAM top
691A: 93      	        SUB     E               ; Subtract LSB of string space
691B: 5F      	        LD      E,A             ; Save LSB
691C: 7C      	        LD      A,H             ; Get MSB of new RAM top
691D: 9A      	        SBC     A,D             ; Subtract MSB of string space
691E: 57      	        LD      D,A             ; Save MSB
691F: DAA263  	        JP      C,OMERR         ; ?OM Error if not enough mem
6922: E5      	        PUSH    HL              ; Save RAM top
6923: 2AD680  	        LD      HL,(PROGND)     ; Get program end
6926: 012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
6929: 09      	        ADD     HL,BC           ; Get lowest address
692A: CD7566  	        CALL    CPDEHL          ; Enough memory?
692D: D2A263  	        JP      NC,OMERR        ; No - ?OM Error
6930: EB      	        EX      DE,HL           ; RAM top to HL
6931: 225A80  	        LD      (STRSPC),HL     ; Set new string space
6934: E1      	        POP     HL              ; End of memory to use
6935: 22AF80  	        LD      (LSTRAM),HL     ; Set new top of RAM
6938: E1      	        POP     HL              ; Restore code string address
6939: C3C964  	        JP      INTVAR          ; Initialise variables
              	
693C: CAC564  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
693F: CDC964  	        CALL    INTVAR          ; Initialise variables
6942: 01C567  	        LD      BC,RUNCNT       ; Execution driver loop
6945: C35869  	        JP      RUNLIN          ; RUN from line number
              	
6948: 0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
694A: CD8A63  	        CALL    CHKSTK          ; Check for 3 levels of stack
694D: C1      	        POP     BC              ; Get return address
694E: E5      	        PUSH    HL              ; Save code string for RETURN
694F: E5      	        PUSH    HL              ; And for GOSUB routine
6950: 2A5C80  	        LD      HL,(LINEAT)     ; Get current line
6953: E3      	        EX      (SP),HL         ; Into stack - Code string out
6954: 3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
6956: F5      	        PUSH    AF              ; Save token
6957: 33      	        INC     SP              ; Don't save flags
              	
6958: C5      	RUNLIN: PUSH    BC              ; Save return address
6959: CDD168  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
695C: CD9E69  	        CALL    REM             ; Get end of line
695F: E5      	        PUSH    HL              ; Save end of line
6960: 2A5C80  	        LD      HL,(LINEAT)     ; Get current line
6963: CD7566  	        CALL    CPDEHL          ; Line after current?
6966: E1      	        POP     HL              ; Restore end of line
6967: 23      	        INC     HL              ; Start of next line
6968: DC9C64  	        CALL    C,SRCHLP        ; Line is after current line
696B: D49964  	        CALL    NC,SRCHLN       ; Line is before current line
696E: 60      	        LD      H,B             ; Set up code string address
696F: 69      	        LD      L,C
6970: 2B      	        DEC     HL              ; Incremented after
6971: D8      	        RET     C               ; Line found
6972: 1E0E    	ULERR:  LD      E,UL            ; ?UL Error
6974: C3C163  	        JP      ERROR           ; Output error message
              	
6977: C0      	RETURN: RET     NZ              ; Return if not just RETURN
6978: 16FF    	        LD      D,-1            ; Flag "GOSUB" search
697A: CD5663  	        CALL    BAKSTK          ; Look "GOSUB" block
697D: F9      	        LD      SP,HL           ; Kill all FORs in subroutine
697E: FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
6980: 1E04    	        LD      E,RG            ; ?RG Error
6982: C2C163  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
6985: E1      	        POP     HL              ; Get RETURN line number
6986: 225C80  	        LD      (LINEAT),HL     ; Save as current
6989: 23      	        INC     HL              ; Was it from direct statement?
698A: 7C      	        LD      A,H
698B: B5      	        OR      L               ; Return to line
698C: C29669  	        JP      NZ,RETLIN       ; No - Return to line
698F: 3ACC80  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
6992: B7      	        OR      A               ; If so buffer is corrupted
6993: C2F763  	        JP      NZ,POPNOK       ; Yes - Go to command mode
6996: 21C567  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
6999: E3      	        EX      (SP),HL         ; Into stack - Code string out
699A: 3E      	        .BYTE      3EH             ; Skip "POP HL"
699B: E1      	NXTDTA: POP     HL              ; Restore code string address
              	
699C: 013A    	DATA:   .BYTE      01H,3AH         ; ':' End of statement
699E: 0E00    	REM:    LD      C,0             ; 00  End of statement
69A0: 0600    	        LD      B,0
69A2: 79      	NXTSTL: LD      A,C             ; Statement and byte
69A3: 48      	        LD      C,B
69A4: 47      	        LD      B,A             ; Statement end byte
69A5: 7E      	NXTSTT: LD      A,(HL)          ; Get byte
69A6: B7      	        OR      A               ; End of line?
69A7: C8      	        RET     Z               ; Yes - Exit
69A8: B8      	        CP      B               ; End of statement?
69A9: C8      	        RET     Z               ; Yes - Exit
69AA: 23      	        INC     HL              ; Next byte
69AB: FE22    	        CP      '"'             ; Literal string?
69AD: CAA269  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
69B0: C3A569  	        JP      NXTSTT          ; Keep looking
              	
69B3: CD686E  	LET:    CALL    GETVAR          ; Get variable name
69B6: CD7B66  	        CALL    CHKSYN          ; Make sure "=" follows
69B9: B4      	        .BYTE      ZEQUAL          ; "=" token
69BA: D5      	        PUSH    DE              ; Save address of variable
69BB: 3AAD80  	        LD      A,(TYPE)        ; Get data type
69BE: F5      	        PUSH    AF              ; Save type
69BF: CD846C  	        CALL    EVAL            ; Evaluate expression
69C2: F1      	        POP     AF              ; Restore type
69C3: E3      	        EX      (SP),HL         ; Save code - Get var addr
69C4: 22CE80  	        LD      (BRKLIN),HL     ; Save address of variable
69C7: 1F      	        RRA                     ; Adjust type
69C8: CD776C  	        CALL    CHKTYP          ; Check types are the same
69CB: CA066A  	        JP      Z,LETNUM        ; Numeric - Move value
69CE: E5      	LETSTR: PUSH    HL              ; Save address of string var
69CF: 2AE480  	        LD      HL,(FPREG)      ; Pointer to string entry
69D2: E5      	        PUSH    HL              ; Save it on stack
69D3: 23      	        INC     HL              ; Skip over length
69D4: 23      	        INC     HL
69D5: 5E      	        LD      E,(HL)          ; LSB of string address
69D6: 23      	        INC     HL
69D7: 56      	        LD      D,(HL)          ; MSB of string address
69D8: 2A5E80  	        LD      HL,(BASTXT)     ; Point to start of program
69DB: CD7566  	        CALL    CPDEHL          ; Is string before program?
69DE: D2F569  	        JP      NC,CRESTR       ; Yes - Create string entry
69E1: 2A5A80  	        LD      HL,(STRSPC)     ; Point to string space
69E4: CD7566  	        CALL    CPDEHL          ; Is string literal in program?
69E7: D1      	        POP     DE              ; Restore address of string
69E8: D2FD69  	        JP      NC,MVSTPT       ; Yes - Set up pointer
69EB: 21BF80  	        LD      HL,TMPSTR       ; Temporary string pool
69EE: CD7566  	        CALL    CPDEHL          ; Is string in temporary pool?
69F1: D2FD69  	        JP      NC,MVSTPT       ; No - Set up pointer
69F4: 3E      	        .BYTE   3EH             ; Skip "POP DE"
69F5: D1      	CRESTR: POP     DE              ; Restore address of string
69F6: CDAC72  	        CALL    BAKTMP          ; Back to last tmp-str entry
69F9: EB      	        EX      DE,HL           ; Address of string entry
69FA: CDE570  	        CALL    SAVSTR          ; Save string in string area
69FD: CDAC72  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
6A00: E1      	        POP     HL              ; Get string pointer
6A01: CDAF76  	        CALL    DETHL4          ; Move string pointer to var
6A04: E1      	        POP     HL              ; Restore code string address
6A05: C9      	        RET
              	
6A06: E5      	LETNUM: PUSH    HL              ; Save address of variable
6A07: CDAC76  	        CALL    FPTHL           ; Move value to variable
6A0A: D1      	        POP     DE              ; Restore address of variable
6A0B: E1      	        POP     HL              ; Restore code string address
6A0C: C9      	        RET
              	
6A0D: CDD373  	ON:     CALL    GETINT          ; Get integer 0-255
6A10: 7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
6A11: 47      	        LD      B,A             ; Save in B
6A12: FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
6A14: CA1C6A  	        JP      Z,ONGO          ; Yes - Find line number
6A17: CD7B66  	        CALL    CHKSYN          ; Make sure it's "GOTO"
6A1A: 88      	        .BYTE   ZGOTO           ; "GOTO" token
6A1B: 2B      	        DEC     HL              ; Cancel increment
6A1C: 4B      	ONGO:   LD      C,E             ; Integer of branch value
6A1D: 0D      	ONGOLP: DEC     C               ; Count branches
6A1E: 78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
6A1F: CAED67  	        JP      Z,ONJMP         ; Go to that line if right one
6A22: CDD268  	        CALL    GETLN           ; Get line number to DE
6A25: FE2C    	        CP      ','             ; Another line number?
6A27: C0      	        RET     NZ              ; No - Drop through
6A28: C31D6A  	        JP      ONGOLP          ; Yes - loop
              	
6A2B: CD846C  	IF:     CALL    EVAL            ; Evaluate expression
6A2E: 7E      	        LD      A,(HL)          ; Get token
6A2F: FE88    	        CP      ZGOTO           ; "GOTO" token?
6A31: CA396A  	        JP      Z,IFGO          ; Yes - Get line
6A34: CD7B66  	        CALL    CHKSYN          ; Make sure it's "THEN"
6A37: A9      	        .BYTE      ZTHEN           ; "THEN" token
6A38: 2B      	        DEC     HL              ; Cancel increment
6A39: CD756C  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
6A3C: CD5476  	        CALL    TSTSGN          ; Test state of expression
6A3F: CA9E69  	        JP      Z,REM           ; False - Drop through
6A42: CD0568  	        CALL    GETCHR          ; Get next character
6A45: DA5969  	        JP      C,GOTO          ; Number - GOTO that line
6A48: C3EC67  	        JP      IFJMP           ; Otherwise do statement
              	
6A4B: 2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
6A4C: CD0568  	        CALL    GETCHR          ; Get next character
6A4F: CAAD6A  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
6A52: C8      	PRNTLP: RET     Z               ; End of list - Exit
6A53: FEA5    	        CP      ZTAB            ; "TAB(" token?
6A55: CAE06A  	        JP      Z,DOTAB         ; Yes - Do TAB routine
6A58: FEA8    	        CP      ZSPC            ; "SPC(" token?
6A5A: CAE06A  	        JP      Z,DOTAB         ; Yes - Do SPC routine
6A5D: E5      	        PUSH    HL              ; Save code string address
6A5E: FE2C    	        CP      ','             ; Comma?
6A60: CAC96A  	        JP      Z,DOCOM         ; Yes - Move to next zone
6A63: FE3B    	        CP      59 ;";"         ; Semi-colon?
6A65: CA036B  	        JP      Z,NEXITM        ; Do semi-colon routine
6A68: C1      	        POP     BC              ; Code string address to BC
6A69: CD846C  	        CALL    EVAL            ; Evaluate expression
6A6C: E5      	        PUSH    HL              ; Save code string address
6A6D: 3AAD80  	        LD      A,(TYPE)        ; Get variable type
6A70: B7      	        OR      A               ; Is it a string variable?
6A71: C2996A  	        JP      NZ,PRNTST       ; Yes - Output string contents
6A74: CDF977  	        CALL    NUMASC          ; Convert number to text
6A77: CD0971  	        CALL    CRTST           ; Create temporary string
6A7A: 3620    	        LD      (HL),' '        ; Followed by a space
6A7C: 2AE480  	        LD      HL,(FPREG)      ; Get length of output
6A7F: 34      	        INC     (HL)            ; Plus 1 for the space
6A80: 2AE480  	        LD      HL,(FPREG)      ; < Not needed >
6A83: 3A4280  	        LD      A,(LWIDTH)      ; Get width of line
6A86: 47      	        LD      B,A             ; To B
6A87: 04      	        INC     B               ; Width 255 (No limit)?
6A88: CA956A  	        JP      Z,PRNTNB        ; Yes - Output number string
6A8B: 04      	        INC     B               ; Adjust it
6A8C: 3AAB80  	        LD      A,(CURPOS)      ; Get cursor position
6A8F: 86      	        ADD     A,(HL)          ; Add length of string
6A90: 3D      	        DEC     A               ; Adjust it
6A91: B8      	        CP      B               ; Will output fit on this line?
6A92: D4AD6A  	        CALL    NC,PRNTCRLF     ; No - CRLF first
6A95: CD4E71  	PRNTNB: CALL    PRS1            ; Output string at (HL)
6A98: AF      	        XOR     A               ; Skip CALL by setting 'z' flag
6A99: C44E71  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
6A9C: E1      	        POP     HL              ; Restore code string address
6A9D: C34B6A  	        JP      MRPRNT          ; See if more to PRINT
              	
6AA0: 3AAB80  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
6AA3: B7      	        OR      A               ; Already at start?
6AA4: C8      	        RET     Z               ; Yes - Do nothing
6AA5: C3AD6A  	        JP      PRNTCRLF        ; Start a new line
              	
6AA8: 3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
6AAA: 216080  	        LD      HL,BUFFER-1     ; Point to buffer
6AAD: 3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
6AAF: CD8666  	        CALL    OUTC            ; Output character
6AB2: 3E0A    	        LD      A,LF            ; Load a LF
6AB4: CD8666  	        CALL    OUTC            ; Output character
6AB7: AF      	DONULL: XOR     A               ; Set to position 0
6AB8: 32AB80  	        LD      (CURPOS),A      ; Store it
6ABB: 3A4180  	        LD      A,(NULLS)       ; Get number of nulls
6ABE: 3D      	NULLP:  DEC     A               ; Count them
6ABF: C8      	        RET     Z               ; Return if done
6AC0: F5      	        PUSH    AF              ; Save count
6AC1: AF      	        XOR     A               ; Load a null
6AC2: CD8666  	        CALL    OUTC            ; Output it
6AC5: F1      	        POP     AF              ; Restore count
6AC6: C3BE6A  	        JP      NULLP           ; Keep counting
              	
6AC9: 3A4380  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
6ACC: 47      	        LD      B,A             ; Save in B
6ACD: 3AAB80  	        LD      A,(CURPOS)      ; Get current position
6AD0: B8      	        CP      B               ; Within the limit?
6AD1: D4AD6A  	        CALL    NC,PRNTCRLF     ; No - output CRLF
6AD4: D2036B  	        JP      NC,NEXITM       ; Get next item
6AD7: D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
6AD9: D2D76A  	        JP      NC,ZONELP       ; Repeat if more zones
6ADC: 2F      	        CPL                     ; Number of spaces to output
6ADD: C3F86A  	        JP      ASPCS           ; Output them
              	
6AE0: F5      	DOTAB:  PUSH    AF              ; Save token
6AE1: CDD073  	        CALL    FNDNUM          ; Evaluate expression
6AE4: CD7B66  	        CALL    CHKSYN          ; Make sure ")" follows
6AE7: 29      	        .BYTE   ")"
6AE8: 2B      	        DEC     HL              ; Back space on to ")"
6AE9: F1      	        POP     AF              ; Restore token
6AEA: D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
6AEC: E5      	        PUSH    HL              ; Save code string address
6AED: CAF36A  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
6AF0: 3AAB80  	        LD      A,(CURPOS)      ; Get current position
6AF3: 2F      	DOSPC:  CPL                     ; Number of spaces to print to
6AF4: 83      	        ADD     A,E             ; Total number to print
6AF5: D2036B  	        JP      NC,NEXITM       ; TAB < Current POS(X)
6AF8: 3C      	ASPCS:  INC     A               ; Output A spaces
6AF9: 47      	        LD      B,A             ; Save number to print
6AFA: 3E20    	        LD      A,' '           ; Space
6AFC: CD8666  	SPCLP:  CALL    OUTC            ; Output character in A
6AFF: 05      	        DEC     B               ; Count them
6B00: C2FC6A  	        JP      NZ,SPCLP        ; Repeat if more
6B03: E1      	NEXITM: POP     HL              ; Restore code string address
6B04: CD0568  	        CALL    GETCHR          ; Get next character
6B07: C3526A  	        JP      PRNTLP          ; More to print
              	
6B0A: 3F526564	REDO:   .BYTE   "?Redo from start",CR,LF,0
6B0E: 6F206672	
6B12: 6F6D2073	
6B16: 74617274	
6B1A: 0D0A00  	
              	
6B1D: 3ACD80  	BADINP: LD      A,(READFG)      ; READ or INPUT?
6B20: B7      	        OR      A
6B21: C2A763  	        JP      NZ,DATSNR       ; READ - ?SN Error
6B24: C1      	        POP     BC              ; Throw away code string addr
6B25: 210A6B  	        LD      HL,REDO         ; "Redo from start" message
6B28: CD4B71  	        CALL    PRS             ; Output string
6B2B: C3F864  	        JP      DOAGN           ; Do last INPUT again
              	
6B2E: CDB670  	INPUT:  CALL    IDTEST          ; Test for illegal direct
6B31: 7E      	        LD      A,(HL)          ; Get character after "INPUT"
6B32: FE22    	        CP      '"'             ; Is there a prompt string?
6B34: 3E00    	        LD      A,0             ; Clear A and leave flags
6B36: 324580  	        LD      (CTLOFG),A      ; Enable output
6B39: C2486B  	        JP      NZ,NOPMPT       ; No prompt - get input
6B3C: CD0A71  	        CALL    QTSTR           ; Get string terminated by '"'
6B3F: CD7B66  	        CALL    CHKSYN          ; Check for ';' after prompt
6B42: 3B      	        .BYTE   ';'
6B43: E5      	        PUSH    HL              ; Save code string address
6B44: CD4E71  	        CALL    PRS1            ; Output prompt string
6B47: 3E      	        .BYTE   3EH             ; Skip "PUSH HL"
6B48: E5      	NOPMPT: PUSH    HL              ; Save code string address
6B49: CDFC64  	        CALL    PROMPT          ; Get input with "? " prompt
6B4C: C1      	        POP     BC              ; Restore code string address
6B4D: DA5468  	        JP      C,INPBRK        ; Break pressed - Exit
6B50: 23      	        INC     HL              ; Next byte
6B51: 7E      	        LD      A,(HL)          ; Get it
6B52: B7      	        OR      A               ; End of line?
6B53: 2B      	        DEC     HL              ; Back again
6B54: C5      	        PUSH    BC              ; Re-save code string address
6B55: CA9B69  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
6B58: 362C    	        LD      (HL),','        ; Store comma as separator
6B5A: C3626B  	        JP      NXTITM          ; Get next item
              	
6B5D: E5      	READ:   PUSH    HL              ; Save code string address
6B5E: 2ADC80  	        LD      HL,(NXTDAT)     ; Next DATA statement
6B61: F6      	        .BYTE   0F6H            ; Flag "READ"
6B62: AF      	NXTITM: XOR     A               ; Flag "INPUT"
6B63: 32CD80  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
6B66: E3      	        EX      (SP),HL         ; Get code str' , Save pointer
6B67: C36E6B  	        JP      GTVLUS          ; Get values
              	
6B6A: CD7B66  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
6B6D: 2C      	        .BYTE      ','
6B6E: CD686E  	GTVLUS: CALL    GETVAR          ; Get variable name
6B71: E3      	        EX      (SP),HL         ; Save code str" , Get pointer
6B72: D5      	        PUSH    DE              ; Save variable address
6B73: 7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
6B74: FE2C    	        CP      ','             ; Comma?
6B76: CA966B  	        JP      Z,ANTVLU        ; Yes - Get another value
6B79: 3ACD80  	        LD      A,(READFG)      ; Is it READ?
6B7C: B7      	        OR      A
6B7D: C2036C  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
6B80: 3E3F    	        LD      A,'?'           ; More INPUT needed
6B82: CD8666  	        CALL    OUTC            ; Output character
6B85: CDFC64  	        CALL    PROMPT          ; Get INPUT with prompt
6B88: D1      	        POP     DE              ; Variable address
6B89: C1      	        POP     BC              ; Code string address
6B8A: DA5468  	        JP      C,INPBRK        ; Break pressed
6B8D: 23      	        INC     HL              ; Point to next DATA byte
6B8E: 7E      	        LD      A,(HL)          ; Get byte
6B8F: B7      	        OR      A               ; Is it zero (No input) ?
6B90: 2B      	        DEC     HL              ; Back space INPUT pointer
6B91: C5      	        PUSH    BC              ; Save code string address
6B92: CA9B69  	        JP      Z,NXTDTA        ; Find end of buffer
6B95: D5      	        PUSH    DE              ; Save variable address
6B96: 3AAD80  	ANTVLU: LD      A,(TYPE)        ; Check data type
6B99: B7      	        OR      A               ; Is it numeric?
6B9A: CAC06B  	        JP      Z,INPBIN        ; Yes - Convert to binary
6B9D: CD0568  	        CALL    GETCHR          ; Get next character
6BA0: 57      	        LD      D,A             ; Save input character
6BA1: 47      	        LD      B,A             ; Again
6BA2: FE22    	        CP      '"'             ; Start of literal sting?
6BA4: CAB46B  	        JP      Z,STRENT        ; Yes - Create string entry
6BA7: 3ACD80  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
6BAA: B7      	        OR      A
6BAB: 57      	        LD      D,A             ; Save 00 if "INPUT"
6BAC: CAB16B  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
6BAF: 163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
6BB1: 062C    	ITMSEP: LD      B,','           ; Item separator
6BB3: 2B      	        DEC     HL              ; Back space for DTSTR
6BB4: CD0D71  	STRENT: CALL    DTSTR           ; Get string terminated by D
6BB7: EB      	        EX      DE,HL           ; String address to DE
6BB8: 21CB6B  	        LD      HL,LTSTND       ; Where to go after LETSTR
6BBB: E3      	        EX      (SP),HL         ; Save HL , get input pointer
6BBC: D5      	        PUSH    DE              ; Save address of string
6BBD: C3CE69  	        JP      LETSTR          ; Assign string to variable
              	
6BC0: CD0568  	INPBIN: CALL    GETCHR          ; Get next character
6BC3: CD5B77  	        CALL    ASCTFP          ; Convert ASCII to FP number
6BC6: E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
6BC7: CDAC76  	        CALL    FPTHL           ; Move FPREG to variable
6BCA: E1      	        POP     HL              ; Restore input pointer
6BCB: 2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
6BCC: CD0568  	        CALL    GETCHR          ; Get next character
6BCF: CAD76B  	        JP      Z,MORDT         ; End of line - More needed?
6BD2: FE2C    	        CP      ','             ; Another value?
6BD4: C21D6B  	        JP      NZ,BADINP       ; No - Bad input
6BD7: E3      	MORDT:  EX      (SP),HL         ; Get code string address
6BD8: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
6BD9: CD0568  	        CALL    GETCHR          ; Get next character
6BDC: C26A6B  	        JP      NZ,NEDMOR       ; More needed - Get it
6BDF: D1      	        POP     DE              ; Restore DATA pointer
6BE0: 3ACD80  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
6BE3: B7      	        OR      A
6BE4: EB      	        EX      DE,HL           ; DATA pointer to HL
6BE5: C22B68  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
6BE8: D5      	        PUSH    DE              ; Save code string address
6BE9: B6      	        OR      (HL)            ; More input given?
6BEA: 21F26B  	        LD      HL,EXTIG        ; "?Extra ignored" message
6BED: C44B71  	        CALL    NZ,PRS          ; Output string if extra given
6BF0: E1      	        POP     HL              ; Restore code string address
6BF1: C9      	        RET
              	
6BF2: 3F457874	EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
6BF6: 72612069	
6BFA: 676E6F72	
6BFE: 65640D0A	
6C02: 00      	
              	
6C03: CD9C69  	FDTLP:  CALL    DATA            ; Get next statement
6C06: B7      	        OR      A               ; End of line?
6C07: C21C6C  	        JP      NZ,FANDT        ; No - See if DATA statement
6C0A: 23      	        INC     HL
6C0B: 7E      	        LD      A,(HL)          ; End of program?
6C0C: 23      	        INC     HL
6C0D: B6      	        OR      (HL)            ; 00 00 Ends program
6C0E: 1E06    	        LD      E,OD            ; ?OD Error
6C10: CAC163  	        JP      Z,ERROR         ; Yes - Out of DATA
6C13: 23      	        INC     HL
6C14: 5E      	        LD      E,(HL)          ; LSB of line number
6C15: 23      	        INC     HL
6C16: 56      	        LD      D,(HL)          ; MSB of line number
6C17: EB      	        EX      DE,HL
6C18: 22C980  	        LD      (DATLIN),HL     ; Set line of current DATA item
6C1B: EB      	        EX      DE,HL
6C1C: CD0568  	FANDT:  CALL    GETCHR          ; Get next character
6C1F: FE83    	        CP      ZDATA           ; "DATA" token
6C21: C2036C  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
6C24: C3966B  	        JP      ANTVLU          ; Found - Convert input
              	
6C27: 110000  	NEXT:   LD      DE,0            ; In case no index given
6C2A: C4686E  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
6C2D: 22CE80  	        LD      (BRKLIN),HL     ; Save code string address
6C30: CD5663  	        CALL    BAKSTK          ; Look for "FOR" block
6C33: C2B363  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
6C36: F9      	        LD      SP,HL           ; Clear nested loops
6C37: D5      	        PUSH    DE              ; Save index address
6C38: 7E      	        LD      A,(HL)          ; Get sign of STEP
6C39: 23      	        INC     HL
6C3A: F5      	        PUSH    AF              ; Save sign of STEP
6C3B: D5      	        PUSH    DE              ; Save index address
6C3C: CD9276  	        CALL    PHLTFP          ; Move index value to FPREG
6C3F: E3      	        EX      (SP),HL         ; Save address of TO value
6C40: E5      	        PUSH    HL              ; Save address of index
6C41: CDFF73  	        CALL    ADDPHL          ; Add STEP to index value
6C44: E1      	        POP     HL              ; Restore address of index
6C45: CDAC76  	        CALL    FPTHL           ; Move value to index variable
6C48: E1      	        POP     HL              ; Restore address of TO value
6C49: CDA376  	        CALL    LOADFP          ; Move TO value to BCDE
6C4C: E5      	        PUSH    HL              ; Save address of line of FOR
6C4D: CDCF76  	        CALL    CMPNUM          ; Compare index with TO value
6C50: E1      	        POP     HL              ; Restore address of line num
6C51: C1      	        POP     BC              ; Address of sign of STEP
6C52: 90      	        SUB     B               ; Compare with expected sign
6C53: CDA376  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
6C56: CA626C  	        JP      Z,KILFOR        ; Loop finished - Terminate it
6C59: EB      	        EX      DE,HL           ; Loop statement line number
6C5A: 225C80  	        LD      (LINEAT),HL     ; Set loop line number
6C5D: 69      	        LD      L,C             ; Set code string to loop
6C5E: 60      	        LD      H,B
6C5F: C3C167  	        JP      PUTFID          ; Put back "FOR" and continue
              	
6C62: F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
6C63: 2ACE80  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
6C66: 7E      	        LD      A,(HL)          ; Get next byte in code string
6C67: FE2C    	        CP      ','             ; More NEXTs ?
6C69: C2C567  	        JP      NZ,RUNCNT       ; No - Do next statement
6C6C: CD0568  	        CALL    GETCHR          ; Position to index name
6C6F: CD2A6C  	        CALL    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
6C72: CD846C  	GETNUM: CALL    EVAL            ; Get a numeric expression
6C75: F6      	TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
6C76: 37      	TSTSTR: SCF                     ; Set carry (string)
6C77: 3AAD80  	CHKTYP: LD      A,(TYPE)        ; Check types match
6C7A: 8F      	        ADC     A,A             ; Expected + actual
6C7B: B7      	        OR      A               ; Clear carry , set parity
6C7C: E8      	        RET     PE              ; Even parity - Types match
6C7D: C3BF63  	        JP      TMERR           ; Different types - Error
              	
6C80: CD7B66  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
6C83: 28      	        .BYTE   "("
6C84: 2B      	EVAL:   DEC     HL              ; Evaluate expression & save
6C85: 1600    	        LD      D,0             ; Precedence value
6C87: D5      	EVAL1:  PUSH    DE              ; Save precedence
6C88: 0E01    	        LD      C,1
6C8A: CD8A63  	        CALL    CHKSTK          ; Check for 1 level of stack
6C8D: CDFB6C  	        CALL    OPRND           ; Get next expression value
6C90: 22D080  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
6C93: 2AD080  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
6C96: C1      	        POP     BC              ; Precedence value and operator
6C97: 78      	        LD      A,B             ; Get precedence value
6C98: FE78    	        CP      78H             ; "AND" or "OR" ?
6C9A: D4756C  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
6C9D: 7E      	        LD      A,(HL)          ; Get next operator / function
6C9E: 1600    	        LD      D,0             ; Clear Last relation
6CA0: D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
6CA2: DABC6C  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
6CA5: FE03    	        CP      ZLTH+1-ZGTR     ; < = >
6CA7: D2BC6C  	        JP      NC,FOPRND       ; Function - Call it
6CAA: FE01    	        CP      ZEQUAL-ZGTR     ; "="
6CAC: 17      	        RLA                     ; <- Test for legal
6CAD: AA      	        XOR     D               ; <- combinations of < = >
6CAE: BA      	        CP      D               ; <- by combining last token
6CAF: 57      	        LD      D,A             ; <- with current one
6CB0: DAAD63  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
6CB3: 22C580  	        LD      (CUROPR),HL     ; Save address of current token
6CB6: CD0568  	        CALL    GETCHR          ; Get next character
6CB9: C3A06C  	        JP      RLTLP           ; Treat the two as one
              	
6CBC: 7A      	FOPRND: LD      A,D             ; < = > found ?
6CBD: B7      	        OR      A
6CBE: C2E36D  	        JP      NZ,TSTRED       ; Yes - Test for reduction
6CC1: 7E      	        LD      A,(HL)          ; Get operator token
6CC2: 22C580  	        LD      (CUROPR),HL     ; Save operator address
6CC5: D6AC    	        SUB     ZPLUS           ; Operator or function?
6CC7: D8      	        RET     C               ; Neither - Exit
6CC8: FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
6CCA: D0      	        RET     NC              ; No - Exit
6CCB: 5F      	        LD      E,A             ; Coded operator
6CCC: 3AAD80  	        LD      A,(TYPE)        ; Get data type
6CCF: 3D      	        DEC     A               ; FF = numeric , 00 = string
6CD0: B3      	        OR      E               ; Combine with coded operator
6CD1: 7B      	        LD      A,E             ; Get coded operator
6CD2: CA4172  	        JP      Z,CONCAT        ; String concatenation
6CD5: 07      	        RLCA                    ; Times 2
6CD6: 83      	        ADD     A,E             ; Times 3
6CD7: 5F      	        LD      E,A             ; To DE (D is 0)
6CD8: 219F62  	        LD      HL,PRITAB       ; Precedence table
6CDB: 19      	        ADD     HL,DE           ; To the operator concerned
6CDC: 78      	        LD      A,B             ; Last operator precedence
6CDD: 56      	        LD      D,(HL)          ; Get evaluation precedence
6CDE: BA      	        CP      D               ; Compare with eval precedence
6CDF: D0      	        RET     NC              ; Exit if higher precedence
6CE0: 23      	        INC     HL              ; Point to routine address
6CE1: CD756C  	        CALL    TSTNUM          ; Make sure it's a number
              	
6CE4: C5      	STKTHS: PUSH    BC              ; Save last precedence & token
6CE5: 01936C  	        LD      BC,EVAL3        ; Where to go on prec' break
6CE8: C5      	        PUSH    BC              ; Save on stack for return
6CE9: 43      	        LD      B,E             ; Save operator
6CEA: 4A      	        LD      C,D             ; Save precedence
6CEB: CD8576  	        CALL    STAKFP          ; Move value to stack
6CEE: 58      	        LD      E,B             ; Restore operator
6CEF: 51      	        LD      D,C             ; Restore precedence
6CF0: 4E      	        LD      C,(HL)          ; Get LSB of routine address
6CF1: 23      	        INC     HL
6CF2: 46      	        LD      B,(HL)          ; Get MSB of routine address
6CF3: 23      	        INC     HL
6CF4: C5      	        PUSH    BC              ; Save routine address
6CF5: 2AC580  	        LD      HL,(CUROPR)     ; Address of current operator
6CF8: C3876C  	        JP      EVAL1           ; Loop until prec' break
              	
6CFB: AF      	OPRND:  XOR     A               ; Get operand routine
6CFC: 32AD80  	        LD      (TYPE),A        ; Set numeric expected
6CFF: CD0568  	        CALL    GETCHR          ; Get next character
6D02: 1E24    	        LD      E,MO            ; ?MO Error
6D04: CAC163  	        JP      Z,ERROR         ; No operand - Error
6D07: DA5B77  	        JP      C,ASCTFP        ; Number - Get value
6D0A: CDA368  	        CALL    CHKLTR          ; See if a letter
6D0D: D2626D  	        JP      NC,CONVAR       ; Letter - Find variable
6D10: FE26    	        CP		'&'				; &H = HEX, &B = BINARY
6D12: 2012    	        JR		NZ, NOTAMP
6D14: CD0568  	        CALL    GETCHR          ; Get next character
6D17: FE48    	        CP      'H'             ; Hex number indicated? [function added]
6D19: CA9F7B  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
6D1C: FE42    	        CP      'B'             ; Binary number indicated? [function added]
6D1E: CA0F7C  	        JP      Z,BINTFP        ; Convert Bin to FPREG
6D21: 1E02    	        LD      E,SN            ; If neither then a ?SN Error
6D23: CAC163  	        JP      Z,ERROR         ; 
6D26: FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
6D28: CAFB6C  	        JP      Z,OPRND         ; Yes - Look for operand
6D2B: FE2E    	        CP      '.'             ; '.' ?
6D2D: CA5B77  	        JP      Z,ASCTFP        ; Yes - Create FP number
6D30: FEAD    	        CP      ZMINUS          ; '-' Token ?
6D32: CA516D  	        JP      Z,MINUS         ; Yes - Do minus
6D35: FE22    	        CP      '"'             ; Literal string ?
6D37: CA0A71  	        JP      Z,QTSTR         ; Get string terminated by '"'
6D3A: FEAA    	        CP      ZNOT            ; "NOT" Token ?
6D3C: CA436E  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
6D3F: FEA7    	        CP      ZFN             ; "FN" Token ?
6D41: CA6E70  	        JP      Z,DOFN          ; Yes - Do FN routine
6D44: D6B6    	        SUB     ZSGN            ; Is it a function?
6D46: D2736D  	        JP      NC,FNOFST       ; Yes - Evaluate function
6D49: CD806C  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
6D4C: CD7B66  	        CALL    CHKSYN          ; Make sure ")" follows
6D4F: 29      	        .BYTE   ")"
6D50: C9      	        RET
              	
6D51: 167D    	MINUS:  LD      D,7DH           ; '-' precedence
6D53: CD876C  	        CALL    EVAL1           ; Evaluate until prec' break
6D56: 2AD080  	        LD      HL,(NXTOPR)     ; Get next operator address
6D59: E5      	        PUSH    HL              ; Save next operator address
6D5A: CD7D76  	        CALL    INVSGN          ; Negate value
6D5D: CD756C  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
6D60: E1      	        POP     HL              ; Restore next operator address
6D61: C9      	        RET
              	
6D62: CD686E  	CONVAR: CALL    GETVAR          ; Get variable address to DE
6D65: E5      	FRMEVL: PUSH    HL              ; Save code string address
6D66: EB      	        EX      DE,HL           ; Variable address to HL
6D67: 22E480  	        LD      (FPREG),HL      ; Save address of variable
6D6A: 3AAD80  	        LD      A,(TYPE)        ; Get type
6D6D: B7      	        OR      A               ; Numeric?
6D6E: CC9276  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
6D71: E1      	        POP     HL              ; Restore code string address
6D72: C9      	        RET
              	
6D73: 0600    	FNOFST: LD      B,0             ; Get address of function
6D75: 07      	        RLCA                    ; Double function offset
6D76: 4F      	        LD      C,A             ; BC = Offset in function table
6D77: C5      	        PUSH    BC              ; Save adjusted token value
6D78: CD0568  	        CALL    GETCHR          ; Get next character
6D7B: 79      	        LD      A,C             ; Get adjusted token value
6D7C: FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
6D7E: DA9A6D  	        JP      C,FNVAL         ; No - Do function
6D81: CD806C  	        CALL    OPNPAR          ; Evaluate expression  (X,...
6D84: CD7B66  	        CALL    CHKSYN          ; Make sure ',' follows
6D87: 2C      	        .BYTE      ','
6D88: CD766C  	        CALL    TSTSTR          ; Make sure it's a string
6D8B: EB      	        EX      DE,HL           ; Save code string address
6D8C: 2AE480  	        LD      HL,(FPREG)      ; Get address of string
6D8F: E3      	        EX      (SP),HL         ; Save address of string
6D90: E5      	        PUSH    HL              ; Save adjusted token value
6D91: EB      	        EX      DE,HL           ; Restore code string address
6D92: CDD373  	        CALL    GETINT          ; Get integer 0-255
6D95: EB      	        EX      DE,HL           ; Save code string address
6D96: E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
6D97: C3A26D  	        JP      GOFUNC          ; Jump to string function
              	
6D9A: CD496D  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
6D9D: E3      	        EX      (SP),HL         ; HL = Adjusted token value
6D9E: 115D6D  	        LD      DE,RETNUM       ; Return number from function
6DA1: D5      	        PUSH    DE              ; Save on stack
6DA2: 01FE60  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
6DA5: 09      	        ADD     HL,BC           ; Point to right address
6DA6: 4E      	        LD      C,(HL)          ; Get LSB of address
6DA7: 23      	        INC     HL              ;
6DA8: 66      	        LD      H,(HL)          ; Get MSB of address
6DA9: 69      	        LD      L,C             ; Address to HL
6DAA: E9      	        JP      (HL)            ; Jump to function
              	
6DAB: 15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
6DAC: FEAD    	        CP      ZMINUS          ; '-' token ?
6DAE: C8      	        RET     Z               ; Yes - Return
6DAF: FE2D    	        CP      '-'             ; '-' ASCII ?
6DB1: C8      	        RET     Z               ; Yes - Return
6DB2: 14      	        INC     D               ; Inc to flag positive exponent
6DB3: FE2B    	        CP      '+'             ; '+' ASCII ?
6DB5: C8      	        RET     Z               ; Yes - Return
6DB6: FEAC    	        CP      ZPLUS           ; '+' token ?
6DB8: C8      	        RET     Z               ; Yes - Return
6DB9: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
6DBA: C9      	        RET                     ; Return "NZ"
              	
6DBB: F6      	POR:    .BYTE      0F6H            ; Flag "OR"
6DBC: AF      	PAND:   XOR     A               ; Flag "AND"
6DBD: F5      	        PUSH    AF              ; Save "AND" / "OR" flag
6DBE: CD756C  	        CALL    TSTNUM          ; Make sure it's a number
6DC1: CDB768  	        CALL    DEINT           ; Get integer -32768 to 32767
6DC4: F1      	        POP     AF              ; Restore "AND" / "OR" flag
6DC5: EB      	        EX      DE,HL           ; <- Get last
6DC6: C1      	        POP     BC              ; <-  value
6DC7: E3      	        EX      (SP),HL         ; <-  from
6DC8: EB      	        EX      DE,HL           ; <-  stack
6DC9: CD9576  	        CALL    FPBCDE          ; Move last value to FPREG
6DCC: F5      	        PUSH    AF              ; Save "AND" / "OR" flag
6DCD: CDB768  	        CALL    DEINT           ; Get integer -32768 to 32767
6DD0: F1      	        POP     AF              ; Restore "AND" / "OR" flag
6DD1: C1      	        POP     BC              ; Get value
6DD2: 79      	        LD      A,C             ; Get LSB
6DD3: 212C70  	        LD      HL,ACPASS       ; Address of save AC as current
6DD6: C2DE6D  	        JP      NZ,POR1         ; Jump if OR
6DD9: A3      	        AND     E               ; "AND" LSBs
6DDA: 4F      	        LD      C,A             ; Save LSB
6DDB: 78      	        LD      A,B             ; Get MBS
6DDC: A2      	        AND     D               ; "AND" MSBs
6DDD: E9      	        JP      (HL)            ; Save AC as current (ACPASS)
              	
6DDE: B3      	POR1:   OR      E               ; "OR" LSBs
6DDF: 4F      	        LD      C,A             ; Save LSB
6DE0: 78      	        LD      A,B             ; Get MSB
6DE1: B2      	        OR      D               ; "OR" MSBs
6DE2: E9      	        JP      (HL)            ; Save AC as current (ACPASS)
              	
6DE3: 21F56D  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
6DE6: 3AAD80  	        LD      A,(TYPE)        ; Get data type
6DE9: 1F      	        RRA                     ; Carry set = string
6DEA: 7A      	        LD      A,D             ; Get last precedence value
6DEB: 17      	        RLA                     ; Times 2 plus carry
6DEC: 5F      	        LD      E,A             ; To E
6DED: 1664    	        LD      D,64H           ; Relational precedence
6DEF: 78      	        LD      A,B             ; Get current precedence
6DF0: BA      	        CP      D               ; Compare with last
6DF1: D0      	        RET     NC              ; Eval if last was rel' or log'
6DF2: C3E46C  	        JP      STKTHS          ; Stack this one and get next
              	
6DF5: F76D    	CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
6DF7: 79      	CMPLG1: LD      A,C             ; Get data type
6DF8: B7      	        OR      A
6DF9: 1F      	        RRA
6DFA: C1      	        POP     BC              ; Get last expression to BCDE
6DFB: D1      	        POP     DE
6DFC: F5      	        PUSH    AF              ; Save status
6DFD: CD776C  	        CALL    CHKTYP          ; Check that types match
6E00: 21396E  	        LD      HL,CMPRES       ; Result to comparison
6E03: E5      	        PUSH    HL              ; Save for RETurn
6E04: CACF76  	        JP      Z,CMPNUM        ; Compare values if numeric
6E07: AF      	        XOR     A               ; Compare two strings
6E08: 32AD80  	        LD      (TYPE),A        ; Set type to numeric
6E0B: D5      	        PUSH    DE              ; Save string name
6E0C: CD8E72  	        CALL    GSTRCU          ; Get current string
6E0F: 7E      	        LD      A,(HL)          ; Get length of string
6E10: 23      	        INC     HL
6E11: 23      	        INC     HL
6E12: 4E      	        LD      C,(HL)          ; Get LSB of address
6E13: 23      	        INC     HL
6E14: 46      	        LD      B,(HL)          ; Get MSB of address
6E15: D1      	        POP     DE              ; Restore string name
6E16: C5      	        PUSH    BC              ; Save address of string
6E17: F5      	        PUSH    AF              ; Save length of string
6E18: CD9272  	        CALL    GSTRDE          ; Get second string
6E1B: CDA376  	        CALL    LOADFP          ; Get address of second string
6E1E: F1      	        POP     AF              ; Restore length of string 1
6E1F: 57      	        LD      D,A             ; Length to D
6E20: E1      	        POP     HL              ; Restore address of string 1
6E21: 7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
6E22: B2      	        OR      D               ; Bytes of string 1 to do
6E23: C8      	        RET     Z               ; Exit if all bytes compared
6E24: 7A      	        LD      A,D             ; Get bytes of string 1 to do
6E25: D601    	        SUB     1
6E27: D8      	        RET     C               ; Exit if end of string 1
6E28: AF      	        XOR     A
6E29: BB      	        CP      E               ; Bytes of string 2 to do
6E2A: 3C      	        INC     A
6E2B: D0      	        RET     NC              ; Exit if end of string 2
6E2C: 15      	        DEC     D               ; Count bytes in string 1
6E2D: 1D      	        DEC     E               ; Count bytes in string 2
6E2E: 0A      	        LD      A,(BC)          ; Byte in string 2
6E2F: BE      	        CP      (HL)            ; Compare to byte in string 1
6E30: 23      	        INC     HL              ; Move up string 1
6E31: 03      	        INC     BC              ; Move up string 2
6E32: CA216E  	        JP      Z,CMPSTR        ; Same - Try next bytes
6E35: 3F      	        CCF                     ; Flag difference (">" or "<")
6E36: C35F76  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
6E39: 3C      	CMPRES: INC     A               ; Increment current value
6E3A: 8F      	        ADC     A,A             ; Double plus carry
6E3B: C1      	        POP     BC              ; Get other value
6E3C: A0      	        AND     B               ; Combine them
6E3D: C6FF    	        ADD     A,-1            ; Carry set if different
6E3F: 9F      	        SBC     A,A             ; 00 - Equal , FF - Different
6E40: C36676  	        JP      FLGREL          ; Set current value & continue
              	
6E43: 165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
6E45: CD876C  	        CALL    EVAL1           ; Eval until precedence break
6E48: CD756C  	        CALL    TSTNUM          ; Make sure it's a number
6E4B: CDB768  	        CALL    DEINT           ; Get integer -32768 - 32767
6E4E: 7B      	        LD      A,E             ; Get LSB
6E4F: 2F      	        CPL                     ; Invert LSB
6E50: 4F      	        LD      C,A             ; Save "NOT" of LSB
6E51: 7A      	        LD      A,D             ; Get MSB
6E52: 2F      	        CPL                     ; Invert MSB
6E53: CD2C70  	        CALL    ACPASS          ; Save AC as current
6E56: C1      	        POP     BC              ; Clean up stack
6E57: C3936C  	        JP      EVAL3           ; Continue evaluation
              	
6E5A: 2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
6E5B: CD0568  	        CALL    GETCHR          ; Get next character
6E5E: C8      	        RET     Z               ; End of DIM statement
6E5F: CD7B66  	        CALL    CHKSYN          ; Make sure ',' follows
6E62: 2C      	        .BYTE      ','
6E63: 015A6E  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
6E66: C5      	        PUSH    BC              ; Save on stack
6E67: F6      	        .BYTE      0F6H            ; Flag "Create" variable
6E68: AF      	GETVAR: XOR     A               ; Find variable address,to DE
6E69: 32AC80  	        LD      (LCRFLG),A      ; Set locate / create flag
6E6C: 46      	        LD      B,(HL)          ; Get First byte of name
6E6D: CDA368  	GTFNAM: CALL    CHKLTR          ; See if a letter
6E70: DAAD63  	        JP      C,SNERR         ; ?SN Error if not a letter
6E73: AF      	        XOR     A
6E74: 4F      	        LD      C,A             ; Clear second byte of name
6E75: 32AD80  	        LD      (TYPE),A        ; Set type to numeric
6E78: CD0568  	        CALL    GETCHR          ; Get next character
6E7B: DA846E  	        JP      C,SVNAM2        ; Numeric - Save in name
6E7E: CDA368  	        CALL    CHKLTR          ; See if a letter
6E81: DA916E  	        JP      C,CHARTY        ; Not a letter - Check type
6E84: 4F      	SVNAM2: LD      C,A             ; Save second byte of name
6E85: CD0568  	ENDNAM: CALL    GETCHR          ; Get next character
6E88: DA856E  	        JP      C,ENDNAM        ; Numeric - Get another
6E8B: CDA368  	        CALL    CHKLTR          ; See if a letter
6E8E: D2856E  	        JP      NC,ENDNAM       ; Letter - Get another
6E91: D624    	CHARTY: SUB     '$'             ; String variable?
6E93: C2A06E  	        JP      NZ,NOTSTR       ; No - Numeric variable
6E96: 3C      	        INC     A               ; A = 1 (string type)
6E97: 32AD80  	        LD      (TYPE),A        ; Set type to string
6E9A: 0F      	        RRCA                    ; A = 80H , Flag for string
6E9B: 81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
6E9C: 4F      	        LD      C,A             ; Resave second byte on name
6E9D: CD0568  	        CALL    GETCHR          ; Get next character
6EA0: 3ACB80  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
6EA3: 3D      	        DEC     A
6EA4: CA4D6F  	        JP      Z,ARLDSV        ; Yes - Get array name
6EA7: F2B06E  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
6EAA: 7E      	        LD      A,(HL)          ; Get byte again
6EAB: D628    	        SUB     '('             ; Subscripted variable?
6EAD: CA256F  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
              	
6EB0: AF      	NSCFOR: XOR     A               ; Simple variable
6EB1: 32CB80  	        LD      (FORFLG),A      ; Clear "FOR" flag
6EB4: E5      	        PUSH    HL              ; Save code string address
6EB5: 50      	        LD      D,B             ; DE = Variable name to find
6EB6: 59      	        LD      E,C
6EB7: 2ADE80  	        LD      HL,(FNRGNM)     ; FN argument name
6EBA: CD7566  	        CALL    CPDEHL          ; Is it the FN argument?
6EBD: 11E080  	        LD      DE,FNARG        ; Point to argument value
6EC0: CA9575  	        JP      Z,POPHRT        ; Yes - Return FN argument value
6EC3: 2AD880  	        LD      HL,(VAREND)     ; End of variables
6EC6: EB      	        EX      DE,HL           ; Address of end of search
6EC7: 2AD680  	        LD      HL,(PROGND)     ; Start of variables address
6ECA: CD7566  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
6ECD: CAE36E  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
6ED0: 79      	        LD      A,C             ; Get second byte of name
6ED1: 96      	        SUB     (HL)            ; Compare with name in list
6ED2: 23      	        INC     HL              ; Move on to first byte
6ED3: C2D86E  	        JP      NZ,FNTHR        ; Different - Find another
6ED6: 78      	        LD      A,B             ; Get first byte of name
6ED7: 96      	        SUB     (HL)            ; Compare with name in list
6ED8: 23      	FNTHR:  INC     HL              ; Move on to LSB of value
6ED9: CA176F  	        JP      Z,RETADR        ; Found - Return address
6EDC: 23      	        INC     HL              ; <- Skip
6EDD: 23      	        INC     HL              ; <- over
6EDE: 23      	        INC     HL              ; <- F.P.
6EDF: 23      	        INC     HL              ; <- value
6EE0: C3CA6E  	        JP      FNDVAR          ; Keep looking
              	
6EE3: E1      	CFEVAL: POP     HL              ; Restore code string address
6EE4: E3      	        EX      (SP),HL         ; Get return address
6EE5: D5      	        PUSH    DE              ; Save address of variable
6EE6: 11656D  	        LD      DE,FRMEVL       ; Return address in EVAL
6EE9: CD7566  	        CALL    CPDEHL          ; Called from EVAL ?
6EEC: D1      	        POP     DE              ; Restore address of variable
6EED: CA1A6F  	        JP      Z,RETNUL        ; Yes - Return null variable
6EF0: E3      	        EX      (SP),HL         ; Put back return
6EF1: E5      	        PUSH    HL              ; Save code string address
6EF2: C5      	        PUSH    BC              ; Save variable name
6EF3: 010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
6EF6: 2ADA80  	        LD      HL,(ARREND)     ; End of arrays
6EF9: E5      	        PUSH    HL              ; Save end of arrays
6EFA: 09      	        ADD     HL,BC           ; Move up 6 bytes
6EFB: C1      	        POP     BC              ; Source address in BC
6EFC: E5      	        PUSH    HL              ; Save new end address
6EFD: CD7963  	        CALL    MOVUP           ; Move arrays up
6F00: E1      	        POP     HL              ; Restore new end address
6F01: 22DA80  	        LD      (ARREND),HL     ; Set new end address
6F04: 60      	        LD      H,B             ; End of variables to HL
6F05: 69      	        LD      L,C
6F06: 22D880  	        LD      (VAREND),HL     ; Set new end address
              	
6F09: 2B      	ZEROLP: DEC     HL              ; Back through to zero variable
6F0A: 3600    	        LD      (HL),0          ; Zero byte in variable
6F0C: CD7566  	        CALL    CPDEHL          ; Done them all?
6F0F: C2096F  	        JP      NZ,ZEROLP       ; No - Keep on going
6F12: D1      	        POP     DE              ; Get variable name
6F13: 73      	        LD      (HL),E          ; Store second character
6F14: 23      	        INC     HL
6F15: 72      	        LD      (HL),D          ; Store first character
6F16: 23      	        INC     HL
6F17: EB      	RETADR: EX      DE,HL           ; Address of variable in DE
6F18: E1      	        POP     HL              ; Restore code string address
6F19: C9      	        RET
              	
6F1A: 32E780  	RETNUL: LD      (FPEXP),A       ; Set result to zero
6F1D: 214963  	        LD      HL,ZERBYT       ; Also set a null string
6F20: 22E480  	        LD      (FPREG),HL      ; Save for EVAL
6F23: E1      	        POP     HL              ; Restore code string address
6F24: C9      	        RET
              	
6F25: E5      	SBSCPT: PUSH    HL              ; Save code string address
6F26: 2AAC80  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
6F29: E3      	        EX      (SP),HL         ; Save and get code string
6F2A: 57      	        LD      D,A             ; Zero number of dimensions
6F2B: D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
6F2C: C5      	        PUSH    BC              ; Save array name
6F2D: CDAB68  	        CALL    FPSINT          ; Get subscript (0-32767)
6F30: C1      	        POP     BC              ; Restore array name
6F31: F1      	        POP     AF              ; Get number of dimensions
6F32: EB      	        EX      DE,HL
6F33: E3      	        EX      (SP),HL         ; Save subscript value
6F34: E5      	        PUSH    HL              ; Save LCRFLG and TYPE
6F35: EB      	        EX      DE,HL
6F36: 3C      	        INC     A               ; Count dimensions
6F37: 57      	        LD      D,A             ; Save in D
6F38: 7E      	        LD      A,(HL)          ; Get next byte in code string
6F39: FE2C    	        CP      ','             ; Comma (more to come)?
6F3B: CA2B6F  	        JP      Z,SCPTLP        ; Yes - More subscripts
6F3E: CD7B66  	        CALL    CHKSYN          ; Make sure ")" follows
6F41: 29      	        .BYTE      ")"
6F42: 22D080  	        LD      (NXTOPR),HL     ; Save code string address
6F45: E1      	        POP     HL              ; Get LCRFLG and TYPE
6F46: 22AC80  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
6F49: 1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
6F4B: D5      	        PUSH    DE              ; Save number of dimensions (D)
6F4C: 11      	        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
              	
6F4D: E5      	ARLDSV: PUSH    HL              ; Save code string address
6F4E: F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
6F4F: 2AD880  	        LD      HL,(VAREND)     ; Start of arrays
6F52: 3E      	        .BYTE      3EH             ; Skip "ADD HL,DE"
6F53: 19      	FNDARY: ADD     HL,DE           ; Move to next array start
6F54: EB      	        EX      DE,HL
6F55: 2ADA80  	        LD      HL,(ARREND)     ; End of arrays
6F58: EB      	        EX      DE,HL           ; Current array pointer
6F59: CD7566  	        CALL    CPDEHL          ; End of arrays found?
6F5C: CA856F  	        JP      Z,CREARY        ; Yes - Create array
6F5F: 7E      	        LD      A,(HL)          ; Get second byte of name
6F60: B9      	        CP      C               ; Compare with name given
6F61: 23      	        INC     HL              ; Move on
6F62: C2676F  	        JP      NZ,NXTARY       ; Different - Find next array
6F65: 7E      	        LD      A,(HL)          ; Get first byte of name
6F66: B8      	        CP      B               ; Compare with name given
6F67: 23      	NXTARY: INC     HL              ; Move on
6F68: 5E      	        LD      E,(HL)          ; Get LSB of next array address
6F69: 23      	        INC     HL
6F6A: 56      	        LD      D,(HL)          ; Get MSB of next array address
6F6B: 23      	        INC     HL
6F6C: C2536F  	        JP      NZ,FNDARY       ; Not found - Keep looking
6F6F: 3AAC80  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
6F72: B7      	        OR      A
6F73: C2B663  	        JP      NZ,DDERR        ; Create - ?DD Error
6F76: F1      	        POP     AF              ; Locate - Get number of dim'ns
6F77: 44      	        LD      B,H             ; BC Points to array dim'ns
6F78: 4D      	        LD      C,L
6F79: CA9575  	        JP      Z,POPHRT        ; Jump if array load/save
6F7C: 96      	        SUB     (HL)            ; Same number of dimensions?
6F7D: CAE36F  	        JP      Z,FINDEL        ; Yes - Find element
6F80: 1E10    	BSERR:  LD      E,BS            ; ?BS Error
6F82: C3C163  	        JP      ERROR           ; Output error
              	
6F85: 110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
6F88: F1      	        POP     AF              ; Array to save or 0 dim'ns?
6F89: CACC68  	        JP      Z,FCERR         ; Yes - ?FC Error
6F8C: 71      	        LD      (HL),C          ; Save second byte of name
6F8D: 23      	        INC     HL
6F8E: 70      	        LD      (HL),B          ; Save first byte of name
6F8F: 23      	        INC     HL
6F90: 4F      	        LD      C,A             ; Number of dimensions to C
6F91: CD8A63  	        CALL    CHKSTK          ; Check if enough memory
6F94: 23      	        INC     HL              ; Point to number of dimensions
6F95: 23      	        INC     HL
6F96: 22C580  	        LD      (CUROPR),HL     ; Save address of pointer
6F99: 71      	        LD      (HL),C          ; Set number of dimensions
6F9A: 23      	        INC     HL
6F9B: 3AAC80  	        LD      A,(LCRFLG)      ; Locate of Create?
6F9E: 17      	        RLA                     ; Carry set = Create
6F9F: 79      	        LD      A,C             ; Get number of dimensions
6FA0: 010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
6FA3: D2A86F  	        JP      NC,DEFSIZ       ; Locate - Set default size
6FA6: C1      	        POP     BC              ; Get specified dimension size
6FA7: 03      	        INC     BC              ; Include zero element
6FA8: 71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
6FA9: 23      	        INC     HL
6FAA: 70      	        LD      (HL),B          ; Save MSB of dimension size
6FAB: 23      	        INC     HL
6FAC: F5      	        PUSH    AF              ; Save num' of dim'ns an status
6FAD: E5      	        PUSH    HL              ; Save address of dim'n size
6FAE: CD4077  	        CALL    MLDEBC          ; Multiply DE by BC to find
6FB1: EB      	        EX      DE,HL           ; amount of mem needed (to DE)
6FB2: E1      	        POP     HL              ; Restore address of dimension
6FB3: F1      	        POP     AF              ; Restore number of dimensions
6FB4: 3D      	        DEC     A               ; Count them
6FB5: C2A06F  	        JP      NZ,CRARLP       ; Do next dimension if more
6FB8: F5      	        PUSH    AF              ; Save locate/create flag
6FB9: 42      	        LD      B,D             ; MSB of memory needed
6FBA: 4B      	        LD      C,E             ; LSB of memory needed
6FBB: EB      	        EX      DE,HL
6FBC: 19      	        ADD     HL,DE           ; Add bytes to array start
6FBD: DAA263  	        JP      C,OMERR         ; Too big - Error
6FC0: CD9363  	        CALL    ENFMEM          ; See if enough memory
6FC3: 22DA80  	        LD      (ARREND),HL     ; Save new end of array
              	
6FC6: 2B      	ZERARY: DEC     HL              ; Back through array data
6FC7: 3600    	        LD      (HL),0          ; Set array element to zero
6FC9: CD7566  	        CALL    CPDEHL          ; All elements zeroed?
6FCC: C2C66F  	        JP      NZ,ZERARY       ; No - Keep on going
6FCF: 03      	        INC     BC              ; Number of bytes + 1
6FD0: 57      	        LD      D,A             ; A=0
6FD1: 2AC580  	        LD      HL,(CUROPR)     ; Get address of array
6FD4: 5E      	        LD      E,(HL)          ; Number of dimensions
6FD5: EB      	        EX      DE,HL           ; To HL
6FD6: 29      	        ADD     HL,HL           ; Two bytes per dimension size
6FD7: 09      	        ADD     HL,BC           ; Add number of bytes
6FD8: EB      	        EX      DE,HL           ; Bytes needed to DE
6FD9: 2B      	        DEC     HL
6FDA: 2B      	        DEC     HL
6FDB: 73      	        LD      (HL),E          ; Save LSB of bytes needed
6FDC: 23      	        INC     HL
6FDD: 72      	        LD      (HL),D          ; Save MSB of bytes needed
6FDE: 23      	        INC     HL
6FDF: F1      	        POP     AF              ; Locate / Create?
6FE0: DA0770  	        JP      C,ENDDIM        ; A is 0 , End if create
6FE3: 47      	FINDEL: LD      B,A             ; Find array element
6FE4: 4F      	        LD      C,A
6FE5: 7E      	        LD      A,(HL)          ; Number of dimensions
6FE6: 23      	        INC     HL
6FE7: 16      	        .BYTE      16H             ; Skip "POP HL"
6FE8: E1      	FNDELP: POP     HL              ; Address of next dim' size
6FE9: 5E      	        LD      E,(HL)          ; Get LSB of dim'n size
6FEA: 23      	        INC     HL
6FEB: 56      	        LD      D,(HL)          ; Get MSB of dim'n size
6FEC: 23      	        INC     HL
6FED: E3      	        EX      (SP),HL         ; Save address - Get index
6FEE: F5      	        PUSH    AF              ; Save number of dim'ns
6FEF: CD7566  	        CALL    CPDEHL          ; Dimension too large?
6FF2: D2806F  	        JP      NC,BSERR        ; Yes - ?BS Error
6FF5: E5      	        PUSH    HL              ; Save index
6FF6: CD4077  	        CALL    MLDEBC          ; Multiply previous by size
6FF9: D1      	        POP     DE              ; Index supplied to DE
6FFA: 19      	        ADD     HL,DE           ; Add index to pointer
6FFB: F1      	        POP     AF              ; Number of dimensions
6FFC: 3D      	        DEC     A               ; Count them
6FFD: 44      	        LD      B,H             ; MSB of pointer
6FFE: 4D      	        LD      C,L             ; LSB of pointer
6FFF: C2E86F  	        JP      NZ,FNDELP       ; More - Keep going
7002: 29      	        ADD     HL,HL           ; 4 Bytes per element
7003: 29      	        ADD     HL,HL
7004: C1      	        POP     BC              ; Start of array
7005: 09      	        ADD     HL,BC           ; Point to element
7006: EB      	        EX      DE,HL           ; Address of element to DE
7007: 2AD080  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
700A: C9      	        RET
              	
700B: 2ADA80  	FRE:    LD      HL,(ARREND)     ; Start of free memory
700E: EB      	        EX      DE,HL           ; To DE
700F: 210000  	        LD      HL,0            ; End of free memory
7012: 39      	        ADD     HL,SP           ; Current stack value
7013: 3AAD80  	        LD      A,(TYPE)        ; Dummy argument type
7016: B7      	        OR      A
7017: CA2770  	        JP      Z,FRENUM        ; Numeric - Free variable space
701A: CD8E72  	        CALL    GSTRCU          ; Current string to pool
701D: CD8E71  	        CALL    GARBGE          ; Garbage collection
7020: 2A5A80  	        LD      HL,(STRSPC)     ; Bottom of string space in use
7023: EB      	        EX      DE,HL           ; To DE
7024: 2AC380  	        LD      HL,(STRBOT)     ; Bottom of string space
7027: 7D      	FRENUM: LD      A,L             ; Get LSB of end
7028: 93      	        SUB     E               ; Subtract LSB of beginning
7029: 4F      	        LD      C,A             ; Save difference if C
702A: 7C      	        LD      A,H             ; Get MSB of end
702B: 9A      	        SBC     A,D             ; Subtract MSB of beginning
702C: 41      	ACPASS: LD      B,C             ; Return integer AC
702D: 50      	ABPASS: LD      D,B             ; Return integer AB
702E: 1E00    	        LD      E,0
7030: 21AD80  	        LD      HL,TYPE         ; Point to type
7033: 73      	        LD      (HL),E          ; Set type to numeric
7034: 0690    	        LD      B,80H+16        ; 16 bit integer
7036: C36B76  	        JP      RETINT          ; Return the integr
              	
7039: 3AAB80  	POS:    LD      A,(CURPOS)      ; Get cursor position
703C: 47      	PASSA:  LD      B,A             ; Put A into AB
703D: AF      	        XOR     A               ; Zero A
703E: C32D70  	        JP      ABPASS          ; Return integer AB
              	
7041: CDC470  	DEF:    CALL    CHEKFN          ; Get "FN" and name
7044: CDB670  	        CALL    IDTEST          ; Test for illegal direct
7047: 019C69  	        LD      BC,DATA         ; To get next statement
704A: C5      	        PUSH    BC              ; Save address for RETurn
704B: D5      	        PUSH    DE              ; Save address of function ptr
704C: CD7B66  	        CALL    CHKSYN          ; Make sure "(" follows
704F: 28      	        .BYTE      "("
7050: CD686E  	        CALL    GETVAR          ; Get argument variable name
7053: E5      	        PUSH    HL              ; Save code string address
7054: EB      	        EX      DE,HL           ; Argument address to HL
7055: 2B      	        DEC     HL
7056: 56      	        LD      D,(HL)          ; Get first byte of arg name
7057: 2B      	        DEC     HL
7058: 5E      	        LD      E,(HL)          ; Get second byte of arg name
7059: E1      	        POP     HL              ; Restore code string address
705A: CD756C  	        CALL    TSTNUM          ; Make sure numeric argument
705D: CD7B66  	        CALL    CHKSYN          ; Make sure ")" follows
7060: 29      	        .BYTE      ")"
7061: CD7B66  	        CALL    CHKSYN          ; Make sure "=" follows
7064: B4      	        .BYTE      ZEQUAL          ; "=" token
7065: 44      	        LD      B,H             ; Code string address to BC
7066: 4D      	        LD      C,L
7067: E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
7068: 71      	        LD      (HL),C          ; Save LSB of FN code string
7069: 23      	        INC     HL
706A: 70      	        LD      (HL),B          ; Save MSB of FN code string
706B: C30371  	        JP      SVSTAD          ; Save address and do function
              	
706E: CDC470  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
7071: D5      	        PUSH    DE              ; Save function pointer address
7072: CD496D  	        CALL    EVLPAR          ; Evaluate expression in "()"
7075: CD756C  	        CALL    TSTNUM          ; Make sure numeric result
7078: E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
7079: 5E      	        LD      E,(HL)          ; Get LSB of FN code string
707A: 23      	        INC     HL
707B: 56      	        LD      D,(HL)          ; Get MSB of FN code string
707C: 23      	        INC     HL
707D: 7A      	        LD      A,D             ; And function DEFined?
707E: B3      	        OR      E
707F: CAB963  	        JP      Z,UFERR         ; No - ?UF Error
7082: 7E      	        LD      A,(HL)          ; Get LSB of argument address
7083: 23      	        INC     HL
7084: 66      	        LD      H,(HL)          ; Get MSB of argument address
7085: 6F      	        LD      L,A             ; HL = Arg variable address
7086: E5      	        PUSH    HL              ; Save it
7087: 2ADE80  	        LD      HL,(FNRGNM)     ; Get old argument name
708A: E3      	        EX      (SP),HL ;       ; Save old , Get new
708B: 22DE80  	        LD      (FNRGNM),HL     ; Set new argument name
708E: 2AE280  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
7091: E5      	        PUSH    HL              ; Save it
7092: 2AE080  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
7095: E5      	        PUSH    HL              ; Save it
7096: 21E080  	        LD      HL,FNARG        ; HL = Value of argument
7099: D5      	        PUSH    DE              ; Save FN code string address
709A: CDAC76  	        CALL    FPTHL           ; Move FPREG to argument
709D: E1      	        POP     HL              ; Get FN code string address
709E: CD726C  	        CALL    GETNUM          ; Get value from function
70A1: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
70A2: CD0568  	        CALL    GETCHR          ; Get next character
70A5: C2AD63  	        JP      NZ,SNERR        ; Bad character in FN - Error
70A8: E1      	        POP     HL              ; Get MSB,EXP of old arg
70A9: 22E080  	        LD      (FNARG),HL      ; Restore it
70AC: E1      	        POP     HL              ; Get LSB,NLSB of old arg
70AD: 22E280  	        LD      (FNARG+2),HL    ; Restore it
70B0: E1      	        POP     HL              ; Get name of old arg
70B1: 22DE80  	        LD      (FNRGNM),HL     ; Restore it
70B4: E1      	        POP     HL              ; Restore code string address
70B5: C9      	        RET
              	
70B6: E5      	IDTEST: PUSH    HL              ; Save code string address
70B7: 2A5C80  	        LD      HL,(LINEAT)     ; Get current line number
70BA: 23      	        INC     HL              ; -1 means direct statement
70BB: 7C      	        LD      A,H
70BC: B5      	        OR      L
70BD: E1      	        POP     HL              ; Restore code string address
70BE: C0      	        RET     NZ              ; Return if in program
70BF: 1E16    	        LD      E,ID            ; ?ID Error
70C1: C3C163  	        JP      ERROR
              	
70C4: CD7B66  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
70C7: A7      	        .BYTE      ZFN             ; "FN" token
70C8: 3E80    	        LD      A,80H
70CA: 32CB80  	        LD      (FORFLG),A      ; Flag FN name to find
70CD: B6      	        OR      (HL)            ; FN name has bit 7 set
70CE: 47      	        LD      B,A             ; in first byte of name
70CF: CD6D6E  	        CALL    GTFNAM          ; Get FN name
70D2: C3756C  	        JP      TSTNUM          ; Make sure numeric function
              	
70D5: CD756C  	STR:    CALL    TSTNUM          ; Make sure it's a number
70D8: CDF977  	        CALL    NUMASC          ; Turn number into text
70DB: CD0971  	STR1:   CALL    CRTST           ; Create string entry for it
70DE: CD8E72  	        CALL    GSTRCU          ; Current string to pool
70E1: 01E972  	        LD      BC,TOPOOL       ; Save in string pool
70E4: C5      	        PUSH    BC              ; Save address on stack
              	
70E5: 7E      	SAVSTR: LD      A,(HL)          ; Get string length
70E6: 23      	        INC     HL
70E7: 23      	        INC     HL
70E8: E5      	        PUSH    HL              ; Save pointer to string
70E9: CD6471  	        CALL    TESTR           ; See if enough string space
70EC: E1      	        POP     HL              ; Restore pointer to string
70ED: 4E      	        LD      C,(HL)          ; Get LSB of address
70EE: 23      	        INC     HL
70EF: 46      	        LD      B,(HL)          ; Get MSB of address
70F0: CDFD70  	        CALL    CRTMST          ; Create string entry
70F3: E5      	        PUSH    HL              ; Save pointer to MSB of addr
70F4: 6F      	        LD      L,A             ; Length of string
70F5: CD8172  	        CALL    TOSTRA          ; Move to string area
70F8: D1      	        POP     DE              ; Restore pointer to MSB
70F9: C9      	        RET
              	
70FA: CD6471  	MKTMST: CALL    TESTR           ; See if enough string space
70FD: 21BF80  	CRTMST: LD      HL,TMPSTR       ; Temporary string
7100: E5      	        PUSH    HL              ; Save it
7101: 77      	        LD      (HL),A          ; Save length of string
7102: 23      	        INC     HL
7103: 23      	SVSTAD: INC     HL
7104: 73      	        LD      (HL),E          ; Save LSB of address
7105: 23      	        INC     HL
7106: 72      	        LD      (HL),D          ; Save MSB of address
7107: E1      	        POP     HL              ; Restore pointer
7108: C9      	        RET
              	
7109: 2B      	CRTST:  DEC     HL              ; DEC - INCed after
710A: 0622    	QTSTR:  LD      B,'"'           ; Terminating quote
710C: 50      	        LD      D,B             ; Quote to D
710D: E5      	DTSTR:  PUSH    HL              ; Save start
710E: 0EFF    	        LD      C,-1            ; Set counter to -1
7110: 23      	QTSTLP: INC     HL              ; Move on
7111: 7E      	        LD      A,(HL)          ; Get byte
7112: 0C      	        INC     C               ; Count bytes
7113: B7      	        OR      A               ; End of line?
7114: CA1F71  	        JP      Z,CRTSTE        ; Yes - Create string entry
7117: BA      	        CP      D               ; Terminator D found?
7118: CA1F71  	        JP      Z,CRTSTE        ; Yes - Create string entry
711B: B8      	        CP      B               ; Terminator B found?
711C: C21071  	        JP      NZ,QTSTLP       ; No - Keep looking
711F: FE22    	CRTSTE: CP      '"'             ; End with '"'?
7121: CC0568  	        CALL    Z,GETCHR        ; Yes - Get next character
7124: E3      	        EX      (SP),HL         ; Starting quote
7125: 23      	        INC     HL              ; First byte of string
7126: EB      	        EX      DE,HL           ; To DE
7127: 79      	        LD      A,C             ; Get length
7128: CDFD70  	        CALL    CRTMST          ; Create string entry
712B: 11BF80  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
712E: 2AB180  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
7131: 22E480  	        LD      (FPREG),HL      ; Save address of string ptr
7134: 3E01    	        LD      A,1
7136: 32AD80  	        LD      (TYPE),A        ; Set type to string
7139: CDAF76  	        CALL    DETHL4          ; Move string to pool
713C: CD7566  	        CALL    CPDEHL          ; Out of string pool?
713F: 22B180  	        LD      (TMSTPT),HL     ; Save new pointer
7142: E1      	        POP     HL              ; Restore code string address
7143: 7E      	        LD      A,(HL)          ; Get next code byte
7144: C0      	        RET     NZ              ; Return if pool OK
7145: 1E1E    	        LD      E,ST            ; ?ST Error
7147: C3C163  	        JP      ERROR           ; String pool overflow
              	
714A: 23      	PRNUMS: INC     HL              ; Skip leading space
714B: CD0971  	PRS:    CALL    CRTST           ; Create string entry for it
714E: CD8E72  	PRS1:   CALL    GSTRCU          ; Current string to pool
7151: CDA376  	        CALL    LOADFP          ; Move string block to BCDE
7154: 1C      	        INC     E               ; Length + 1
7155: 1D      	PRSLP:  DEC     E               ; Count characters
7156: C8      	        RET     Z               ; End of string
7157: 0A      	        LD      A,(BC)          ; Get byte to output
7158: CD8666  	        CALL    OUTC            ; Output character in A
715B: FE0D    	        CP      CR              ; Return?
715D: CCB76A  	        CALL    Z,DONULL        ; Yes - Do nulls
7160: 03      	        INC     BC              ; Next byte in string
7161: C35571  	        JP      PRSLP           ; More characters to output
              	
7164: B7      	TESTR:  OR      A               ; Test if enough room
7165: 0E      	        .BYTE      0EH             ; No garbage collection done
7166: F1      	GRBDON: POP     AF              ; Garbage collection done
7167: F5      	        PUSH    AF              ; Save status
7168: 2A5A80  	        LD      HL,(STRSPC)     ; Bottom of string space in use
716B: EB      	        EX      DE,HL           ; To DE
716C: 2AC380  	        LD      HL,(STRBOT)     ; Bottom of string area
716F: 2F      	        CPL                     ; Negate length (Top down)
7170: 4F      	        LD      C,A             ; -Length to BC
7171: 06FF    	        LD      B,-1            ; BC = -ve length of string
7173: 09      	        ADD     HL,BC           ; Add to bottom of space in use
7174: 23      	        INC     HL              ; Plus one for 2's complement
7175: CD7566  	        CALL    CPDEHL          ; Below string RAM area?
7178: DA8271  	        JP      C,TESTOS        ; Tidy up if not done else err
717B: 22C380  	        LD      (STRBOT),HL     ; Save new bottom of area
717E: 23      	        INC     HL              ; Point to first byte of string
717F: EB      	        EX      DE,HL           ; Address to DE
7180: F1      	POPAF:  POP     AF              ; Throw away status push
7181: C9      	        RET
              	
7182: F1      	TESTOS: POP     AF              ; Garbage collect been done?
7183: 1E1A    	        LD      E,OS            ; ?OS Error
7185: CAC163  	        JP      Z,ERROR         ; Yes - Not enough string apace
7188: BF      	        CP      A               ; Flag garbage collect done
7189: F5      	        PUSH    AF              ; Save status
718A: 016671  	        LD      BC,GRBDON       ; Garbage collection done
718D: C5      	        PUSH    BC              ; Save for RETurn
718E: 2AAF80  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
7191: 22C380  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
7194: 210000  	        LD      HL,0
7197: E5      	        PUSH    HL              ; Flag no string found
7198: 2A5A80  	        LD      HL,(STRSPC)     ; Get bottom of string space
719B: E5      	        PUSH    HL              ; Save bottom of string space
719C: 21B380  	        LD      HL,TMSTPL       ; Temporary string pool
719F: EB      	GRBLP:  EX      DE,HL
71A0: 2AB180  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
71A3: EB      	        EX      DE,HL
71A4: CD7566  	        CALL    CPDEHL          ; Temporary string pool done?
71A7: 019F71  	        LD      BC,GRBLP        ; Loop until string pool done
71AA: C2F371  	        JP      NZ,STPOOL       ; No - See if in string area
71AD: 2AD680  	        LD      HL,(PROGND)     ; Start of simple variables
71B0: EB      	SMPVAR: EX      DE,HL
71B1: 2AD880  	        LD      HL,(VAREND)     ; End of simple variables
71B4: EB      	        EX      DE,HL
71B5: CD7566  	        CALL    CPDEHL          ; All simple strings done?
71B8: CAC671  	        JP      Z,ARRLP         ; Yes - Do string arrays
71BB: 7E      	        LD      A,(HL)          ; Get type of variable
71BC: 23      	        INC     HL
71BD: 23      	        INC     HL
71BE: B7      	        OR      A               ; "S" flag set if string
71BF: CDF671  	        CALL    STRADD          ; See if string in string area
71C2: C3B071  	        JP      SMPVAR          ; Loop until simple ones done
              	
71C5: C1      	GNXARY: POP     BC              ; Scrap address of this array
71C6: EB      	ARRLP:  EX      DE,HL
71C7: 2ADA80  	        LD      HL,(ARREND)     ; End of string arrays
71CA: EB      	        EX      DE,HL
71CB: CD7566  	        CALL    CPDEHL          ; All string arrays done?
71CE: CA1C72  	        JP      Z,SCNEND        ; Yes - Move string if found
71D1: CDA376  	        CALL    LOADFP          ; Get array name to BCDE
71D4: 7B      	        LD      A,E             ; Get type of array     
71D5: E5      	        PUSH    HL              ; Save address of num of dim'ns
71D6: 09      	        ADD     HL,BC           ; Start of next array
71D7: B7      	        OR      A               ; Test type of array
71D8: F2C571  	        JP      P,GNXARY        ; Numeric array - Ignore it
71DB: 22C580  	        LD      (CUROPR),HL     ; Save address of next array
71DE: E1      	        POP     HL              ; Get address of num of dim'ns
71DF: 4E      	        LD      C,(HL)          ; BC = Number of dimensions
71E0: 0600    	        LD      B,0
71E2: 09      	        ADD     HL,BC           ; Two bytes per dimension size
71E3: 09      	        ADD     HL,BC
71E4: 23      	        INC     HL              ; Plus one for number of dim'ns
71E5: EB      	GRBARY: EX      DE,HL
71E6: 2AC580  	        LD      HL,(CUROPR)     ; Get address of next array
71E9: EB      	        EX      DE,HL
71EA: CD7566  	        CALL    CPDEHL          ; Is this array finished?
71ED: CAC671  	        JP      Z,ARRLP         ; Yes - Get next one
71F0: 01E571  	        LD      BC,GRBARY       ; Loop until array all done
71F3: C5      	STPOOL: PUSH    BC              ; Save return address
71F4: F680    	        OR      80H             ; Flag string type
71F6: 7E      	STRADD: LD      A,(HL)          ; Get string length
71F7: 23      	        INC     HL
71F8: 23      	        INC     HL
71F9: 5E      	        LD      E,(HL)          ; Get LSB of string address
71FA: 23      	        INC     HL
71FB: 56      	        LD      D,(HL)          ; Get MSB of string address
71FC: 23      	        INC     HL
71FD: F0      	        RET     P               ; Not a string - Return
71FE: B7      	        OR      A               ; Set flags on string length
71FF: C8      	        RET     Z               ; Null string - Return
7200: 44      	        LD      B,H             ; Save variable pointer
7201: 4D      	        LD      C,L
7202: 2AC380  	        LD      HL,(STRBOT)     ; Bottom of new area
7205: CD7566  	        CALL    CPDEHL          ; String been done?
7208: 60      	        LD      H,B             ; Restore variable pointer
7209: 69      	        LD      L,C
720A: D8      	        RET     C               ; String done - Ignore
720B: E1      	        POP     HL              ; Return address
720C: E3      	        EX      (SP),HL         ; Lowest available string area
720D: CD7566  	        CALL    CPDEHL          ; String within string area?
7210: E3      	        EX      (SP),HL         ; Lowest available string area
7211: E5      	        PUSH    HL              ; Re-save return address
7212: 60      	        LD      H,B             ; Restore variable pointer
7213: 69      	        LD      L,C
7214: D0      	        RET     NC              ; Outside string area - Ignore
7215: C1      	        POP     BC              ; Get return , Throw 2 away
7216: F1      	        POP     AF              ; 
7217: F1      	        POP     AF              ; 
7218: E5      	        PUSH    HL              ; Save variable pointer
7219: D5      	        PUSH    DE              ; Save address of current
721A: C5      	        PUSH    BC              ; Put back return address
721B: C9      	        RET                     ; Go to it
              	
721C: D1      	SCNEND: POP     DE              ; Addresses of strings
721D: E1      	        POP     HL              ; 
721E: 7D      	        LD      A,L             ; HL = 0 if no more to do
721F: B4      	        OR      H
7220: C8      	        RET     Z               ; No more to do - Return
7221: 2B      	        DEC     HL
7222: 46      	        LD      B,(HL)          ; MSB of address of string
7223: 2B      	        DEC     HL
7224: 4E      	        LD      C,(HL)          ; LSB of address of string
7225: E5      	        PUSH    HL              ; Save variable address
7226: 2B      	        DEC     HL
7227: 2B      	        DEC     HL
7228: 6E      	        LD      L,(HL)          ; HL = Length of string
7229: 2600    	        LD      H,0
722B: 09      	        ADD     HL,BC           ; Address of end of string+1
722C: 50      	        LD      D,B             ; String address to DE
722D: 59      	        LD      E,C
722E: 2B      	        DEC     HL              ; Last byte in string
722F: 44      	        LD      B,H             ; Address to BC
7230: 4D      	        LD      C,L
7231: 2AC380  	        LD      HL,(STRBOT)     ; Current bottom of string area
7234: CD7C63  	        CALL    MOVSTR          ; Move string to new address
7237: E1      	        POP     HL              ; Restore variable address
7238: 71      	        LD      (HL),C          ; Save new LSB of address
7239: 23      	        INC     HL
723A: 70      	        LD      (HL),B          ; Save new MSB of address
723B: 69      	        LD      L,C             ; Next string area+1 to HL
723C: 60      	        LD      H,B
723D: 2B      	        DEC     HL              ; Next string area address
723E: C39171  	        JP      GARBLP          ; Look for more strings
              	
7241: C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
7242: E5      	        PUSH    HL              ; 
7243: 2AE480  	        LD      HL,(FPREG)      ; Get first string
7246: E3      	        EX      (SP),HL         ; Save first string
7247: CDFB6C  	        CALL    OPRND           ; Get second string
724A: E3      	        EX      (SP),HL         ; Restore first string
724B: CD766C  	        CALL    TSTSTR          ; Make sure it's a string
724E: 7E      	        LD      A,(HL)          ; Get length of second string
724F: E5      	        PUSH    HL              ; Save first string
7250: 2AE480  	        LD      HL,(FPREG)      ; Get second string
7253: E5      	        PUSH    HL              ; Save second string
7254: 86      	        ADD     A,(HL)          ; Add length of second string
7255: 1E1C    	        LD      E,LS            ; ?LS Error
7257: DAC163  	        JP      C,ERROR         ; String too long - Error
725A: CDFA70  	        CALL    MKTMST          ; Make temporary string
725D: D1      	        POP     DE              ; Get second string to DE
725E: CD9272  	        CALL    GSTRDE          ; Move to string pool if needed
7261: E3      	        EX      (SP),HL         ; Get first string
7262: CD9172  	        CALL    GSTRHL          ; Move to string pool if needed
7265: E5      	        PUSH    HL              ; Save first string
7266: 2AC180  	        LD      HL,(TMPSTR+2)   ; Temporary string address
7269: EB      	        EX      DE,HL           ; To DE
726A: CD7872  	        CALL    SSTSA           ; First string to string area
726D: CD7872  	        CALL    SSTSA           ; Second string to string area
7270: 21906C  	        LD      HL,EVAL2        ; Return to evaluation loop
7273: E3      	        EX      (SP),HL         ; Save return,get code string
7274: E5      	        PUSH    HL              ; Save code string address
7275: C32B71  	        JP      TSTOPL          ; To temporary string to pool
              	
7278: E1      	SSTSA:  POP     HL              ; Return address
7279: E3      	        EX      (SP),HL         ; Get string block,save return
727A: 7E      	        LD      A,(HL)          ; Get length of string
727B: 23      	        INC     HL
727C: 23      	        INC     HL
727D: 4E      	        LD      C,(HL)          ; Get LSB of string address
727E: 23      	        INC     HL
727F: 46      	        LD      B,(HL)          ; Get MSB of string address
7280: 6F      	        LD      L,A             ; Length to L
7281: 2C      	TOSTRA: INC     L               ; INC - DECed after
7282: 2D      	TSALP:  DEC     L               ; Count bytes moved
7283: C8      	        RET     Z               ; End of string - Return
7284: 0A      	        LD      A,(BC)          ; Get source
7285: 12      	        LD      (DE),A          ; Save destination
7286: 03      	        INC     BC              ; Next source
7287: 13      	        INC     DE              ; Next destination
7288: C38272  	        JP      TSALP           ; Loop until string moved
              	
728B: CD766C  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
728E: 2AE480  	GSTRCU: LD      HL,(FPREG)      ; Get current string
7291: EB      	GSTRHL: EX      DE,HL           ; Save DE
7292: CDAC72  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
7295: EB      	        EX      DE,HL           ; Restore DE
7296: C0      	        RET     NZ              ; No - Return
7297: D5      	        PUSH    DE              ; Save string
7298: 50      	        LD      D,B             ; String block address to DE
7299: 59      	        LD      E,C
729A: 1B      	        DEC     DE              ; Point to length
729B: 4E      	        LD      C,(HL)          ; Get string length
729C: 2AC380  	        LD      HL,(STRBOT)     ; Current bottom of string area
729F: CD7566  	        CALL    CPDEHL          ; Last one in string area?
72A2: C2AA72  	        JP      NZ,POPHL        ; No - Return
72A5: 47      	        LD      B,A             ; Clear B (A=0)
72A6: 09      	        ADD     HL,BC           ; Remove string from str' area
72A7: 22C380  	        LD      (STRBOT),HL     ; Save new bottom of str' area
72AA: E1      	POPHL:  POP     HL              ; Restore string
72AB: C9      	        RET
              	
72AC: 2AB180  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
72AF: 2B      	        DEC     HL              ; Back
72B0: 46      	        LD      B,(HL)          ; Get MSB of address
72B1: 2B      	        DEC     HL              ; Back
72B2: 4E      	        LD      C,(HL)          ; Get LSB of address
72B3: 2B      	        DEC     HL              ; Back
72B4: 2B      	        DEC     HL              ; Back
72B5: CD7566  	        CALL    CPDEHL          ; String last in string pool?
72B8: C0      	        RET     NZ              ; Yes - Leave it
72B9: 22B180  	        LD      (TMSTPT),HL     ; Save new string pool top
72BC: C9      	        RET
              	
72BD: 013C70  	LEN:    LD      BC,PASSA        ; To return integer A
72C0: C5      	        PUSH    BC              ; Save address
72C1: CD8B72  	GETLEN: CALL    GETSTR          ; Get string and its length
72C4: AF      	        XOR     A
72C5: 57      	        LD      D,A             ; Clear D
72C6: 32AD80  	        LD      (TYPE),A        ; Set type to numeric
72C9: 7E      	        LD      A,(HL)          ; Get length of string
72CA: B7      	        OR      A               ; Set status flags
72CB: C9      	        RET
              	
72CC: 013C70  	ASC:    LD      BC,PASSA        ; To return integer A
72CF: C5      	        PUSH    BC              ; Save address
72D0: CDC172  	GTFLNM: CALL    GETLEN          ; Get length of string
72D3: CACC68  	        JP      Z,FCERR         ; Null string - Error
72D6: 23      	        INC     HL
72D7: 23      	        INC     HL
72D8: 5E      	        LD      E,(HL)          ; Get LSB of address
72D9: 23      	        INC     HL
72DA: 56      	        LD      D,(HL)          ; Get MSB of address
72DB: 1A      	        LD      A,(DE)          ; Get first byte of string
72DC: C9      	        RET
              	
72DD: 3E01    	CHR:    LD      A,1             ; One character string
72DF: CDFA70  	        CALL    MKTMST          ; Make a temporary string
72E2: CDD673  	        CALL    MAKINT          ; Make it integer A
72E5: 2AC180  	        LD      HL,(TMPSTR+2)   ; Get address of string
72E8: 73      	        LD      (HL),E          ; Save character
72E9: C1      	TOPOOL: POP     BC              ; Clean up stack
72EA: C32B71  	        JP      TSTOPL          ; Temporary string to pool
              	
72ED: CD8673  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
72F0: AF      	        XOR     A               ; Start at first byte in string
72F1: E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
72F2: 4F      	        LD      C,A             ; Starting position in string
72F3: E5      	MID1:   PUSH    HL              ; Save string block address
72F4: 7E      	        LD      A,(HL)          ; Get length of string
72F5: B8      	        CP      B               ; Compare with number given
72F6: DAFB72  	        JP      C,ALLFOL        ; All following bytes required
72F9: 78      	        LD      A,B             ; Get new length
72FA: 11      	        .BYTE      11H             ; Skip "LD C,0"
72FB: 0E00    	ALLFOL: LD      C,0             ; First byte of string
72FD: C5      	        PUSH    BC              ; Save position in string
72FE: CD6471  	        CALL    TESTR           ; See if enough string space
7301: C1      	        POP     BC              ; Get position in string
7302: E1      	        POP     HL              ; Restore string block address
7303: E5      	        PUSH    HL              ; And re-save it
7304: 23      	        INC     HL
7305: 23      	        INC     HL
7306: 46      	        LD      B,(HL)          ; Get LSB of address
7307: 23      	        INC     HL
7308: 66      	        LD      H,(HL)          ; Get MSB of address
7309: 68      	        LD      L,B             ; HL = address of string
730A: 0600    	        LD      B,0             ; BC = starting address
730C: 09      	        ADD     HL,BC           ; Point to that byte
730D: 44      	        LD      B,H             ; BC = source string
730E: 4D      	        LD      C,L
730F: CDFD70  	        CALL    CRTMST          ; Create a string entry
7312: 6F      	        LD      L,A             ; Length of new string
7313: CD8172  	        CALL    TOSTRA          ; Move string to string area
7316: D1      	        POP     DE              ; Clear stack
7317: CD9272  	        CALL    GSTRDE          ; Move to string pool if needed
731A: C32B71  	        JP      TSTOPL          ; Temporary string to pool
              	
731D: CD8673  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
7320: D1      	        POP     DE              ; Get string length
7321: D5      	        PUSH    DE              ; And re-save
7322: 1A      	        LD      A,(DE)          ; Get length
7323: 90      	        SUB     B               ; Move back N bytes
7324: C3F172  	        JP      RIGHT1          ; Go and get sub-string
              	
7327: EB      	MID:    EX      DE,HL           ; Get code string address
7328: 7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
7329: CD8B73  	        CALL    MIDNUM          ; Get number supplied
732C: 04      	        INC     B               ; Is it character zero?
732D: 05      	        DEC     B
732E: CACC68  	        JP      Z,FCERR         ; Yes - Error
7331: C5      	        PUSH    BC              ; Save starting position
7332: 1EFF    	        LD      E,255           ; All of string
7334: FE29    	        CP      ')'             ; Any length given?
7336: CA4073  	        JP      Z,RSTSTR        ; No - Rest of string
7339: CD7B66  	        CALL    CHKSYN          ; Make sure ',' follows
733C: 2C      	        .BYTE      ','
733D: CDD373  	        CALL    GETINT          ; Get integer 0-255
7340: CD7B66  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
7343: 29      	        .BYTE      ")"
7344: F1      	        POP     AF              ; Restore starting position
7345: E3      	        EX      (SP),HL         ; Get string,8ave code string
7346: 01F372  	        LD      BC,MID1         ; Continuation of MID$ routine
7349: C5      	        PUSH    BC              ; Save for return
734A: 3D      	        DEC     A               ; Starting position-1
734B: BE      	        CP      (HL)            ; Compare with length
734C: 0600    	        LD      B,0             ; Zero bytes length
734E: D0      	        RET     NC              ; Null string if start past end
734F: 4F      	        LD      C,A             ; Save starting position-1
7350: 7E      	        LD      A,(HL)          ; Get length of string
7351: 91      	        SUB     C               ; Subtract start
7352: BB      	        CP      E               ; Enough string for it?
7353: 47      	        LD      B,A             ; Save maximum length available
7354: D8      	        RET     C               ; Truncate string if needed
7355: 43      	        LD      B,E             ; Set specified length
7356: C9      	        RET                     ; Go and create string
              	
7357: CDC172  	VAL:    CALL    GETLEN          ; Get length of string
735A: CA7474  	        JP      Z,RESZER        ; Result zero
735D: 5F      	        LD      E,A             ; Save length
735E: 23      	        INC     HL
735F: 23      	        INC     HL
7360: 7E      	        LD      A,(HL)          ; Get LSB of address
7361: 23      	        INC     HL
7362: 66      	        LD      H,(HL)          ; Get MSB of address
7363: 6F      	        LD      L,A             ; HL = String address
7364: E5      	        PUSH    HL              ; Save string address
7365: 19      	        ADD     HL,DE
7366: 46      	        LD      B,(HL)          ; Get end of string+1 byte
7367: 72      	        LD      (HL),D          ; Zero it to terminate
7368: E3      	        EX      (SP),HL         ; Save string end,get start
7369: C5      	        PUSH    BC              ; Save end+1 byte
736A: 7E      	        LD      A,(HL)          ; Get starting byte
736B: FE24    	    CP	'$'		; Hex number indicated? [function added]
736D: C27573  	    JP	NZ,VAL1
7370: CD9F7B  	    CALL	HEXTFP		; Convert Hex to FPREG
7373: 180D    	    JR	VAL3
7375: FE25    	VAL1:	CP	'%'		; Binary number indicated? [function added]
7377: C27F73  	    JP	NZ,VAL2
737A: CD0F7C  	    CALL	BINTFP		; Convert Bin to FPREG
737D: 1803    	    JR	VAL3
737F: CD5B77  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
7382: C1      	VAL3:   POP     BC              ; Restore end+1 byte
7383: E1      	        POP     HL              ; Restore end+1 address
7384: 70      	        LD      (HL),B          ; Put back original byte
7385: C9      	        RET
              	
7386: EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
7387: CD7B66  	        CALL    CHKSYN          ; Make sure ")" follows
738A: 29      	        .BYTE      ")"
738B: C1      	MIDNUM: POP     BC              ; Get return address
738C: D1      	        POP     DE              ; Get number supplied
738D: C5      	        PUSH    BC              ; Re-save return address
738E: 43      	        LD      B,E             ; Number to B
738F: C9      	        RET
              	
7390: CDD673  	INP:    CALL    MAKINT          ; Make it integer A
7393: 323F80  	        LD      (INPORT),A      ; Set input port
7396: CD3E80  	        CALL    INPSUB          ; Get input from port
7399: C33C70  	        JP      PASSA           ; Return integer A
              	
739C: CDC073  	POUT:   CALL    SETIO           ; Set up port number
739F: C30680  	        JP      OUTSUB          ; Output data and return
              	
73A2: CDC073  	WAIT:   CALL    SETIO           ; Set up port number
73A5: F5      	        PUSH    AF              ; Save AND mask
73A6: 1E00    	        LD      E,0             ; Assume zero if none given
73A8: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
73A9: CD0568  	        CALL    GETCHR          ; Get next character
73AC: CAB673  	        JP      Z,NOXOR         ; No XOR byte given
73AF: CD7B66  	        CALL    CHKSYN          ; Make sure ',' follows
73B2: 2C      	        .BYTE      ','
73B3: CDD373  	        CALL    GETINT          ; Get integer 0-255 to XOR with
73B6: C1      	NOXOR:  POP     BC              ; Restore AND mask
73B7: CD3E80  	WAITLP: CALL    INPSUB          ; Get input
73BA: AB      	        XOR     E               ; Flip selected bits
73BB: A0      	        AND     B               ; Result non-zero?
73BC: CAB773  	        JP      Z,WAITLP        ; No = keep waiting
73BF: C9      	        RET
              	
73C0: CDD373  	SETIO:  CALL    GETINT          ; Get integer 0-255
73C3: 323F80  	        LD      (INPORT),A      ; Set input port
73C6: 320780  	        LD      (OTPORT),A      ; Set output port
73C9: CD7B66  	        CALL    CHKSYN          ; Make sure ',' follows
73CC: 2C      	        .BYTE      ','
73CD: C3D373  	        JP      GETINT          ; Get integer 0-255 and return
              	
73D0: CD0568  	FNDNUM: CALL    GETCHR          ; Get next character
73D3: CD726C  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
73D6: CDB168  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
73D9: 7A      	        LD      A,D             ; Get MSB of number
73DA: B7      	        OR      A               ; Zero?
73DB: C2CC68  	        JP      NZ,FCERR        ; No - Error
73DE: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
73DF: CD0568  	        CALL    GETCHR          ; Get next character
73E2: 7B      	        LD      A,E             ; Get number to A
73E3: C9      	        RET
              	
73E4: CDB768  	PEEK:   CALL    DEINT           ; Get memory address
73E7: 1A      	        LD      A,(DE)          ; Get byte in memory
73E8: C33C70  	        JP      PASSA           ; Return integer A
              	
73EB: CD726C  	POKE:   CALL    GETNUM          ; Get memory address
73EE: CDB768  	        CALL    DEINT           ; Get integer -32768 to 3276
73F1: D5      	        PUSH    DE              ; Save memory address
73F2: CD7B66  	        CALL    CHKSYN          ; Make sure ',' follows
73F5: 2C      	        .BYTE      ','
73F6: CDD373  	        CALL    GETINT          ; Get integer 0-255
73F9: D1      	        POP     DE              ; Restore memory address
73FA: 12      	        LD      (DE),A          ; Load it into memory
73FB: C9      	        RET
              	
73FC: 21D278  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
73FF: CDA376  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
7402: C30E74  	        JP      FPADD           ; Add BCDE to FPREG
              	
7405: CDA376  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
7408: 21      	        .BYTE      21H             ; Skip "POP BC" and "POP DE"
7409: C1      	PSUB:   POP     BC              ; Get FP number from stack
740A: D1      	        POP     DE
740B: CD7D76  	SUBCDE: CALL    INVSGN          ; Negate FPREG
740E: 78      	FPADD:  LD      A,B             ; Get FP exponent
740F: B7      	        OR      A               ; Is number zero?
7410: C8      	        RET     Z               ; Yes - Nothing to add
7411: 3AE780  	        LD      A,(FPEXP)       ; Get FPREG exponent
7414: B7      	        OR      A               ; Is this number zero?
7415: CA9576  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
7418: 90      	        SUB     B               ; BCDE number larger?
7419: D22874  	        JP      NC,NOSWAP       ; No - Don't swap them
741C: 2F      	        CPL                     ; Two's complement
741D: 3C      	        INC     A               ;  FP exponent
741E: EB      	        EX      DE,HL
741F: CD8576  	        CALL    STAKFP          ; Put FPREG on stack
7422: EB      	        EX      DE,HL
7423: CD9576  	        CALL    FPBCDE          ; Move BCDE to FPREG
7426: C1      	        POP     BC              ; Restore number from stack
7427: D1      	        POP     DE
7428: FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
742A: D0      	        RET     NC              ; Yes - First number is result
742B: F5      	        PUSH    AF              ; Save number of bits to scale
742C: CDBA76  	        CALL    SIGNS           ; Set MSBs & sign of result
742F: 67      	        LD      H,A             ; Save sign of result
7430: F1      	        POP     AF              ; Restore scaling factor
7431: CDD374  	        CALL    SCALE           ; Scale BCDE to same exponent
7434: B4      	        OR      H               ; Result to be positive?
7435: 21E480  	        LD      HL,FPREG        ; Point to FPREG
7438: F24E74  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
743B: CDB374  	        CALL    PLUCDE          ; Add FPREG to CDE
743E: D29474  	        JP      NC,RONDUP       ; No overflow - Round it up
7441: 23      	        INC     HL              ; Point to exponent
7442: 34      	        INC     (HL)            ; Increment it
7443: CABC63  	        JP      Z,OVERR         ; Number overflowed - Error
7446: 2E01    	        LD      L,1             ; 1 bit to shift right
7448: CDE974  	        CALL    SHRT1           ; Shift result right
744B: C39474  	        JP      RONDUP          ; Round it up
              	
744E: AF      	MINCDE: XOR     A               ; Clear A and carry
744F: 90      	        SUB     B               ; Negate exponent
7450: 47      	        LD      B,A             ; Re-save exponent
7451: 7E      	        LD      A,(HL)          ; Get LSB of FPREG
7452: 9B      	        SBC     A, E            ; Subtract LSB of BCDE
7453: 5F      	        LD      E,A             ; Save LSB of BCDE
7454: 23      	        INC     HL
7455: 7E      	        LD      A,(HL)          ; Get NMSB of FPREG
7456: 9A      	        SBC     A,D             ; Subtract NMSB of BCDE
7457: 57      	        LD      D,A             ; Save NMSB of BCDE
7458: 23      	        INC     HL
7459: 7E      	        LD      A,(HL)          ; Get MSB of FPREG
745A: 99      	        SBC     A,C             ; Subtract MSB of BCDE
745B: 4F      	        LD      C,A             ; Save MSB of BCDE
745C: DCBF74  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
              	
745F: 68      	BNORM:  LD      L,B             ; L = Exponent
7460: 63      	        LD      H,E             ; H = LSB
7461: AF      	        XOR     A
7462: 47      	BNRMLP: LD      B,A             ; Save bit count
7463: 79      	        LD      A,C             ; Get MSB
7464: B7      	        OR      A               ; Is it zero?
7465: C28174  	        JP      NZ,PNORM        ; No - Do it bit at a time
7468: 4A      	        LD      C,D             ; MSB = NMSB
7469: 54      	        LD      D,H             ; NMSB= LSB
746A: 65      	        LD      H,L             ; LSB = VLSB
746B: 6F      	        LD      L,A             ; VLSB= 0
746C: 78      	        LD      A,B             ; Get exponent
746D: D608    	        SUB     8               ; Count 8 bits
746F: FEE0    	        CP      -24-8           ; Was number zero?
7471: C26274  	        JP      NZ,BNRMLP       ; No - Keep normalising
7474: AF      	RESZER: XOR     A               ; Result is zero
7475: 32E780  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
7478: C9      	        RET
              	
7479: 05      	NORMAL: DEC     B               ; Count bits
747A: 29      	        ADD     HL,HL           ; Shift HL left
747B: 7A      	        LD      A,D             ; Get NMSB
747C: 17      	        RLA                     ; Shift left with last bit
747D: 57      	        LD      D,A             ; Save NMSB
747E: 79      	        LD      A,C             ; Get MSB
747F: 8F      	        ADC     A,A             ; Shift left with last bit
7480: 4F      	        LD      C,A             ; Save MSB
7481: F27974  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
7484: 78      	        LD      A,B             ; Number of bits shifted
7485: 5C      	        LD      E,H             ; Save HL in EB
7486: 45      	        LD      B,L
7487: B7      	        OR      A               ; Any shifting done?
7488: CA9474  	        JP      Z,RONDUP        ; No - Round it up
748B: 21E780  	        LD      HL,FPEXP        ; Point to exponent
748E: 86      	        ADD     A,(HL)          ; Add shifted bits
748F: 77      	        LD      (HL),A          ; Re-save exponent
7490: D27474  	        JP      NC,RESZER       ; Underflow - Result is zero
7493: C8      	        RET     Z               ; Result is zero
7494: 78      	RONDUP: LD      A,B             ; Get VLSB of number
7495: 21E780  	RONDB:  LD      HL,FPEXP        ; Point to exponent
7498: B7      	        OR      A               ; Any rounding?
7499: FCA674  	        CALL    M,FPROND        ; Yes - Round number up
749C: 46      	        LD      B,(HL)          ; B = Exponent
749D: 23      	        INC     HL
749E: 7E      	        LD      A,(HL)          ; Get sign of result
749F: E680    	        AND     10000000B       ; Only bit 7 needed
74A1: A9      	        XOR     C               ; Set correct sign
74A2: 4F      	        LD      C,A             ; Save correct sign in number
74A3: C39576  	        JP      FPBCDE          ; Move BCDE to FPREG
              	
74A6: 1C      	FPROND: INC     E               ; Round LSB
74A7: C0      	        RET     NZ              ; Return if ok
74A8: 14      	        INC     D               ; Round NMSB
74A9: C0      	        RET     NZ              ; Return if ok
74AA: 0C      	        INC     C               ; Round MSB
74AB: C0      	        RET     NZ              ; Return if ok
74AC: 0E80    	        LD      C,80H           ; Set normal value
74AE: 34      	        INC     (HL)            ; Increment exponent
74AF: C0      	        RET     NZ              ; Return if ok
74B0: C3BC63  	        JP      OVERR           ; Overflow error
              	
74B3: 7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
74B4: 83      	        ADD     A,E             ; Add LSB of BCDE
74B5: 5F      	        LD      E,A             ; Save LSB of BCDE
74B6: 23      	        INC     HL
74B7: 7E      	        LD      A,(HL)          ; Get NMSB of FPREG
74B8: 8A      	        ADC     A,D             ; Add NMSB of BCDE
74B9: 57      	        LD      D,A             ; Save NMSB of BCDE
74BA: 23      	        INC     HL
74BB: 7E      	        LD      A,(HL)          ; Get MSB of FPREG
74BC: 89      	        ADC     A,C             ; Add MSB of BCDE
74BD: 4F      	        LD      C,A             ; Save MSB of BCDE
74BE: C9      	        RET
              	
74BF: 21E880  	COMPL:  LD      HL,SGNRES       ; Sign of result
74C2: 7E      	        LD      A,(HL)          ; Get sign of result
74C3: 2F      	        CPL                     ; Negate it
74C4: 77      	        LD      (HL),A          ; Put it back
74C5: AF      	        XOR     A
74C6: 6F      	        LD      L,A             ; Set L to zero
74C7: 90      	        SUB     B               ; Negate exponent,set carry
74C8: 47      	        LD      B,A             ; Re-save exponent
74C9: 7D      	        LD      A,L             ; Load zero
74CA: 9B      	        SBC     A,E             ; Negate LSB
74CB: 5F      	        LD      E,A             ; Re-save LSB
74CC: 7D      	        LD      A,L             ; Load zero
74CD: 9A      	        SBC     A,D             ; Negate NMSB
74CE: 57      	        LD      D,A             ; Re-save NMSB
74CF: 7D      	        LD      A,L             ; Load zero
74D0: 99      	        SBC     A,C             ; Negate MSB
74D1: 4F      	        LD      C,A             ; Re-save MSB
74D2: C9      	        RET
              	
74D3: 0600    	SCALE:  LD      B,0             ; Clear underflow
74D5: D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
74D7: DAE274  	        JP      C,SHRITE        ; No - Shift right A bits
74DA: 43      	        LD      B,E             ; <- Shift
74DB: 5A      	        LD      E,D             ; <- right
74DC: 51      	        LD      D,C             ; <- eight
74DD: 0E00    	        LD      C,0             ; <- bits
74DF: C3D574  	        JP      SCALLP          ; More bits to shift
              	
74E2: C609    	SHRITE: ADD     A,8+1           ; Adjust count
74E4: 6F      	        LD      L,A             ; Save bits to shift
74E5: AF      	SHRLP:  XOR     A               ; Flag for all done
74E6: 2D      	        DEC     L               ; All shifting done?
74E7: C8      	        RET     Z               ; Yes - Return
74E8: 79      	        LD      A,C             ; Get MSB
74E9: 1F      	SHRT1:  RRA                     ; Shift it right
74EA: 4F      	        LD      C,A             ; Re-save
74EB: 7A      	        LD      A,D             ; Get NMSB
74EC: 1F      	        RRA                     ; Shift right with last bit
74ED: 57      	        LD      D,A             ; Re-save it
74EE: 7B      	        LD      A,E             ; Get LSB
74EF: 1F      	        RRA                     ; Shift right with last bit
74F0: 5F      	        LD      E,A             ; Re-save it
74F1: 78      	        LD      A,B             ; Get underflow
74F2: 1F      	        RRA                     ; Shift right with last bit
74F3: 47      	        LD      B,A             ; Re-save underflow
74F4: C3E574  	        JP      SHRLP           ; More bits to do
              	
74F7: 00000081	UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
              	
74FB: 03      	LOGTAB: .BYTE      3                       ; Table used by LOG
74FC: AA561980	        .BYTE      0AAH,056H,019H,080H     ; 0.59898
7500: F1227680	        .BYTE      0F1H,022H,076H,080H     ; 0.96147
7504: 45AA3882	        .BYTE      045H,0AAH,038H,082H     ; 2.88539
              	
7508: CD5476  	LOG:    CALL    TSTSGN          ; Test sign of value
750B: B7      	        OR      A
750C: EACC68  	        JP      PE,FCERR        ; ?FC Error if <= zero
750F: 21E780  	        LD      HL,FPEXP        ; Point to exponent
7512: 7E      	        LD      A,(HL)          ; Get exponent
7513: 013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
7516: 11F304  	        LD      DE,04F3H
7519: 90      	        SUB     B               ; Scale value to be < 1
751A: F5      	        PUSH    AF              ; Save scale factor
751B: 70      	        LD      (HL),B          ; Save new exponent
751C: D5      	        PUSH    DE              ; Save SQR(1/2)
751D: C5      	        PUSH    BC
751E: CD0E74  	        CALL    FPADD           ; Add SQR(1/2) to value
7521: C1      	        POP     BC              ; Restore SQR(1/2)
7522: D1      	        POP     DE
7523: 04      	        INC     B               ; Make it SQR(2)
7524: CDAA75  	        CALL    DVBCDE          ; Divide by SQR(2)
7527: 21F774  	        LD      HL,UNITY        ; Point to 1.
752A: CD0574  	        CALL    SUBPHL          ; Subtract FPREG from 1
752D: 21FB74  	        LD      HL,LOGTAB       ; Coefficient table
7530: CD9C79  	        CALL    SUMSER          ; Evaluate sum of series
7533: 018080  	        LD      BC,8080H        ; BCDE = -0.5
7536: 110000  	        LD      DE,0000H
7539: CD0E74  	        CALL    FPADD           ; Subtract 0.5 from FPREG
753C: F1      	        POP     AF              ; Restore scale factor
753D: CDCF77  	        CALL    RSCALE          ; Re-scale number
7540: 013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
7543: 111872  	        LD      DE,7218H
7546: 21      	        .BYTE      21H             ; Skip "POP BC" and "POP DE"
              	
7547: C1      	MULT:   POP     BC              ; Get number from stack
7548: D1      	        POP     DE
7549: CD5476  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
754C: C8      	        RET     Z               ; Return zero if zero
754D: 2E00    	        LD      L,0             ; Flag add exponents
754F: CD1276  	        CALL    ADDEXP          ; Add exponents
7552: 79      	        LD      A,C             ; Get MSB of multiplier
7553: 32F680  	        LD      (MULVAL),A      ; Save MSB of multiplier
7556: EB      	        EX      DE,HL
7557: 22F780  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
755A: 010000  	        LD      BC,0            ; Partial product (BCDE) = zero
755D: 50      	        LD      D,B
755E: 58      	        LD      E,B
755F: 215F74  	        LD      HL,BNORM        ; Address of normalise
7562: E5      	        PUSH    HL              ; Save for return
7563: 216B75  	        LD      HL,MULT8        ; Address of 8 bit multiply
7566: E5      	        PUSH    HL              ; Save for NMSB,MSB
7567: E5      	        PUSH    HL              ; 
7568: 21E480  	        LD      HL,FPREG        ; Point to number
756B: 7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
756C: 23      	        INC     HL              ; Point to NMSB
756D: B7      	        OR      A               ; Test LSB
756E: CA9775  	        JP      Z,BYTSFT        ; Zero - shift to next byte
7571: E5      	        PUSH    HL              ; Save address of number
7572: 2E08    	        LD      L,8             ; 8 bits to multiply by
7574: 1F      	MUL8LP: RRA                     ; Shift LSB right
7575: 67      	        LD      H,A             ; Save LSB
7576: 79      	        LD      A,C             ; Get MSB
7577: D28575  	        JP      NC,NOMADD       ; Bit was zero - Don't add
757A: E5      	        PUSH    HL              ; Save LSB and count
757B: 2AF780  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
757E: 19      	        ADD     HL,DE           ; Add NMSB and LSB
757F: EB      	        EX      DE,HL           ; Leave sum in DE
7580: E1      	        POP     HL              ; Restore MSB and count
7581: 3AF680  	        LD      A,(MULVAL)      ; Get MSB of multiplier
7584: 89      	        ADC     A,C             ; Add MSB
7585: 1F      	NOMADD: RRA                     ; Shift MSB right
7586: 4F      	        LD      C,A             ; Re-save MSB
7587: 7A      	        LD      A,D             ; Get NMSB
7588: 1F      	        RRA                     ; Shift NMSB right
7589: 57      	        LD      D,A             ; Re-save NMSB
758A: 7B      	        LD      A,E             ; Get LSB
758B: 1F      	        RRA                     ; Shift LSB right
758C: 5F      	        LD      E,A             ; Re-save LSB
758D: 78      	        LD      A,B             ; Get VLSB
758E: 1F      	        RRA                     ; Shift VLSB right
758F: 47      	        LD      B,A             ; Re-save VLSB
7590: 2D      	        DEC     L               ; Count bits multiplied
7591: 7C      	        LD      A,H             ; Get LSB of multiplier
7592: C27475  	        JP      NZ,MUL8LP       ; More - Do it
7595: E1      	POPHRT: POP     HL              ; Restore address of number
7596: C9      	        RET
              	
7597: 43      	BYTSFT: LD      B,E             ; Shift partial product left
7598: 5A      	        LD      E,D
7599: 51      	        LD      D,C
759A: 4F      	        LD      C,A
759B: C9      	        RET
              	
759C: CD8576  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
759F: 012084  	        LD      BC,8420H        ; BCDE = 10.
75A2: 110000  	        LD      DE,0000H
75A5: CD9576  	        CALL    FPBCDE          ; Move 10 to FPREG
              	
75A8: C1      	DIV:    POP     BC              ; Get number from stack
75A9: D1      	        POP     DE
75AA: CD5476  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
75AD: CAB063  	        JP      Z,DZERR         ; Error if division by zero
75B0: 2EFF    	        LD      L,-1            ; Flag subtract exponents
75B2: CD1276  	        CALL    ADDEXP          ; Subtract exponents
75B5: 34      	        INC     (HL)            ; Add 2 to exponent to adjust
75B6: 34      	        INC     (HL)
75B7: 2B      	        DEC     HL              ; Point to MSB
75B8: 7E      	        LD      A,(HL)          ; Get MSB of dividend
75B9: 321280  	        LD      (DIV3),A        ; Save for subtraction
75BC: 2B      	        DEC     HL
75BD: 7E      	        LD      A,(HL)          ; Get NMSB of dividend
75BE: 320E80  	        LD      (DIV2),A        ; Save for subtraction
75C1: 2B      	        DEC     HL
75C2: 7E      	        LD      A,(HL)          ; Get MSB of dividend
75C3: 320A80  	        LD      (DIV1),A        ; Save for subtraction
75C6: 41      	        LD      B,C             ; Get MSB
75C7: EB      	        EX      DE,HL           ; NMSB,LSB to HL
75C8: AF      	        XOR     A
75C9: 4F      	        LD      C,A             ; Clear MSB of quotient
75CA: 57      	        LD      D,A             ; Clear NMSB of quotient
75CB: 5F      	        LD      E,A             ; Clear LSB of quotient
75CC: 321580  	        LD      (DIV4),A        ; Clear overflow count
75CF: E5      	DIVLP:  PUSH    HL              ; Save divisor
75D0: C5      	        PUSH    BC
75D1: 7D      	        LD      A,L             ; Get LSB of number
75D2: CD0980  	        CALL    DIVSUP          ; Subt' divisor from dividend
75D5: DE00    	        SBC     A,0             ; Count for overflows
75D7: 3F      	        CCF
75D8: D2E275  	        JP      NC,RESDIV       ; Restore divisor if borrow
75DB: 321580  	        LD      (DIV4),A        ; Re-save overflow count
75DE: F1      	        POP     AF              ; Scrap divisor
75DF: F1      	        POP     AF
75E0: 37      	        SCF                     ; Set carry to
75E1: D2      	        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
              	
75E2: C1      	RESDIV: POP     BC              ; Restore divisor
75E3: E1      	        POP     HL
75E4: 79      	        LD      A,C             ; Get MSB of quotient
75E5: 3C      	        INC     A
75E6: 3D      	        DEC     A
75E7: 1F      	        RRA                     ; Bit 0 to bit 7
75E8: FA9574  	        JP      M,RONDB         ; Done - Normalise result
75EB: 17      	        RLA                     ; Restore carry
75EC: 7B      	        LD      A,E             ; Get LSB of quotient
75ED: 17      	        RLA                     ; Double it
75EE: 5F      	        LD      E,A             ; Put it back
75EF: 7A      	        LD      A,D             ; Get NMSB of quotient
75F0: 17      	        RLA                     ; Double it
75F1: 57      	        LD      D,A             ; Put it back
75F2: 79      	        LD      A,C             ; Get MSB of quotient
75F3: 17      	        RLA                     ; Double it
75F4: 4F      	        LD      C,A             ; Put it back
75F5: 29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
75F6: 78      	        LD      A,B             ; Get MSB of divisor
75F7: 17      	        RLA                     ; Double it
75F8: 47      	        LD      B,A             ; Put it back
75F9: 3A1580  	        LD      A,(DIV4)        ; Get VLSB of quotient
75FC: 17      	        RLA                     ; Double it
75FD: 321580  	        LD      (DIV4),A        ; Put it back
7600: 79      	        LD      A,C             ; Get MSB of quotient
7601: B2      	        OR      D               ; Merge NMSB
7602: B3      	        OR      E               ; Merge LSB
7603: C2CF75  	        JP      NZ,DIVLP        ; Not done - Keep dividing
7606: E5      	        PUSH    HL              ; Save divisor
7607: 21E780  	        LD      HL,FPEXP        ; Point to exponent
760A: 35      	        DEC     (HL)            ; Divide by 2
760B: E1      	        POP     HL              ; Restore divisor
760C: C2CF75  	        JP      NZ,DIVLP        ; Ok - Keep going
760F: C3BC63  	        JP      OVERR           ; Overflow error
              	
7612: 78      	ADDEXP: LD      A,B             ; Get exponent of dividend
7613: B7      	        OR      A               ; Test it
7614: CA3676  	        JP      Z,OVTST3        ; Zero - Result zero
7617: 7D      	        LD      A,L             ; Get add/subtract flag
7618: 21E780  	        LD      HL,FPEXP        ; Point to exponent
761B: AE      	        XOR     (HL)            ; Add or subtract it
761C: 80      	        ADD     A,B             ; Add the other exponent
761D: 47      	        LD      B,A             ; Save new exponent
761E: 1F      	        RRA                     ; Test exponent for overflow
761F: A8      	        XOR     B
7620: 78      	        LD      A,B             ; Get exponent
7621: F23576  	        JP      P,OVTST2        ; Positive - Test for overflow
7624: C680    	        ADD     A,80H           ; Add excess 128
7626: 77      	        LD      (HL),A          ; Save new exponent
7627: CA9575  	        JP      Z,POPHRT        ; Zero - Result zero
762A: CDBA76  	        CALL    SIGNS           ; Set MSBs and sign of result
762D: 77      	        LD      (HL),A          ; Save new exponent
762E: 2B      	        DEC     HL              ; Point to MSB
762F: C9      	        RET
              	
7630: CD5476  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
7633: 2F      	        CPL                     ; Invert sign
7634: E1      	        POP     HL              ; Clean up stack
7635: B7      	OVTST2: OR      A               ; Test if new exponent zero
7636: E1      	OVTST3: POP     HL              ; Clear off return address
7637: F27474  	        JP      P,RESZER        ; Result zero
763A: C3BC63  	        JP      OVERR           ; Overflow error
              	
763D: CDA076  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
7640: 78      	        LD      A,B             ; Get exponent
7641: B7      	        OR      A               ; Is it zero?
7642: C8      	        RET     Z               ; Yes - Result is zero
7643: C602    	        ADD     A,2             ; Multiply by 4
7645: DABC63  	        JP      C,OVERR         ; Overflow - ?OV Error
7648: 47      	        LD      B,A             ; Re-save exponent
7649: CD0E74  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
764C: 21E780  	        LD      HL,FPEXP        ; Point to exponent
764F: 34      	        INC     (HL)            ; Double number (Times 10)
7650: C0      	        RET     NZ              ; Ok - Return
7651: C3BC63  	        JP      OVERR           ; Overflow error
              	
7654: 3AE780  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
7657: B7      	        OR      A
7658: C8      	        RET     Z               ; RETurn if number is zero
7659: 3AE680  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
765C: FE      	        .BYTE      0FEH            ; Test sign
765D: 2F      	RETREL: CPL                     ; Invert sign
765E: 17      	        RLA                     ; Sign bit to carry
765F: 9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
7660: C0      	        RET     NZ              ; Return -1 if negative
7661: 3C      	        INC     A               ; Bump to +1
7662: C9      	        RET                     ; Positive - Return +1
              	
7663: CD5476  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
7666: 0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
7668: 110000  	        LD      DE,0            ; Zero NMSB and LSB
766B: 21E780  	RETINT: LD      HL,FPEXP        ; Point to exponent
766E: 4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
766F: 70      	        LD      (HL),B          ; Save exponent
7670: 0600    	        LD      B,0             ; CDE = integer to normalise
7672: 23      	        INC     HL              ; Point to sign of result
7673: 3680    	        LD      (HL),80H        ; Set sign of result
7675: 17      	        RLA                     ; Carry = sign of integer
7676: C35C74  	        JP      CONPOS          ; Set sign of result
              	
7679: CD5476  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
767C: F0      	        RET     P               ; Return if positive
767D: 21E680  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
7680: 7E      	        LD      A,(HL)          ; Get sign of mantissa
7681: EE80    	        XOR     80H             ; Invert sign of mantissa
7683: 77      	        LD      (HL),A          ; Re-save sign of mantissa
7684: C9      	        RET
              	
7685: EB      	STAKFP: EX      DE,HL           ; Save code string address
7686: 2AE480  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
7689: E3      	        EX      (SP),HL         ; Stack them,get return
768A: E5      	        PUSH    HL              ; Re-save return
768B: 2AE680  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
768E: E3      	        EX      (SP),HL         ; Stack them,get return
768F: E5      	        PUSH    HL              ; Re-save return
7690: EB      	        EX      DE,HL           ; Restore code string address
7691: C9      	        RET
              	
7692: CDA376  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
7695: EB      	FPBCDE: EX      DE,HL           ; Save code string address
7696: 22E480  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
7699: 60      	        LD      H,B             ; Exponent of number
769A: 69      	        LD      L,C             ; MSB of number
769B: 22E680  	        LD      (FPREG+2),HL    ; Save MSB and exponent
769E: EB      	        EX      DE,HL           ; Restore code string address
769F: C9      	        RET
              	
76A0: 21E480  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
76A3: 5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
76A4: 23      	        INC     HL
76A5: 56      	        LD      D,(HL)          ; Get NMSB of number
76A6: 23      	        INC     HL
76A7: 4E      	        LD      C,(HL)          ; Get MSB of number
76A8: 23      	        INC     HL
76A9: 46      	        LD      B,(HL)          ; Get exponent of number
76AA: 23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
76AB: C9      	        RET
              	
76AC: 11E480  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
76AF: 0604    	DETHL4: LD      B,4             ; 4 bytes to move
76B1: 1A      	DETHLB: LD      A,(DE)          ; Get source
76B2: 77      	        LD      (HL),A          ; Save destination
76B3: 13      	        INC     DE              ; Next source
76B4: 23      	        INC     HL              ; Next destination
76B5: 05      	        DEC     B               ; Count bytes
76B6: C2B176  	        JP      NZ,DETHLB       ; Loop if more
76B9: C9      	        RET
              	
76BA: 21E680  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
76BD: 7E      	        LD      A,(HL)          ; Get MSB
76BE: 07      	        RLCA                    ; Old sign to carry
76BF: 37      	        SCF                     ; Set MSBit
76C0: 1F      	        RRA                     ; Set MSBit of MSB
76C1: 77      	        LD      (HL),A          ; Save new MSB
76C2: 3F      	        CCF                     ; Complement sign
76C3: 1F      	        RRA                     ; Old sign to carry
76C4: 23      	        INC     HL
76C5: 23      	        INC     HL
76C6: 77      	        LD      (HL),A          ; Set sign of result
76C7: 79      	        LD      A,C             ; Get MSB
76C8: 07      	        RLCA                    ; Old sign to carry
76C9: 37      	        SCF                     ; Set MSBit
76CA: 1F      	        RRA                     ; Set MSBit of MSB
76CB: 4F      	        LD      C,A             ; Save MSB
76CC: 1F      	        RRA
76CD: AE      	        XOR     (HL)            ; New sign of result
76CE: C9      	        RET
              	
76CF: 78      	CMPNUM: LD      A,B             ; Get exponent of number
76D0: B7      	        OR      A
76D1: CA5476  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
76D4: 215D76  	        LD      HL,RETREL       ; Return relation routine
76D7: E5      	        PUSH    HL              ; Save for return
76D8: CD5476  	        CALL    TSTSGN          ; Test sign of FPREG
76DB: 79      	        LD      A,C             ; Get MSB of number
76DC: C8      	        RET     Z               ; FPREG zero - Number's MSB
76DD: 21E680  	        LD      HL,FPREG+2      ; MSB of FPREG
76E0: AE      	        XOR     (HL)            ; Combine signs
76E1: 79      	        LD      A,C             ; Get MSB of number
76E2: F8      	        RET     M               ; Exit if signs different
76E3: CDE976  	        CALL    CMPFP           ; Compare FP numbers
76E6: 1F      	        RRA                     ; Get carry to sign
76E7: A9      	        XOR     C               ; Combine with MSB of number
76E8: C9      	        RET
              	
76E9: 23      	CMPFP:  INC     HL              ; Point to exponent
76EA: 78      	        LD      A,B             ; Get exponent
76EB: BE      	        CP      (HL)            ; Compare exponents
76EC: C0      	        RET     NZ              ; Different
76ED: 2B      	        DEC     HL              ; Point to MBS
76EE: 79      	        LD      A,C             ; Get MSB
76EF: BE      	        CP      (HL)            ; Compare MSBs
76F0: C0      	        RET     NZ              ; Different
76F1: 2B      	        DEC     HL              ; Point to NMSB
76F2: 7A      	        LD      A,D             ; Get NMSB
76F3: BE      	        CP      (HL)            ; Compare NMSBs
76F4: C0      	        RET     NZ              ; Different
76F5: 2B      	        DEC     HL              ; Point to LSB
76F6: 7B      	        LD      A,E             ; Get LSB
76F7: 96      	        SUB     (HL)            ; Compare LSBs
76F8: C0      	        RET     NZ              ; Different
76F9: E1      	        POP     HL              ; Drop RETurn
76FA: E1      	        POP     HL              ; Drop another RETurn
76FB: C9      	        RET
              	
76FC: 47      	FPINT:  LD      B,A             ; <- Move
76FD: 4F      	        LD      C,A             ; <- exponent
76FE: 57      	        LD      D,A             ; <- to all
76FF: 5F      	        LD      E,A             ; <- bits
7700: B7      	        OR      A               ; Test exponent
7701: C8      	        RET     Z               ; Zero - Return zero
7702: E5      	        PUSH    HL              ; Save pointer to number
7703: CDA076  	        CALL    BCDEFP          ; Move FPREG to BCDE
7706: CDBA76  	        CALL    SIGNS           ; Set MSBs & sign of result
7709: AE      	        XOR     (HL)            ; Combine with sign of FPREG
770A: 67      	        LD      H,A             ; Save combined signs
770B: FC2077  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
770E: 3E98    	        LD      A,80H+24        ; 24 bits
7710: 90      	        SUB     B               ; Bits to shift
7711: CDD374  	        CALL    SCALE           ; Shift BCDE
7714: 7C      	        LD      A,H             ; Get combined sign
7715: 17      	        RLA                     ; Sign to carry
7716: DCA674  	        CALL    C,FPROND        ; Negative - Round number up
7719: 0600    	        LD      B,0             ; Zero exponent
771B: DCBF74  	        CALL    C,COMPL         ; If negative make positive
771E: E1      	        POP     HL              ; Restore pointer to number
771F: C9      	        RET
              	
7720: 1B      	DCBCDE: DEC     DE              ; Decrement BCDE
7721: 7A      	        LD      A,D             ; Test LSBs
7722: A3      	        AND     E
7723: 3C      	        INC     A
7724: C0      	        RET     NZ              ; Exit if LSBs not FFFF
7725: 0B      	        DEC     BC              ; Decrement MSBs
7726: C9      	        RET
              	
7727: 21E780  	INT:    LD      HL,FPEXP        ; Point to exponent
772A: 7E      	        LD      A,(HL)          ; Get exponent
772B: FE98    	        CP      80H+24          ; Integer accuracy only?
772D: 3AE480  	        LD      A,(FPREG)       ; Get LSB
7730: D0      	        RET     NC              ; Yes - Already integer
7731: 7E      	        LD      A,(HL)          ; Get exponent
7732: CDFC76  	        CALL    FPINT           ; F.P to integer
7735: 3698    	        LD      (HL),80H+24     ; Save 24 bit integer
7737: 7B      	        LD      A,E             ; Get LSB of number
7738: F5      	        PUSH    AF              ; Save LSB
7739: 79      	        LD      A,C             ; Get MSB of number
773A: 17      	        RLA                     ; Sign to carry
773B: CD5C74  	        CALL    CONPOS          ; Set sign of result
773E: F1      	        POP     AF              ; Restore LSB of number
773F: C9      	        RET
              	
7740: 210000  	MLDEBC: LD      HL,0            ; Clear partial product
7743: 78      	        LD      A,B             ; Test multiplier
7744: B1      	        OR      C
7745: C8      	        RET     Z               ; Return zero if zero
7746: 3E10    	        LD      A,16            ; 16 bits
7748: 29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
7749: DA806F  	        JP      C,BSERR         ; ?BS Error if overflow
774C: EB      	        EX      DE,HL
774D: 29      	        ADD     HL,HL           ; Shift multiplier left
774E: EB      	        EX      DE,HL
774F: D25677  	        JP      NC,NOMLAD       ; Bit was zero - No add
7752: 09      	        ADD     HL,BC           ; Add multiplicand
7753: DA806F  	        JP      C,BSERR         ; ?BS Error if overflow
7756: 3D      	NOMLAD: DEC     A               ; Count bits
7757: C24877  	        JP      NZ,MLDBLP       ; More
775A: C9      	        RET
              	
775B: FE2D    	ASCTFP: CP      '-'             ; Negative?
775D: F5      	        PUSH    AF              ; Save it and flags
775E: CA6777  	        JP      Z,CNVNUM        ; Yes - Convert number
7761: FE2B    	        CP      '+'             ; Positive?
7763: CA6777  	        JP      Z,CNVNUM        ; Yes - Convert number
7766: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
7767: CD7474  	CNVNUM: CALL    RESZER          ; Set result to zero
776A: 47      	        LD      B,A             ; Digits after point counter
776B: 57      	        LD      D,A             ; Sign of exponent
776C: 5F      	        LD      E,A             ; Exponent of ten
776D: 2F      	        CPL
776E: 4F      	        LD      C,A             ; Before or after point flag
776F: CD0568  	MANLP:  CALL    GETCHR          ; Get next character
7772: DAB877  	        JP      C,ADDIG         ; Digit - Add to number
7775: FE2E    	        CP      '.'
7777: CA9377  	        JP      Z,DPOINT        ; '.' - Flag point
777A: FE45    	        CP      'E'
777C: C29777  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
777F: CD0568  	        CALL    GETCHR          ; Get next character
7782: CDAB6D  	        CALL    SGNEXP          ; Get sign of exponent
7785: CD0568  	EXPLP:  CALL    GETCHR          ; Get next character
7788: DADA77  	        JP      C,EDIGIT        ; Digit - Add to exponent
778B: 14      	        INC     D               ; Is sign negative?
778C: C29777  	        JP      NZ,CONEXP       ; No - Scale number
778F: AF      	        XOR     A
7790: 93      	        SUB     E               ; Negate exponent
7791: 5F      	        LD      E,A             ; And re-save it
7792: 0C      	        INC     C               ; Flag end of number
7793: 0C      	DPOINT: INC     C               ; Flag point passed
7794: CA6F77  	        JP      Z,MANLP         ; Zero - Get another digit
7797: E5      	CONEXP: PUSH    HL              ; Save code string address
7798: 7B      	        LD      A,E             ; Get exponent
7799: 90      	        SUB     B               ; Subtract digits after point
779A: F4B077  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
779D: F2A677  	        JP      P,ENDCON        ; Positive - All done
77A0: F5      	        PUSH    AF              ; Save number of times to /10
77A1: CD9C75  	        CALL    DIV10           ; Divide by 10
77A4: F1      	        POP     AF              ; Restore count
77A5: 3C      	        INC     A               ; Count divides
              	
77A6: C29A77  	ENDCON: JP      NZ,SCALMI       ; More to do
77A9: D1      	        POP     DE              ; Restore code string address
77AA: F1      	        POP     AF              ; Restore sign of number
77AB: CC7D76  	        CALL    Z,INVSGN        ; Negative - Negate number
77AE: EB      	        EX      DE,HL           ; Code string address to HL
77AF: C9      	        RET
              	
77B0: C8      	SCALPL: RET     Z               ; Exit if no scaling needed
77B1: F5      	MULTEN: PUSH    AF              ; Save count
77B2: CD3D76  	        CALL    MLSP10          ; Multiply number by 10
77B5: F1      	        POP     AF              ; Restore count
77B6: 3D      	        DEC     A               ; Count multiplies
77B7: C9      	        RET
              	
77B8: D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
77B9: 57      	        LD      D,A             ; Save digit
77BA: 78      	        LD      A,B             ; Get digits after point
77BB: 89      	        ADC     A,C             ; Add one if after point
77BC: 47      	        LD      B,A             ; Re-save counter
77BD: C5      	        PUSH    BC              ; Save point flags
77BE: E5      	        PUSH    HL              ; Save code string address
77BF: D5      	        PUSH    DE              ; Save digit
77C0: CD3D76  	        CALL    MLSP10          ; Multiply number by 10
77C3: F1      	        POP     AF              ; Restore digit
77C4: D630    	        SUB     '0'             ; Make it absolute
77C6: CDCF77  	        CALL    RSCALE          ; Re-scale number
77C9: E1      	        POP     HL              ; Restore code string address
77CA: C1      	        POP     BC              ; Restore point flags
77CB: D1      	        POP     DE              ; Restore sign of exponent
77CC: C36F77  	        JP      MANLP           ; Get another digit
              	
77CF: CD8576  	RSCALE: CALL    STAKFP          ; Put number on stack
77D2: CD6676  	        CALL    FLGREL          ; Digit to add to FPREG
77D5: C1      	PADD:   POP     BC              ; Restore number
77D6: D1      	        POP     DE
77D7: C30E74  	        JP      FPADD           ; Add BCDE to FPREG and return
              	
77DA: 7B      	EDIGIT: LD      A,E             ; Get digit
77DB: 07      	        RLCA                    ; Times 2
77DC: 07      	        RLCA                    ; Times 4
77DD: 83      	        ADD     A,E             ; Times 5
77DE: 07      	        RLCA                    ; Times 10
77DF: 86      	        ADD     A,(HL)          ; Add next digit
77E0: D630    	        SUB     '0'             ; Make it absolute
77E2: 5F      	        LD      E,A             ; Save new digit
77E3: C38577  	        JP      EXPLP           ; Look for another digit
              	
77E6: E5      	LINEIN: PUSH    HL              ; Save code string address
77E7: 214563  	        LD      HL,INMSG        ; Output " in "
77EA: CD4B71  	        CALL    PRS             ; Output string at HL
77ED: E1      	        POP     HL              ; Restore code string address
77EE: EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
77EF: AF      	        XOR     A
77F0: 0698    	        LD      B,80H+24        ; 24 bits
77F2: CD6B76  	        CALL    RETINT          ; Return the integer
77F5: 214A71  	        LD      HL,PRNUMS       ; Print number string
77F8: E5      	        PUSH    HL              ; Save for return
77F9: 21E980  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
77FC: E5      	        PUSH    HL              ; Save for return
77FD: CD5476  	        CALL    TSTSGN          ; Test sign of FPREG
7800: 3620    	        LD      (HL),' '        ; Space at start
7802: F20778  	        JP      P,SPCFST        ; Positive - Space to start
7805: 362D    	        LD      (HL),'-'        ; '-' sign at start
7807: 23      	SPCFST: INC     HL              ; First byte of number
7808: 3630    	        LD      (HL),'0'        ; '0' if zero
780A: CABD78  	        JP      Z,JSTZER        ; Return '0' if zero
780D: E5      	        PUSH    HL              ; Save buffer address
780E: FC7D76  	        CALL    M,INVSGN        ; Negate FPREG if negative
7811: AF      	        XOR     A               ; Zero A
7812: F5      	        PUSH    AF              ; Save it
7813: CDC378  	        CALL    RNGTST          ; Test number is in range
7816: 014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
7819: 11F84F  	        LD      DE,4FF8H
781C: CDCF76  	        CALL    CMPNUM          ; Compare numbers
781F: B7      	        OR      A
7820: E23478  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
7823: F1      	        POP     AF              ; Restore count
7824: CDB177  	        CALL    MULTEN          ; Multiply by ten
7827: F5      	        PUSH    AF              ; Re-save count
7828: C31678  	        JP      SIXDIG          ; Test it again
              	
782B: CD9C75  	GTSIXD: CALL    DIV10           ; Divide by 10
782E: F1      	        POP     AF              ; Get count
782F: 3C      	        INC     A               ; Count divides
7830: F5      	        PUSH    AF              ; Re-save count
7831: CDC378  	        CALL    RNGTST          ; Test number is in range
7834: CDFC73  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
7837: 3C      	        INC     A
7838: CDFC76  	        CALL    FPINT           ; F.P to integer
783B: CD9576  	        CALL    FPBCDE          ; Move BCDE to FPREG
783E: 010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
7841: F1      	        POP     AF              ; Restore count
7842: 81      	        ADD     A,C             ; 6 digits before point
7843: 3C      	        INC     A               ; Add one
7844: FA5078  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
7847: FE08    	        CP      6+1+1           ; More than 999999 ?
7849: D25078  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
784C: 3C      	        INC     A               ; Adjust for exponent
784D: 47      	        LD      B,A             ; Exponent of number
784E: 3E02    	        LD      A,2             ; Make it zero after
              	
7850: 3D      	MAKNUM: DEC     A               ; Adjust for digits to do
7851: 3D      	        DEC     A
7852: E1      	        POP     HL              ; Restore buffer address
7853: F5      	        PUSH    AF              ; Save count
7854: 11D678  	        LD      DE,POWERS       ; Powers of ten
7857: 05      	        DEC     B               ; Count digits before point
7858: C26178  	        JP      NZ,DIGTXT       ; Not zero - Do number
785B: 362E    	        LD      (HL),'.'        ; Save point
785D: 23      	        INC     HL              ; Move on
785E: 3630    	        LD      (HL),'0'        ; Save zero
7860: 23      	        INC     HL              ; Move on
7861: 05      	DIGTXT: DEC     B               ; Count digits before point
7862: 362E    	        LD      (HL),'.'        ; Save point in case
7864: CCAA76  	        CALL    Z,INCHL         ; Last digit - move on
7867: C5      	        PUSH    BC              ; Save digits before point
7868: E5      	        PUSH    HL              ; Save buffer address
7869: D5      	        PUSH    DE              ; Save powers of ten
786A: CDA076  	        CALL    BCDEFP          ; Move FPREG to BCDE
786D: E1      	        POP     HL              ; Powers of ten table
786E: 062F    	        LD      B, '0'-1        ; ASCII '0' - 1
7870: 04      	TRYAGN: INC     B               ; Count subtractions
7871: 7B      	        LD      A,E             ; Get LSB
7872: 96      	        SUB     (HL)            ; Subtract LSB
7873: 5F      	        LD      E,A             ; Save LSB
7874: 23      	        INC     HL
7875: 7A      	        LD      A,D             ; Get NMSB
7876: 9E      	        SBC     A,(HL)          ; Subtract NMSB
7877: 57      	        LD      D,A             ; Save NMSB
7878: 23      	        INC     HL
7879: 79      	        LD      A,C             ; Get MSB
787A: 9E      	        SBC     A,(HL)          ; Subtract MSB
787B: 4F      	        LD      C,A             ; Save MSB
787C: 2B      	        DEC     HL              ; Point back to start
787D: 2B      	        DEC     HL
787E: D27078  	        JP      NC,TRYAGN       ; No overflow - Try again
7881: CDB374  	        CALL    PLUCDE          ; Restore number
7884: 23      	        INC     HL              ; Start of next number
7885: CD9576  	        CALL    FPBCDE          ; Move BCDE to FPREG
7888: EB      	        EX      DE,HL           ; Save point in table
7889: E1      	        POP     HL              ; Restore buffer address
788A: 70      	        LD      (HL),B          ; Save digit in buffer
788B: 23      	        INC     HL              ; And move on
788C: C1      	        POP     BC              ; Restore digit count
788D: 0D      	        DEC     C               ; Count digits
788E: C26178  	        JP      NZ,DIGTXT       ; More - Do them
7891: 05      	        DEC     B               ; Any decimal part?
7892: CAA178  	        JP      Z,DOEBIT        ; No - Do 'E' bit
7895: 2B      	SUPTLZ: DEC     HL              ; Move back through buffer
7896: 7E      	        LD      A,(HL)          ; Get character
7897: FE30    	        CP      '0'             ; '0' character?
7899: CA9578  	        JP      Z,SUPTLZ        ; Yes - Look back for more
789C: FE2E    	        CP      '.'             ; A decimal point?
789E: C4AA76  	        CALL    NZ,INCHL        ; Move back over digit
              	
78A1: F1      	DOEBIT: POP     AF              ; Get 'E' flag
78A2: CAC078  	        JP      Z,NOENED        ; No 'E' needed - End buffer
78A5: 3645    	        LD      (HL),'E'        ; Put 'E' in buffer
78A7: 23      	        INC     HL              ; And move on
78A8: 362B    	        LD      (HL),'+'        ; Put '+' in buffer
78AA: F2B178  	        JP      P,OUTEXP        ; Positive - Output exponent
78AD: 362D    	        LD      (HL),'-'        ; Put '-' in buffer
78AF: 2F      	        CPL                     ; Negate exponent
78B0: 3C      	        INC     A
78B1: 062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
78B3: 04      	EXPTEN: INC     B               ; Count subtractions
78B4: D60A    	        SUB     10              ; Tens digit
78B6: D2B378  	        JP      NC,EXPTEN       ; More to do
78B9: C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
78BB: 23      	        INC     HL              ; Move on
78BC: 70      	        LD      (HL),B          ; Save MSB of exponent
78BD: 23      	JSTZER: INC     HL              ;
78BE: 77      	        LD      (HL),A          ; Save LSB of exponent
78BF: 23      	        INC     HL
78C0: 71      	NOENED: LD      (HL),C          ; Mark end of buffer
78C1: E1      	        POP     HL              ; Restore code string address
78C2: C9      	        RET
              	
78C3: 017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
78C6: 11F723  	        LD      DE,23F7H
78C9: CDCF76  	        CALL    CMPNUM          ; Compare numbers
78CC: B7      	        OR      A
78CD: E1      	        POP     HL              ; Return address to HL
78CE: E22B78  	        JP      PO,GTSIXD       ; Too big - Divide by ten
78D1: E9      	        JP      (HL)            ; Otherwise return to caller
              	
78D2: 00000080	HALF:   .BYTE      00H,00H,00H,80H ; 0.5
              	
78D6: A08601  	POWERS: .BYTE      0A0H,086H,001H  ; 100000
78D9: 102700  	        .BYTE      010H,027H,000H  ;  10000
78DC: E80300  	        .BYTE      0E8H,003H,000H  ;   1000
78DF: 640000  	        .BYTE      064H,000H,000H  ;    100
78E2: 0A0000  	        .BYTE      00AH,000H,000H  ;     10
78E5: 010000  	        .BYTE      001H,000H,000H  ;      1
              	
78E8: 217D76  	NEGAFT: LD  HL,INVSGN           ; Negate result
78EB: E3      	        EX      (SP),HL         ; To be done after caller
78EC: E9      	        JP      (HL)            ; Return to caller
              	
78ED: CD8576  	SQR:    CALL    STAKFP          ; Put value on stack
78F0: 21D278  	        LD      HL,HALF         ; Set power to 1/2
78F3: CD9276  	        CALL    PHLTFP          ; Move 1/2 to FPREG
              	
78F6: C1      	POWER:  POP     BC              ; Get base
78F7: D1      	        POP     DE
78F8: CD5476  	        CALL    TSTSGN          ; Test sign of power
78FB: 78      	        LD      A,B             ; Get exponent of base
78FC: CA3B79  	        JP      Z,EXP           ; Make result 1 if zero
78FF: F20679  	        JP      P,POWER1        ; Positive base - Ok
7902: B7      	        OR      A               ; Zero to negative power?
7903: CAB063  	        JP      Z,DZERR         ; Yes - ?/0 Error
7906: B7      	POWER1: OR      A               ; Base zero?
7907: CA7574  	        JP      Z,SAVEXP        ; Yes - Return zero
790A: D5      	        PUSH    DE              ; Save base
790B: C5      	        PUSH    BC
790C: 79      	        LD      A,C             ; Get MSB of base
790D: F67F    	        OR      01111111B       ; Get sign status
790F: CDA076  	        CALL    BCDEFP          ; Move power to BCDE
7912: F22379  	        JP      P,POWER2        ; Positive base - Ok
7915: D5      	        PUSH    DE              ; Save power
7916: C5      	        PUSH    BC
7917: CD2777  	        CALL    INT             ; Get integer of power
791A: C1      	        POP     BC              ; Restore power
791B: D1      	        POP     DE
791C: F5      	        PUSH    AF              ; MSB of base
791D: CDCF76  	        CALL    CMPNUM          ; Power an integer?
7920: E1      	        POP     HL              ; Restore MSB of base
7921: 7C      	        LD      A,H             ; but don't affect flags
7922: 1F      	        RRA                     ; Exponent odd or even?
7923: E1      	POWER2: POP     HL              ; Restore MSB and exponent
7924: 22E680  	        LD      (FPREG+2),HL    ; Save base in FPREG
7927: E1      	        POP     HL              ; LSBs of base
7928: 22E480  	        LD      (FPREG),HL      ; Save in FPREG
792B: DCE878  	        CALL    C,NEGAFT        ; Odd power - Negate result
792E: CC7D76  	        CALL    Z,INVSGN        ; Negative base - Negate it
7931: D5      	        PUSH    DE              ; Save power
7932: C5      	        PUSH    BC
7933: CD0875  	        CALL    LOG             ; Get LOG of base
7936: C1      	        POP     BC              ; Restore power
7937: D1      	        POP     DE
7938: CD4975  	        CALL    FPMULT          ; Multiply LOG by power
              	
793B: CD8576  	EXP:    CALL    STAKFP          ; Put value on stack
793E: 013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
7941: 113BAA  	        LD      DE,0AA3BH
7944: CD4975  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
7947: 3AE780  	        LD      A,(FPEXP)       ; Get exponent
794A: FE88    	        CP      80H+8           ; Is it in range?
794C: D23076  	        JP      NC,OVTST1       ; No - Test for overflow
794F: CD2777  	        CALL    INT             ; Get INT of FPREG
7952: C680    	        ADD     A,80H           ; For excess 128
7954: C602    	        ADD     A,2             ; Exponent > 126?
7956: DA3076  	        JP      C,OVTST1        ; Yes - Test for overflow
7959: F5      	        PUSH    AF              ; Save scaling factor
795A: 21F774  	        LD      HL,UNITY        ; Point to 1.
795D: CDFF73  	        CALL    ADDPHL          ; Add 1 to FPREG
7960: CD4075  	        CALL    MULLN2          ; Multiply by LN(2)
7963: F1      	        POP     AF              ; Restore scaling factor
7964: C1      	        POP     BC              ; Restore exponent
7965: D1      	        POP     DE
7966: F5      	        PUSH    AF              ; Save scaling factor
7967: CD0B74  	        CALL    SUBCDE          ; Subtract exponent from FPREG
796A: CD7D76  	        CALL    INVSGN          ; Negate result
796D: 217B79  	        LD      HL,EXPTAB       ; Coefficient table
7970: CDAB79  	        CALL    SMSER1          ; Sum the series
7973: 110000  	        LD      DE,0            ; Zero LSBs
7976: C1      	        POP     BC              ; Scaling factor
7977: 4A      	        LD      C,D             ; Zero MSB
7978: C34975  	        JP      FPMULT          ; Scale result to correct value
              	
797B: 08      	EXPTAB: .BYTE      8                       ; Table used by EXP
797C: 402E9474	        .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
7980: 704F2E77	        .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
7984: 6E02887A	        .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
7988: E6A02A7C	        .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
798C: 50AAAA7E	        .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
7990: FFFF7F7F	        .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
7994: 00008081	        .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
7998: 00000081	        .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
              	
799C: CD8576  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
799F: 114775  	        LD      DE,MULT         ; Multiply by "X"
79A2: D5      	        PUSH    DE              ; To be done after
79A3: E5      	        PUSH    HL              ; Save address of table
79A4: CDA076  	        CALL    BCDEFP          ; Move FPREG to BCDE
79A7: CD4975  	        CALL    FPMULT          ; Square the value
79AA: E1      	        POP     HL              ; Restore address of table
79AB: CD8576  	SMSER1: CALL    STAKFP          ; Put value on stack
79AE: 7E      	        LD      A,(HL)          ; Get number of coefficients
79AF: 23      	        INC     HL              ; Point to start of table
79B0: CD9276  	        CALL    PHLTFP          ; Move coefficient to FPREG
79B3: 06      	        .BYTE      06H             ; Skip "POP AF"
79B4: F1      	SUMLP:  POP     AF              ; Restore count
79B5: C1      	        POP     BC              ; Restore number
79B6: D1      	        POP     DE
79B7: 3D      	        DEC     A               ; Cont coefficients
79B8: C8      	        RET     Z               ; All done
79B9: D5      	        PUSH    DE              ; Save number
79BA: C5      	        PUSH    BC
79BB: F5      	        PUSH    AF              ; Save count
79BC: E5      	        PUSH    HL              ; Save address in table
79BD: CD4975  	        CALL    FPMULT          ; Multiply FPREG by BCDE
79C0: E1      	        POP     HL              ; Restore address in table
79C1: CDA376  	        CALL    LOADFP          ; Number at HL to BCDE
79C4: E5      	        PUSH    HL              ; Save address in table
79C5: CD0E74  	        CALL    FPADD           ; Add coefficient to FPREG
79C8: E1      	        POP     HL              ; Restore address in table
79C9: C3B479  	        JP      SUMLP           ; More coefficients
              	
79CC: CD5476  	RND:    CALL    TSTSGN          ; Test sign of FPREG
79CF: 211980  	        LD      HL,SEED+2       ; Random number seed
79D2: FA2D7A  	        JP      M,RESEED        ; Negative - Re-seed
79D5: 213A80  	        LD      HL,LSTRND       ; Last random number
79D8: CD9276  	        CALL    PHLTFP          ; Move last RND to FPREG
79DB: 211980  	        LD      HL,SEED+2       ; Random number seed
79DE: C8      	        RET     Z               ; Return if RND(0)
79DF: 86      	        ADD     A,(HL)          ; Add (SEED)+2)
79E0: E607    	        AND     00000111B       ; 0 to 7
79E2: 0600    	        LD      B,0
79E4: 77      	        LD      (HL),A          ; Re-save seed
79E5: 23      	        INC     HL              ; Move to coefficient table
79E6: 87      	        ADD     A,A             ; 4 bytes
79E7: 87      	        ADD     A,A             ; per entry
79E8: 4F      	        LD      C,A             ; BC = Offset into table
79E9: 09      	        ADD     HL,BC           ; Point to coefficient
79EA: CDA376  	        CALL    LOADFP          ; Coefficient to BCDE
79ED: CD4975  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
79F0: 3A1880  	        LD      A,(SEED+1)      ; Get (SEED+1)
79F3: 3C      	        INC     A               ; Add 1
79F4: E603    	        AND     00000011B       ; 0 to 3
79F6: 0600    	        LD      B,0
79F8: FE01    	        CP      1               ; Is it zero?
79FA: 88      	        ADC     A,B             ; Yes - Make it 1
79FB: 321880  	        LD      (SEED+1),A      ; Re-save seed
79FE: 21317A  	        LD      HL,RNDTAB-4     ; Addition table
7A01: 87      	        ADD     A,A             ; 4 bytes
7A02: 87      	        ADD     A,A             ; per entry
7A03: 4F      	        LD      C,A             ; BC = Offset into table
7A04: 09      	        ADD     HL,BC           ; Point to value
7A05: CDFF73  	        CALL    ADDPHL          ; Add value to FPREG
7A08: CDA076  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
7A0B: 7B      	        LD      A,E             ; Get LSB
7A0C: 59      	        LD      E,C             ; LSB = MSB
7A0D: EE4F    	        XOR     01001111B       ; Fiddle around
7A0F: 4F      	        LD      C,A             ; New MSB
7A10: 3680    	        LD      (HL),80H        ; Set exponent
7A12: 2B      	        DEC     HL              ; Point to MSB
7A13: 46      	        LD      B,(HL)          ; Get MSB
7A14: 3680    	        LD      (HL),80H        ; Make value -0.5
7A16: 211780  	        LD      HL,SEED         ; Random number seed
7A19: 34      	        INC     (HL)            ; Count seed
7A1A: 7E      	        LD      A,(HL)          ; Get seed
7A1B: D6AB    	        SUB     171             ; Do it modulo 171
7A1D: C2247A  	        JP      NZ,RND2         ; Non-zero - Ok
7A20: 77      	        LD      (HL),A          ; Zero seed
7A21: 0C      	        INC     C               ; Fillde about
7A22: 15      	        DEC     D               ; with the
7A23: 1C      	        INC     E               ; number
7A24: CD5F74  	RND2:   CALL    BNORM           ; Normalise number
7A27: 213A80  	        LD      HL,LSTRND       ; Save random number
7A2A: C3AC76  	        JP      FPTHL           ; Move FPREG to last and return
              	
7A2D: 77      	RESEED: LD      (HL),A          ; Re-seed random numbers
7A2E: 2B      	        DEC     HL
7A2F: 77      	        LD      (HL),A
7A30: 2B      	        DEC     HL
7A31: 77      	        LD      (HL),A
7A32: C3087A  	        JP      RND1            ; Return RND seed
              	
7A35: 68B14668	RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
7A39: 99E99269	        .BYTE   099H,0E9H,092H,069H
7A3D: 10D17568	        .BYTE   010H,0D1H,075H,068H
              	
7A41: 218B7A  	COS:    LD      HL,HALFPI       ; Point to PI/2
7A44: CDFF73  	        CALL    ADDPHL          ; Add it to PPREG
7A47: CD8576  	SIN:    CALL    STAKFP          ; Put angle on stack
7A4A: 014983  	        LD      BC,8349H        ; BCDE = 2 PI
7A4D: 11DB0F  	        LD      DE,0FDBH
7A50: CD9576  	        CALL    FPBCDE          ; Move 2 PI to FPREG
7A53: C1      	        POP     BC              ; Restore angle
7A54: D1      	        POP     DE
7A55: CDAA75  	        CALL    DVBCDE          ; Divide angle by 2 PI
7A58: CD8576  	        CALL    STAKFP          ; Put it on stack
7A5B: CD2777  	        CALL    INT             ; Get INT of result
7A5E: C1      	        POP     BC              ; Restore number
7A5F: D1      	        POP     DE
7A60: CD0B74  	        CALL    SUBCDE          ; Make it 0 <= value < 1
7A63: 218F7A  	        LD      HL,QUARTR       ; Point to 0.25
7A66: CD0574  	        CALL    SUBPHL          ; Subtract value from 0.25
7A69: CD5476  	        CALL    TSTSGN          ; Test sign of value
7A6C: 37      	        SCF                     ; Flag positive
7A6D: F2777A  	        JP      P,SIN1          ; Positive - Ok
7A70: CDFC73  	        CALL    ROUND           ; Add 0.5 to value
7A73: CD5476  	        CALL    TSTSGN          ; Test sign of value
7A76: B7      	        OR      A               ; Flag negative
7A77: F5      	SIN1:   PUSH    AF              ; Save sign
7A78: F47D76  	        CALL    P,INVSGN        ; Negate value if positive
7A7B: 218F7A  	        LD      HL,QUARTR       ; Point to 0.25
7A7E: CDFF73  	        CALL    ADDPHL          ; Add 0.25 to value
7A81: F1      	        POP     AF              ; Restore sign
7A82: D47D76  	        CALL    NC,INVSGN       ; Negative - Make positive
7A85: 21937A  	        LD      HL,SINTAB       ; Coefficient table
7A88: C39C79  	        JP      SUMSER          ; Evaluate sum of series
              	
7A8B: DB0F4981	HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
              	
7A8F: 0000007F	QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
              	
7A93: 05      	SINTAB: .BYTE   5                       ; Table used by SIN
7A94: BAD71E86	        .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
7A98: 64269987	        .BYTE   064H,026H,099H,087H     ;-76.575
7A9C: 58342387	        .BYTE   058H,034H,023H,087H     ; 81.602
7AA0: E05DA586	        .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
7AA4: DA0F4983	        .BYTE   0DAH,00FH,049H,083H     ;  6.2832
              	
7AA8: CD8576  	TAN:    CALL    STAKFP          ; Put angle on stack
7AAB: CD477A  	        CALL    SIN             ; Get SIN of angle
7AAE: C1      	        POP     BC              ; Restore angle
7AAF: E1      	        POP     HL
7AB0: CD8576  	        CALL    STAKFP          ; Save SIN of angle
7AB3: EB      	        EX      DE,HL           ; BCDE = Angle
7AB4: CD9576  	        CALL    FPBCDE          ; Angle to FPREG
7AB7: CD417A  	        CALL    COS             ; Get COS of angle
7ABA: C3A875  	        JP      DIV             ; TAN = SIN / COS
              	
7ABD: CD5476  	ATN:    CALL    TSTSGN          ; Test sign of value
7AC0: FCE878  	        CALL    M,NEGAFT        ; Negate result after if -ve
7AC3: FC7D76  	        CALL    M,INVSGN        ; Negate value if -ve
7AC6: 3AE780  	        LD      A,(FPEXP)       ; Get exponent
7AC9: FE81    	        CP      81H             ; Number less than 1?
7ACB: DADA7A  	        JP      C,ATN1          ; Yes - Get arc tangnt
7ACE: 010081  	        LD      BC,8100H        ; BCDE = 1
7AD1: 51      	        LD      D,C
7AD2: 59      	        LD      E,C
7AD3: CDAA75  	        CALL    DVBCDE          ; Get reciprocal of number
7AD6: 210574  	        LD      HL,SUBPHL       ; Sub angle from PI/2
7AD9: E5      	        PUSH    HL              ; Save for angle > 1
7ADA: 21E47A  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
7ADD: CD9C79  	        CALL    SUMSER          ; Evaluate sum of series
7AE0: 218B7A  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
7AE3: C9      	        RET                     ; Number > 1 - Sub from PI/2
              	
7AE4: 09      	ATNTAB: .BYTE   9                       ; Table used by ATN
7AE5: 4AD73B78	        .BYTE   04AH,0D7H,03BH,078H     ; 1/17
7AE9: 026E847B	        .BYTE   002H,06EH,084H,07BH     ;-1/15
7AED: FEC12F7C	        .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
7AF1: 74319A7D	        .BYTE   074H,031H,09AH,07DH     ;-1/11
7AF5: 843D5A7D	        .BYTE   084H,03DH,05AH,07DH     ; 1/9
7AF9: C87F917E	        .BYTE   0C8H,07FH,091H,07EH     ;-1/7
7AFD: E4BB4C7E	        .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
7B01: 6CAAAA7F	        .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
7B05: 00000081	        .BYTE   000H,000H,000H,081H     ; 1/1
              	
              	
7B09: C9      	ARET:   RET                     ; A RETurn instruction
              	
7B0A: D7      	GETINP: RST	    10H             ;input a character
7B0B: C9      	        RET
              	
7B0C:         	CLS: 
7B0C: 3E0C    	        LD      A,CS            ; ASCII Clear screen
7B0E: C3467C  	        JP      MONOUT          ; Output character
              	
7B11: CDD373  	WIDTH:  CALL    GETINT          ; Get integer 0-255
7B14: 7B      	        LD      A,E             ; Width to A
7B15: 324280  	        LD      (LWIDTH),A      ; Set width
7B18: C9      	        RET
              	
7B19: CD726C  	LINES:  CALL    GETNUM          ; Get a number
7B1C: CDB768  	        CALL    DEINT           ; Get integer -32768 to 32767
7B1F: ED534680	        LD      (LINESC),DE     ; Set lines counter
7B23: ED534880	        LD      (LINESN),DE     ; Set lines number
7B27: C9      	        RET
              	
7B28: CDB768  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
7B2B: D5      	        PUSH    DE              ; Save number
7B2C: E1      	        POP     HL              ; Number to HL
7B2D: 46      	        LD      B,(HL)          ; Get LSB of contents
7B2E: 23      	        INC     HL
7B2F: 7E      	        LD      A,(HL)          ; Get MSB of contents
7B30: C32D70  	        JP      ABPASS          ; Return integer AB
              	
7B33: CD726C  	DOKE:   CALL    GETNUM          ; Get a number
7B36: CDB768  	        CALL    DEINT           ; Get integer -32768 to 32767
7B39: D5      	        PUSH    DE              ; Save address
7B3A: CD7B66  	        CALL    CHKSYN          ; Make sure ',' follows
7B3D: 2C      	        .BYTE      ','
7B3E: CD726C  	        CALL    GETNUM          ; Get a number
7B41: CDB768  	        CALL    DEINT           ; Get integer -32768 to 32767
7B44: E3      	        EX      (SP),HL         ; Save value,get address
7B45: 73      	        LD      (HL),E          ; Save LSB of value
7B46: 23      	        INC     HL
7B47: 72      	        LD      (HL),D          ; Save MSB of value
7B48: E1      	        POP     HL              ; Restore code string address
7B49: C9      	        RET
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
              	
7B4A: CD756C  	HEX: 	CALL	TSTNUM          ; Verify it's a number
7B4D: CDB768  	        CALL	DEINT           ; Get integer -32768 to 32767
7B50: C5      	        PUSH	BC              ; Save contents of BC
7B51: 21E980  	        LD	    HL,PBUFF
7B54: 7A      	        LD	    A,D             ; Get high order into A
7B55: FE00    	        CP      $0
7B57: 280C    			JR      Z,HEX2          ; Skip output if both high digits are zero
7B59: CD827B  	        CALL    BYT2ASC         ; Convert D to ASCII
7B5C: 78      			LD      A,B
7B5D: FE30    			CP      '0'
7B5F: 2802    			JR      Z,HEX1          ; Don't store high digit if zero
7B61: 70      	        LD	    (HL),B          ; Store it to PBUFF
7B62: 23      	        INC	    HL              ; Next location
7B63: 71      	HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
7B64: 23      	        INC     HL              ; Next location
7B65: 7B      	HEX2:   LD	    A,E             ; Get lower byte
7B66: CD827B  	        CALL    BYT2ASC         ; Convert E to ASCII
7B69: 7A      			LD      A,D
7B6A: FE00    	        CP      $0
7B6C: 2005    			JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
7B6E: 78      			LD      A,B
7B6F: FE30    			CP      '0'             ; If high digit of lower byte is zero then don't print
7B71: 2802    			JR      Z,HEX4
7B73: 70      	HEX3:   LD      (HL),B          ; to PBUFF+2
7B74: 23      	        INC     HL              ; Next location
7B75: 71      	HEX4:   LD      (HL),C          ; to PBUFF+3
7B76: 23      	        INC     HL              ; PBUFF+4 to zero
7B77: AF      	        XOR     A               ; Terminating character
7B78: 77      	        LD      (HL),A          ; Store zero to terminate
7B79: 23      	        INC     HL              ; Make sure PBUFF is terminated
7B7A: 77      	        LD      (HL),A          ; Store the double zero there
7B7B: C1      	        POP     BC              ; Get BC back
7B7C: 21E980  	        LD      HL,PBUFF        ; Reset to start of PBUFF
7B7F: C3DB70  	        JP      STR1            ; Convert the PBUFF to a string and return it
              	
7B82: 47      	BYT2ASC	LD      B,A             ; Save original value
7B83: E60F    	        AND     $0F             ; Strip off upper nybble
7B85: FE0A    	        CP      $0A             ; 0-9?
7B87: 3802    	        JR      C,ADD30         ; If A-F, add 7 more
7B89: C607    	        ADD     A,$07           ; Bring value up to ASCII A-F
7B8B: C630    	ADD30	ADD     A,$30           ; And make ASCII
7B8D: 4F      	        LD      C,A             ; Save converted char to C
7B8E: 78      	        LD      A,B             ; Retrieve original value
7B8F: 0F      	        RRCA                    ; and Rotate it right
7B90: 0F      	        RRCA
7B91: 0F      	        RRCA
7B92: 0F      	        RRCA
7B93: E60F    	        AND     $0F             ; Mask off upper nybble
7B95: FE0A    	        CP      $0A             ; 0-9? < A hex?
7B97: 3802    	        JR      C,ADD301        ; Skip Add 7
7B99: C607    	        ADD     A,$07           ; Bring it up to ASCII A-F
7B9B: C630    	ADD301	ADD     A,$30           ; And make it full ASCII
7B9D: 47      	        LD      B,A             ; Store high order byte
7B9E: C9      	        RET	
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
7B9F: EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
7BA0: 210000  	        LD      HL,$0000        ; Zero out the value
7BA3: CDB87B  	        CALL    GETHEX          ; Check the number for valid hex
7BA6: DAD87B  	        JP      C,HXERR         ; First value wasn't hex, HX error
7BA9: 1805    	        JR      HEXLP1          ; Convert first character
7BAB: CDB87B  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
7BAE: 381F    	        JR      C,HEXIT         ; Exit if not a hex character
7BB0: 29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
7BB1: 29      	        ADD     HL,HL
7BB2: 29      	        ADD     HL,HL
7BB3: 29      	        ADD     HL,HL
7BB4: B5      	        OR      L               ; Add in D0-D3 into L
7BB5: 6F      	        LD      L,A             ; Save new value
7BB6: 18F3    	        JR      HEXLP           ; And continue until all hex characters are in
              	
7BB8: 13      	GETHEX  INC     DE              ; Next location
7BB9: 1A      	        LD      A,(DE)          ; Load character at pointer
7BBA: FE20    	        CP      ' '
7BBC: CAB87B  	        JP      Z,GETHEX        ; Skip spaces
7BBF: D630    	        SUB     $30             ; Get absolute value
7BC1: D8      	        RET     C               ; < "0", error
7BC2: FE0A    	        CP      $0A
7BC4: 3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
7BC6: D607    	        SUB     $07             ; Reduce to A-F
7BC8: FE0A    	        CP      $0A             ; Value should be $0A-$0F at this point
7BCA: D8      	        RET     C               ; CY set if was :            ; < = > ? @
7BCB: FE10    	NOSUB7  CP      $10             ; > Greater than "F"?
7BCD: 3F      	        CCF
7BCE: C9      	        RET                     ; CY set if it wasn't valid hex
              	    
7BCF: EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
7BD0: 7A      	        LD      A,D             ; Load DE into AC
7BD1: 4B      	        LD      C,E             ; For prep to 
7BD2: E5      	        PUSH    HL
7BD3: CD2C70  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
7BD6: E1      	        POP     HL
7BD7: C9      	        RET
              	
7BD8: 1E26    	HXERR:  LD      E,HX            ; ?HEX Error
7BDA: C3C163  	        JP      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
7BDD: CD756C  	BIN:    CALL    TSTNUM          ; Verify it's a number
7BE0: CDB768  	        CALL    DEINT           ; Get integer -32768 to 32767
7BE3: C5      	BIN2:   PUSH    BC              ; Save contents of BC
7BE4: 21E980  	        LD      HL,PBUFF
7BE7: 0611    	        LD      B,17            ; One higher than max char count
7BE9:         	ZEROSUP:                        ; Suppress leading zeros
7BE9: 05      	        DEC     B               ; Max 16 chars
7BEA: 78      	        LD      A,B
7BEB: FE01    	        CP      $01
7BED: 2808    	        JR      Z,BITOUT        ; Always output at least one character
7BEF: CB13    	        RL      E
7BF1: CB12    	        RL      D
7BF3: 30F4    	        JR      NC,ZEROSUP
7BF5: 1804    	        JR      BITOUT2
7BF7:         	BITOUT:      
7BF7: CB13    	        RL      E
7BF9: CB12    	        RL      D               ; Top bit now in carry
7BFB:         	BITOUT2:
7BFB: 3E30    	        LD      A,'0'           ; Char for '0'
7BFD: CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
7BFF: 77      	        LD      (HL),A
7C00: 23      	        INC     HL
7C01: 05      	        DEC     B
7C02: 20F3    	        JR      NZ,BITOUT
7C04: AF      	        XOR     A               ; Terminating character
7C05: 77      	        LD      (HL),A          ; Store zero to terminate
7C06: 23      	        INC     HL              ; Make sure PBUFF is terminated
7C07: 77      	        LD      (HL),A          ; Store the double zero there
7C08: C1      	        POP     BC
7C09: 21E980  	        LD      HL,PBUFF
7C0C: C3DB70  	        JP      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
7C0F: EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
7C10: 210000  	        LD      HL,$0000        ; Zero out the value
7C13: CD2C7C  	        CALL    CHKBIN          ; Check the number for valid bin
7C16: DA3A7C  	        JP      C,BINERR        ; First value wasn't bin, HX error
7C19: D630    	BINIT:  SUB     '0'
7C1B: 29      	        ADD     HL,HL           ; Rotate HL left
7C1C: B5      	        OR      L
7C1D: 6F      	        LD      L,A
7C1E: CD2C7C  	        CALL    CHKBIN          ; Get second and addtional characters
7C21: 30F6    	        JR      NC,BINIT        ; Process if a bin character
7C23: EB      	        EX      DE,HL           ; Value into DE, Code string into HL
7C24: 7A      	        LD      A,D             ; Load DE into AC
7C25: 4B      	        LD      C,E             ; For prep to 
7C26: E5      	        PUSH    HL
7C27: CD2C70  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
7C2A: E1      	        POP     HL
7C2B: C9      	        RET
              	
              	; Char is in A, NC if char is 0 or 1
7C2C: 13      	CHKBIN: INC     DE
7C2D: 1A      	        LD      A,(DE)
7C2E: FE20    	        CP      ' '
7C30: CA2C7C  	        JP      Z,CHKBIN        ; Skip spaces
7C33: FE30    	        CP      '0'             ; Set C if < '0'
7C35: D8      	        RET     C
7C36: FE32    	        CP      '2'
7C38: 3F      	        CCF                     ; Set C if > '1'
7C39: C9      	        RET
              	
7C3A: 1E28    	BINERR: LD      E,BN            ; ?BIN Error
7C3C: C3C163  	        JP      ERROR
              	
              	
7C3F:         	JJUMP1: 
7C3F: DD21FFFF	        LD      IX,-1           ; Flag cold start
7C43: C31160  	        JP      CSTART          ; Go and initialise
              	
7C46:         	MONOUT: 
7C46: C30800  	        JP      $0008           ; output a char
              	
              	
7C49:         	MONITR: 
7C49: C30000  	        JP      $0000           ; Restart (Normally Monitor Start)
              	
              	
7C4C: 3E00    	INITST: LD      A,0             ; Clear break flag
7C4E: 324D80  	        LD      (BRKFLG),A
7C51: C31860  	        JP      INIT
              	
7C54: ED45    	ARETN:  RETN                    ; Return from NMI
              	
              	
7C56: F5      	TSTBIT: PUSH    AF              ; Save bit mask
7C57: A0      	        AND     B               ; Get common bits
7C58: C1      	        POP     BC              ; Restore bit mask
7C59: B8      	        CP      B               ; Same bit set?
7C5A: 3E00    	        LD      A,0             ; Return 0 in A
7C5C: C9      	        RET
              	
7C5D: CD8666  	OUTNCR: CALL    OUTC            ; Output character in A
7C60: C3AD6A  	        JP      PRNTCRLF        ; Output CRLF
              	
              	.end
              	
              	.end


; +++ segments +++

#CODE          = $0000 =     0,  size = $7C63 = 31843

; +++ global symbols +++

ABPASS         = $702D = 28717          basicV2.asm:2410
ABS            = $7679 = 30329          basicV2.asm:3433
AC2HEX1        = $0234 =   564          Keyboard.asm:58
AC2HEX2        = $0236 =   566          Keyboard.asm:61
AC2HEX3        = $0242 =   578          Keyboard.asm:67
ACCSUM         = $6896 = 26774          basicV2.asm:1312 (unused)
ACPASS         = $702C = 28716          basicV2.asm:2409
ADD30          = $7B8B = 31627          basicV2.asm:4181
ADD301         = $7B9B = 31643          basicV2.asm:4192
ADDEXP         = $7612 = 30226          basicV2.asm:3368
ADDIG          = $77B8 = 30648          basicV2.asm:3656
ADDOFFSET      = $0292 =   658          Keyboard.asm:128
ADDPHL         = $73FF = 29695          basicV2.asm:3015
ADDR           = $F425 = 62501          bootV2.asm:129
ADDR_FROM      = $F427 = 62503          bootV2.asm:130
ADDR_SIZE      = $F42B = 62507          bootV2.asm:132
ADDR_TO        = $F429 = 62505          bootV2.asm:131
ALLFOL         = $72FB = 29435          basicV2.asm:2857
ANTVLU         = $6B96 = 27542          basicV2.asm:1719
API            = $00C8 =   200          bootV2.asm:204 (unused)
APIHandler     = $0142 =   322          API.asm:40
APITable       = $0154 =   340          API.asm:60
ARET           = $7B09 = 31497          basicV2.asm:4096 (unused)
ARETN          = $7C54 = 31828          basicV2.asm:4324 (unused)
ARLDSV         = $6F4D = 28493          basicV2.asm:2265
ARREND         = $80DA = 32986          basicV2.asm:88
ARRLP          = $71C6 = 29126          basicV2.asm:2648
ASC            = $72CC = 29388          basicV2.asm:2827
ASC2HEX        = $022A =   554          Keyboard.asm:53
ASCTFP         = $775B = 30555          basicV2.asm:3602
ASPCS          = $6AF8 = 27384          basicV2.asm:1642
ATN            = $7ABD = 31421          basicV2.asm:4067
ATN1           = $7ADA = 31450          basicV2.asm:4079
ATNTAB         = $7AE4 = 31460          basicV2.asm:4084
ATOH           = $68D1 = 26833          basicV2.asm:1345
B1200          = $0080 =   128          bootV2.asm:87 (unused)
B2400          = $003F =    63          bootV2.asm:88 (unused)
B300           = $0220 =   544          bootV2.asm:86 (unused)
B4800          = $001B =    27          bootV2.asm:89
B9600          = $000B =    11          bootV2.asm:90 (unused)
BADINP         = $6B1D = 27421          basicV2.asm:1654
BAKSTK         = $6356 = 25430          basicV2.asm:518
BAKTMP         = $72AC = 29356          basicV2.asm:2805
BASIC          = $6000 = 24576          bootV2.asm:77
BASIC_W        = $6002 = 24578          bootV2.asm:78
BASTXT         = $805E = 32862          basicV2.asm:64
BAUD           = $F430 = 62512          bootV2.asm:136
BCDEFP         = $76A0 = 30368          basicV2.asm:3460
BCRLF          = $0FBF =  4031          Monitor.asm:431
BFREE          = $60AD = 24749          basicV2.asm:217
BIN            = $7BDD = 31709          basicV2.asm:4241
BIN2           = $7BE3 = 31715          basicV2.asm:4243 (unused)
BINERR         = $7C3A = 31802          basicV2.asm:4304
BINIT          = $7C19 = 31769          basicV2.asm:4279
BINTFP         = $7C0F = 31759          basicV2.asm:4275
BITIM1         = $0D7E =  3454          SoftSerial.asm:172
BITIME         = $0D79 =  3449          SoftSerial.asm:169
BITOUT         = $7BF7 = 31735          basicV2.asm:4255
BITOUT2        = $7BFB = 31739          basicV2.asm:4258
BKSP           = $0008 =     8          bootV2.asm:35
BN             = $0028 =    40          basicV2.asm:122
BNORM          = $745F = 29791          basicV2.asm:3074
BNRMLP         = $7462 = 29794          basicV2.asm:3077
BREAK_CONTINUE = $1191 =  4497          Monitor.asm:812
BREAK_CONTINUE_LOOP = $1197 =  4503          Monitor.asm:815
BRK            = $6848 = 26696          basicV2.asm:1267
BRKFLG         = $804D = 32845          basicV2.asm:57
BRKLIN         = $80CE = 32974          basicV2.asm:82
BRKMSG         = $6350 = 25424          basicV2.asm:516
BRKRET         = $60A7 = 24743          basicV2.asm:214
BS             = $0010 =    16          basicV2.asm:110
BSERR          = $6F80 = 28544          basicV2.asm:2296
BUFFER         = $8061 = 32865          basicV2.asm:65
BYT2ASC        = $7B82 = 31618          basicV2.asm:4176
BYTASC         = $1227 =  4647          Monitor.asm:922
BYTOUT         = $1219 =  4633          Monitor.asm:896
BYTSFT         = $7597 = 30103          basicV2.asm:3285
Boucle16X      = $05D1 =  1489          LCDGraphic.asm:643
Boucle32X      = $05C3 =  1475          LCDGraphic.asm:632
BufferImage128x64 = $01B6 =   438          API.asm:134
CFEVAL         = $6EE3 = 28387          basicV2.asm:2196
CHARTY         = $6E91 = 28305          basicV2.asm:2152
CHEKFN         = $70C4 = 28868          basicV2.asm:2501
CHKBIN         = $7C2C = 31788          basicV2.asm:4294
CHKKEY         = $0245 =   581          Keyboard.asm:74
CHKLTR         = $68A3 = 26787          basicV2.asm:1321
CHKSTK         = $638A = 25482          basicV2.asm:555
CHKSUM         = $804A = 32842          basicV2.asm:55
CHKSYN         = $667B = 26235          basicV2.asm:991
CHKTYP         = $6C77 = 27767          basicV2.asm:1834
CHR            = $72DD = 29405          basicV2.asm:2839
CLEAR          = $68F6 = 26870          basicV2.asm:1369
CLOTST         = $66B0 = 26288          basicV2.asm:1023
CLREG          = $64DF = 25823          basicV2.asm:763
CLRPTR         = $64BA = 25786          basicV2.asm:743
CLS            = $7B0C = 31500          basicV2.asm:4101
CMPFP          = $76E9 = 30441          basicV2.asm:3518
CMPLG1         = $6DF7 = 28151          basicV2.asm:2058
CMPLOG         = $6DF5 = 28149          basicV2.asm:2057
CMPNUM         = $76CF = 30415          basicV2.asm:3501
CMPRES         = $6E39 = 28217          basicV2.asm:2106
CMPSTR         = $6E21 = 28193          basicV2.asm:2086
CN             = $0020 =    32          basicV2.asm:118
CNVNUM         = $7767 = 30567          basicV2.asm:3608
COLD           = $6000 = 24576          basicV2.asm:126 (unused)
COMMAN         = $8043 = 32835          basicV2.asm:50
COMPL          = $74BF = 29887          basicV2.asm:3148
CONCAT         = $7241 = 29249          basicV2.asm:2738
CONEXP         = $7797 = 30615          basicV2.asm:3632
CONPOS         = $745C = 29788          basicV2.asm:3072
CONT           = $687B = 26747          basicV2.asm:1295
CONTAD         = $80D4 = 32980          basicV2.asm:85
CONVAR         = $6D62 = 28002          basicV2.asm:1958
CONV_A_HEX     = $12C5 =  4805          Utils.asm:7
CONV_A_HEX_NYBASC = $12CE =  4814          Utils.asm:17
COPY           = $6020 = 24608          basicV2.asm:143
COS            = $7A41 = 31297          basicV2.asm:4015
COUNT          = $6720 = 26400          basicV2.asm:1089
CPDEHL         = $6675 = 26229          basicV2.asm:984
CPYLIT         = $65B1 = 26033          basicV2.asm:881
CR             = $000D =    13          bootV2.asm:39
CRARLP         = $6FA0 = 28576          basicV2.asm:2316
CREARY         = $6F85 = 28549          basicV2.asm:2299
CRESTR         = $69F5 = 27125          basicV2.asm:1508
CRNCLP         = $6512 = 25874          basicV2.asm:789
CRTMST         = $70FD = 28925          basicV2.asm:2534
CRTST          = $7109 = 28937          basicV2.asm:2545
CRTSTE         = $711F = 28959          basicV2.asm:2559
CRUNCH         = $6509 = 25865          basicV2.asm:785
CS             = $000C =    12          bootV2.asm:38
CSTART         = $6011 = 24593          basicV2.asm:136
CSUMERR        = $1594 =  5524          Strings.asm:51
CTLOFG         = $8045 = 32837          basicV2.asm:52
CTRLC          = $0003 =     3          bootV2.asm:33
CTRLG          = $0007 =     7          bootV2.asm:34
CTRLO          = $000F =    15          bootV2.asm:40
CTRLQ          = $0011 =    17          bootV2.asm:41
CTRLR          = $0012 =    18          bootV2.asm:42
CTRLS          = $0013 =    19          bootV2.asm:43
CTRLU          = $0015 =    21          bootV2.asm:44
CUROPR         = $80C5 = 32965          basicV2.asm:76
CURPOS         = $80AB = 32939          basicV2.asm:67
Clear8x8       = $065C =  1628          LCDGraphic.asm:836
ClearDisplayBuffer = $01C1 =   449          API.asm:143
ClearDisplayBufferEnd = $01D2 =   466          API.asm:152
DATA           = $699C = 27036          basicV2.asm:1460
DATABYTE       = $F420 = 62496          bootV2.asm:124
DATFLG         = $80AE = 32942          basicV2.asm:70
DATLIN         = $80C9 = 32969          basicV2.asm:78
DATSNR         = $63A7 = 25511          basicV2.asm:575
DCBCDE         = $7720 = 30496          basicV2.asm:3561
DD             = $0012 =    18          basicV2.asm:111
DDERR          = $63B6 = 25526          basicV2.asm:583
DEEK           = $7B28 = 31528          basicV2.asm:4116
DEF            = $7041 = 28737          basicV2.asm:2422
DEFSIZ         = $6FA8 = 28584          basicV2.asm:2320
DEINT          = $68B7 = 26807          basicV2.asm:1332
DEL            = $007F =   127          bootV2.asm:46
DELAY_MS       = $05AC =  1452          LCDGraphic.asm:600
DELAY_US       = $05A9 =  1449          LCDGraphic.asm:598
DELCHR         = $65E1 = 26081          basicV2.asm:911
DELETE_CHAR    = $034D =   845          LCDGraphic.asm:123
DELON1         = $0CFA =  3322          SoftSerial.asm:33
DELON2         = $0CFC =  3324          SoftSerial.asm:34
DELONE         = $0CF1 =  3313          SoftSerial.asm:28 (unused)
DEPINT         = $68B1 = 26801          basicV2.asm:1330
DETHL4         = $76AF = 30383          basicV2.asm:3472
DETHLB         = $76B1 = 30385          basicV2.asm:3473
DIGTXT         = $7861 = 30817          basicV2.asm:3754
DIM            = $6E63 = 28259          basicV2.asm:2132
DIMRET         = $6E5A = 28250          basicV2.asm:2127
DINPOS         = $66AA = 26282          basicV2.asm:1018
DISPLAY        = $F000 = 61440          bootV2.asm:122
DISPLAY_SCROLL_UP = $02E6 =   742          LCDGraphic.asm:49
DIV            = $75A8 = 30120          basicV2.asm:3296
DIV1           = $800A = 32778          basicV2.asm:40
DIV10          = $759C = 30108          basicV2.asm:3291
DIV2           = $800E = 32782          basicV2.asm:41
DIV3           = $8012 = 32786          basicV2.asm:42
DIV4           = $8015 = 32789          basicV2.asm:43
DIVLP          = $75CF = 30159          basicV2.asm:3320
DIVSUP         = $8009 = 32777          basicV2.asm:39
DLINE1         = $0F89 =  3977          Monitor.asm:387
DLINE2         = $0F99 =  3993          Monitor.asm:400
DOAGN          = $64F8 = 25848          basicV2.asm:776
DOCOM          = $6AC9 = 27337          basicV2.asm:1618
DODEL          = $65C1 = 26049          basicV2.asm:895
DOEBIT         = $78A1 = 30881          basicV2.asm:3797
DOFN           = $706E = 28782          basicV2.asm:2450
DOKE           = $7B33 = 31539          basicV2.asm:4124
DONULL         = $6AB7 = 27319          basicV2.asm:1607
DOSPC          = $6AF3 = 27379          basicV2.asm:1639
DOT            = $0FA5 =  4005          Monitor.asm:406
DOTAB          = $6AE0 = 27360          basicV2.asm:1629
DPLAY1         = $0F58 =  3928          Monitor.asm:352
DPLAY2         = $0F65 =  3941          Monitor.asm:361
DPLAY3         = $0F6C =  3948          Monitor.asm:366
DPLINE         = $0F7A =  3962          Monitor.asm:376
DPOINT         = $7793 = 30611          basicV2.asm:3630
DSPLAY         = $0F42 =  3906          Monitor.asm:340
DTSTR          = $710D = 28941          basicV2.asm:2548
DVBCDE         = $75AA = 30122          basicV2.asm:3298
DZ             = $0014 =    20          basicV2.asm:112
DZERR          = $63B0 = 25520          basicV2.asm:579
DisplayImage128x64 = $01A9 =   425          API.asm:125
Div_HL_D       = $1311 =  4881          Utils.asm:112
ECHDEL         = $65D5 = 26069          basicV2.asm:904
EDIGIT         = $77DA = 30682          basicV2.asm:3679
ENDBUF         = $65B8 = 26040          basicV2.asm:887
ENDCON         = $77A6 = 30630          basicV2.asm:3642
ENDDIM         = $7007 = 28679          basicV2.asm:2389
ENDINP         = $6AA8 = 27304          basicV2.asm:1601
ENDNAM         = $6E85 = 28293          basicV2.asm:2148
ENDPRG         = $6857 = 26711          basicV2.asm:1278
ENFMEM         = $6393 = 25491          basicV2.asm:561
ERRIN          = $63E1 = 25569          basicV2.asm:605
ERRLIN         = $80D2 = 32978          basicV2.asm:84
ERRMSG         = $633E = 25406          basicV2.asm:512
ERROR          = $63C1 = 25537          basicV2.asm:591
ERRORS         = $62B4 = 25268          basicV2.asm:441
ERR_JAM        = $0001 =     1          I2C.asm:98 (unused)
ERR_NOACK      = $0002 =     2          I2C.asm:99
ERR_NONE       = $0000 =     0          I2C.asm:97 (unused)
ERR_TOUT       = $0003 =     3          I2C.asm:100
ESC            = $001B =    27          bootV2.asm:45
EVAL           = $6C84 = 27780          basicV2.asm:1842
EVAL1          = $6C87 = 27783          basicV2.asm:1844
EVAL2          = $6C90 = 27792          basicV2.asm:1848
EVAL3          = $6C93 = 27795          basicV2.asm:1849
EVLPAR         = $6D49 = 27977          basicV2.asm:1944
EVNOT          = $6E43 = 28227          basicV2.asm:2114
EXCUTE         = $67E5 = 26597          basicV2.asm:1200
EXP            = $793B = 31035          basicV2.asm:3884
EXPLP          = $7785 = 30597          basicV2.asm:3622
EXPTAB         = $797B = 31099          basicV2.asm:3912
EXPTEN         = $78B3 = 30899          basicV2.asm:3807
EXTIG          = $6BF2 = 27634          basicV2.asm:1767
FANDT          = $6C1C = 27676          basicV2.asm:1785
FC             = $0008 =     8          basicV2.asm:106
FCERR          = $68CC = 26828          basicV2.asm:1342
FDTLP          = $6C03 = 27651          basicV2.asm:1769
FILEOK         = $1582 =  5506          Strings.asm:50
FINDEL         = $6FE3 = 28643          basicV2.asm:2361
FLGDIF         = $765F = 30303          basicV2.asm:3416
FLGREL         = $7666 = 30310          basicV2.asm:3422
FNARG          = $80E0 = 32992          basicV2.asm:91
FNCTAB         = $60FE = 24830          basicV2.asm:227
FNDARY         = $6F53 = 28499          basicV2.asm:2269
FNDELP         = $6FE8 = 28648          basicV2.asm:2366
FNDEND         = $648D = 25741          basicV2.asm:706
FNDNUM         = $73D0 = 29648          basicV2.asm:2989
FNDTOK         = $66FF = 26367          basicV2.asm:1069
FNDVAR         = $6ECA = 28362          basicV2.asm:2180
FNDWRD         = $653C = 25916          basicV2.asm:809
FNOFST         = $6D73 = 28019          basicV2.asm:1968
FNRGNM         = $80DE = 32990          basicV2.asm:90
FNTHR          = $6ED8 = 28376          basicV2.asm:2188
FNVAL          = $6D9A = 28058          basicV2.asm:1990
FOPRND         = $6CBC = 27836          basicV2.asm:1870
FOR            = $674C = 26444          basicV2.asm:1111
FORFLG         = $80CB = 32971          basicV2.asm:79
FORFND         = $677C = 26492          basicV2.asm:1139
FORSLP         = $6760 = 26464          basicV2.asm:1120
FPADD          = $740E = 29710          basicV2.asm:3023
FPBCDE         = $7695 = 30357          basicV2.asm:3452
FPEXP          = $80E7 = 32999          basicV2.asm:93
FPINT          = $76FC = 30460          basicV2.asm:3538
FPMULT         = $7549 = 30025          basicV2.asm:3234
FPREG          = $80E4 = 32996          basicV2.asm:92
FPROND         = $74A6 = 29862          basicV2.asm:3124
FPSINT         = $68AB = 26795          basicV2.asm:1328
FPTHL          = $76AC = 30380          basicV2.asm:3471
FRE            = $700B = 28683          basicV2.asm:2392
FRENUM         = $7027 = 28711          basicV2.asm:2404
FRMEVL         = $6D65 = 28005          basicV2.asm:1959
GARBGE         = $718E = 29070          basicV2.asm:2621
GARBLP         = $7191 = 29073          basicV2.asm:2622
GETBT1         = $0B44 =  2884          LoaderIntel.asm:102
GETBT2         = $0B58 =  2904          LoaderIntel.asm:115
GETBYT         = $0B3A =  2874          LoaderIntel.asm:97
GETCH          = $F434 = 62516          bootV2.asm:138
GETCHR         = $6805 = 26629          basicV2.asm:1220
GETCHR_KEYBOARD = $01F0 =   496          Keyboard.asm:7
GETCMD         = $6405 = 25605          basicV2.asm:623
GETHEX         = $7BB8 = 31672          basicV2.asm:4214
GETINP         = $7B0A = 31498          basicV2.asm:4098
GETINT         = $73D3 = 29651          basicV2.asm:2990
GETLEN         = $72C1 = 29377          basicV2.asm:2819
GETLIN         = $65F2 = 26098          basicV2.asm:919
GETLN          = $68D2 = 26834          basicV2.asm:1346
GETNUM         = $6C72 = 27762          basicV2.asm:1831
GETNXT         = $6557 = 25943          basicV2.asm:824
GETNYB         = $020A =   522          Keyboard.asm:20
GETOUT         = $0228 =   552          Keyboard.asm:35
GETSTR         = $728B = 29323          basicV2.asm:2785
GETVAR         = $6E68 = 28264          basicV2.asm:2135
GET_DEV_ADDR   = $10A8 =  4264          Monitor.asm:637
GET_DEV_DD     = $10B6 =  4278          Monitor.asm:645
GET_DEV_RR     = $10C4 =  4292          Monitor.asm:654
GET_FROM_TO_SIZE = $1122 =  4386          Monitor.asm:739
GET_FROM_TO_SIZE_SIZE = $1166 =  4454          Monitor.asm:782
GET_FROM_TO_SIZE_TO = $1148 =  4424          Monitor.asm:762
GNXARY         = $71C5 = 29125          basicV2.asm:2647
GOFUNC         = $6DA2 = 28066          basicV2.asm:1994
GOJMP1         = $12B3 =  4787          Monitor.asm:1030 (unused)
GOJUMP         = $129D =  4765          Monitor.asm:1018
GOJUMP_new     = $1293 =  4755          Monitor.asm:1011
GOSUB          = $6948 = 26952          basicV2.asm:1411
GOTO           = $6959 = 26969          basicV2.asm:1423
GRBARY         = $71E5 = 29157          basicV2.asm:2666
GRBDON         = $7166 = 29030          basicV2.asm:2596
GRBLP          = $719F = 29087          basicV2.asm:2628
GRET           = $0255 =   597          Keyboard.asm:82
GSTRCU         = $728E = 29326          basicV2.asm:2786
GSTRDE         = $7292 = 29330          basicV2.asm:2788
GSTRHL         = $7291 = 29329          basicV2.asm:2787
GTFLNM         = $72D0 = 29392          basicV2.asm:2829 (unused)
GTFNAM         = $6E6D = 28269          basicV2.asm:2138
GTLNLP         = $68D5 = 26837          basicV2.asm:1347
GTSIXD         = $782B = 30763          basicV2.asm:3723
GTVLUS         = $6B6E = 27502          basicV2.asm:1697
HALF           = $78D2 = 30930          basicV2.asm:3828
HALFPI         = $7A8B = 31371          basicV2.asm:4046
HEX            = $7B4A = 31562          basicV2.asm:4141
HEX1           = $7B63 = 31587          basicV2.asm:4154
HEX2           = $7B65 = 31589          basicV2.asm:4156
HEX3           = $7B73 = 31603          basicV2.asm:4164
HEX4           = $7B75 = 31605          basicV2.asm:4166
HEXIT          = $7BCF = 31695          basicV2.asm:4229
HEXLP          = $7BAB = 31659          basicV2.asm:4204
HEXLP1         = $7BB0 = 31664          basicV2.asm:4206
HEXTFP         = $7B9F = 31647          basicV2.asm:4199
HX             = $0026 =    38          basicV2.asm:121
HXERR          = $7BD8 = 31704          basicV2.asm:4237
H_Delay        = $12EF =  4847          Utils.asm:66
HexOut         = $0CBB =  3259          I2C.asm:404
HexOutHex      = $0CC8 =  3272          I2C.asm:414
HexOutSkip     = $0CCE =  3278          I2C.asm:417
I2CA_BLOCK     = $00AE =   174          bootV2.asm:103
I2CCPUTOMEM    = $10FA =  4346          Monitor.asm:700
I2CCPUTOMEM_OK = $111B =  4379          Monitor.asm:729
I2CClose       = $01DC =   476          API.asm:162
I2CLIST        = $0C26 =  3110          I2C.asm:278
I2CMEMTOCPU    = $10D2 =  4306          Monitor.asm:666
I2CMEMTOCPU_OK = $10F3 =  4339          Monitor.asm:694
I2COpen        = $01D9 =   473          API.asm:159
I2CRead        = $01DF =   479          API.asm:165
I2CWrite       = $01E2 =   482          API.asm:168
I2C_ADDR       = $F422 = 62498          bootV2.asm:126
I2C_Close      = $0B6D =  2925          I2C.asm:22
I2C_DD         = $F424 = 62500          bootV2.asm:128
I2C_INIT       = $0BF3 =  3059          I2C.asm:228
I2C_MemRd      = $0C50 =  3152          I2C.asm:318
I2C_MemRdRead  = $0C74 =  3188          I2C.asm:340
I2C_MemRdReady = $0C65 =  3173          I2C.asm:332
I2C_MemRdRepeat = $0C54 =  3156          I2C.asm:320
I2C_MemWr      = $0C85 =  3205          I2C.asm:364
I2C_MemWrBlock = $0C9B =  3227          I2C.asm:379 (unused)
I2C_MemWrReady = $0C9A =  3226          I2C.asm:378
I2C_MemWrRepeat = $0C89 =  3209          I2C.asm:366
I2C_MemWrStore = $0CB3 =  3251          I2C.asm:394
I2C_MemWrWrite = $0CA3 =  3235          I2C.asm:383
I2C_Open       = $0B66 =  2918          I2C.asm:10
I2C_PORT       = $0021 =    33          I2C.asm:88
I2C_QUIES      = $0081 =   129          I2C.asm:93
I2C_RAMCPY     = $F421 = 62497          bootV2.asm:125
I2C_RD         = $1042 =  4162          Monitor.asm:558
I2C_RD_LOOP    = $1053 =  4179          Monitor.asm:570
I2C_RD_RR      = $1073 =  4211          Monitor.asm:597
I2C_RD_RR_LOOP = $1081 =  4225          Monitor.asm:608
I2C_RR         = $F423 = 62499          bootV2.asm:127
I2C_RdPort     = $0C1D =  3101          I2C.asm:254
I2C_Read       = $0BAD =  2989          I2C.asm:163
I2C_ReadNoAck  = $0BCF =  3023          I2C.asm:183
I2C_ReadRd_Loop = $0BB5 =  2997          I2C.asm:168
I2C_ReadRotate = $0BC1 =  3009          I2C.asm:174
I2C_SCL_HI     = $0BF7 =  3063          I2C.asm:231
I2C_SCL_LO     = $0BFE =  3070          I2C.asm:235
I2C_SCL_RD     = $0000 =     0          I2C.asm:92 (unused)
I2C_SCL_WR     = $0000 =     0          I2C.asm:91
I2C_SDA_HI     = $0C05 =  3077          I2C.asm:239
I2C_SDA_LO     = $0C0C =  3084          I2C.asm:243
I2C_SDA_RD     = $0007 =     7          I2C.asm:90
I2C_SDA_WR     = $0007 =     7          I2C.asm:89
I2C_Start      = $0BDA =  3034          I2C.asm:198
I2C_Stop       = $0BE5 =  3045          I2C.asm:214
I2C_WR_DD      = $0FF3 =  4083          Monitor.asm:487
I2C_WR_DD_LOOP = $1001 =  4097          Monitor.asm:498
I2C_WR_RR_DD   = $1016 =  4118          Monitor.asm:520
I2C_WR_RR_DD_LOOP = $1024 =  4132          Monitor.asm:531
I2C_WrPort     = $0C11 =  3089          I2C.asm:246
I2C_Write      = $0B70 =  2928          I2C.asm:116
I2C_WriteBit_Clk = $0B81 =  2945          I2C.asm:125
I2C_WriteBit_Hi = $0B7E =  2942          I2C.asm:124
I2C_WriteNoAck = $0B9E =  2974          I2C.asm:143
I2C_WriteWr_Loop = $0B75 =  2933          I2C.asm:120
ID             = $0016 =    22          basicV2.asm:113
IDTEST         = $70B6 = 28854          basicV2.asm:2491
IF             = $6A2B = 27179          basicV2.asm:1541
IFGO           = $6A39 = 27193          basicV2.asm:1548
IFJMP          = $67EC = 26604          basicV2.asm:1203
INBUF          = $0FBC =  4028          Monitor.asm:425
INCH           = $0D1B =  3355          SoftSerial.asm:73 (unused)
INCHL          = $76AA = 30378          basicV2.asm:3468
INCLEN         = $66A6 = 26278          basicV2.asm:1016
INDFND         = $6370 = 25456          basicV2.asm:537
INEWLN         = $6455 = 25685          basicV2.asm:666
INIT           = $6018 = 24600          basicV2.asm:140
INITAB         = $62DE = 25310          basicV2.asm:465
INITBE         = $633E = 25406          basicV2.asm:508
INITST         = $7C4C = 31820          basicV2.asm:4320
INIT_LCD       = $02AE =   686          LCDGraphic.asm:13
INIT_SOFTSERIAL = $0CD4 =  3284          SoftSerial.asm:3
INIT_TXT_LCD   = $02CD =   717          LCDGraphic.asm:36
INMSG          = $6345 = 25413          basicV2.asm:513
INP            = $7390 = 29584          basicV2.asm:2958
INPBIN         = $6BC0 = 27584          basicV2.asm:1741
INPBRK         = $6854 = 26708          basicV2.asm:1276
INPORT         = $803F = 32831          basicV2.asm:47
INPORT_MON     = $0FD7 =  4055          Monitor.asm:462
INPSUB         = $803E = 32830          basicV2.asm:46
INPUT          = $6B2E = 27438          basicV2.asm:1662
INRNG          = $7834 = 30772          basicV2.asm:3728
INSBUF         = $1238 =  4664          Monitor.asm:940 (unused)
INT            = $7727 = 30503          basicV2.asm:3569
INTEL1         = $0AE2 =  2786          LoaderIntel.asm:40
INTEL2         = $0B0D =  2829          LoaderIntel.asm:69
INTEL4         = $0B28 =  2856          LoaderIntel.asm:87
INTELH         = $0ADE =  2782          LoaderIntel.asm:36
INTEL_HEX      = $1185 =  4485          Monitor.asm:804
INTHEX         = $0AB3 =  2739          LoaderIntel.asm:4
INTVAR         = $64C9 = 25801          basicV2.asm:754
INVSGN         = $767D = 30333          basicV2.asm:3435
ITHEX1         = $0AD1 =  2769          LoaderIntel.asm:21
ITMSEP         = $6BB1 = 27569          basicV2.asm:1732
InputCharKey   = $0183 =   387          API.asm:92
JJUMP1         = $7C3F = 31807          basicV2.asm:4308 (unused)
JSTZER         = $78BD = 30909          basicV2.asm:3813
KDOWN          = $00B6 =   182          bootV2.asm:54
KEY            = $0DBF =  3519          Monitor.asm:40
KEYMAP         = $0068 =   104          bootV2.asm:190
KEYOUT         = $02A3 =   675          Keyboard.asm:140
KEYREADINIT    = $025A =   602          Keyboard.asm:92
KEY_IN         = $0040 =    64          bootV2.asm:27
KEY_OUT        = $0040 =    64          bootV2.asm:28
KF1            = $0080 =   128          bootV2.asm:55
KF2            = $0081 =   129          bootV2.asm:56
KF3            = $0082 =   130          bootV2.asm:57
KF4            = $0083 =   131          bootV2.asm:58
KF5            = $0084 =   132          bootV2.asm:59
KF6            = $0085 =   133          bootV2.asm:60
KF7            = $0086 =   134          bootV2.asm:61
KF8            = $0087 =   135          bootV2.asm:62
KILFOR         = $6C62 = 27746          basicV2.asm:1822
KILIN          = $65EC = 26092          basicV2.asm:916
KLEFT          = $00B4 =   180          bootV2.asm:51
KRIGHT         = $00B7 =   183          bootV2.asm:52
KUP            = $00B5 =   181          bootV2.asm:53
LCDCTRL        = $0070 =   112          bootV2.asm:25
LCDDATA        = $0071 =   113          bootV2.asm:26
LCD_AUTO_X     = $F446 = 62534          bootV2.asm:151
LCD_BIT_INDEX  = $F43C = 62524          bootV2.asm:144
LCD_BYTE_INDEX = $F43A = 62522          bootV2.asm:143
LCD_CHAR       = $F435 = 62517          bootV2.asm:139
LCD_CHAR_H     = $F441 = 62529          bootV2.asm:147
LCD_CHAR_POINT = $F436 = 62518          bootV2.asm:140
LCD_CHAR_W     = $F442 = 62530          bootV2.asm:148
LCD_COOX       = $F448 = 62536          bootV2.asm:153 (unused)
LCD_COOY       = $F449 = 62537          bootV2.asm:154 (unused)
LCD_DATA       = $F42F = 62511          bootV2.asm:135 (unused)
LCD_DELETE_CHAR = $F445 = 62533          bootV2.asm:150
LCD_LINE1      = $0080 =   128          bootV2.asm:110 (unused)
LCD_LINE2      = $0090 =   144          bootV2.asm:111 (unused)
LCD_LINE3      = $0088 =   136          bootV2.asm:112 (unused)
LCD_LINE4      = $0098 =   152          bootV2.asm:113 (unused)
LCD_PRINT_H    = $F44A = 62538          bootV2.asm:155 (unused)
LCD_PRINT_IMAGE = $F44C = 62540          bootV2.asm:157 (unused)
LCD_PRINT_W    = $F44B = 62539          bootV2.asm:156 (unused)
LCD_TEMP       = $F447 = 62535          bootV2.asm:152
LCD_TMP_POINT  = $F443 = 62531          bootV2.asm:149
LCD_TXT_X      = $F438 = 62520          bootV2.asm:141
LCD_TXT_X_TMP  = $F43D = 62525          bootV2.asm:145
LCD_TXT_Y      = $F439 = 62521          bootV2.asm:142
LCD_TXT_Y_TMP  = $F43F = 62527          bootV2.asm:146
LCRFLG         = $80AC = 32940          basicV2.asm:68
LEFT           = $72ED = 29421          basicV2.asm:2847
LEN            = $72BD = 29373          basicV2.asm:2817
LET            = $69B3 = 27059          basicV2.asm:1476
LETNUM         = $6A06 = 27142          basicV2.asm:1518
LETSTR         = $69CE = 27086          basicV2.asm:1489
LF             = $000A =    10          bootV2.asm:36
LFRGNM         = $7386 = 29574          basicV2.asm:2949
LINEAT         = $805C = 32860          basicV2.asm:63
LINEIN         = $77E6 = 30694          basicV2.asm:3689
LINES          = $7B19 = 31513          basicV2.asm:4110
LINESC         = $8046 = 32838          basicV2.asm:53
LINESN         = $8048 = 32840          basicV2.asm:54
LINFND         = $643E = 25662          basicV2.asm:652
LIST           = $66C1 = 26305          basicV2.asm:1033
LISTLOOP       = $0C2E =  3118          I2C.asm:281
LISTLP         = $66CD = 26317          basicV2.asm:1039
LISTMsg        = $146C =  5228          Strings.asm:28
LISTNEXT       = $0C3D =  3133          I2C.asm:289
LISTTEST       = $0C47 =  3143          I2C.asm:301
LOADFP         = $76A3 = 30371          basicV2.asm:3461
LOADSHIFT      = $028F =   655          Keyboard.asm:125
LOG            = $7508 = 29960          basicV2.asm:3202
LOGARITHM      = $027B =   635          Keyboard.asm:114
LOGTAB         = $74FB = 29947          basicV2.asm:3197
LOKFOR         = $635A = 25434          basicV2.asm:520
LOOPST         = $80C7 = 32967          basicV2.asm:77
LS             = $001C =    28          basicV2.asm:116
LSTBIN         = $80CC = 32972          basicV2.asm:80
LSTLP2         = $66ED = 26349          basicV2.asm:1060
LSTLP3         = $66F0 = 26352          basicV2.asm:1061
LSTRAM         = $80AF = 32943          basicV2.asm:71
LSTRND         = $803A = 32826          basicV2.asm:45
LTSTND         = $6BCB = 27595          basicV2.asm:1746
LWIDTH         = $8042 = 32834          basicV2.asm:49
LcdSetCXY      = $01E5 =   485          API.asm:171
LineOut        = $12DE =  4830          Utils.asm:40
LoopBC         = $12F5 =  4853          Utils.asm:72
LoopDE         = $12F2 =  4850          Utils.asm:70
MAKINT         = $73D6 = 29654          basicV2.asm:2991
MAKNUM         = $7850 = 30800          basicV2.asm:3743
MANLP          = $776F = 30575          basicV2.asm:3614
MATCH          = $6589 = 25993          basicV2.asm:856
MDIFY1         = $1251 =  4689          Monitor.asm:965
MDIFY2         = $128C =  4748          Monitor.asm:1001
MEMMSG         = $60F3 = 24819          basicV2.asm:223
MID            = $7327 = 29479          basicV2.asm:2887
MID1           = $72F3 = 29427          basicV2.asm:2851
MIDNUM         = $738B = 29579          basicV2.asm:2952
MINCDE         = $744E = 29774          basicV2.asm:3058
MINUS          = $6D51 = 27985          basicV2.asm:1949
MKTMST         = $70FA = 28922          basicV2.asm:2533
MLDBLP         = $7748 = 30536          basicV2.asm:3590
MLDEBC         = $7740 = 30528          basicV2.asm:3585
MLOOP          = $6048 = 24648          basicV2.asm:161
MLSP10         = $763D = 30269          basicV2.asm:3396
MO             = $0024 =    36          basicV2.asm:120
MODIFY         = $123B =  4667          Monitor.asm:950
MONITR         = $7C49 = 31817          basicV2.asm:4316
MONOUT         = $7C46 = 31814          basicV2.asm:4312
MORDT          = $6BD7 = 27607          basicV2.asm:1751
MORINP         = $65FB = 26107          basicV2.asm:924
MOVBUF         = $6474 = 25716          basicV2.asm:687
MOVDIR         = $6591 = 26001          basicV2.asm:864
MOVLP          = $637F = 25471          basicV2.asm:547
MOVSTR         = $637C = 25468          basicV2.asm:544
MOVUP          = $6379 = 25465          basicV2.asm:543
MRPRNT         = $6A4B = 27211          basicV2.asm:1555
MSGBUF         = $F401 = 62465          bootV2.asm:123
MSG_BASIC      = $1558 =  5464          Strings.asm:47
MSG_COPYFAIL   = $151E =  5406          Strings.asm:41
MSG_COPYOK     = $1515 =  5397          Strings.asm:40
MSG_CPU2MEM    = $1499 =  5273          Strings.asm:30
MSG_DEV_ADDR   = $1529 =  5417          Strings.asm:43
MSG_DEV_DATA   = $154C =  5452          Strings.asm:45
MSG_DEV_REG    = $153C =  5436          Strings.asm:44
MSG_FROM       = $14F9 =  5369          Strings.asm:37
MSG_I2C_RD     = $14D5 =  5333          Strings.asm:34
MSG_I2C_RD_RR  = $14E5 =  5349          Strings.asm:35
MSG_I2C_WR_DD  = $14AF =  5295          Strings.asm:32
MSG_I2C_WR_RR_DD = $14C0 =  5312          Strings.asm:33
MSG_ILOAD      = $156C =  5484          Strings.asm:49
MSG_MEM2CPU    = $1483 =  5251          Strings.asm:29
MSG_MENU0      = $134D =  4941          Strings.asm:4
MSG_MENU1      = $1360 =  4960          Strings.asm:5
MSG_MENU10     = $13E6 =  5094          Strings.asm:14
MSG_MENU11     = $13F7 =  5111          Strings.asm:15
MSG_MENU12     = $1407 =  5127          Strings.asm:16
MSG_MENU13     = $141A =  5146          Strings.asm:17
MSG_MENU14     = $142F =  5167          Strings.asm:18
MSG_MENU15     = $1443 =  5187          Strings.asm:19
MSG_MENU2      = $1375 =  4981          Strings.asm:6
MSG_MENU3      = $1380 =  4992          Strings.asm:7
MSG_MENU4      = $1392 =  5010          Strings.asm:8
MSG_MENU5      = $13A3 =  5027          Strings.asm:9
MSG_MENU6      = $13B3 =  5043          Strings.asm:10
MSG_MENU7      = $13C0 =  5056          Strings.asm:11
MSG_MENU8      = $13C9 =  5065          Strings.asm:12
MSG_MENU9      = $13D5 =  5077          Strings.asm:13
MSG_MENU_CONTINUE = $1451 =  5201          Strings.asm:21
MSG_MONITOR    = $1338 =  4920          Strings.asm:2
MSG_READFILE_EXE = $145D =  5213          Strings.asm:24
MSG_READFILE_IMG = $1462 =  5218          Strings.asm:25
MSG_READFILE_TXT = $1467 =  5223          Strings.asm:26
MSG_SIZE       = $1506 =  5382          Strings.asm:39
MSG_TO         = $1500 =  5376          Strings.asm:38
MSIZE          = $6035 = 24629          basicV2.asm:154
MUL8LP         = $7574 = 30068          basicV2.asm:3257
MULLN2         = $7540 = 30016          basicV2.asm:3228
MULT           = $7547 = 30023          basicV2.asm:3232
MULT8          = $756B = 30059          basicV2.asm:3251
MULTEN         = $77B1 = 30641          basicV2.asm:3650
MULVAL         = $80F6 = 33014          basicV2.asm:96
MVSTPT         = $69FD = 27133          basicV2.asm:1512
NDOT           = $0FA7 =  4007          Monitor.asm:407
NEDMOR         = $6B6A = 27498          basicV2.asm:1695
NEGAFT         = $78E8 = 30952          basicV2.asm:3837
NEW            = $64B9 = 25785          basicV2.asm:742
NEXITM         = $6B03 = 27395          basicV2.asm:1648
NEXT           = $6C27 = 27687          basicV2.asm:1790
NEXT1          = $6C2A = 27690          basicV2.asm:1791
NEXTKEY        = $0265 =   613          Keyboard.asm:102
NF             = $0000 =     0          basicV2.asm:102
NFERR          = $63B3 = 25523          basicV2.asm:581
NMIFLG         = $804C = 32844          basicV2.asm:56 (unused)
NOCHNG         = $6581 = 25985          basicV2.asm:851
NOENED         = $78C0 = 30912          basicV2.asm:3816
NOLIN          = $686A = 26730          basicV2.asm:1287
NOMADD         = $7585 = 30085          basicV2.asm:3268
NOMLAD         = $7756 = 30550          basicV2.asm:3598
NOPMPT         = $6B48 = 27464          basicV2.asm:1674
NORMAL         = $7479 = 29817          basicV2.asm:3093
NOSPC          = $6578 = 25976          basicV2.asm:846
NOSUB7         = $7BCB = 31691          basicV2.asm:4225
NOSWAP         = $7428 = 29736          basicV2.asm:3039
NOTAMP         = $6D26 = 27942          basicV2.asm:1930
NOTSTR         = $6EA0 = 28320          basicV2.asm:2160
NOXOR          = $73B6 = 29622          basicV2.asm:2975
NSCFOR         = $6EB0 = 28336          basicV2.asm:2168
NULFLG         = $8044 = 32836          basicV2.asm:51
NULL           = $688E = 26766          basicV2.asm:1306
NULLP          = $6ABE = 27326          basicV2.asm:1610
NULLS          = $8041 = 32833          basicV2.asm:48
NUMASC         = $77F9 = 30713          basicV2.asm:3699
NXTARY         = $6F67 = 28519          basicV2.asm:2281
NXTBIT         = $0D32 =  3378          SoftSerial.asm:102
NXTBYT         = $6567 = 25959          basicV2.asm:836
NXTCHR         = $65A8 = 26024          basicV2.asm:876
NXTDAT         = $80DC = 32988          basicV2.asm:89
NXTDTA         = $699B = 27035          basicV2.asm:1458
NXTITM         = $6B62 = 27490          basicV2.asm:1690
NXTOPR         = $80D0 = 32976          basicV2.asm:83
NXTSTL         = $69A2 = 27042          basicV2.asm:1463
NXTSTT         = $69A5 = 27045          basicV2.asm:1466
NYBASC         = $1230 =  4656          Monitor.asm:932
NYBOUT         = $121C =  4636          Monitor.asm:897
OD             = $0006 =     6          basicV2.asm:105
OKMSG          = $634A = 25418          basicV2.asm:515
OM             = $000C =    12          basicV2.asm:108
OMERR          = $63A2 = 25506          basicV2.asm:572
ON             = $6A0D = 27149          basicV2.asm:1524
ONGO           = $6A1C = 27164          basicV2.asm:1532
ONGOLP         = $6A1D = 27165          basicV2.asm:1533
ONJMP          = $67ED = 26605          basicV2.asm:1204
OPNPAR         = $6C80 = 27776          basicV2.asm:1840
OPRND          = $6CFB = 27899          basicV2.asm:1913
OS             = $001A =    26          basicV2.asm:115
OTKLN          = $65E9 = 26089          basicV2.asm:915
OTPORT         = $8007 = 32775          basicV2.asm:38
OUTC           = $6686 = 26246          basicV2.asm:999
OUTCH          = $0D15 =  3349          SoftSerial.asm:68
OUTEXP         = $78B1 = 30897          basicV2.asm:3806
OUTIT          = $6667 = 26215          basicV2.asm:977
OUTNBS         = $666D = 26221          basicV2.asm:980
OUTNCR         = $7C5D = 31837          basicV2.asm:4334
OUTPORT        = $0FC0 =  4032          Monitor.asm:441
OUTSP          = $0341 =   833          LCDGraphic.asm:111
OUTSUB         = $8006 = 32774          basicV2.asm:37
OUTWRD         = $6709 = 26377          basicV2.asm:1075
OV             = $000A =    10          basicV2.asm:107
OVERR          = $63BC = 25532          basicV2.asm:587
OVTST1         = $7630 = 30256          basicV2.asm:3388
OVTST2         = $7635 = 30261          basicV2.asm:3391
OVTST3         = $7636 = 30262          basicV2.asm:3392
OutLcdChar     = $0186 =   390          API.asm:95
OutLcdNewLine  = $0189 =   393          API.asm:98
PADD           = $77D5 = 30677          basicV2.asm:3675
PAND           = $6DBC = 28092          basicV2.asm:2016
PASSA          = $703C = 28732          basicV2.asm:2418
PBUFF          = $80E9 = 33001          basicV2.asm:95
PEEK           = $73E4 = 29668          basicV2.asm:3000
PEND           = $684F = 26703          basicV2.asm:1273
PHLTFP         = $7692 = 30354          basicV2.asm:3451
PLOT_COLUMN    = $0596 =  1430          LCDGraphic.asm:580
PLOT_ROW       = $057F =  1407          LCDGraphic.asm:567
PLOT_TO_LCD    = $057D =  1405          LCDGraphic.asm:564 (unused)
PLUCDE         = $74B3 = 29875          basicV2.asm:3135
PNORM          = $7481 = 29825          basicV2.asm:3101
POINT          = $8051 = 32849          basicV2.asm:59
POKE           = $73EB = 29675          basicV2.asm:3004
POPAF          = $7180 = 29056          basicV2.asm:2611
POPHL          = $72AA = 29354          basicV2.asm:2802
POPHRT         = $7595 = 30101          basicV2.asm:3282
POPNOK         = $63F7 = 25591          basicV2.asm:615
POR            = $6DBB = 28091          basicV2.asm:2015
POR1           = $6DDE = 28126          basicV2.asm:2039
PORT_OUT_VAL   = $F42E = 62510          bootV2.asm:134
PORT_SET       = $F42D = 62509          bootV2.asm:133
POS            = $7039 = 28729          basicV2.asm:2417
POSINT         = $68AE = 26798          basicV2.asm:1329
POUT           = $739C = 29596          basicV2.asm:2963
POWER          = $78F6 = 30966          basicV2.asm:3845
POWER1         = $7906 = 30982          basicV2.asm:3853
POWER2         = $7923 = 31011          basicV2.asm:3871
POWERS         = $78D6 = 30934          basicV2.asm:3830
PRINT          = $6A4F = 27215          basicV2.asm:1557
PRINTCHAR      = $0368 =   872          LCDGraphic.asm:144
PRITAB         = $629F = 25247          basicV2.asm:418
PRNTCRLF       = $6AAD = 27309          basicV2.asm:1603
PRNTHL         = $77EE = 30702          basicV2.asm:3693
PRNTLP         = $6A52 = 27218          basicV2.asm:1558
PRNTNB         = $6A95 = 27285          basicV2.asm:1590
PRNTOK         = $63F8 = 25592          basicV2.asm:617
PRNTST         = $6A99 = 27289          basicV2.asm:1592
PRNUMS         = $714A = 29002          basicV2.asm:2580
PROCES         = $6614 = 26132          basicV2.asm:935
PROGND         = $80D6 = 32982          basicV2.asm:86
PROGST         = $80F9 = 33017          basicV2.asm:97
PROMPT         = $64FC = 25852          basicV2.asm:779
PRS            = $714B = 29003          basicV2.asm:2581
PRS1           = $714E = 29006          basicV2.asm:2582
PRSLP          = $7155 = 29013          basicV2.asm:2585
PSET           = $8054 = 32852          basicV2.asm:60
PSUB           = $7409 = 29705          basicV2.asm:3020
PTRLP          = $6481 = 25729          basicV2.asm:696
PUTBUF         = $6653 = 26195          basicV2.asm:966
PUTCH          = $F432 = 62514          bootV2.asm:137
PUTCTL         = $6658 = 26200          basicV2.asm:968
PUTFID         = $67C1 = 26561          basicV2.asm:1177
Print8x8       = $0686 =  1670          LCDGraphic.asm:875
PrintBufferChar = $037A =   890          LCDGraphic.asm:161
PrtIRd         = $01A2 =   418          API.asm:119
PrtORd         = $019E =   414          API.asm:115
PrtOWr         = $0192 =   402          API.asm:106
PrtSet         = $018E =   398          API.asm:102
QTSTLP         = $7110 = 28944          basicV2.asm:2550
QTSTR          = $710A = 28938          basicV2.asm:2546
QUARTR         = $7A8F = 31375          basicV2.asm:4048
READ           = $6B5D = 27485          basicV2.asm:1687
READFG         = $80CD = 32973          basicV2.asm:81
READKEY        = $025F =   607          Keyboard.asm:97
READ_FILE      = $0E4C =  3660          Monitor.asm:141
READ_FILE_EXE  = $0EB5 =  3765          Monitor.asm:215
READ_FILE_IMG  = $0ECB =  3787          Monitor.asm:235
READ_FILE_IMG_K = $0EE3 =  3811          Monitor.asm:255
READ_FILE_TXT  = $0EEC =  3820          Monitor.asm:262
READ_FILE_TXT_L = $0EFC =  3836          Monitor.asm:278
READ_IIC_DE    = $0F21 =  3873          Monitor.asm:310
READ_MEM_FILES = $0E3F =  3647          Monitor.asm:131
READ_MEM_KEY   = $0E66 =  3686          Monitor.asm:156
READ_MEM_NEXT  = $0E42 =  3650          Monitor.asm:133
READ_MEM_STEP  = $0E9E =  3742          Monitor.asm:190
READ_MEM_STEP_L = $0EA9 =  3753          Monitor.asm:201
READ_NAME      = $0E58 =  3672          Monitor.asm:147
REDO           = $6B0A = 27402          basicV2.asm:1652
REM            = $699E = 27038          basicV2.asm:1461
RESDIV         = $75E2 = 30178          basicV2.asm:3333
RESEED         = $7A2D = 31277          basicV2.asm:4004
RESET          = $8057 = 32855          basicV2.asm:61
RESET_WARM     = $0DAE =  3502          Monitor.asm:28
RESTNL         = $682A = 26666          basicV2.asm:1243
RESTOR         = $6815 = 26645          basicV2.asm:1232
RESZER         = $7474 = 29812          basicV2.asm:3089
RETADR         = $6F17 = 28439          basicV2.asm:2228
RETINT         = $766B = 30315          basicV2.asm:3424
RETLIN         = $6996 = 27030          basicV2.asm:1455
RETNAD         = $658D = 25997          basicV2.asm:860
RETNUL         = $6F1A = 28442          basicV2.asm:2232
RETNUM         = $6D5D = 27997          basicV2.asm:1954
RETREL         = $765D = 30301          basicV2.asm:3414
RETURN         = $6977 = 26999          basicV2.asm:1439
RG             = $0004 =     4          basicV2.asm:104
RIGHT          = $731D = 29469          basicV2.asm:2880
RIGHT1         = $72F1 = 29425          basicV2.asm:2849
RINPUT         = $804E = 32846          basicV2.asm:58
RLTLP          = $6CA0 = 27808          basicV2.asm:1856
RND            = $79CC = 31180          basicV2.asm:3951
RND1           = $7A08 = 31240          basicV2.asm:3982
RND2           = $7A24 = 31268          basicV2.asm:4000
RNDTAB         = $7A35 = 31285          basicV2.asm:4011
RNGTST         = $78C3 = 30915          basicV2.asm:3820
RONDB          = $7495 = 29845          basicV2.asm:3113
RONDUP         = $7494 = 29844          basicV2.asm:3112
ROUND          = $73FC = 29692          basicV2.asm:3014
RSCALE         = $77CF = 30671          basicV2.asm:3673
RSLNBK         = $6743 = 26435          basicV2.asm:1107
RST00          = $0000 =     0          bootV2.asm:161 (unused)
RST08          = $0008 =     8          bootV2.asm:165 (unused)
RST10          = $0010 =    16          bootV2.asm:168 (unused)
RST18          = $0018 =    24          bootV2.asm:171 (unused)
RST20          = $001B =    27          bootV2.asm:173 (unused)
RST28          = $0021 =    33          bootV2.asm:176 (unused)
RST30          = $0030 =    48          bootV2.asm:180 (unused)
RST38          = $0033 =    51          bootV2.asm:182 (unused)
RST66          = $003A =    58          bootV2.asm:185 (unused)
RSTSTR         = $7340 = 29504          basicV2.asm:2900
RUN            = $693C = 26940          basicV2.asm:1406
RUNCNT         = $67C5 = 26565          basicV2.asm:1181
RUNFST         = $64C5 = 25797          basicV2.asm:751
RUNLIN         = $6958 = 26968          basicV2.asm:1422
RXDAT1         = $0D4E =  3406          SoftSerial.asm:134
RXDAT2         = $0D66 =  3430          SoftSerial.asm:151
RXDATA         = $0D4C =  3404          SoftSerial.asm:129
SAVEXP         = $7475 = 29813          basicV2.asm:3090
SAVSTP         = $67B8 = 26552          basicV2.asm:1170
SAVSTR         = $70E5 = 28901          basicV2.asm:2517
SBSCPT         = $6F25 = 28453          basicV2.asm:2238
SCALE          = $74D3 = 29907          basicV2.asm:3167
SCALLP         = $74D5 = 29909          basicV2.asm:3168
SCALMI         = $779A = 30618          basicV2.asm:3635
SCALPL         = $77B0 = 30640          basicV2.asm:3649
SCNEND         = $721C = 29212          basicV2.asm:2707
SCPTLP         = $6F2B = 28459          basicV2.asm:2242
SDBUFFERMSG1   = $0650 =  1616          LCDGraphic.asm:823
SDBUFFERMSG2   = $065B =  1627          LCDGraphic.asm:829
SDLCDMSG1      = $063C =  1596          LCDGraphic.asm:797
SDLCDMSG2      = $0647 =  1607          LCDGraphic.asm:803
SDMSG1         = $0D09 =  3337          SoftSerial.asm:55
SDMSG2         = $0D14 =  3348          SoftSerial.asm:61
SEARCH         = $6555 = 25941          basicV2.asm:822
SEED           = $8017 = 32791          basicV2.asm:44
SERIAL_RX_PORT = $00C0 =   192          bootV2.asm:92
SERIAL_TX_PORT = $00C0 =   192          bootV2.asm:93
SETIO          = $73C0 = 29632          basicV2.asm:2982
SETLIN         = $6717 = 26391          basicV2.asm:1083
SETLIT         = $659F = 26015          basicV2.asm:872
SETPTR         = $647C = 25724          basicV2.asm:693
SETTOP         = $606C = 24684          basicV2.asm:186
SFTPRG         = $6446 = 25670          basicV2.asm:656
SGN            = $7663 = 30307          basicV2.asm:3421
SGNEXP         = $6DAB = 28075          basicV2.asm:2002
SGNRES         = $80E8 = 33000          basicV2.asm:94
SHIFTKEYMAP    = $0098 =   152          bootV2.asm:196
SHOWHELP       = $11A0 =  4512          Monitor.asm:822
SHOW_MSG_EXE   = $0F0C =  3852          Monitor.asm:291
SHOW_MSG_IMG   = $0F13 =  3859          Monitor.asm:296
SHOW_MSG_TXT   = $0F1A =  3866          Monitor.asm:301
SHRITE         = $74E2 = 29922          basicV2.asm:3176
SHRLP          = $74E5 = 29925          basicV2.asm:3178
SHRT1          = $74E9 = 29929          basicV2.asm:3182
SIGNON         = $60BC = 24764          basicV2.asm:219
SIGNS          = $76BA = 30394          basicV2.asm:3481
SIN            = $7A47 = 31303          basicV2.asm:4017
SIN1           = $7A77 = 31351          basicV2.asm:4037
SINTAB         = $7A93 = 31379          basicV2.asm:4050
SIXDIG         = $7816 = 30742          basicV2.asm:3713
SMPVAR         = $71B0 = 29104          basicV2.asm:2635
SMSER1         = $79AB = 31147          basicV2.asm:3929
SN             = $0002 =     2          basicV2.asm:103
SNDBUFFERMSG   = $064E =  1614          LCDGraphic.asm:821 (unused)
SNDLCDMSG      = $063A =  1594          LCDGraphic.asm:795
SNDMSG         = $0D07 =  3335          SoftSerial.asm:54
SNERR          = $63AD = 25517          basicV2.asm:577
SPCBUF         = $0FBA =  4026          Monitor.asm:424
SPCFST         = $7807 = 30727          basicV2.asm:3705
SPCLP          = $6AFC = 27388          basicV2.asm:1645
SQR            = $78ED = 30957          basicV2.asm:3841
SRCHLN         = $6499 = 25753          basicV2.asm:715
SRCHLP         = $649C = 25756          basicV2.asm:716
SSTSA          = $7278 = 29304          basicV2.asm:2767
ST             = $001E =    30          basicV2.asm:117
STACK          = $8066 = 32870          basicV2.asm:66
STAKFP         = $7685 = 30341          basicV2.asm:3441
STALL          = $683E = 26686          basicV2.asm:1260
STARTB         = $6006 = 24582          basicV2.asm:128
START_BASIC    = $0E24 =  3620          Monitor.asm:112
START_BASIC_KEY = $0E2F =  3631          Monitor.asm:118
START_MONITOR  = $0D86 =  3462          Monitor.asm:4
STKTHS         = $6CE4 = 27876          basicV2.asm:1897
STLOOK         = $815D = 33117          basicV2.asm:98
STOP           = $684D = 26701          basicV2.asm:1271
STORED         = $6919 = 26905          basicV2.asm:1386
STPOOL         = $71F3 = 29171          basicV2.asm:2672
STR            = $70D5 = 28885          basicV2.asm:2510
STR1           = $70DB = 28891          basicV2.asm:2512
STRADD         = $71F6 = 29174          basicV2.asm:2674
STRBOT         = $80C3 = 32963          basicV2.asm:75
STRENT         = $6BB4 = 27572          basicV2.asm:1734
STRSPC         = $805A = 32858          basicV2.asm:62
STTLIN         = $6AA0 = 27296          basicV2.asm:1596
SUBCDE         = $740B = 29707          basicV2.asm:3022
SUBPHL         = $7405 = 29701          basicV2.asm:3018
SUMLP          = $79B4 = 31156          basicV2.asm:3934
SUMSER         = $799C = 31132          basicV2.asm:3922
SUPTLZ         = $7895 = 30869          basicV2.asm:3790
SVNAM2         = $6E84 = 28292          basicV2.asm:2147
SVSTAD         = $7103 = 28931          basicV2.asm:2538
SYSTEM         = $FFF0 = 65520          bootV2.asm:98
ShowBufferDisplay = $01D3 =   467          API.asm:155
SpaceOut       = $12DA =  4826          Utils.asm:32
StrOut         = $12E3 =  4835          Utils.asm:49
SysReset       = $0180 =   384          API.asm:89
TABLE          = $06B3 =  1715          LCDGraphic.asm:922
TAN            = $7AA8 = 31400          basicV2.asm:4057
TESTOS         = $7182 = 29058          basicV2.asm:2614
TESTR          = $7164 = 29028          basicV2.asm:2594
TIMEOUT        = $2710 = 10000          bootV2.asm:104
TM             = $0018 =    24          basicV2.asm:114
TMERR          = $63BF = 25535          basicV2.asm:589
TMPSTR         = $80BF = 32959          basicV2.asm:74
TMSTPL         = $80B3 = 32947          basicV2.asm:73
TMSTPT         = $80B1 = 32945          basicV2.asm:72
TOPOOL         = $72E9 = 29417          basicV2.asm:2844
TOSTRA         = $7281 = 29313          basicV2.asm:2776
TRANSKEY       = $0298 =   664          Keyboard.asm:132 (unused)
TRYAGN         = $7870 = 30832          basicV2.asm:3763
TSALP          = $7282 = 29314          basicV2.asm:2777
TSTBIT         = $7C56 = 31830          basicV2.asm:4327 (unused)
TSTBRK         = $6830 = 26672          basicV2.asm:1249
TSTMEM         = $605A = 24666          basicV2.asm:174
TSTNUM         = $6C75 = 27765          basicV2.asm:1832
TSTOPL         = $712B = 28971          basicV2.asm:2566
TSTRED         = $6DE3 = 28131          basicV2.asm:2045
TSTREM         = $65A2 = 26018          basicV2.asm:873
TSTSGN         = $7654 = 30292          basicV2.asm:3409
TSTSTR         = $6C76 = 27766          basicV2.asm:1833
TTYLIN         = $65F2 = 26098          basicV2.asm:920
TXCRLF         = $0347 =   839          LCDGraphic.asm:118
TXDATA         = $0D21 =  3361          SoftSerial.asm:86
TYPE           = $80AD = 32941          basicV2.asm:69
UF             = $0022 =    34          basicV2.asm:119
UFERR          = $63B9 = 25529          basicV2.asm:585
UL             = $000E =    14          basicV2.asm:109
ULERR          = $6972 = 26994          basicV2.asm:1436
UNITY          = $74F7 = 29943          basicV2.asm:3195
UPDATA         = $682B = 26667          basicV2.asm:1244
USR            = $8003 = 32771          basicV2.asm:36
VAL            = $7357 = 29527          basicV2.asm:2919
VAL1           = $7375 = 29557          basicV2.asm:2939
VAL2           = $737F = 29567          basicV2.asm:2943
VAL3           = $7382 = 29570          basicV2.asm:2944
VAREND         = $80D8 = 32984          basicV2.asm:87
VT             = $000B =    11          bootV2.asm:37 (unused)
WAIT           = $73A2 = 29602          basicV2.asm:2966
WAITLP         = $73B7 = 29623          basicV2.asm:2976
WARM           = $6003 = 24579          basicV2.asm:127 (unused)
WARMST         = $60A4 = 24740          basicV2.asm:213
WELLCOME       = $1320 =  4896          Strings.asm:1
WIDTH          = $7B11 = 31505          basicV2.asm:4105
WORDS          = $6136 = 24886          basicV2.asm:258
WORDTB         = $6255 = 25173          basicV2.asm:347
WRDASC         = $1222 =  4642          Monitor.asm:916
WRDOUT         = $1216 =  4630          Monitor.asm:895
WRKSPC         = $8000 = 32768          basicV2.asm:35
ZDATA          = $0083 =   131          basicV2.asm:389
ZDIV           = $00AF =   175          basicV2.asm:407 (unused)
ZEND           = $0080 =   128          basicV2.asm:387
ZEQUAL         = $00B4 =   180          basicV2.asm:410
ZERARY         = $6FC6 = 28614          basicV2.asm:2341
ZERBYT         = $6349 = 25417          basicV2.asm:514
ZEROLP         = $6F09 = 28425          basicV2.asm:2219
ZEROSUP        = $7BE9 = 31721          basicV2.asm:4246
ZFN            = $00A7 =   167          basicV2.asm:398
ZFOR           = $0081 =   129          basicV2.asm:388
ZGOSUB         = $008C =   140          basicV2.asm:391
ZGOTO          = $0088 =   136          basicV2.asm:390
ZGTR           = $00B3 =   179          basicV2.asm:409
ZLEFT          = $00CF =   207          basicV2.asm:414
ZLTH           = $00B5 =   181          basicV2.asm:411
ZMINUS         = $00AD =   173          basicV2.asm:405
ZNEW           = $00A4 =   164          basicV2.asm:394
ZNOT           = $00AA =   170          basicV2.asm:401
ZONELP         = $6AD7 = 27351          basicV2.asm:1624
ZOR            = $00B2 =   178          basicV2.asm:408
ZPLUS          = $00AC =   172          basicV2.asm:404
ZPOINT         = $00C7 =   199          basicV2.asm:413 (unused)
ZPRINT         = $009E =   158          basicV2.asm:393
ZREM           = $008E =   142          basicV2.asm:392
ZSGN           = $00B6 =   182          basicV2.asm:412
ZSPC           = $00A8 =   168          basicV2.asm:399
ZSTEP          = $00AB =   171          basicV2.asm:402
ZTAB           = $00A5 =   165          basicV2.asm:396
ZTHEN          = $00A9 =   169          basicV2.asm:400
ZTIMES         = $00AE =   174          basicV2.asm:406 (unused)
ZTO            = $00A6 =   166          basicV2.asm:397
_end           = $7C63 = 31843          bootV2.asm:160 (unused)
_loop          = $1314 =  4884          Utils.asm:115
_overflow      = $131B =  4891          Utils.asm:121
_size          = $7C63 = 31843          bootV2.asm:160 (unused)
_skip          = $131D =  4893          Utils.asm:124
_z80_          = $0001 =     1          bootV2.asm:1 (unused)
ajustX         = $03F6 =  1014          LCDGraphic.asm:263
ajustXOK       = $03F9 =  1017          LCDGraphic.asm:265
clear8x8_Y     = $0674 =  1652          LCDGraphic.asm:854
clear8x8_Y_OK  = $0677 =  1655          LCDGraphic.asm:858
clear8x8_loop  = $067C =  1660          LCDGraphic.asm:862
cls_GRAPHIC    = $05BD =  1469          LCDGraphic.asm:621
cls_TXT        = $05B2 =  1458          LCDGraphic.asm:609
delay          = $04CA =  1226          LCDGraphic.asm:413
delayLCD       = $0616 =  1558          LCDGraphic.asm:743
delayLCDclear  = $0624 =  1572          LCDGraphic.asm:759
delay_loop     = $04CF =  1231          LCDGraphic.asm:418
delay_loop_b   = $04CD =  1229          LCDGraphic.asm:416
enable_grafic  = $0560 =  1376          LCDGraphic.asm:543
incXOK         = $04C2 =  1218          LCDGraphic.asm:394
incYOK         = $04BC =  1212          LCDGraphic.asm:390
kAPILast       = $0015 =    21          API.asm:82
kCPUClock      = $0900 =4000000          bootV2.asm:67
kDelayCnt      = $0098 =   152          bootV2.asm:72
kDelayLP       = $001A =    26          bootV2.asm:69
kDelayOH       = $0024 =    36          bootV2.asm:68
kDelayTA       = $0FA0 =  4000          bootV2.asm:70
kDelayTB       = $0F7C =  3964          bootV2.asm:71
lcd_asciiz_char_loop = $0603 =  1539          LCDGraphic.asm:720
lcd_asciiz_done = $0613 =  1555          LCDGraphic.asm:735
lcd_asciiz_wait_loop = $0605 =  1541          LCDGraphic.asm:723 (unused)
lcd_clear      = $054E =  1358          LCDGraphic.asm:513
lcd_clearPixel = $0512 =  1298          LCDGraphic.asm:470
lcd_clearPixel_bit = $053A =  1338          LCDGraphic.asm:490
lcd_clearPixel_fim = $0543 =  1347          LCDGraphic.asm:496
lcd_send_asciiz = $0601 =  1537          LCDGraphic.asm:717 (unused)
lcd_send_command = $05E3 =  1507          LCDGraphic.asm:667
lcd_send_command_clear = $05ED =  1517          LCDGraphic.asm:683
lcd_send_data  = $05F7 =  1527          LCDGraphic.asm:698
lcd_setPixel   = $04D9 =  1241          LCDGraphic.asm:430
lcd_setPixel_bit = $0501 =  1281          LCDGraphic.asm:451
lcd_setPixel_fim = $050A =  1290          LCDGraphic.asm:457
multY          = $040E =  1038          LCDGraphic.asm:279
multYfim       = $0417 =  1047          LCDGraphic.asm:286
multYfimok     = $041D =  1053          LCDGraphic.asm:290
multiplication = $1304 =  4868          Utils.asm:92
multiplicationLOOP = $130D =  4877          Utils.asm:99
print8x8_Y     = $069F =  1695          LCDGraphic.asm:894
print8x8_Y_OK  = $06A2 =  1698          LCDGraphic.asm:898
print8x8_loop  = $06A7 =  1703          LCDGraphic.asm:903
print_char_fim = $04C5 =  1221          LCDGraphic.asm:397
print_image    = $0579 =  1401          LCDGraphic.asm:559
print_lcd      = $03D7 =   983          LCDGraphic.asm:239
printchar_loopH = $042D =  1069          LCDGraphic.asm:302
printchar_loopW = $0439 =  1081          LCDGraphic.asm:309
printchar_loopWC = $044C =  1100          LCDGraphic.asm:318
printchar_loopWE = $0452 =  1106          LCDGraphic.asm:322
ver_delete     = $0388 =   904          LCDGraphic.asm:175 (unused)
ver_enter      = $03A0 =   928          LCDGraphic.asm:190
ver_enter_incYOK = $03B8 =   952          LCDGraphic.asm:210
ver_limpa      = $03BE =   958          LCDGraphic.asm:215
ver_line       = $03D0 =   976          LCDGraphic.asm:230


total time: 0.0467 sec.
no errors
