; --------------------------------------
; zasm: assemble "bootV2.asm"
; date: 2023-07-10 15:03:18
; --------------------------------------


; Diego Cruz - Nov 2022
; 
; bootV2: 
;         - CPU Z80@4Mhz
;         - Lcd Grafico 128x64
;         - Keyboard 40 keys + Shift
;         - Rom 32k 0000h - 7FFFh
;         - Ram 32k 8000h - FFFFh
;         
;
;         - Ports:
;               - Keyboard: 40H
;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
;               - User IN/OUT: C0H
;               - Leds: 00H (Red B0-B3, Green B4-B7)
;
;
;         Compiler: https://k1.spdns.de/Develop/Projects/zasm/Distributions/
;         Command line: 
;
;
; -----------------------------------------------------------------------------
; PORTS
; -----------------------------------------------------------------------------
LCDCTRL	    .EQU    70H
LCDDATA     .EQU    71H
KEY_IN      .EQU    40H
KEY_OUT     .EQU    40H

; -----------------------------------------------------------------------------
; CONTROL KEYS
; -----------------------------------------------------------------------------
CTRLC       .EQU    03H             ; Control "C"
CTRLG       .EQU    07H             ; Control "G"
BKSP        .EQU    08H             ; Back space
LF          .EQU    0AH             ; Line feed
VT          .equ    0BH             ; 
CS          .EQU    0CH             ; Clear screen
CR          .EQU    0DH             ; Carriage return [Enter]
CTRLO       .EQU    0FH             ; Control "O"
CTRLQ	    .EQU	11H		        ; Control "Q"
CTRLR       .EQU    12H             ; Control "R"
CTRLS       .EQU    13H             ; Control "S"
CTRLU       .EQU    15H             ; Control "U"
ESC         .EQU    1BH             ; Escape
DEL         .EQU    7FH             ; Delete

; -----------------------------------------------------------------------------
; KEYS MAP
; -----------------------------------------------------------------------------
KLEFT       .EQU    $B4             ; Key Left
KRIGHT      .EQU    $B7             ; Key Right
KUP         .EQU    $B5             ; Key Up
KDOWN       .EQU    $B6             ; Key Down
KF1         .EQU    $80             ; Key F1
KF2         .EQU    $81             ; Key F2
KF3         .EQU    $82             ; Key F3
KF4         .EQU    $83             ; Key F4
KF5         .EQU    $84             ; Key F5 (SHIFT)
KF6         .EQU    $85             ; Key F6 (SHIFT)
KF7         .EQU    $86             ; Key F7 (SHIFT)
KF8         .EQU    $87             ; Key F8 (SHIFT)

; -----------------------------------------------------------------------------
; H_Delay CONFIG
; -----------------------------------------------------------------------------
kCPUClock:  .EQU 4000000       ;CPU clock speed in Hz
kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop

; -----------------------------------------------------------------------------
; MS BASIC ENTRY POINT
; -----------------------------------------------------------------------------
BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H

; -----------------------------------------------------------------------------
; SOFTWARE SERIAL
; -----------------------------------------------------------------------------
;
; BAUD RATE CONSTANTS
;
B300:	.EQU	0220H	;300 BAUD
B1200:	.EQU	0080H	;1200 BAUD
B2400:	.EQU	003FH	;2400 BAUD
B4800:	.EQU	001BH	;4800 BAUD
B9600:	.EQU	000BH	;9600 BAUD

SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6

; -----------------------------------------------------------------------------
; SYSTEM SETTINGS
; -----------------------------------------------------------------------------
SYSTEM:	.EQU 	$FFF0	;INITIAL STACK POINTER

; -----------------------------------------------------------------------------
; I2C SETTINGS
; -----------------------------------------------------------------------------
I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
TIMEOUT:    .EQU 10000          ;Timeout loop counter

; -----------------------------------------------------------------------------
; LCD CONSTANTS
; -----------------------------------------------------------------------------
    ; LCD TEXT MODE
LCD_LINE1   .EQU    80H
LCD_LINE2   .EQU    90H
LCD_LINE3   .EQU    88H
LCD_LINE4   .EQU    98H

; -----------------------------------------------------------------------------
; MEMORY MAP
; -----------------------------------------------------------------------------
; $0000 - 7FFF ROM (Monitor)
; $8000 - EFFF USER RAM
; $F000 - FFFF SYSTEM MONITOR

DISPLAY             .EQU    $F000   ; 1024 bytes - Display buffer
MSGBUF:             .EQU    $F401   ; 32 bytes - STRING HANDLING AREA
DATA:               .EQU    $F420   ; 1 byte - THE DATA
I2C_RAMCPY:         .EQU    $F421   ; 1 byte - RAM copy of output port
I2C_ADDR            .EQU    $F422   ; 1 byte - device address
I2C_RR              .EQU    $F423   ; 1 byte - register
I2C_DD              .EQU    $F424   ; 1 byte - data
ADDR:               .EQU    $F425   ; 2 bytes - THE ADDRESS
ADDR_FROM           .EQU    $F427   ; 2 bytes - THE ADDRESS FROM
ADDR_TO             .EQU    $F429   ; 2 bytes - THE ADDRESS TO
ADDR_SIZE           .EQU    $F42B   ; 2 bytes - THE ADDRESS SIZE
PORT_SET            .EQU    $F42D   ; 1 byte - Define port (input/output) Default 0xC0(onboard)
PORT_OUT_VAL        .EQU    $F42E   ; 1 byte - save value out port
LCD_DATA            .EQU    $F42F   ; 1 byte
BAUD:	            .EQU    $F430   ;2 bytes - BAUD RATE
PUTCH:              .EQU    $F432   ;2 bytes - OUTPUT A CHARACTER TO SERIAL
GETCH:              .EQU    $F434   ;2 bytes - WAIT FOR A CHARACTER FROM SERIAL
LCD_CHAR            .EQU    $F435   ; 1 byte char ex: 'A'
LCD_CHAR_POINT      .EQU    $F436   ; 2 bytes ponteiro para o mapa de caracteres
LCD_TXT_X           .EQU    $F438   ; 1 byte  0-20 (21 col)
LCD_TXT_Y           .EQU    $F439   ; 1 byte  0-7  (8 row)
LCD_BYTE_INDEX      .EQU    $F43A   ; 2 bytes pointer pixel(8)
LCD_BIT_INDEX       .EQU    $F43C   ; 1 byte pointer pixel(1)
LCD_TXT_X_TMP       .EQU    $F43D   ; 2 bytes = LCD_TXT_X * 6
LCD_TXT_Y_TMP       .EQU    $F43F   ; 2 bytes = LCD_TXT_Y * 128
LCD_CHAR_H          .EQU    $F441   ; 1 byte altura do char
LCD_CHAR_W          .EQU    $F442   ; 1 byte largura do char
LCD_TMP_POINT       .EQU    $F443   ; 2 bytes ponteiro do pixel altural do print
LCD_DELETE_CHAR     .EQU    $F445   ; 1 byte, 0 n√£o, ff delete proximo char
LCD_AUTO_X          .EQU    $F446   ; 1 byte, 0 sim, ff nao
LCD_TEMP            .EQU    $F447 ; 1 byte
LCD_COOX            .EQU    $F448 ; 1 byte, local onde vai printar
LCD_COOY            .EQU    $F449 ; 1 byte
LCD_PRINT_H         .EQU    $F44A ; 1 byte, tamanho do que vai printar
LCD_PRINT_W         .EQU    $F44B ; 1 byte
LCD_PRINT_IMAGE     .EQU    $F44C ; 2 bytes


        .ORG 0
RST00	DI
        JP  START_MONITOR
						
        .ORG     0008H
RST08   JP  PRINTCHAR

        .ORG 0010H
RST10   JP KEYREADINIT

        .ORG 0018H ; check break
RST18   JP CHKKEY

        .ORG 0030H
RST30   JP APIHandler


#include "Keyboard.asm"
KEYMAP:
.BYTE   "12345",KF1,"67890"
.BYTE   KF2,"QWERT",KF3,"YUIOP"
.BYTE   KF4,"ASDFG",KLEFT,"HJKL", CR
.BYTE   KDOWN,CTRLC, "ZXCV",KRIGHT,"BNM ", DEL, KUP

SHIFTKEYMAP:
.BYTE   "!@#$%",KF5,"^&*()"
.BYTE   KF6,"`~-_=",KF7,"+;:'" 
.BYTE   22h
.BYTE   KF8,"{}[]|",KLEFT,$5C,"<>?", CR
.BYTE   KDOWN,ESC,"/,. ",KRIGHT,"    ", DEL, KUP


;-----------------------------
; GET A BYTE FROM KEYBOARD
;-----------------------------
GETCHR: CALL KEYREADINIT ; read key
       CP    ESC
       JR    Z,GETOUT
       CP    CTRLC  ; key BK (reset)
       JP    Z, RESET_WARM
       LD    B,A                ;SAVE TO ECHO      
       CALL  ASC2HEX
       JR    NC,GETCHR          ;REJECT NON HEX CHARS    
       LD    HL, DATA
       LD    (HL), A 
       LD    A,B         
       CALL  PRINTCHAR             ;ECHO VALID HEX
       
GETNYB: CALL  KEYREADINIT
       CP    ESC
       JR    Z,GETOUT
       CP    CTRLC  ; key BK (reset)
       JP    Z, RESET_WARM
       LD    B,A               ;SAVE TO ECHO
       CALL  ASC2HEX
       JR    NC,GETNYB         ;REJECT NON HEX CHARS
       RLD
       LD    A,B
       CALL  PRINTCHAR             ;ECHO VALID HEX
       LD    A,(HL)
       CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
       CCF                    ;AND THEN COMPLEMENTING IT
       RET   
GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
       RET
    

;----------------------------------------
; CONVERT ASCII CHARACTER INTO HEX NYBBLE
;----------------------------------------
; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
; ENTRY OTHER THAN HEXADECIMAL KEYS
;
;CONVERTS ASCII 0-9,A-F INTO HEX LSN
;ENTRY : A= ASCII 0-9,A-F
;EXIT  : CARRY =  1
;          A= HEX 0-F IN LSN    
;      : CARRY = 0
;          A= OUT OF RANGE CHARACTER & 7FH
; A AND F REGISTERS MODIFIED
;
ASC2HEX: AND   7FH        ;STRIP OUT PARITY
       CP    30H
       JR    C,AC2HEX3    ;LESS THAN 0
       CP    3AH
       JR    NC,AC2HEX2   ;MORE THAN 9
AC2HEX1: SCF               ;SET THE CARRY - IS HEX
       RET
;     
AC2HEX2: CP    41H
       JR    C,AC2HEX3    ;LESS THAN A
       CP    47H
       JR    NC,AC2HEX3   ;MORE THAN F
       SUB   07H        ;CONVERT TO NYBBLE
       JR    AC2HEX1  
AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
       RET


; -----------------------------------------------------------------------------
;   Check break key (Basic)
; -----------------------------------------------------------------------------
CHKKEY: LD  A, $40
	OUT (KEY_OUT), A ; line 4
	IN  A, (KEY_IN)
	CP  1
	JP  NZ, GRET
	LD  A, CTRLC
	CP	0
	RET
GRET:
	LD  A, 0
	CP 0
	RET



; -----------------------------------------------------------------------------
;   KEYREAD - KEY In A
; -----------------------------------------------------------------------------
KEYREADINIT:
    PUSH    BC
	PUSH	DE
	PUSH    HL
	LD      E, 0                    ; E will be the last pressed key
READKEY:        
    LD      H, 1                    ; H is the line register, start with second
	LD      B, 0                    ; Count lines for later multiplication	
	LD      D, 0                    ; DE will be the adress for mask
						
NEXTKEY:        
    LD      A, H						
    CP      0                       ; All lines tried? 
    JP      Z, KEYOUT               ; Then check if there was a key pressed
	OUT     (KEY_OUT), A		    ; Put current line to register
	IN      A, (KEY_IN)		        ; Input Keys
	AND     $3F                     ; only 6 bits
	SLA     H                       ; Next line
    INC     B
    CP      0                       ; Was key zero?
    JP      Z, NEXTKEY              ; Then try again with next lines
    LD      D, 0                    ; In D will be the number of the key
LOGARITHM:      
    INC     D	                    ; Add one per shift
    SRL     A                       ; Shift key right
    JP      NZ, LOGARITHM		    ; If not zero shift again
    DEC     D                       ; Was too much
	IN      A, (KEY_IN)
    AND     $80                     ; Check if first bit set (shift key pressed)
    JP      NZ, LOADSHIFT		    ; Then jump to read with shift
    LD      A, D                    ; Put read key into accu
    ADD     A, KEYMAP               ; Add base of key map array
    JP      ADDOFFSET               ; Jump to load key
LOADSHIFT:
    LD      A, D
    ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
ADDOFFSET:
    ADD     A, 6                    ; Add 6 for every line
    DJNZ    ADDOFFSET               ; Jump back (do while loop)
	SUB     6                       ; Since do while is one too much
TRANSKEY:
    XOR     B                       ; Empty B
	LD      C, A                    ; A will be address in BC
	LD      A, (BC)	                ; Load key
	CP      E                       ; Same key?
	JP      Z, READKEY              ; Then from beginning
	LD      E, A                    ; Otherwise save new key
	JP      READKEY	                ; And restart
KEYOUT:
    LD      A, E
    LD      E, 0                    ; empty it
    OR      A	                    ; Was a key read?
    JP      Z, READKEY              ; If not restart
    POP     HL
    POP     DE
    POP     BC
    RET
#include "LCDGraphic.asm"
; -----------------------------------------------------------------------------
;   LCD DRIVER
; -----------------------------------------------------------------------------
; INIT_LCD - Inicia o lcd em mode texto
; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
; lcd_clear - Limpa buffer do lcd
; enable_grafic - Coloca o LCD em modo grafico
; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
; cls_TXT - Limpa LCD mode text
; cls_GRAPHIC - Limpa LCD modo grafico

INIT_LCD:
    ;Initialisation
	ld a, 30H
	call lcd_send_command

	ld a, 0b00100000
	call lcd_send_command

	ld a, 30H
	call lcd_send_command

	ld a, 0CH
	call lcd_send_command

	ld a, 01H
	call lcd_send_command_clear ;; clear

	ld a, 02H
	call lcd_send_command
    RET



INIT_TXT_LCD:
    ld a, 0
    ld (LCD_TXT_X), a
    ld (LCD_TXT_Y), a
    ld (LCD_DELETE_CHAR), a
    ld (LCD_AUTO_X), a
    ld hl, 0
    ld (LCD_TXT_X_TMP), hl
    inc hl
    ld (LCD_TXT_Y_TMP), hl
    RET


DISPLAY_SCROLL_UP:
    ; cada linha tem 128 bytes
    ; temos 8 linhas
    ; total 1024 bytes

    ; display lines 0 to 7
    ; move line 1 to 0
    ld hl, DISPLAY+128
    ld de, DISPLAY
    ld bc, 127
    ldir

    ; move line 2 to 1
    ld hl, DISPLAY+256
    ld de, DISPLAY+128
    ld bc, 127
    ldir

    ; move line 3 to 2
    ld hl, DISPLAY+384
    ld de, DISPLAY+256
    ld bc, 127
    ldir

    ; move line 4 to 3
    ld hl, DISPLAY+512
    ld de, DISPLAY+384
    ld bc, 127
    ldir

    ; move line 5 to 4
    ld hl, DISPLAY+640
    ld de, DISPLAY+512
    ld bc, 127
    ldir

    ; move line 6 to 5
    ld hl, DISPLAY+768
    ld de, DISPLAY+640
    ld bc, 127
    ldir

    ; move line 7 to 6
    ld hl, DISPLAY+896
    ld de, DISPLAY+768
    ld bc, 127
    ldir

    ; clear line 7
    ; 896 to 1024
    ld hl, DISPLAY+896
    ld e,l
    ld d,h
    inc de
    ld (hl), 0
    ld bc, 127
    ldir
    RET

;---------------
; OUTPUT A SPACE
;---------------
OUTSP:  LD    A, ' '
       CALL  PRINTCHAR
       RET

;-------------      
; OUTPUT CRLF (NEW LINE)
;------------
TXCRLF: LD   A,CR
       CALL PRINTCHAR   
       RET
       

DELETE_CHAR:
    POP HL ; retorno do call
    LD A, 0
    LD (LCD_DELETE_CHAR), A
    LD A, (LCD_TXT_X)
    DEC A
    LD (LCD_TXT_X), A

    LD A, $FF
    LD (LCD_AUTO_X), A

    POP AF
    LD A, ' '
    LD (LCD_CHAR), A
    PUSH AF
    PUSH HL ; call
    RET


; Print char in buffer and show to lcd
; char in A
PRINTCHAR:
    PUSH AF
    PUSH BC
    PUSH DE
    PUSH HL
    CALL PrintBufferChar
    LD HL, DISPLAY
    CALL print_image
    POP HL
    POP DE
    POP BC
    POP AF
    RET


; Print char in buffer lcd (without show to lcd)
; char in A
PrintBufferChar:
    LD (LCD_CHAR), A ; save char to print

    PUSH AF
    PUSH BC
    PUSH DE
    PUSH HL

    PUSH AF
    LD A, $0
    LD (LCD_AUTO_X), A
    POP AF


ver_delete:
    PUSH AF
    LD A, (LCD_DELETE_CHAR)
    or a
    CP $FF
    call z, DELETE_CHAR
    POP AF
    or a
    CP $0
    jr nz, ver_enter
    LD A, $FF ; delete proximo char
    LD (LCD_DELETE_CHAR), A
    jp print_char_fim

    ; Verificar Enter, clear, etc... SEM PERDER O reg. A
ver_enter:       

                ; trata dados para o lcd
                CP      CR                     ; compara com ENTER
                jr      nz, ver_limpa

                LD A,0
                LD (LCD_TXT_X), A ; ajusta X para o inicio da linha

                LD A, (LCD_TXT_Y)
                inc a
                cp 8
                jp nz, ver_enter_incYOK
                
                CALL DISPLAY_SCROLL_UP
                ;ld hl, DISPLAY
                ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                
                jp print_char_fim

ver_enter_incYOK:
                ld (LCD_TXT_Y), a
                jp print_char_fim


ver_limpa:
                CP      $0C                     ; compara com limpar tela
                jr      NZ, ver_line
                
                ;call    clear_lcd_screen
                ;call    show_lcd_screen
                call lcd_clear
                ;ld hl, DISPLAY
                ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                LD A, 0
                LD (LCD_TXT_X), A
                LD (LCD_TXT_Y), A

                JP print_char_fim

ver_line:
                CP      LF                     ; retorna come√ßo da linha
                jr      NZ, print_lcd      

                    ;----- verificar se precisa add algo aqui
                ;call    shift_lcd_up
                ;call    show_lcd_screen
                JP print_char_fim

print_lcd:
    ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
    ld H, 0
    ld L, A
    ADD HL, HL ; hl x 8
    ADD HL, HL
    ADD HL, HL

    LD D, H
    LD E, L
    ld hl, TABLE
    add hl, de
    ld (LCD_CHAR_POINT), HL ; table


    ; ajusta X
    ld b, 6
    ld a, (LCD_TXT_X)
    or A
    jp z, ajustX
    ld c, a
    call multiplication
    jp ajustXOK
    
ajustX:
    ld hl, 0
ajustXOK:
    ld (LCD_TXT_X_TMP), HL 



    ; ajuste Y
    ld d, 4
    ld e, 0 ; = 128x8 proxima linha
    ld hl, (LCD_TXT_Y_TMP)
    ld a, (LCD_TXT_Y)
    or a
    JP Z, multYfim
    ld hl, 0
    ld b, a
multY:
    add hl, de
    DJNZ multY

    ld (LCD_TXT_Y_TMP), HL
    jp multYfimok

multYfim:
    ld hl, 0
    ld (LCD_TXT_Y_TMP), HL

multYfimok:

    ld hl, (LCD_TXT_Y_TMP)
    ld de, (LCD_TXT_X_TMP)

    add hl, de  ; hl tem pos do pix 0-8191

    ld (LCD_TMP_POINT), hl


    ld a, 8 ; altura do caracter
    ld (LCD_CHAR_H), a
printchar_loopH:
    ld hl, (LCD_CHAR_POINT)
    ld a, (HL)
    ld (LCD_TEMP), a

    ld a, 6 ; largura do caracter
    ld (LCD_CHAR_W), a
printchar_loopW:
    ld a, (LCD_TEMP)
    and 128
    cp 0
    jp z, printchar_loopWC
    ld hl, (LCD_TMP_POINT)
    call lcd_setPixel
    JP printchar_loopWE

printchar_loopWC:
    ld hl, (LCD_TMP_POINT)
    call lcd_clearPixel

printchar_loopWE:
    ld a, (LCD_TEMP)
    sla a
    ld (LCD_TEMP), a
    
    ld hl, (LCD_TMP_POINT)
    inc hl
    ld (LCD_TMP_POINT), hl

    ld a, (LCD_CHAR_W)
    dec A
    ld (LCD_CHAR_W), a
    cp 0
    JP NZ, printchar_loopW


    ld hl, (LCD_TMP_POINT)
    dec hl
    dec hl
    dec hl
    dec hl
    dec hl
    dec hl

    ld d, 0
    ld e, 128
    add hl, de
    ld (LCD_TMP_POINT), HL

    ld hl, (LCD_CHAR_POINT)
    inc hl
    ld (LCD_CHAR_POINT), hl


    ld a, (LCD_CHAR_H)
    dec A
    ld (LCD_CHAR_H), a
    cp 0
    jp NZ, printchar_loopH

    ;ld hl, DISPLAY
    ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


    ; check auto x
    LD A, (LCD_AUTO_X)
    OR A
    CP $FF
    JP Z, print_char_fim

    ; increment X, Y
    ld a, (LCD_TXT_X)
    inc a
    cp 21
    jp nz, incXOK
    ld a, 0
    ld (LCD_TXT_X), a
    ld a, (LCD_TXT_Y)
    inc a
    cp 8
    jp nz, incYOK
    CALL DISPLAY_SCROLL_UP
    ;ld hl, DISPLAY
    ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    ld a, 0
    ld (LCD_TXT_X), a
    jp print_char_fim

incYOK:
    ld (LCD_TXT_Y), a
    jp print_char_fim

incXOK:
    ld (LCD_TXT_X), a

print_char_fim:
    ;ld hl, DISPLAY
    ;CALL print_image
    POP HL
    POP DE
    POP BC
    POP AF
    RET
;-------- FIM PRINTCHAR ------------------




; =========================================================
; Delay
; =========================================================
delay:
	push bc                       ; 2.75 us
    ld b, 1                     ; 1.75 us
delay_loop_b:
	ld c, 255                     ; 1.75 us
delay_loop:
	dec c                         ; 1 us
    jp nz, delay_loop             ; true = 3 us, false 1.75 us
    dec b                         ; 1 us
    jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
    pop bc                        ; 2.50 us
    ret   




; pixel index in HL
lcd_setPixel:
    push hl
    push bc
    push de
    push af
    xor A
    ld (LCD_BIT_INDEX), A
    ld (LCD_BYTE_INDEX), A

    ld d, 8
    call Div_HL_D
    ld (LCD_BIT_INDEX), A
    ld (LCD_BYTE_INDEX), HL
    ld BC, (LCD_BYTE_INDEX)
    ld hl, DISPLAY
    add hl, bc
    
    ld b, 128 ; 1000 0000
    ld a, (LCD_BIT_INDEX) ;
    cp 0
    jp z, lcd_setPixel_fim
lcd_setPixel_bit:
    srl B
    dec A
    jp z, lcd_setPixel_fim
    
    jp lcd_setPixel_bit
lcd_setPixel_fim
    ld a, (hl)
    or b
    ld (hl), a

    pop af
    pop bc
    pop de
    pop hl
    ret

;===============================
; pixel index in HL
lcd_clearPixel:
    push hl
    push bc
    push de
    push af
    xor A
    ld (LCD_BIT_INDEX), A
    ld (LCD_BYTE_INDEX), A
    ld d, 8
    call Div_HL_D
    ld (LCD_BIT_INDEX), A
    ld (LCD_BYTE_INDEX), HL
    ld BC, (LCD_BYTE_INDEX)
    ld hl, DISPLAY
    add hl, bc
    
    ld b, 128 ; 1000 0000
    ld a, (LCD_BIT_INDEX) ;
    cp 0
    jp z, lcd_clearPixel_fim
lcd_clearPixel_bit:
    srl B
    dec A
    jp z, lcd_clearPixel_fim
    
    jp lcd_clearPixel_bit
lcd_clearPixel_fim
    ld a, b
    cpl     ; NOT B
    ld b, a

    ld a, (hl)
    and b
    ld (hl), a

    pop af
    pop bc
    pop de
    pop hl
    ret


;;--------------------------------------------------
lcd_clear:
    ;; HL = start address of block
    ld hl, DISPLAY

    ;; DE = HL + 1
    ld e,l
    ld d,h
    inc de

    ;; initialise first byte of block
    ;; with data byte (&00)
    ld (hl), 0
        
    ;; BC = length of block in bytes
    ;; HL+BC-1 = end address of block

    ld bc, 1024

    ;; fill memory
    ldir
    ret


;===================

; grafic mode - enable
enable_grafic:
	ld a, 30H
	call lcd_send_command
	call delayLCD
	
	ld a, 34H
	call lcd_send_command
	call delayLCD
	
	ld a, 36H
	call lcd_send_command
	call delayLCD
    ret


;==========================
print_image:
        PUSH AF
        PUSH BC
        PUSH DE
        PUSH HL
PLOT_TO_LCD:	
        LD HL, DISPLAY
        LD C, 80H
PLOT_ROW:	
        LD A, C
        AND 9FH
        OUT (LCDCTRL), A ;Vertical
        CALL DELAY_US
        LD A, 80H
        BIT 5, C
        JR Z, $ + 4
        OR 08H
        OUT (LCDCTRL), A ;Horizontal
        CALL DELAY_US
        
        LD B, 10H 		;send eight double bytes (16 bytes)
PLOT_COLUMN:	
        LD A, (HL)
        OUT (LCDDATA), A ;Byte 1
        CALL DELAY_US
        INC HL
        DJNZ PLOT_COLUMN
        INC C
        BIT 6, C 		;Is Row = 64?
        JR Z, PLOT_ROW

        POP HL
        POP DE
        POP BC
        POP AF
        RET
        
; Delay for LCD write
DELAY_US:	
        LD DE, $0004 ;DELAY BETWEEN, was 0010H
DELAY_MS:	
        DEC DE 			;EACH BYTE
        LD A, D 		;AS PER
        OR E 			;LCD MANUFACTER'S
        JR NZ, DELAY_MS ;INSTRUCTIONS
        RET

print_image2:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
									; HL content the data address
    push af
	push de
	push bc


; premiere partie : X de 0 √† 127 / Y de 0 √† 32

	ld a,32
	ld d,a							; boucle Y
	ld a,0
	ld e,a
	
boucle_colonne:
		ld a,$80					; coordonn√©e Y (0)
		add a,e
		call lcd_send_command
		
		ld a,$80					; coordonn√©e X (0)		
		call lcd_send_command
		
		ld a,8
		ld b,a						; boucle X
		
boucle_ligne:	
			ld a,(hl)
			call lcd_send_data
			inc hl
			ld a,(hl)
			call lcd_send_data		; auto-increment on screen address
			inc hl
			dec b
			XOR a
			OR b
			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
		
		dec d
		inc e
		XOR a
		OR d
		jp nz,boucle_colonne
		

; seconde partie : X de 128 √† 255 / Y de 0 √† 32

	ld a,32
	ld d,a							; boucle Y
	ld a,0
	ld e,a
	
boucle_colonne2:
		ld a,$80					; coordonn√©e Y (0)
		add a, e
		call lcd_send_command
		
		ld a,$88					; coordonn√©e X (8)		
		call lcd_send_command
		
		ld a,8
		ld b,a						; boucle X
		
boucle_ligne2:	
			ld a,(hl)
			call lcd_send_data
			inc hl
			ld a,(hl)
			call lcd_send_data		; auto-increment on screen address
			inc hl
			dec b
			XOR a
			OR b
			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
		
		dec d
		inc e
		XOR a
		OR d
		jp nz,boucle_colonne2

	pop bc
	pop de
    pop af

    ret



; ======================
cls_TXT:
	; # CLEAR DISPLAY IN TEXT MODE # 
	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
	call lcd_send_command_clear		; CLEAR DISPLAY	
    ret

; ========================

cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
					;	Graphic RAM (GDRAM) use :
					;	1. Set vertical address (Y) for GDRAM
					;	2. Set horizontal address (X) for GDRAM
					;	3. Write D15~D8 to GDRAM (first byte)
					;	4. Write D7~D0 to GDRAM (second byte)
	push bc
	push de

	ld e,$20						; e = 32 
	ld d,$0							; d = 0
Boucle32X:
		ld a,d
		OR $80
		call lcd_send_command
		
		ld a,$80					; Set horizontal addressÔºàXÔºâ for GDRAM = 0 ($80)
		call lcd_send_command
		
		xor a							 	
		ld b,$10							; b = 17
		
Boucle16X:	 
			call lcd_send_data 			; Write D15„ÄúD8 to GDRAM (first byte)
			call lcd_send_data 			; Write D7„ÄúD0 to GDRAM (second byte)
											; Address counter will automatically increase by one for the next two-byte data												
			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
		
		dec e 
		inc d
		xor a							; a = 0
		or e
		jp nz,Boucle32X

	pop de
	pop bc
	
    ret



;******************
;Send a command byte to the LCD
;Entry: A= command byte
;Exit: All preserved
;******************
lcd_send_command:
	push bc				;Preserve
	ld c, LCDCTRL   	;Command port
	
	call delayLCD
	
	out (c),a			;Send command
	pop bc				;Restore
	ret


;******************
;Send a command byte to the LCD
;Entry: A= command byte
;Exit: All preserved
;******************
lcd_send_command_clear:
	push bc				;Preserve
	
	call delayLCDclear
	
    ld c, LCDCTRL   	;Command port
	out (c),a			;Send command
	pop bc				;Restore
	ret
	
;******************
;Send a data byte to the LCD
;Entry: A= data byte
;Exit: All preserved
;******************
lcd_send_data:
	push bc				;Preserve
	
    ;Busy wait
	call delayLCD

	ld c, LCDDATA	;Data port $71
	out (c),a			;Send data
	pop bc				;Restore
	ret




;******************
;Send an asciiz string to the LCD
;Entry: HL=address of string
;Exit: HL=address of ending zero of the string. All others preserved
;******************
lcd_send_asciiz:
	push af
	push bc				;Preserve
lcd_asciiz_char_loop:
	ld c, LCDCTRL   	;Command port
	
lcd_asciiz_wait_loop:	;Busy wait
	call delayLCD
	
	ld a,(hl)			;Get character
	and a				;Is it zero?
	jr z,lcd_asciiz_done	;If so, we're done
	
	ld c, LCDDATA	;Data port
	out (c),a			;Send data
	inc hl				;Next char
	jr lcd_asciiz_char_loop
	
lcd_asciiz_done:
	pop bc				;Restore
	pop af
	ret

; =========================================================
; Delay LCD
; =========================================================
delayLCD:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    ret

delayLCDclear:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    ret

;-----------------------------------------
; SEND AN ASCII STRING OUT LCD
;-----------------------------------------
; 
; SENDS A ZERO TERMINATED STRING OR 
; 128 CHARACTERS MAX. OUT LCD
;
;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
;      EXIT  : NONE
;
;       MODIFIES : A,B,C
;          
SNDLCDMSG:
    LD    B,128         ;128 CHARS MAX
SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
    CP    00H          ;ZERO TERMINATOR?
    JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
    CALL PrintBufferChar         ;TRANSMIT THE CHAR
    INC   HL
    DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
SDLCDMSG2: 
    LD HL, DISPLAY
    CALL print_image
    RET


















TABLE:
.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
.db $00, $00, $00, $00, $00, $00, $00, $00 ; US

; DEC 32
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @

; DEC 65 Maiusculas
.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z

; DEC 91
.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
.db $40, $20, $10, $00, $00, $00, $00, $00 ; `

; DEC 97 "Minusculas"
.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z

; DEC 123
.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
#include "API.asm"
; **********************************************************************
; **  API - Public functions                                          **
; **********************************************************************
; API: Main entry point
;   On entry: C = Function number
;             A, DE = Parameters (as specified by function)
;   On exit:  AF,BC,DE,HL = Return values (as specified by function)
;             IX IY I AF' BC' DE' HL' preserved
; This handler modifies: F, B, HL but preserves A, C, DE
; Other registers depend on API function called
APIHandler: LD   HL,APITable    ;Start of function address table
            LD   B,A            ;Preserve A
            LD   A,C            ;Get function number
            CP   kAPILast+1     ;Supported function?
            RET  NC             ;No, so abort
            LD   A,B            ;Restore A
            LD   B,0
            ADD  HL,BC          ;Calculate table pointer..
            ADD  HL,BC
            LD   B,(HL)         ;Read function address from table..
            INC  HL
            LD   H,(HL)
            LD   L,B
            JP   (HL)           ;Jump to function address


; API: Function address table (function in C)
; This table contains a list of addresses, one for each API function. 
; Each is the address of the subroutine for the relevant function.
APITable:   .DW  SysReset           ; 0x00 = System reset
            .DW  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
            .DW  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
            .DW  OutLcdNewLine      ; 0x03 = Output new line LCD
            .DW  H_Delay            ; 0x04 = Delay in milliseconds
            .DW  PrtSet             ; 0x05 = Set Port (Default C0)
            .DW  PrtOWr             ; 0x06 = Write to output port
            .DW  PrtORd             ; 0x07 = Read from output port
            .DW  PrtIRd             ; 0x08 = Read from input port
            .DW  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
            .DW  DisplayImage128x64 ; 0x0A = Print image (Pointer in DE), 128x64, 1024 bytes
            .DW  ClearDisplayBuffer ; 0x0B = Clear display buffer (A=$00 without show LCD, A > $00 show to LCD)
            .DW  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
            .DW  LcdSetCXY          ; 0x0D = LCD Cursor X (0-20), Y (0-7) value in D(X) E(Y)
            .DW  SysReset           ; 0x0E = Reserved
            .DW  SysReset           ; 0x0F = Reserved
            .DW  I2COpen            ; 0x10 = Start i2c (Device address in A)
            .DW  I2CClose           ; 0x11 = Close i2c 
            .DW  I2CRead            ; 0x12 = I2C Read
            .DW  I2CWrite           ; 0x13 = I2C Write
kAPILast:   .EQU $13                ;Last API function number







SysReset:
    JP START_MONITOR

InputCharKey:
    JP KEYREADINIT

OutLcdChar:
    JP PRINTCHAR

OutLcdNewLine:
    LD A, CR
    JP PRINTCHAR

PrtSet:
    LD (PORT_SET), A ; define a porta padr√£o de entrada e saida
    RET

PrtOWr:
    LD B, A
    LD A, (PORT_SET)
    LD C, A
    LD A, B
    LD (PORT_OUT_VAL), A
    out (C), A
    RET

PrtORd: ; Return value from output port
    LD A, (PORT_OUT_VAL)
    RET

PrtIRd: ; Return value from input
    LD A, (PORT_SET)
    LD C, A
    in A, (C)
    RET

DisplayImage128x64:
    LD H, D
    LD L, E
    JP print_image

ClearDisplayBuffer:
    PUSH AF
    CALL lcd_clear
    POP AF
    OR A
    CP $00
    JP Z, ClearDisplayBufferEnd
    LD HL, DISPLAY
    JP print_image
ClearDisplayBufferEnd:
    RET

ShowBufferDisplay:
    LD HL, DISPLAY
    JP print_image

I2COpen:
    JP I2C_Open

I2CClose:
    JP I2C_Close

I2CRead:
    JP I2C_Read

I2CWrite:
    JP I2C_Write

LcdSetCXY:
    PUSH AF
    LD A, D
    LD (LCD_TXT_X), A

    LD A, E
    LD (LCD_TXT_Y), A
    POP AF
    RET
#include "LoaderIntel.asm"
;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------       
INTHEX: 
       LD HL, MSG_ILOAD
       CALL  SNDLCDMSG

       LD HL, MSG_ILOAD
       CALL  SNDMSG
       

       CALL  INTELH
       JR    NZ,ITHEX1      

       LD    HL,FILEOK
       CALL  SNDLCDMSG   ;GOT FILE OK LCD
       LD    HL,FILEOK
       CALL  SNDMSG      ;GOT FILE OK Serial
       
       RET
ITHEX1: LD    HL,CSUMERR
       CALL  SNDLCDMSG

       LD    HL,CSUMERR
       CALL  SNDMSG      ;CHECKSUM ERROR
       
       RET  





;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------
INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
;
; WAIT FOR RECORD MARK
;
INTEL1:	XOR	A
	LD	(IX+3),A	;CLEAR CHECKSUM
	CALL	RXDATA	;WAIT FOR THE RECORD MARK
	CP	':'	;TO BE TRANSMITTED
	JR	NZ,INTEL1	;NOT RECORD MARK
;
; GET RECORD LENGTH
;
	CALL	GETBYT
	LD	(IX+0),A	;NUMBER OF DATA BYTES
;
; GET ADDRESS FIELD
;
	CALL	GETBYT
	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
	CALL	GETBYT
	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
;
; GET RECORD TYPE
;
	CALL	GETBYT
	JR	NZ,INTEL4	;END OF FILE RECORD
;
; READ IN THE DATA
;
	LD	B,(IX+0)	;NUMBER OF DATA BYTES
	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE

INTEL2:	CALL	GETBYT	;GET DATA BYTE
	LD	(HL),A	;STORE DATA BYTE
	INC	HL
	DJNZ	INTEL2	;LOAD MORE BYTES
;
; GET CHECKSUM AND COMPARE
;
	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE RECORD CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
    RET             ;NZ=CHECKSUM ERROR
;
; END OF FILE RECORD
;
INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE EOF CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	RET  	    ;NZ=CHECKSUM ERROR
;--------------------------
; GET BYTE FROM SERIAL PORT
;--------------------------
GETBYT:	PUSH	BC
	CALL	RXDATA
	BIT	6,A
	JR	Z,GETBT1
	ADD	A,09H
GETBT1:	AND	0FH
	SLA 	A
	SLA	A
	SLA	A
	SLA	A
	LD	C,A
;
; GET LOW NYBBLE
;
	CALL	RXDATA
	BIT	6,A
	JR	Z,GETBT2
	ADD	A,09H
GETBT2:	AND	0FH
	OR	C
	LD	B,A
	ADD	A,(IX+3)
	LD	(IX+3),A	;ADD TO CHECKSUM
	LD	A,B
	AND	A	;CLEAR CARRY
    POP	BC
	RET
#include "I2C.asm"
; **********************************************************************
; I2C support functions

; I2C bus open device
;   On entry: A = Device address (bit zero is read flag)
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             BC DE HL IX IY preserved
I2C_Open:   PUSH AF
            CALL I2C_Start      ;Output start condition
            POP  AF
            JR   I2C_Write      ;Write data byte


; I2C bus close device
;   On entry: SCL = unknown, SDA = unknown
;   On exit:  If successfully A=0 and Z flagged
;             If unsuccessfully A=Error and NZ flagged
;             SCL = hi, SDA = hi
;             BC DE HL IX IY preserved
I2C_Close:  JP   I2C_Stop       ;Output stop condition


; **********************************************************************
; **********************************************************************
; I2C bus master driver
; **********************************************************************
; **********************************************************************

; Functions provided are:
;     I2C_Start
;     I2C_Stop
;     I2C_Read
;     I2C_Write
;
; This code has delays between all I/O operations to ensure it works
; with the slowest I2C devices
;
; I2C transfer sequence
;   +-------+  +---------+  +---------+     +---------+  +-------+
;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
;   +-------+  +---------+  +---------+     +---------+  +-------+
;
;
; Start condition                     Stop condition
; Output by master device             Output by master device
;       ----+                                      +----
; SDA       |                         SDA          |
;           +-------                        -------+
;       -------+                                +-------
; SCL          |                      SCL       |
;              +----                        ----+
;
;
; Address frame
; Clock and data output from master device
; Receiving device outputs acknowledge 
;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
;
;
; Data frame 
; Clock output by master device
; Data output by transmitting device
; Receiving device outputs acknowledge 
;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
;


; **********************************************************************
; I2C constants


; I2C bus master interface
; The default device option is for SC126 or compatible

I2C_PORT:   .EQU $21           ;Host I2C port address
I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value


; I2C support constants
ERR_NONE:   .EQU 0              ;Error = None
ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
ERR_TOUT:   .EQU 3              ;Error = Timeout


; **********************************************************************
; Hardware dependent I2C bus functions


; I2C bus transmit frame (address or data)
;   On entry: A = Data byte, or
;                 Address byte (bit zero is read flag)
;             SCL = low, SDA = low
;   On exit:  If successful A=0 and Z flagged
;                SCL = lo, SDA = lo
;             If unsuccessful A=Error and NZ flagged
;                SCL = high, SDA = high, I2C closed
;             BC DE HL IX IY preserved
I2C_Write:  PUSH BC             ;Preserve registers
            PUSH DE
            LD   D,A            ;Store byte to be written
            LD   B,8            ;8 data bits, bit 7 first
I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
            JR   C,I2C_WriteBit_Hi      ;High, so skip
            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
            JR   I2C_WriteBit_Clk
I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
            DJNZ I2C_WriteWr_Loop
; Test for acknowledge from slave (receiver)
; On arriving here, SCL = lo, SDA = data bit
            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
            CALL I2C_RdPort     ;Read SDA input
            LD   B,A
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
            BIT  I2C_SDA_RD,B
            JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
            POP  DE             ;Restore registers
            POP  BC
            XOR  A              ;Return success A=0 and Z flagged
            RET
; I2C STOP required as no acknowledge
; On arriving here, SCL = lo, SDA = hi
I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
            POP  DE             ;Restore registers
            POP  BC
            LD   A,ERR_NOACK    ;Return error = No Acknowledge
            OR   A              ;  and NZ flagged
            RET


; I2C bus receive frame (data)
;   On entry: A = Acknowledge flag
;               If A != 0 the read is acknowledged
;             SCL low, SDA low
;   On exit:  If successful A = data byte and Z flagged
;               SCL = low, SDA = low
;             If unsuccessul* A = Error and NZ flagged
;               SCL = low, SDA = low
;             BC DE HL IX IY preserved
; *This function always returns successful
I2C_Read:   PUSH BC             ;Preserve registers
            PUSH DE
            LD   E,A            ;Store acknowledge flag
            LD   B,8            ;8 data bits, 7 first
            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
            CALL I2C_RdPort     ;Read SDA input bit
            SCF                 ;Set carry flag
            BIT  I2C_SDA_RD,A   ;SDA input high?
            JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
            CCF                 ;Clear carry flag
I2C_ReadRotate:    RL   D              ;Rotate result into D
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
            DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
; Acknowledge input byte
; On arriving here, SCL = lo, SDA = hi/input
            LD   A,E            ;Get acknowledge flag
            OR   A              ;A = 0? (indicates no acknowledge)
            JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
            LD   A,D            ;Get data byte received
            POP  DE             ;Restore registers
            POP  BC
            CP   A              ;Return success Z flagged
            RET


; I2C bus start
;   On entry: SCL = unknown, SDA = unknown
;   On exit:  SCL = low, SDA = low
;             A = 0 and Z flagged as we always succeed
;             BC DE HL IX IY preserved
; First ensure SDA and SCL are high
I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
; Generate I2C start condition
            CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
            XOR  A              ;Return success A=0 and Z flagged
            RET


; I2C bus stop 
;   On entry: SCL = unknown, SDA = unknown
;   On exit:  SCL = high, SDA = high
;             A = 0 and Z flagged as we always succeed
;             BC DE HL IX IY preserved
; First ensure SDA and SCL are low
I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
; Generate stop condition
            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
            XOR  A              ;Return success A=0 and Z flagged
            RET


; **********************************************************************
; I2C bus simple I/O functions
;   On entry: No parameters required
;   On exit:  BC DE HL IX IY preserved

I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
            JR   I2C_WrPort

I2C_SCL_HI: LD   A,(I2C_RAMCPY)
            SET  I2C_SCL_WR,A
            JR   I2C_WrPort

I2C_SCL_LO: LD   A,(I2C_RAMCPY)
            RES  I2C_SCL_WR,A
            JR   I2C_WrPort

I2C_SDA_HI: LD   A,(I2C_RAMCPY)
            SET  I2C_SDA_WR,A
            JR   I2C_WrPort

I2C_SDA_LO: LD   A,(I2C_RAMCPY)
            RES  I2C_SDA_WR,A

I2C_WrPort: PUSH BC             ;Preserve registers
            LD   B,0            ;Set up BC for 16-bit
            LD   C,I2C_PORT     ;  I/O address of I2C port
            OUT  (C),A          ;Write A to I2C I/O port
            LD   (I2C_RAMCPY),A ;Write A to RAM copy
            POP  BC             ;Restore registers
            RET

I2C_RdPort: PUSH BC             ;Preserve registers
            LD   B,0            ;Set up BC for 16-bit
            LD   C,I2C_PORT     ;  I/O address of I2C port
            IN   A,(C)          ;Read A from I/O port
            POP  BC             ;Restore registers
            RET



;==============================================================================
;==============================================================================
;==============================================================================
;===================       FUNCTIONS    =======================================
;==============================================================================
;==============================================================================




; **********************************************************************
; List devices found on the I2C bus
;
; Test each I2C device address and reports any that acknowledge

I2CLIST:       LD   DE,LISTMsg        ;Address of message string
            CALL StrOut         ;Output string
            LD   D,0            ;First I2C device address to test
LISTLOOP:      PUSH DE             ;Preserve DE
            LD   A,D            ;Get device address to be tested
            CALL LISTTEST          ;Test if device is present
            POP  DE             ;Restore DE
            JR   NZ,LISTNEXT       ;Skip if no acknowledge
            LD   A,D            ;Get address of device tested
            CALL HexOut         ;Output as two character hex 
            CALL SpaceOut       ;Output space character
LISTNEXT:      INC  D              ;Get next write address
            INC  D
            LD   A,D            ;Address of next device to test
            OR   A              ;Have we tested all addresses?
            JR   NZ,LISTLOOP       ;No, so loop again
            CALL LineOut        ;Output new line
            RET

; Test if device at I2C address A acknowledges
;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
;   On exit:  Z flagged if device acknowledges
;             NZ flagged if devices does not acknowledge
LISTTEST:      CALL I2C_Open       ;Open I2C device for write
            RET  NZ             ;Abort if failed to open
            CALL I2C_Close      ;Close I2C device 
            XOR  A              ;Return with Z flagged
            RET




; Copy a block from I2C memory to CPU memory
;   On entry: DE = First address in I2C memory
;             HL = First address in CPU memory
;             BC = Number of bytes to be copied
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             IX IY preserved
I2C_MemRd:  PUSH BC
            LD   BC,TIMEOUT     ;Timeout loop counter
I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
            CALL I2C_Open       ;Open for write
            JR   Z,I2C_MemRdReady       ;If open okay then skip on
            DEC  BC
            LD   A,B
            OR   C              ;Timeout?
            JR   NZ,I2C_MemRdRepeat     ;No, so go try again
            POP  BC
            LD   A,ERR_TOUT     ;Error code
            OR   A              ;Error, so NZ flagged
            RET                 ;Return with error
; Device opened okay
I2C_MemRdReady:     POP  BC             ;Restore byte counter
            LD   A,D            ;Address (hi) in I2C memory
            CALL I2C_Write      ;Write address
            LD   A,E            ;Address (lo) in I2C memory
            CALL I2C_Write      ;Write address
            LD   A,I2CA_BLOCK+1 ;I2C device to be read from
            CALL I2C_Open       ;Open for read
            RET  NZ             ;Abort if error
I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
            LD   A,B
            OR   C              ;Last byte to be read?
            CALL I2C_Read       ;Read byte with no ack on last byte
            LD   (HL),A         ;Write byte in CPU memory
            INC  HL             ;Increment CPU memory pointer
            LD   A,B
            OR   C              ;Finished?
            JR   NZ,I2C_MemRdRead       ;No, so go read next byte
            CALL I2C_Stop       ;Generate I2C stop
            XOR  A              ;Return with success (Z flagged)
            RET


; Copy a block from CPU memory to I2C memory
;   On entry: DE = First address in I2C memory
;             HL = First address in CPU memory
;             BC = Number of bytes to be copied
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             IX IY preserved
; The 24LC64 requires blocks of data to be written in 64 byte (or less)
; pages.
I2C_MemWr:  PUSH BC
            LD   BC,TIMEOUT     ;Timeout loop counter
I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
            CALL I2C_Open       ;Open for write
            JR   Z,I2C_MemWrReady       ;If open okay then skip on
            DEC  BC
            LD   A,B
            OR   C              ;Timeout?
            JR   NZ,I2C_MemWrRepeat     ;No, so go try again
            POP  BC
            LD   A,ERR_TOUT     ;Error code
            OR   A              ;Error, so NZ flagged
            RET                 ;Return with error
; Device opened okay
I2C_MemWrReady:     POP  BC             ;Restore byte counter
I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
            CALL I2C_Write      ;Write address
            LD   A,E            ;Address (lo) in I2C memory
            CALL I2C_Write      ;Write address
I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
            CALL I2C_Write      ;Read byte from I2C memory
            INC  HL             ;Increment CPU memory pointer
            INC  DE             ;Increment I2C memory pointer
            DEC  BC             ;Decrement byte counter
            LD   A,B
            OR   C              ;Finished?
            JR   Z,I2C_MemWrStore       ;Yes, so go store this page
            LD   A,E            ;Get address in I2C memory (lo byte)
            AND  63             ;64 byte page boundary?
            JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
            LD   A,B
            OR   C              ;Finished?
            JR   NZ,I2C_MemWr   ;No, so go write some more
            RET   


; Hex byte output to console
;   On entry: A = Byte to be output in hex
;   On exit:  BC DE HL IX IY preserved
HexOut:     PUSH AF             ;Preserve byte to be output
            RRA                 ;Shift top nibble to
            RRA                 ;  botom four bits..
            RRA
            RRA
            AND  $0F           ;Mask off unwanted bits
            CALL HexOutHex           ;Output hi nibble
            POP  AF             ;Restore byte to be output
            AND  $0F           ;Mask off unwanted bits
; Output nibble as ascii character
HexOutHex:       CP   $0A           ;Nibble > 10 ?
            JR   C,HexOutSkip        ;No, so skip
            ADD  A,7            ;Yes, so add 7
HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
            CALL $0008       ;Write character
            RET

#include "SoftSerial.asm"


INIT_SOFTSERIAL:
    ; init serial
    CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
    LD    HL,TXDATA
    LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
    LD    HL,RXDATA
    LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
    
    LD	HL,B4800
	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD

    LD A, $FF
    OUT (SERIAL_TX_PORT), A

    LD HL, WELLCOME
    CALL SNDMSG
    RET

;-----------------
; ONE SECOND DELAY
;-----------------
;
; ENTRY : NONE
; EXIT : FLAG REGISTER MODIFIED
;
DELONE:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	DE,0001H
	LD	HL,0870H
DELON1:	LD	B,92H
DELON2:	DJNZ	DELON2	;INNER LOOP
	SBC	HL,DE
	JP	NC,DELON1	;OUTER LOOP
	POP	HL
	POP	DE
	POP	BC
	RET

;-----------------------------------------
; SEND AN ASCII STRING OUT THE SERIAL PORT
;-----------------------------------------
; 
; SENDS A ZERO TERMINATED STRING OR 
; 128 CHARACTERS MAX. OUT THE SERIAL PORT
;
;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
;      EXIT  : NONE
;
;       MODIFIES : A,B,C
;          
SNDMSG: LD    B,128         ;128 CHARS MAX
SDMSG1: LD    A,(HL)        ;GET THE CHAR
       CP    00H          ;ZERO TERMINATOR?
       JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
       CALL  OUTCH         ;TRANSMIT THE CHAR
       INC   HL
       DJNZ  SDMSG1        ;128 CHARS MAX!    
SDMSG2: RET



;-----------------------------------
; OUTPUT A CHARACTER TO THE TERMINAL
;-----------------------------------       
OUTCH:  LD   IX,(PUTCH)
       JP   (IX)
;------------------------------------
; INPUT A CHARACTER FROM THE TERMINAL
;------------------------------------
INCH:  LD   IX,(GETCH)
      JP   (IX)



;------------------------
; SERIAL TRANSMIT ROUTINE
;------------------------
;TRANSMIT BYTE SERIALLY ON DOUT
;
; ENTRY : A = BYTE TO TRANSMIT
;  EXIT : NO REGISTERS MODIFIED
;
TXDATA:	PUSH	AF
	PUSH	BC
	PUSH	HL
	LD	HL,(BAUD)
	LD	C,A
;
; TRANSMIT START BIT
;
	XOR	A
	OUT	(SERIAL_TX_PORT),A
	CALL	BITIME
;
; TRANSMIT DATA
;
	LD	B,08H
	RRC	C
NXTBIT:	RRC	C	;SHIFT BITS TO D6,
	LD	A,C	;LSB FIRST AND OUTPUT
	AND	40H	;THEM FOR ONE BIT TIME.
	OUT	(SERIAL_TX_PORT),A
	CALL	BITIME
	DJNZ	NXTBIT
;
; SEND STOP BITS
;
	LD	A,40H
	OUT	(SERIAL_TX_PORT),A
	CALL	BITIME
	CALL	BITIME
	POP	HL
	POP	BC
	POP	AF
	RET
;-----------------------
; SERIAL RECEIVE ROUTINE
;-----------------------
;RECEIVE SERIAL BYTE FROM DIN
;
; ENTRY : NONE
;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
;
; REGISTERS MODIFIED A AND F
;
RXDATA:	PUSH	BC
	PUSH	HL
;
; WAIT FOR START BIT 
;
RXDAT1: IN	A,(SERIAL_RX_PORT)
	    BIT	7,A
	    JR	NZ,RXDAT1	;NO START BIT
;
; DETECTED START BIT
;
	LD	HL,(BAUD)
	SRL	H
	RR	L 	;DELAY FOR HALF BIT TIME
	CALL 	BITIME
	IN	A,(SERIAL_RX_PORT)
	BIT	7,A
	JR	NZ,RXDAT1	;START BIT NOT VALID
;
; DETECTED VALID START BIT,READ IN DATA
;
	LD	B,08H
RXDAT2:	LD	HL,(BAUD)
	CALL	BITIME	;DELAY ONE BIT TIME
	IN	A,(SERIAL_RX_PORT)
	RL	A
	RR	C	;SHIFT BIT INTO DATA REG
	DJNZ	RXDAT2
	LD	A,C
	OR	A	;CLEAR CARRY FLAG
    POP	HL
	POP	BC
	RET
;---------------
; BIT TIME DELAY
;---------------
;DELAY FOR ONE SERIAL BIT TIME
;ENTRY : HL = DELAY TIME
; NO REGISTERS MODIFIED
;
BITIME:	PUSH	HL
	PUSH	DE
	LD	DE,0001H
BITIM1:	SBC	HL,DE
	JP	NC,BITIM1
	POP	DE
	POP	HL
	RET
#include "Monitor.asm"
; -----------------------------------------------------------------------------
;   START_MONITOR
; -----------------------------------------------------------------------------
START_MONITOR:
    LD  SP, SYSTEM  ; Set stack point

    LD A, 0
    LD (PORT_OUT_VAL), A ; Set default value to port

    LD A, $c0
    LD (PORT_SET), A

    CALL INIT_SOFTSERIAL ; Initialize software serial

    ; Init LCD hardware
    CALL INIT_LCD
    call delay

    call cls_TXT
    call delay

    CALL enable_grafic
    call delay

    call cls_GRAPHIC
    call delay

RESET_WARM:
    call lcd_clear

    ; Init LCD logical
    call INIT_TXT_LCD ; set cursor X Y to 0

    LD HL, MSG_MONITOR
    CALL SNDLCDMSG

    LD A, '>'
    CALL PRINTCHAR

KEY:
    CALL KEYREADINIT

    CP 'H'
    CALL Z, SHOWHELP

    CP KF1
    JP Z, $8000

    CP KF2
    JP Z, INTEL_HEX

    CP 'B'
    JP Z, BASIC

    CP 'G'
    CALL Z, GOJUMP

    CP 'M'
    CALL Z, MODIFY

    CP 'D'
    CALL Z, DSPLAY

    CP 'O'
    CALL Z, OUTPORT

    CP 'I'
    CALL Z, INPORT

    CP '1'
    CALL Z, I2CLIST

    CP '2'
    CALL Z, I2CCPUTOMEM

    CP '3'
    CALL Z, I2CMEMTOCPU

    CP '4'
    CALL Z, I2C_WR_DD

    CP '5'
    CALL Z, I2C_WR_RR_DD

    CP '6'
    CALL Z, I2C_RD

    CP '7'
    CALL Z, I2C_RD_RR

    







    LD A, CR 
    CALL PRINTCHAR
    LD A, '>' 
    CALL PRINTCHAR

    JP  KEY






;--------------------------
; D DISPLAY MEMORY LOCATION
;--------------------------
DSPLAY: LD A, 'D'
        CALL PRINTCHAR
        CALL  OUTSP       ;A SPACE
       CALL  GETCHR
       RET   C         
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; WAIT FOR CR OR ESC
;
DPLAY1: CALL  KEYREADINIT
       CP    ESC
       RET   Z
       CP    CR
       JR    NZ,DPLAY1          
       CALL  TXCRLF      ;NEWLINE
;
; DISPLAY THE LINE
;
DPLAY2: CALL  DPLINE
       LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
;
; DISPLAY MORE LINES OR EXIT
;       
DPLAY3: CALL  KEYREADINIT
       JR    C,DPLAY3   
       CP    CR        ;ENTER DISPLAYS THE NEXT LINE
       JR    Z,DPLAY2
       CP    ESC         ;ESC EXITS (SHIFT + C)
       JR    NZ,DPLAY3     
       RET   
;-------------------------
; DISPLAY A LINE OF MEMORY
;-------------------------      
DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
       LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
;
; DISPLAY THE ADDRESS
;         
       CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
       CALL  SPCBUF        
;
; DISPLAY 4 BYTES
;
       LD    B,4 ;16
DLINE1: LD    A,(DE)
       CALL  BYTASC
       CALL  SPCBUF
       INC   DE        
       DJNZ  DLINE1
       ;CALL  SPCBUF
;
; NOW DISPLAY THE ASCII CHARACTER
; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
; BE DIFFERENT BETWEEN THE TWO PASSES!
;
       LD    DE,(ADDR)    
       LD    B,4 ; 4 bytes
DLINE2: LD    A,(DE)   
       CP    20H
       JR    C,DOT
       CP    7FH
       JR    NC,DOT
       JP    NDOT
DOT:    LD    A,'.'
NDOT:   CALL  INBUF
       INC   DE       
       DJNZ  DLINE2
;         
;TERMINATE AND DISPLAY STRING
;       
       CALL  BCRLF
       LD    A,00H
       LD    (HL),A
       LD    HL,MSGBUF
       CALL  SNDLCDMSG
       RET


;
; PUT A SPACE IN THE BUFFER
;
SPCBUF: LD    A, 8 ;20H(32dec)
INBUF:  LD    (HL),A
       INC   HL
       RET
;
; PUT A CR LF IN THE BUFFER
;        
BCRLF:  ;LD    A,CR  
       ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
       RET



;----------------------------------------------
; Output value to port
; O AA DD - Port address in AA, Data to out in DD
;----------------------------------------------
OUTPORT:
    LD A, 'O'
    CALL PrintBufferChar
    CALL OUTSP ; space and show lcd

    CALL  GETCHR 
    RET   C
    LD C, A

    CALL OUTSP

    CALL  GETCHR 
    RET   C
    OUT (C), A
    RET


;----------------------------------------------
; Read input port and show value to LCD
; I AA - Port address in AA
;----------------------------------------------
INPORT:
    LD A, 'I'
    CALL PrintBufferChar
    CALL OUTSP ; space and show lcd

    CALL  GETCHR 
    RET   C
    LD C, A

    IN A, (C)

    LD B, A
    PUSH BC
    LD A, CR
    CALL PRINTCHAR
    POP BC
    LD A, B

    CALL CONV_A_HEX
    RET


; --------------------------------------
; I2C - Write one byte
; --------------------------------------
I2C_WR_DD:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    ; Show msg func
    LD HL, MSG_I2C_WR_DD
    CALL SNDLCDMSG

    ; Device Address
    CALL GET_DEV_ADDR ; get address

I2C_WR_DD_LOOP:
    ; Get Data
    CALL GET_DEV_DD   ; get data

    ; Send
    LD A, (I2C_ADDR) ; Open
    CALL I2C_Open

    LD A, (I2C_DD)  ; Data
    CALL I2C_Write
 
    CALL I2C_Close  ; Close

    JR I2C_WR_DD_LOOP

    RET



; --------------------------------------
; I2C - Write register one byte
; --------------------------------------
I2C_WR_RR_DD:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    ; Show msg func
    LD HL, MSG_I2C_WR_RR_DD
    CALL SNDLCDMSG

    ; Device Address
    CALL GET_DEV_ADDR ; get address

I2C_WR_RR_DD_LOOP:
    ; Get register
    CALL GET_DEV_RR ; get address

    ; Get Data
    CALL GET_DEV_DD   ; get data

    ; Send
    LD A, (I2C_ADDR) ; Open
    CALL I2C_Open

    LD A, (I2C_RR)  ; register
    CALL I2C_Write

    LD A, (I2C_DD)  ; Data
    CALL I2C_Write

    CALL I2C_Close  ; Close

    JR I2C_WR_RR_DD_LOOP

    RET


; --------------------------------------
; I2C - Read one byte
; --------------------------------------
I2C_RD:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    ; Show msg func
    LD HL, MSG_I2C_RD
    CALL SNDLCDMSG

    ; Device Address
    CALL GET_DEV_ADDR ; get address
    CALL TXCRLF ; new line

I2C_RD_LOOP:
    ; Send
    LD A, (I2C_ADDR) ; Open
    INC A ; To read address + 1 (flag)
    CALL I2C_Open

    CALL I2C_Read      ; Read
    PUSH AF

    CALL I2C_Close     ; Close

    ; Show
    POP AF
    CALL CONV_A_HEX ; Show A to (HEX) LCD
    CALL TXCRLF ; new line

    CALL KEYREADINIT
    CP CTRLC
    JP Z, RESET_WARM

    JR I2C_RD_LOOP
    RET


; --------------------------------------
; I2C - Read register one byte
; --------------------------------------
I2C_RD_RR:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    ; Show msg func
    LD HL, MSG_I2C_RD_RR
    CALL SNDLCDMSG

    ; Device Address
    CALL GET_DEV_ADDR ; get address

I2C_RD_RR_LOOP:
    ; Get register
    CALL GET_DEV_RR ; get address
    CALL TXCRLF ; new line

    ; Send
    LD A, (I2C_ADDR) ; Open
    CALL I2C_Open

    LD A, (I2C_RR)
    CALL I2C_Write ; Register to read

    LD A, (I2C_ADDR) ; Open
    INC A ; To read address + 1 (flag)
    CALL I2C_Open

    CALL I2C_Read ; Read register
    PUSH AF

    CALL I2C_Close ; Close

    ; Show
    POP AF
    CALL CONV_A_HEX ; Show A to (HEX) LCD

    JR I2C_RD_RR_LOOP
    RET


GET_DEV_ADDR:
    LD HL, MSG_DEV_ADDR
    CALL SNDLCDMSG
    CALL  GETCHR 
    RET   C
    LD (I2C_ADDR), A
    RET

GET_DEV_DD:
    LD HL, MSG_DEV_DATA
    CALL SNDLCDMSG

    CALL  GETCHR 
    RET   C
    LD (I2C_DD), A
    RET

GET_DEV_RR:
    LD HL, MSG_DEV_REG
    CALL SNDLCDMSG

    CALL  GETCHR 
    RET   C
    LD (I2C_RR), A
    RET




I2CMEMTOCPU:
    ; Get parameters to copy a block from I2C memory to CPU memory
;   On entry: DE = First address in I2C memory
;             HL = First address in CPU memory
;             BC = Number of bytes to be copied
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             IX IY preserved

    LD HL, MSG_MEM2CPU
    CALL SNDLCDMSG

    CALL GET_FROM_TO_SIZE

;    DE = First address in I2C memory
;    HL = First address in CPU memory
;    BC = Number of bytes to be copied

    LD DE, (ADDR_FROM)
    LD HL, (ADDR_TO)
    LD BC, (ADDR_SIZE)
    CALL I2C_MemRd  

    JP Z, I2CMEMTOCPU_OK
    LD HL, MSG_COPYFAIL
    CALL SNDLCDMSG
    RET
I2CMEMTOCPU_OK:
    LD HL, MSG_COPYOK
    CALL SNDLCDMSG
    RET


I2CCPUTOMEM:
; Get parameters to copy a block from CPU memory to I2C memory
;   On entry: DE = First address in I2C memory
;             HL = First address in CPU memory
;             BC = Number of bytes to be copied
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             IX IY preserved
; The 24LC64 requires blocks of data to be written in 64 byte (or less)
; pages.
    LD HL, MSG_CPU2MEM
    CALL SNDLCDMSG

    CALL GET_FROM_TO_SIZE

;    DE = First address in I2C memory
;    HL = First address in CPU memory
;    BC = Number of bytes to be copied

    LD HL, (ADDR_FROM)
    LD DE, (ADDR_TO)
    LD BC, (ADDR_SIZE)
    CALL I2C_MemWr
    
    JP Z, I2CCPUTOMEM_OK
    LD HL, MSG_COPYFAIL
    CALL SNDLCDMSG
    RET
I2CCPUTOMEM_OK:
    LD HL, MSG_COPYOK
    CALL SNDLCDMSG
    RET






GET_FROM_TO_SIZE:
    ; FROM
    LD HL, MSG_FROM
    CALL SNDLCDMSG
    ;
    ;GET THE ADDRESS  FROM
    ;
    CALL  GETCHR 
    RET   C        
    LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
    CALL  GETCHR
    RET   C
    LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW

    CALL  KEYREADINIT
    CP    ESC         ;ESC KEY?
    RET   Z
    CP    CR
    JR Z, GET_FROM_TO_SIZE_TO
    LD A, CR
    CALL PRINTCHAR
    JP GET_FROM_TO_SIZE

GET_FROM_TO_SIZE_TO:
    ; TO
    LD HL, MSG_TO
    CALL SNDLCDMSG
    ;
    ;GET THE ADDRESS  TO
    ;
    CALL  GETCHR 
    RET   C        
    LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
    CALL  GETCHR
    RET   C
    LD    (ADDR_TO),A    ;SAVE ADDRESS LOW

    CALL  KEYREADINIT
    CP    ESC         ;ESC KEY?
    RET   Z
    CP    CR
    JR NZ, GET_FROM_TO_SIZE_TO

GET_FROM_TO_SIZE_SIZE:
    ; SIZE
    LD HL, MSG_SIZE
    CALL SNDLCDMSG
    ;
    ;GET THE SIZE
    ;
    CALL  GETCHR 
    RET   C        
    LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
    CALL  GETCHR
    RET   C
    LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW

    CALL  KEYREADINIT
    CP    ESC         ;ESC KEY?
    RET   Z
    CP    CR
    JR NZ, GET_FROM_TO_SIZE_SIZE
    RET


INTEL_HEX:
    CALL INTHEX
    CALL delay
    CALL delay
    JP START_MONITOR

SHOWHELP:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    LD HL, MSG_MENU0
    CALL SNDLCDMSG

    LD HL, MSG_MENU1
    CALL SNDLCDMSG

    LD HL, MSG_MENU2
    CALL SNDLCDMSG

    LD HL, MSG_MENU3
    CALL SNDLCDMSG

    LD HL, MSG_MENU4
    CALL SNDLCDMSG

    LD HL, MSG_MENU5
    CALL SNDLCDMSG

    LD HL, MSG_MENU6
    CALL SNDLCDMSG

    LD HL, MSG_MENU7
    CALL SNDLCDMSG

    LD HL, MSG_MENU8
    CALL SNDLCDMSG

    LD HL, MSG_MENU9
    CALL SNDLCDMSG

    LD HL, MSG_MENU10
    CALL SNDLCDMSG

    LD HL, MSG_MENU11
    CALL SNDLCDMSG

    LD HL, MSG_MENU12
    CALL SNDLCDMSG

    LD HL, MSG_MENU13
    CALL SNDLCDMSG

    LD HL, MSG_MENU14
    CALL SNDLCDMSG

    RET



;----------------------     
; SEND ASCII HEX VALUES        
;----------------------
;
; OUTPUT THE 4 BYTE, WRDOUT
; THE 2 BYTE, BYTOUT
; OR THE SINGLE BYTE, NYBOUT
; ASCII STRING AT HL TO THE SERIAL PORT
;
WRDOUT: CALL  BYTOUT
BYTOUT: CALL  NYBOUT
NYBOUT: LD    A,(HL)
       CALL  PRINTCHAR
       INC   HL
       RET       



;----------------
;CONVERT TO ASCII 
;----------------
;
; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
;
;         ENTRY :  A = BINARY TO CONVERT
;                  HL = CHARACTER BUFFER ADDRESS   
;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
;   
;        MODIFIES : DE

WRDASC: LD    A,D         ;CONVERT AND
       CALL  BYTASC      ;OUTPUT D
       LD    A,E         ;THEN E
;
;CONVERT A BYTE TO ASCII 
;
BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
       RRCA              ;SHIFT HIGH NYBBLE ACROSS
       RRCA
       RRCA
       RRCA
       CALL NYBASC       ;CALL NYBBLE CONVERTER 
       POP AF            ;RESTORE LOW NYBBLE
;           
; CONVERT A NYBBLE TO ASCII
;
NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
       ADD   A,90H       ;CONVERT TO
       DAA               ;ASCII
       ADC   A,40H
       DAA
;            
; SAVE IN STRING
;
INSBUF: LD    (HL),A
       INC   HL 
       RET 




;----------------------------
; M DISPLAY AND MODIFY MEMORY
;----------------------------
MODIFY: LD A, 'M'
        CALL PRINTCHAR
     CALL  OUTSP
;
;GET THE ADDRESS        
;
       CALL  GETCHR 
       RET   C        
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; DISPLAY ON A NEW LINE
;       
MDIFY1: CALL  TXCRLF       
       LD    DE,(ADDR)    
       LD    HL,MSGBUF   
       CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
       LD    HL,MSGBUF
       CALL  WRDOUT      ;OUTPUT THE ADDRESS
       CALL  OUTSP    
;      
;GET THE DATA AT THE ADDRESS        
;
        LD   HL,(ADDR)       
        LD   A,(HL)
;
; DISPLAY THE DATA
;        
       LD    HL,MSGBUF
       CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
       LD    HL,MSGBUF
       CALL  BYTOUT      ;OUTPUT THE BYTE
       CALL  OUTSP
;
; GET NEW DATA,EXIT OR CONTINUE
;
       CALL  GETCHR
       RET   C
       LD    B,A         ;SAVE IT FOR LATER
       LD    HL,(ADDR)
       LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
       LD    A,B
       CP    (HL)
       JR    Z,MDIFY2
       LD    A,'?'
       CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
;
; INCREMENT THE ADDRESS
;
MDIFY2: INC   HL
       LD    (ADDR),HL
       JP    MDIFY1



;------------------------------
; GO <ADDR>
; TRANSFERS EXECUTION TO <ADDR>
;------------------------------
GOJUMP_new:
    LD A, CR
    CALL PRINTCHAR

    LD A, '>'
    CALL PRINTCHAR

GOJUMP: LD A, 'G'
        CALL PRINTCHAR
       CALL  OUTSP       
       CALL  GETCHR      ;GET ADDRESS HIGH BYTE
       RET   C
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR      ;GET ADDRESS LOW BYTE
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; WAIT FOR A CR OR ESC
;       
GOJMP1: CALL  KEYREADINIT
       CP    ESC         ;ESC KEY?
       RET   Z
       CP    CR
       ;JR    NZ,GOJMP1
       JR NZ, GOJUMP_new
       CALL  TXCRLF
       POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
       LD    HL,(ADDR)
       JP    (HL)        ;GOOD LUCK WITH THAT!
#include "Utils.asm"
;----------------
;CONVERT A TO ASCII (HEX) AND SHOW LCD
;----------------
;
;CONVERT REG A BYTE TO ASCII 
;
CONV_A_HEX: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
       RRCA              ;SHIFT HIGH NYBBLE ACROSS
       RRCA
       RRCA
       RRCA
       CALL CONV_A_HEX_NYBASC       ;CALL NYBBLE CONVERTER 
       POP AF            ;RESTORE LOW NYBBLE
;           
; CONVERT A NYBBLE TO ASCII
;
CONV_A_HEX_NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
       ADD   A,90H       ;CONVERT TO
       DAA               ;ASCII
       ADC   A,40H
       DAA
;            
; Print inlcd
;
    CALL PRINTCHAR
    RET 


; Space character ouput to console
;   On entry: No parameters required
;   On exit:  BC DE HL IX IY preserved
SpaceOut:   
            LD   A,$20
            RST $08 ; output chat to lcd
            RET

; New line output to console device
;   On entry: No parameters required
;   On exit:  BC DE HL IX IY preserved
LineOut:    PUSH AF
            LD A, CR ; enter char
            RST $08
            RET


; String output to console device
;   On entry: DE = Address of string
;   On exit:  BC DE HL IX IY preserved
StrOut:     PUSH BC             ;Preserve registers
            PUSH DE
            PUSH HL
            LD H, D
            LD L, E
            CALL SNDLCDMSG
            POP  HL             ;Restore registers
            POP  DE
            POP  BC
            RET

            

; **********************************************************************
; Delay by DE milliseconds
;   On entry: DE = Delay time in milliseconds
;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
H_Delay:    PUSH AF
            PUSH BC
            PUSH DE
; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
LoopBC:    DEC  BC             ;[6]     [4]
            LD   A,C            ;[4]     [4]
            OR   B              ;[4]     [4]
            JP   NZ,LoopBC     ;[12/7]  [8/6] 
; Have we looped once for each millisecond requested?
            DEC  DE             ;[6]     [4]
            LD   A,E            ;[4]     [4]
            OR   D              ;[4]     [4]
            JR   NZ, LoopDE     ;[12/7]  [8/6]
            POP  DE
            POP  BC
            POP  AF
            RET


; ----------------------------------
; INPUT: THE VALUES IN REGISTER B EN C
; OUTPUT: HL = B * C
; CHANGES: AF,DE,HL,B
;
multiplication:
	LD HL,0
	LD A,B
	OR A
	RET Z
	LD D,0
	LD E,C
multiplicationLOOP:	ADD HL,DE
	DJNZ multiplicationLOOP
	RET 

;-----------------------------------
; Div_HL_D
;Inputs:
;   HL and D
;Outputs:
;   HL is the quotient (HL/D)
;   A is the remainder
;   B is 0
;   C,D,E are preserved
Div_HL_D:
    xor a         ; Clear upper eight bits of AHL
    ld b,16       ; Sixteen bits in dividend
_loop:
    add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
    rla           ; This moves the upper bits of the dividend into A
    jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
    cp d          ; Check if we can subtract the divisor
    jr c,_skip    ; Carry means A < D
_overflow:
    sub d         ; Do subtraction for real this time
    inc l         ; Set the next bit of the quotient (currently bit 0)
_skip:
    djnz _loop
    ret
#include "Strings.asm"
WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H

MSG_MENU0  .db "F1 RUN (JP $8000)",CR, 00H
MSG_MENU1  .db "F2 Intel hex loader",CR, 00H
MSG_MENU2  .db "B - Basic",CR, 00H
MSG_MENU3  .db "D AAAA - DISPLAY",CR,00H
MSG_MENU4  .db "M AAAA - MODIFY",CR,00H
MSG_MENU5  .db "G AAAA - GO TO",CR, 00H
MSG_MENU6  .db "O Out AA DD",CR, 00H
MSG_MENU7  .db "I In AA",CR, 00H
MSG_MENU8  .db "1 I2C Scan",CR, 00H
MSG_MENU9  .db "2 I2C PC -> MEM",CR, 00H
MSG_MENU10 .db "3 I2C MEM -> PC",CR, 00H
MSG_MENU11 .db "4 I2C WRITE DD",CR, 00H
MSG_MENU12 .db "5 I2C WRITE RR DD",CR, 00H
MSG_MENU13 .db "6 I2C READ ONE BYTE",CR, 00H
MSG_MENU14 .db "7 I2C READ RR BYTE", 00H ; ultimo n√£o tem CR (nova linha)



LISTMsg:    .DB  CS,"I2C device found at:",CR,0
MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H

MSG_I2C_WR_DD    .db CS,"WRITE ONE BYTE",CR, 00H
MSG_I2C_WR_RR_DD .db CS,"WRITE REG ONE BYTE",CR, 00H
MSG_I2C_RD       .db CS,"READ ONE BYTE",CR, 00H
MSG_I2C_RD_RR    .db CS,"READ REG ONE BYTE",CR, 00H

MSG_FROM    .db "FROM: ", 00H
MSG_TO      .db CR,"TO: ", 00H
MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
MSG_COPYOK  .db CR,"COPY OK", 00H
MSG_COPYFAIL  .db CR,"COPY FAIL", 00H

MSG_DEV_ADDR  .db CR,"DEVICE ADDR(AA): ", 00H
MSG_DEV_REG   .db CR,"REGISTER(RR): ", 00H
MSG_DEV_DATA  .db CR,"DATA(DD): ", 00H


MSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
FILEOK    .DB      "FILE RECEIVED OK",CR,00H
CSUMERR   .DB    "CHECKSUM ERROR",CR,00H


.end


; +++ segments +++

#CODE          = $0000 =     0,  size = $134D =  4941

; +++ global symbols +++

AC2HEX1          = $00D7 =   215          Keyboard.asm:69
AC2HEX2          = $00D9 =   217          Keyboard.asm:72
AC2HEX3          = $00E5 =   229          Keyboard.asm:78
ADDOFFSET        = $0135 =   309          Keyboard.asm:139
ADDR             = $F425 = 62501          bootV2.asm:128
ADDR_FROM        = $F427 = 62503          bootV2.asm:129
ADDR_SIZE        = $F42B = 62507          bootV2.asm:131
ADDR_TO          = $F429 = 62505          bootV2.asm:130
APIHandler       = $0948 =  2376          API.asm:11
APITable         = $095A =  2394          API.asm:30
ASC2HEX          = $00CD =   205          Keyboard.asm:64
B1200            = $0080 =   128          bootV2.asm:86 (unused)
B2400            = $003F =    63          bootV2.asm:87 (unused)
B300             = $0220 =   544          bootV2.asm:85 (unused)
B4800            = $001B =    27          bootV2.asm:88
B9600            = $000B =    11          bootV2.asm:89 (unused)
BASIC            = $6000 = 24576          bootV2.asm:77
BAUD             = $F430 = 62512          bootV2.asm:135
BCRLF            = $0DCB =  3531          Monitor.asm:205
BITIM1           = $0CAD =  3245          SoftSerial.asm:172
BITIME           = $0CA8 =  3240          SoftSerial.asm:169
BKSP             = $0008 =     8          bootV2.asm:35 (unused)
BYTASC           = $100E =  4110          Monitor.asm:673
BYTOUT           = $1000 =  4096          Monitor.asm:647
Boucle16X        = $04CB =  1227          LCDGraphic.asm:721
Boucle32X        = $04BD =  1213          LCDGraphic.asm:710
CHKKEY           = $00E8 =   232          Keyboard.asm:85
CONV_A_HEX       = $10AC =  4268          Utils.asm:7
CONV_A_HEX_NYBASC = $10B5 =  4277          Utils.asm:17
CR               = $000D =    13          bootV2.asm:39
CS               = $000C =    12          bootV2.asm:38
CSUMERR          = $133D =  4925          Strings.asm:44
CTRLC            = $0003 =     3          bootV2.asm:33
CTRLG            = $0007 =     7          bootV2.asm:34 (unused)
CTRLO            = $000F =    15          bootV2.asm:40 (unused)
CTRLQ            = $0011 =    17          bootV2.asm:41 (unused)
CTRLR            = $0012 =    18          bootV2.asm:42 (unused)
CTRLS            = $0013 =    19          bootV2.asm:43 (unused)
CTRLU            = $0015 =    21          bootV2.asm:44 (unused)
ClearDisplayBuffer = $09B0 =  2480          API.asm:99
ClearDisplayBufferEnd = $09C1 =  2497          API.asm:108
DATA             = $F420 = 62496          bootV2.asm:123
DEL              = $007F =   127          bootV2.asm:46
DELAY_MS         = $044E =  1102          LCDGraphic.asm:595
DELAY_US         = $044B =  1099          LCDGraphic.asm:593
DELETE_CHAR      = $01F0 =   496          LCDGraphic.asm:123
DELON1           = $0C29 =  3113          SoftSerial.asm:33
DELON2           = $0C2B =  3115          SoftSerial.asm:34
DELONE           = $0C20 =  3104          SoftSerial.asm:28
DISPLAY          = $F000 = 61440          bootV2.asm:121
DISPLAY_SCROLL_UP = $0189 =   393          LCDGraphic.asm:49
DLINE1           = $0D95 =  3477          Monitor.asm:161
DLINE2           = $0DA5 =  3493          Monitor.asm:174
DOT              = $0DB1 =  3505          Monitor.asm:180
DPLAY1           = $0D64 =  3428          Monitor.asm:126
DPLAY2           = $0D71 =  3441          Monitor.asm:135
DPLAY3           = $0D78 =  3448          Monitor.asm:140
DPLINE           = $0D86 =  3462          Monitor.asm:150
DSPLAY           = $0D4E =  3406          Monitor.asm:114
DisplayImage128x64 = $09AB =  2475          API.asm:94
Div_HL_D         = $10F8 =  4344          Utils.asm:112
ERR_JAM          = $0001 =     1          I2C.asm:98 (unused)
ERR_NOACK        = $0002 =     2          I2C.asm:99
ERR_NONE         = $0000 =     0          I2C.asm:97 (unused)
ERR_TOUT         = $0003 =     3          I2C.asm:100
ESC              = $001B =    27          bootV2.asm:45
FILEOK           = $132B =  4907          Strings.asm:43
GETBT1           = $0A70 =  2672          LoaderIntel.asm:102
GETBT2           = $0A84 =  2692          LoaderIntel.asm:115
GETBYT           = $0A66 =  2662          LoaderIntel.asm:97
GETCH            = $F434 = 62516          bootV2.asm:137
GETCHR           = $0093 =   147          Keyboard.asm:18
GETNYB           = $00AD =   173          Keyboard.asm:31
GETOUT           = $00CB =   203          Keyboard.asm:46
GET_DEV_ADDR     = $0EB4 =  3764          Monitor.asm:411
GET_DEV_DD       = $0EC2 =  3778          Monitor.asm:419
GET_DEV_RR       = $0ED0 =  3792          Monitor.asm:428
GET_FROM_TO_SIZE = $0F2E =  3886          Monitor.asm:513
GET_FROM_TO_SIZE_SIZE = $0F72 =  3954          Monitor.asm:556
GET_FROM_TO_SIZE_TO = $0F54 =  3924          Monitor.asm:536
GOJMP1           = $109A =  4250          Monitor.asm:781 (unused)
GOJUMP           = $1084 =  4228          Monitor.asm:769
GOJUMP_new       = $107A =  4218          Monitor.asm:762
GRET             = $00F8 =   248          Keyboard.asm:93
H_Delay          = $10D6 =  4310          Utils.asm:66
HexOut           = $0BE7 =  3047          I2C.asm:404
HexOutHex        = $0BF4 =  3060          I2C.asm:414
HexOutSkip       = $0BFA =  3066          I2C.asm:417
I2CA_BLOCK       = $00AE =   174          bootV2.asm:102
I2CCPUTOMEM      = $0F06 =  3846          Monitor.asm:474
I2CCPUTOMEM_OK   = $0F27 =  3879          Monitor.asm:503
I2CClose         = $09CB =  2507          API.asm:118
I2CLIST          = $0B52 =  2898          I2C.asm:278
I2CMEMTOCPU      = $0EDE =  3806          Monitor.asm:440
I2CMEMTOCPU_OK   = $0EFF =  3839          Monitor.asm:468
I2COpen          = $09C8 =  2504          API.asm:115
I2CRead          = $09CE =  2510          API.asm:121
I2CWrite         = $09D1 =  2513          API.asm:124
I2C_ADDR         = $F422 = 62498          bootV2.asm:125
I2C_Close        = $0A99 =  2713          I2C.asm:22
I2C_DD           = $F424 = 62500          bootV2.asm:127
I2C_INIT         = $0B1F =  2847          I2C.asm:228
I2C_MemRd        = $0B7C =  2940          I2C.asm:318
I2C_MemRdRead    = $0BA0 =  2976          I2C.asm:340
I2C_MemRdReady   = $0B91 =  2961          I2C.asm:332
I2C_MemRdRepeat  = $0B80 =  2944          I2C.asm:320
I2C_MemWr        = $0BB1 =  2993          I2C.asm:364
I2C_MemWrBlock   = $0BC7 =  3015          I2C.asm:379 (unused)
I2C_MemWrReady   = $0BC6 =  3014          I2C.asm:378
I2C_MemWrRepeat  = $0BB5 =  2997          I2C.asm:366
I2C_MemWrStore   = $0BDF =  3039          I2C.asm:394
I2C_MemWrWrite   = $0BCF =  3023          I2C.asm:383
I2C_Open         = $0A92 =  2706          I2C.asm:10
I2C_PORT         = $0021 =    33          I2C.asm:88
I2C_QUIES        = $0081 =   129          I2C.asm:93
I2C_RAMCPY       = $F421 = 62497          bootV2.asm:124
I2C_RD           = $0E4E =  3662          Monitor.asm:332
I2C_RD_LOOP      = $0E5F =  3679          Monitor.asm:344
I2C_RD_RR        = $0E7F =  3711          Monitor.asm:371
I2C_RD_RR_LOOP   = $0E8D =  3725          Monitor.asm:382
I2C_RR           = $F423 = 62499          bootV2.asm:126
I2C_RdPort       = $0B49 =  2889          I2C.asm:254
I2C_Read         = $0AD9 =  2777          I2C.asm:163
I2C_ReadNoAck    = $0AFB =  2811          I2C.asm:183
I2C_ReadRd_Loop  = $0AE1 =  2785          I2C.asm:168
I2C_ReadRotate   = $0AED =  2797          I2C.asm:174
I2C_SCL_HI       = $0B23 =  2851          I2C.asm:231
I2C_SCL_LO       = $0B2A =  2858          I2C.asm:235
I2C_SCL_RD       = $0000 =     0          I2C.asm:92 (unused)
I2C_SCL_WR       = $0000 =     0          I2C.asm:91
I2C_SDA_HI       = $0B31 =  2865          I2C.asm:239
I2C_SDA_LO       = $0B38 =  2872          I2C.asm:243
I2C_SDA_RD       = $0007 =     7          I2C.asm:90
I2C_SDA_WR       = $0007 =     7          I2C.asm:89
I2C_Start        = $0B06 =  2822          I2C.asm:198
I2C_Stop         = $0B11 =  2833          I2C.asm:214
I2C_WR_DD        = $0DFF =  3583          Monitor.asm:261
I2C_WR_DD_LOOP   = $0E0D =  3597          Monitor.asm:272
I2C_WR_RR_DD     = $0E22 =  3618          Monitor.asm:294
I2C_WR_RR_DD_LOOP = $0E30 =  3632          Monitor.asm:305
I2C_WrPort       = $0B3D =  2877          I2C.asm:246
I2C_Write        = $0A9C =  2716          I2C.asm:116
I2C_WriteBit_Clk = $0AAD =  2733          I2C.asm:125
I2C_WriteBit_Hi  = $0AAA =  2730          I2C.asm:124
I2C_WriteNoAck   = $0ACA =  2762          I2C.asm:143
I2C_WriteWr_Loop = $0AA1 =  2721          I2C.asm:120
INBUF            = $0DC8 =  3528          Monitor.asm:199
INCH             = $0C4A =  3146          SoftSerial.asm:73 (unused)
INIT_LCD         = $0151 =   337          LCDGraphic.asm:13
INIT_SOFTSERIAL  = $0C00 =  3072          SoftSerial.asm:3
INIT_TXT_LCD     = $0170 =   368          LCDGraphic.asm:36
INPORT           = $0DE3 =  3555          Monitor.asm:236
INSBUF           = $101F =  4127          Monitor.asm:691 (unused)
INTEL1           = $0A0E =  2574          LoaderIntel.asm:40
INTEL2           = $0A39 =  2617          LoaderIntel.asm:69
INTEL4           = $0A54 =  2644          LoaderIntel.asm:87
INTELH           = $0A0A =  2570          LoaderIntel.asm:36
INTEL_HEX        = $0F91 =  3985          Monitor.asm:578
INTHEX           = $09DF =  2527          LoaderIntel.asm:4
ITHEX1           = $09FD =  2557          LoaderIntel.asm:21
InputCharKey     = $0985 =  2437          API.asm:61
KDOWN            = $00B6 =   182          bootV2.asm:54
KEY              = $0CEE =  3310          Monitor.asm:40
KEYMAP           = $0033 =    51          Keyboard.asm:1
KEYOUT           = $0146 =   326          Keyboard.asm:151
KEYREADINIT      = $00FD =   253          Keyboard.asm:103
KEY_IN           = $0040 =    64          bootV2.asm:27
KEY_OUT          = $0040 =    64          bootV2.asm:28
KF1              = $0080 =   128          bootV2.asm:55
KF2              = $0081 =   129          bootV2.asm:56
KF3              = $0082 =   130          bootV2.asm:57
KF4              = $0083 =   131          bootV2.asm:58
KF5              = $0084 =   132          bootV2.asm:59
KF6              = $0085 =   133          bootV2.asm:60
KF7              = $0086 =   134          bootV2.asm:61
KF8              = $0087 =   135          bootV2.asm:62
KLEFT            = $00B4 =   180          bootV2.asm:51
KRIGHT           = $00B7 =   183          bootV2.asm:52
KUP              = $00B5 =   181          bootV2.asm:53
LCDCTRL          = $0070 =   112          bootV2.asm:25
LCDDATA          = $0071 =   113          bootV2.asm:26
LCD_AUTO_X       = $F446 = 62534          bootV2.asm:150
LCD_BIT_INDEX    = $F43C = 62524          bootV2.asm:143
LCD_BYTE_INDEX   = $F43A = 62522          bootV2.asm:142
LCD_CHAR         = $F435 = 62517          bootV2.asm:138
LCD_CHAR_H       = $F441 = 62529          bootV2.asm:146
LCD_CHAR_POINT   = $F436 = 62518          bootV2.asm:139
LCD_CHAR_W       = $F442 = 62530          bootV2.asm:147
LCD_COOX         = $F448 = 62536          bootV2.asm:152 (unused)
LCD_COOY         = $F449 = 62537          bootV2.asm:153 (unused)
LCD_DATA         = $F42F = 62511          bootV2.asm:134 (unused)
LCD_DELETE_CHAR  = $F445 = 62533          bootV2.asm:149
LCD_LINE1        = $0080 =   128          bootV2.asm:109 (unused)
LCD_LINE2        = $0090 =   144          bootV2.asm:110 (unused)
LCD_LINE3        = $0088 =   136          bootV2.asm:111 (unused)
LCD_LINE4        = $0098 =   152          bootV2.asm:112 (unused)
LCD_PRINT_H      = $F44A = 62538          bootV2.asm:154 (unused)
LCD_PRINT_IMAGE  = $F44C = 62540          bootV2.asm:156 (unused)
LCD_PRINT_W      = $F44B = 62539          bootV2.asm:155 (unused)
LCD_TEMP         = $F447 = 62535          bootV2.asm:151
LCD_TMP_POINT    = $F443 = 62531          bootV2.asm:148
LCD_TXT_X        = $F438 = 62520          bootV2.asm:140
LCD_TXT_X_TMP    = $F43D = 62525          bootV2.asm:144
LCD_TXT_Y        = $F439 = 62521          bootV2.asm:141
LCD_TXT_Y_TMP    = $F43F = 62527          bootV2.asm:145
LF               = $000A =    10          bootV2.asm:36
LISTLOOP         = $0B5A =  2906          I2C.asm:281
LISTMsg          = $1229 =  4649          Strings.asm:22
LISTNEXT         = $0B69 =  2921          I2C.asm:289
LISTTEST         = $0B73 =  2931          I2C.asm:301
LOADSHIFT        = $0132 =   306          Keyboard.asm:136
LOGARITHM        = $011E =   286          Keyboard.asm:125
LcdSetCXY        = $09D4 =  2516          API.asm:127
LineOut          = $10C5 =  4293          Utils.asm:40
LoopBC           = $10DC =  4316          Utils.asm:72
LoopDE           = $10D9 =  4313          Utils.asm:70
MDIFY1           = $1038 =  4152          Monitor.asm:716
MDIFY2           = $1073 =  4211          Monitor.asm:752
MODIFY           = $1022 =  4130          Monitor.asm:701
MSGBUF           = $F401 = 62465          bootV2.asm:122
MSG_COPYFAIL     = $12DB =  4827          Strings.asm:35
MSG_COPYOK       = $12D2 =  4818          Strings.asm:34
MSG_CPU2MEM      = $1256 =  4694          Strings.asm:24
MSG_DEV_ADDR     = $12E6 =  4838          Strings.asm:37
MSG_DEV_DATA     = $1309 =  4873          Strings.asm:39
MSG_DEV_REG      = $12F9 =  4857          Strings.asm:38
MSG_FROM         = $12B6 =  4790          Strings.asm:31
MSG_I2C_RD       = $1292 =  4754          Strings.asm:28
MSG_I2C_RD_RR    = $12A2 =  4770          Strings.asm:29
MSG_I2C_WR_DD    = $126C =  4716          Strings.asm:26
MSG_I2C_WR_RR_DD = $127D =  4733          Strings.asm:27
MSG_ILOAD        = $1315 =  4885          Strings.asm:42
MSG_MEM2CPU      = $1240 =  4672          Strings.asm:23
MSG_MENU0        = $1134 =  4404          Strings.asm:4
MSG_MENU1        = $1147 =  4423          Strings.asm:5
MSG_MENU10       = $11CD =  4557          Strings.asm:14
MSG_MENU11       = $11DE =  4574          Strings.asm:15
MSG_MENU12       = $11EE =  4590          Strings.asm:16
MSG_MENU13       = $1201 =  4609          Strings.asm:17
MSG_MENU14       = $1216 =  4630          Strings.asm:18
MSG_MENU2        = $115C =  4444          Strings.asm:6
MSG_MENU3        = $1167 =  4455          Strings.asm:7
MSG_MENU4        = $1179 =  4473          Strings.asm:8
MSG_MENU5        = $118A =  4490          Strings.asm:9
MSG_MENU6        = $119A =  4506          Strings.asm:10
MSG_MENU7        = $11A7 =  4519          Strings.asm:11
MSG_MENU8        = $11B0 =  4528          Strings.asm:12
MSG_MENU9        = $11BC =  4540          Strings.asm:13
MSG_MONITOR      = $111F =  4383          Strings.asm:2
MSG_SIZE         = $12C3 =  4803          Strings.asm:33
MSG_TO           = $12BD =  4797          Strings.asm:32
NDOT             = $0DB3 =  3507          Monitor.asm:181
NEXTKEY          = $0108 =   264          Keyboard.asm:113
NXTBIT           = $0C61 =  3169          SoftSerial.asm:102
NYBASC           = $1017 =  4119          Monitor.asm:683
NYBOUT           = $1003 =  4099          Monitor.asm:648
OUTCH            = $0C44 =  3140          SoftSerial.asm:68
OUTPORT          = $0DCC =  3532          Monitor.asm:215
OUTSP            = $01E4 =   484          LCDGraphic.asm:111
OutLcdChar       = $0988 =  2440          API.asm:64
OutLcdNewLine    = $098B =  2443          API.asm:67
PLOT_COLUMN      = $0438 =  1080          LCDGraphic.asm:576
PLOT_ROW         = $0421 =  1057          LCDGraphic.asm:563
PLOT_TO_LCD      = $041C =  1052          LCDGraphic.asm:560 (unused)
PORT_OUT_VAL     = $F42E = 62510          bootV2.asm:133
PORT_SET         = $F42D = 62509          bootV2.asm:132
PRINTCHAR        = $020B =   523          LCDGraphic.asm:144
PUTCH            = $F432 = 62514          bootV2.asm:136
PrintBufferChar  = $021D =   541          LCDGraphic.asm:161
PrtIRd           = $09A4 =  2468          API.asm:88
PrtORd           = $09A0 =  2464          API.asm:84
PrtOWr           = $0994 =  2452          API.asm:75
PrtSet           = $0990 =  2448          API.asm:71
READKEY          = $0102 =   258          Keyboard.asm:108
RESET_WARM       = $0CDD =  3293          Monitor.asm:28
RST00            = $0000 =     0          bootV2.asm:160 (unused)
RST08            = $0008 =     8          bootV2.asm:164 (unused)
RST10            = $0010 =    16          bootV2.asm:167 (unused)
RST18            = $0018 =    24          bootV2.asm:170 (unused)
RST30            = $0030 =    48          bootV2.asm:173 (unused)
RXDAT1           = $0C7D =  3197          SoftSerial.asm:134
RXDAT2           = $0C95 =  3221          SoftSerial.asm:151
RXDATA           = $0C7B =  3195          SoftSerial.asm:129
SDLCDMSG1        = $0536 =  1334          LCDGraphic.asm:875
SDLCDMSG2        = $0541 =  1345          LCDGraphic.asm:881
SDMSG1           = $0C38 =  3128          SoftSerial.asm:55
SDMSG2           = $0C43 =  3139          SoftSerial.asm:61
SERIAL_RX_PORT   = $00C0 =   192          bootV2.asm:91
SERIAL_TX_PORT   = $00C0 =   192          bootV2.asm:92
SHIFTKEYMAP      = $0063 =    99          Keyboard.asm:7
SHOWHELP         = $0F9D =  3997          Monitor.asm:584
SNDLCDMSG        = $0534 =  1332          LCDGraphic.asm:873
SNDMSG           = $0C36 =  3126          SoftSerial.asm:54
SPCBUF           = $0DC6 =  3526          Monitor.asm:198
START_MONITOR    = $0CB5 =  3253          Monitor.asm:4
SYSTEM           = $FFF0 = 65520          bootV2.asm:97
ShowBufferDisplay = $09C2 =  2498          API.asm:111
SpaceOut         = $10C1 =  4289          Utils.asm:32
StrOut           = $10CA =  4298          Utils.asm:49
SysReset         = $0982 =  2434          API.asm:58
TABLE            = $0548 =  1352          LCDGraphic.asm:903
TIMEOUT          = $2710 = 10000          bootV2.asm:103
TRANSKEY         = $013B =   315          Keyboard.asm:143 (unused)
TXCRLF           = $01EA =   490          LCDGraphic.asm:118
TXDATA           = $0C50 =  3152          SoftSerial.asm:86
VT               = $000B =    11          bootV2.asm:37 (unused)
WELLCOME         = $1107 =  4359          Strings.asm:1
WRDASC           = $1009 =  4105          Monitor.asm:667
WRDOUT           = $0FFD =  4093          Monitor.asm:646
_end             = $134D =  4941          bootV2.asm:159 (unused)
_loop            = $10FB =  4347          Utils.asm:115
_overflow        = $1102 =  4354          Utils.asm:121
_size            = $134D =  4941          bootV2.asm:159 (unused)
_skip            = $1104 =  4356          Utils.asm:124
_z80_            = $0001 =     1          bootV2.asm:1 (unused)
ajustX           = $0299 =   665          LCDGraphic.asm:263
ajustXOK         = $029C =   668          LCDGraphic.asm:265
boucle_colonne   = $045D =  1117          LCDGraphic.asm:616
boucle_colonne2  = $0488 =  1160          LCDGraphic.asm:653
boucle_ligne     = $046B =  1131          LCDGraphic.asm:627
boucle_ligne2    = $0496 =  1174          LCDGraphic.asm:664
cls_GRAPHIC      = $04B7 =  1207          LCDGraphic.asm:699
cls_TXT          = $04B1 =  1201          LCDGraphic.asm:691
delay            = $036D =   877          LCDGraphic.asm:413
delayLCD         = $0510 =  1296          LCDGraphic.asm:821
delayLCDclear    = $051E =  1310          LCDGraphic.asm:837
delay_loop       = $0372 =   882          LCDGraphic.asm:418
delay_loop_b     = $0370 =   880          LCDGraphic.asm:416
enable_grafic    = $03FF =  1023          LCDGraphic.asm:539
incXOK           = $0365 =   869          LCDGraphic.asm:394
incYOK           = $035F =   863          LCDGraphic.asm:390
kAPILast         = $0013 =    19          API.asm:50
kCPUClock        = $0900 =4000000          bootV2.asm:67
kDelayCnt        = $0098 =   152          bootV2.asm:72
kDelayLP         = $001A =    26          bootV2.asm:69
kDelayOH         = $0024 =    36          bootV2.asm:68
kDelayTA         = $0FA0 =  4000          bootV2.asm:70
kDelayTB         = $0F7C =  3964          bootV2.asm:71
lcd_asciiz_char_loop = $04FD =  1277          LCDGraphic.asm:798
lcd_asciiz_done  = $050D =  1293          LCDGraphic.asm:813
lcd_asciiz_wait_loop = $04FF =  1279          LCDGraphic.asm:801 (unused)
lcd_clear        = $03F1 =  1009          LCDGraphic.asm:513
lcd_clearPixel   = $03B5 =   949          LCDGraphic.asm:470
lcd_clearPixel_bit = $03DD =   989          LCDGraphic.asm:490
lcd_clearPixel_fim = $03E6 =   998          LCDGraphic.asm:496
lcd_send_asciiz  = $04FB =  1275          LCDGraphic.asm:795 (unused)
lcd_send_command = $04DD =  1245          LCDGraphic.asm:745
lcd_send_command_clear = $04E7 =  1255          LCDGraphic.asm:761
lcd_send_data    = $04F1 =  1265          LCDGraphic.asm:776
lcd_setPixel     = $037C =   892          LCDGraphic.asm:430
lcd_setPixel_bit = $03A4 =   932          LCDGraphic.asm:451
lcd_setPixel_fim = $03AD =   941          LCDGraphic.asm:457
multY            = $02B1 =   689          LCDGraphic.asm:279
multYfim         = $02BA =   698          LCDGraphic.asm:286
multYfimok       = $02C0 =   704          LCDGraphic.asm:290
multiplication   = $10EB =  4331          Utils.asm:92
multiplicationLOOP = $10F4 =  4340          Utils.asm:99
print_char_fim   = $0368 =   872          LCDGraphic.asm:397
print_image      = $0418 =  1048          LCDGraphic.asm:555
print_image2     = $0454 =  1108          LCDGraphic.asm:602 (unused)
print_lcd        = $027A =   634          LCDGraphic.asm:239
printchar_loopH  = $02D0 =   720          LCDGraphic.asm:302
printchar_loopW  = $02DC =   732          LCDGraphic.asm:309
printchar_loopWC = $02EF =   751          LCDGraphic.asm:318
printchar_loopWE = $02F5 =   757          LCDGraphic.asm:322
ver_delete       = $022B =   555          LCDGraphic.asm:175 (unused)
ver_enter        = $0243 =   579          LCDGraphic.asm:190
ver_enter_incYOK = $025B =   603          LCDGraphic.asm:210
ver_limpa        = $0261 =   609          LCDGraphic.asm:215
ver_line         = $0273 =   627          LCDGraphic.asm:230


total time: 0.0253 sec.
no errors
