; --------------------------------------
; zasm: assemble "bootV2.asm"
; date: 2024-05-24 21:51:57
; --------------------------------------


; Diego Cruz - Nov 2022
; 
; bootV2: 
;         - CPU Z80@4Mhz
;         - Lcd Grafico 128x64
;         - Keyboard 40 keys + Shift
;         - Rom 32k 0000h - 7FFFh
;         - Ram 32k 8000h - FFFFh
;         
;
;         - Ports:
;               - Keyboard: 40H
;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
;               - User IN/OUT: C0H
;               - Leds: 00H (Red B0-B3, Green B4-B7)
;
;
;         Compiler: https://k1.spdns.de/Develop/Projects/zasm/Distributions/
;         Command line: ./zasm --z80 -w --bin  bootV2.asm
;
;
;         GRAVAÇÃO (32kb):
;	  minipro -p AT28C256 -w bootV2.rom -s	
;
;
; -----------------------------------------------------------------------------
; PORTS
; -----------------------------------------------------------------------------
LCDCTRL	    .EQU    70H
LCDDATA     .EQU    71H
KEY_IN      .EQU    40H
KEY_OUT     .EQU    40H

; -----------------------------------------------------------------------------
; CONTROL KEYS
; -----------------------------------------------------------------------------
CTRLC       .EQU    03H             ; Control "C"
CTRLG       .EQU    07H             ; Control "G"
BKSP        .EQU    08H             ; Back space
LF          .EQU    0AH             ; Line feed
VT          .equ    0BH             ; 
CS          .EQU    0CH             ; Clear screen
CR          .EQU    0DH             ; Carriage return [Enter]
CTRLO       .EQU    0FH             ; Control "O"
CTRLQ	    .EQU    11H		    ; Control "Q"
CTRLR       .EQU    12H             ; Control "R"
CTRLS       .EQU    13H             ; Control "S"
CTRLU       .EQU    15H             ; Control "U"
ESC         .EQU    1BH             ; Escape
DEL         .EQU    7FH             ; Delete

; -----------------------------------------------------------------------------
; KEYS MAP
; -----------------------------------------------------------------------------
KLEFT       .EQU    $B4             ; Key Left
KRIGHT      .EQU    $B7             ; Key Right
KUP         .EQU    $B5             ; Key Up
KDOWN       .EQU    $B6             ; Key Down
KF1         .EQU    $80             ; Key F1
KF2         .EQU    $81             ; Key F2
KF3         .EQU    $82             ; Key F3
KF4         .EQU    $83             ; Key F4
KF5         .EQU    $84             ; Key F5 (SHIFT)
KF6         .EQU    $85             ; Key F6 (SHIFT)
KF7         .EQU    $86             ; Key F7 (SHIFT)
KF8         .EQU    $87             ; Key F8 (SHIFT)

; -----------------------------------------------------------------------------
; H_Delay CONFIG
; -----------------------------------------------------------------------------
kCPUClock:  .EQU 4000000       ;CPU clock speed in Hz
kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop

; -----------------------------------------------------------------------------
; MS BASIC ENTRY POINT
; -----------------------------------------------------------------------------
BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
BASIC_W     .EQU    BASIC+2

; -----------------------------------------------------------------------------
; SOFTWARE SERIAL
; -----------------------------------------------------------------------------
;
; BAUD RATE CONSTANTS
;
B300:	.EQU	0220H	;300 BAUD
B1200:	.EQU	0080H	;1200 BAUD
B2400:	.EQU	003FH	;2400 BAUD
B4800:	.EQU	001BH	;4800 BAUD
B9600:	.EQU	000BH	;9600 BAUD

SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6

; -----------------------------------------------------------------------------
; SYSTEM SETTINGS
; -----------------------------------------------------------------------------
SYSTEM:	.EQU 	$FFF0	;INITIAL STACK POINTER

; -----------------------------------------------------------------------------
; I2C SETTINGS
; -----------------------------------------------------------------------------
I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
TIMEOUT:    .EQU 10000          ;Timeout loop counter

; -----------------------------------------------------------------------------
; LCD CONSTANTS
; -----------------------------------------------------------------------------
    ; LCD TEXT MODE
LCD_LINE1   .EQU    80H
LCD_LINE2   .EQU    90H
LCD_LINE3   .EQU    88H
LCD_LINE4   .EQU    98H

; -----------------------------------------------------------------------------
; MEMORY MAP
; -----------------------------------------------------------------------------
; $0000 - 7FFF ROM (Monitor)
; $8000 - EFFF USER RAM
; $F000 - FFFF SYSTEM MONITOR

DISPLAY             .EQU    $F000   ; 1024 bytes - Display buffer
MSGBUF:             .EQU    $F401   ; 32 bytes - STRING HANDLING AREA
DATABYTE:           .EQU    $F420   ; 1 byte - THE DATA
I2C_RAMCPY:         .EQU    $F421   ; 1 byte - RAM copy of output port
I2C_ADDR            .EQU    $F422   ; 1 byte - device address
I2C_RR              .EQU    $F423   ; 1 byte - register
I2C_DD              .EQU    $F424   ; 1 byte - data
ADDR:               .EQU    $F425   ; 2 bytes - THE ADDRESS
ADDR_FROM           .EQU    $F427   ; 2 bytes - THE ADDRESS FROM
ADDR_TO             .EQU    $F429   ; 2 bytes - THE ADDRESS TO
ADDR_SIZE           .EQU    $F42B   ; 2 bytes - THE ADDRESS SIZE
PORT_SET            .EQU    $F42D   ; 1 byte - Define port (input/output) Default 0xC0(onboard)
PORT_OUT_VAL        .EQU    $F42E   ; 1 byte - save value out port
LCD_DATA            .EQU    $F42F   ; 1 byte
BAUD:	            .EQU    $F430   ;2 bytes - BAUD RATE
PUTCH:              .EQU    $F432   ;2 bytes - OUTPUT A CHARACTER TO SERIAL
GETCH:              .EQU    $F434   ;2 bytes - WAIT FOR A CHARACTER FROM SERIAL
LCD_CHAR            .EQU    $F435   ; 1 byte char ex: 'A'
LCD_CHAR_POINT      .EQU    $F436   ; 2 bytes ponteiro para o mapa de caracteres
LCD_TXT_X           .EQU    $F438   ; 1 byte  0-20 (21 col)
LCD_TXT_Y           .EQU    $F439   ; 1 byte  0-7  (8 row)
LCD_BYTE_INDEX      .EQU    $F43A   ; 2 bytes pointer pixel(8)
LCD_BIT_INDEX       .EQU    $F43C   ; 1 byte pointer pixel(1)
LCD_TXT_X_TMP       .EQU    $F43D   ; 2 bytes = LCD_TXT_X * 6
LCD_TXT_Y_TMP       .EQU    $F43F   ; 2 bytes = LCD_TXT_Y * 128
LCD_CHAR_H          .EQU    $F441   ; 1 byte altura do char
LCD_CHAR_W          .EQU    $F442   ; 1 byte largura do char
LCD_TMP_POINT       .EQU    $F443   ; 2 bytes ponteiro do pixel altural do print
LCD_DELETE_CHAR     .EQU    $F445   ; 1 byte, 0 não, ff delete proximo char
LCD_AUTO_X          .EQU    $F446   ; 1 byte, 0 sim, ff nao
LCD_TEMP            .EQU    $F447   ; 1 byte
LCD_COOX            .EQU    $F448   ; 1 byte, local onde vai printar
LCD_COOY            .EQU    $F449   ; 1 byte
LCD_PRINT_H         .EQU    $F44A   ; 1 byte, tamanho do que vai printar
LCD_PRINT_W         .EQU    $F44B   ; 1 byte
LCD_PRINT_IMAGE     .EQU    $F44C   ; 2 bytes


        .ORG 0
RST00	DI
        JP  START_MONITOR
						
        .ORG     0008H
RST08   JP  PRINTCHAR

        .ORG 0010H
RST10   JP KEYREADINIT

        .ORG 0018H ; check break
RST18   JP CHKKEY

RST20   .ORG 0020H
        RET

RST28   .ORG 0028H
        RET

        .ORG 0030H
RST30   JP APIHandler

RST38   .ORG 0038H ; INT - MASKABLE INTERRUPT MODE-1
        RETI

RST66   .ORG 0066H ; NMI - Non­maskable Interrupt 
        RETN


; Não remover daqui...
KEYMAP:
.BYTE   "12345",KF1,"67890"
.BYTE   KF2,"QWERT",KF3,"YUIOP"
.BYTE   KF4,"ASDFG",KLEFT,"HJKL", CR
.BYTE   KDOWN,CTRLC, "ZXCV",KRIGHT,"BNM ", DEL, KUP

SHIFTKEYMAP:
.BYTE   "!@#$%",KF5,"^&*()"
.BYTE   KF6,"`~-_=",KF7,"+;:'" 
.BYTE   22h
.BYTE   KF8,"{}[]|",KLEFT,$5C,"<>?", CR
.BYTE   KDOWN,ESC,"/,. ",KRIGHT,"    ", DEL, KUP


API     .ORG 0100H ; API POINTER
#include "API.asm" ; manter essa ordem...
; **********************************************************************
; **  API - Public functions                                          **
; **********************************************************************

; API: CALLs
; Copy by APITable!
    JP  SysReset           ; 0x00 = System reset
    JP  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
    JP  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
    JP  OutLcdNewLine      ; 0x03 = Output new line LCD
    JP  H_Delay            ; 0x04 = Delay in milliseconds (DE in millis)
    JP  PrtSet             ; 0x05 = Set Port (Default C0)
    JP  PrtOWr             ; 0x06 = Write to output port
    JP  PrtORd             ; 0x07 = Read from output port
    JP  PrtIRd             ; 0x08 = Read from input port
    JP  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
    JP  DisplayImage128x64 ; 0x0A = Print image to buffer and LCD (Pointer in DE), 128x64, 1024 bytes
    JP  ClearDisplayBuffer ; 0x0B = Clear display buffer (A=$00 without show LCD, A > $00 show to LCD)
    JP  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
    JP  LcdSetCXY          ; 0x0D = LCD Cursor X (0-20), Y (0-7) value in D(X) E(Y)
    JP  BufferImage128x64  ; 0x0E = Print image to buffer without LCD, (Pointer in DE), 128x64, 1024 bytes
    JP  SysReset           ; 0x0F = Reserved
    JP  I2COpen            ; 0x10 = Start i2c (Device address in A)
    JP  I2CClose           ; 0x11 = Close i2c 
    JP  I2CRead            ; 0x12 = I2C Read
    JP  I2CWrite           ; 0x13 = I2C Write
    JP  Print8x8           ; 0x14 = Print image 8x8 bits in buffer, A = Y[7b-4b] X[3b-0b], DE = Image pointer
    JP  Clear8x8           ; 0x15 = Print image 8x8bits with 0 in buffer, A = Y[7b-4b] X[3b-0b]




; API: Main entry point
;   On entry: C = Function number
;             A, DE = Parameters (as specified by function)
;   On exit:  AF,BC,DE,HL = Return values (as specified by function)
;             IX IY I AF' BC' DE' HL' preserved
; This handler modifies: F, B, HL but preserves A, C, DE
; Other registers depend on API function called
APIHandler: LD   HL,APITable    ;Start of function address table
            LD   B,A            ;Preserve A
            LD   A,C            ;Get function number
            CP   kAPILast+1     ;Supported function?
            RET  NC             ;No, so abort
            LD   A,B            ;Restore A
            LD   B,0
            ADD  HL,BC          ;Calculate table pointer..
            ADD  HL,BC
            LD   B,(HL)         ;Read function address from table..
            INC  HL
            LD   H,(HL)
            LD   L,B
            JP   (HL)           ;Jump to function address



; API: Function address table (function in C)
; This table contains a list of addresses, one for each API function. 
; Each is the address of the subroutine for the relevant function.
APITable:   .DW  SysReset           ; 0x00 = System reset
            .DW  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
            .DW  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
            .DW  OutLcdNewLine      ; 0x03 = Output new line LCD
            .DW  H_Delay            ; 0x04 = Delay in milliseconds (DE in millis)
            .DW  PrtSet             ; 0x05 = Set Port (Default C0)
            .DW  PrtOWr             ; 0x06 = Write to output port
            .DW  PrtORd             ; 0x07 = Read from output port
            .DW  PrtIRd             ; 0x08 = Read from input port
            .DW  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
            .DW  DisplayImage128x64 ; 0x0A = Print image (Pointer in DE), 128x64, 1024 bytes
            .DW  ClearDisplayBuffer ; 0x0B = Clear display buffer (A=$00 without show LCD, A > $00 show to LCD)
            .DW  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
            .DW  LcdSetCXY          ; 0x0D = LCD Cursor X (0-20), Y (0-7) value in D(X) E(Y)
            .DW  BufferImage128x64  ; 0x0E = Print image to buffer without LCD, (Pointer in DE), 128x64, 1024 bytes
            .DW  SysReset           ; 0x0F = Reserved
            .DW  I2COpen            ; 0x10 = Start i2c (Device address in A)
            .DW  I2CClose           ; 0x11 = Close i2c 
            .DW  I2CRead            ; 0x12 = I2C Read
            .DW  I2CWrite           ; 0x13 = I2C Write
            .DW  Print8x8           ; 0x14 = Print image 8x8 bits in buffer, A = Y[7b-4b] X[3b-0b], DE = Image pointer
            .DW  Clear8x8           ; 0x15 = Print image 8x8bits with 0 in buffer, A = Y[7b-4b] X[3b-0b]
kAPILast:   .EQU $15                ;Last API function number






SysReset:
    JP RESET_WARM

InputCharKey:
    JP KEYREADINIT

OutLcdChar:
    JP PRINTCHAR

OutLcdNewLine:
    LD A, CR
    JP PRINTCHAR

PrtSet:
    LD (PORT_SET), A ; define a porta padrão de entrada e saida
    RET

PrtOWr:
    LD B, A
    LD A, (PORT_SET)
    LD C, A
    LD A, B
    LD (PORT_OUT_VAL), A
    out (C), A
    RET

PrtORd: ; Return value from output port
    LD A, (PORT_OUT_VAL)
    RET

PrtIRd: ; Return value from input
    LD A, (PORT_SET)
    LD C, A
    in A, (C)
    RET

DisplayImage128x64:
    ; copy to buffer
    LD H, D   ; FROM
    LD L, E
    LD DE, DISPLAY  ; TO
    LD BC, $0400    ; 1024 bytes to copy
    LDIR            ; Start copy
    JP ShowBufferDisplay

BufferImage128x64:
    ; copy (DE) to buffer
    LD H, D   ; FROM
    LD L, E
    LD DE, DISPLAY  ; TO
    LD BC, $0400    ; 1024 bytes to copy
    LDIR            ; Start copy
    RET

ClearDisplayBuffer:
    PUSH AF
    CALL lcd_clear
    POP AF
    OR A
    CP $00
    JP Z, ClearDisplayBufferEnd
    LD HL, DISPLAY
    JP print_image
ClearDisplayBufferEnd:
    RET

ShowBufferDisplay:
    LD HL, DISPLAY
    JP print_image

I2COpen:
    JP I2C_Open

I2CClose:
    JP I2C_Close

I2CRead:
    JP I2C_Read

I2CWrite:
    JP I2C_Write

LcdSetCXY:
    PUSH AF
    LD A, D
    LD (LCD_TXT_X), A

    LD A, E
    LD (LCD_TXT_Y), A
    POP AF
    RET
#include "Keyboard.asm"



;-----------------------------
; GET A BYTE FROM KEYBOARD
;-----------------------------
GETCHR_KEYBOARD: CALL KEYREADINIT ; read key
       CP    ESC
       JR    Z,GETOUT
       CP    CTRLC  ; key BK (reset)
       JP    Z, RESET_WARM
       LD    B,A                ;SAVE TO ECHO      
       CALL  ASC2HEX
       JR    NC,GETCHR_KEYBOARD          ;REJECT NON HEX CHARS    
       LD    HL, DATABYTE
       LD    (HL), A 
       LD    A,B         
       CALL  PRINTCHAR             ;ECHO VALID HEX
       
GETNYB: CALL  KEYREADINIT
       CP    ESC
       JR    Z,GETOUT
       CP    CTRLC  ; key BK (reset)
       JP    Z, RESET_WARM
       LD    B,A               ;SAVE TO ECHO
       CALL  ASC2HEX
       JR    NC,GETNYB         ;REJECT NON HEX CHARS
       RLD
       LD    A,B
       CALL  PRINTCHAR             ;ECHO VALID HEX
       LD    A,(HL)
       CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
       CCF                    ;AND THEN COMPLEMENTING IT
       RET   
GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
       RET
    

;----------------------------------------
; CONVERT ASCII CHARACTER INTO HEX NYBBLE
;----------------------------------------
; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
; ENTRY OTHER THAN HEXADECIMAL KEYS
;
;CONVERTS ASCII 0-9,A-F INTO HEX LSN
;ENTRY : A= ASCII 0-9,A-F
;EXIT  : CARRY =  1
;          A= HEX 0-F IN LSN    
;      : CARRY = 0
;          A= OUT OF RANGE CHARACTER & 7FH
; A AND F REGISTERS MODIFIED
;
ASC2HEX: AND   7FH        ;STRIP OUT PARITY
       CP    30H
       JR    C,AC2HEX3    ;LESS THAN 0
       CP    3AH
       JR    NC,AC2HEX2   ;MORE THAN 9
AC2HEX1: SCF               ;SET THE CARRY - IS HEX
       RET
;     
AC2HEX2: CP    41H
       JR    C,AC2HEX3    ;LESS THAN A
       CP    47H
       JR    NC,AC2HEX3   ;MORE THAN F
       SUB   07H        ;CONVERT TO NYBBLE
       JR    AC2HEX1  
AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
       RET


; -----------------------------------------------------------------------------
;   Check break key (Basic)
; -----------------------------------------------------------------------------
CHKKEY: LD  A, $40
	OUT (KEY_OUT), A ; line 4
	IN  A, (KEY_IN)
	CP  1
	JP  NZ, GRET
	LD  A, CTRLC
	CP	0
	RET
GRET:
	LD  A, 0
	CP 0
	RET



; -----------------------------------------------------------------------------
;   KEYREAD - KEY In A
; -----------------------------------------------------------------------------
KEYREADINIT:
    PUSH    BC
	PUSH	DE
	PUSH    HL
	LD      E, 0                    ; E will be the last pressed key
READKEY:        
    LD      H, 1                    ; H is the line register, start with second
	LD      B, 0                    ; Count lines for later multiplication	
	LD      D, 0                    ; DE will be the adress for mask
						
NEXTKEY:        
    LD      A, H						
    CP      0                       ; All lines tried? 
    JP      Z, KEYOUT               ; Then check if there was a key pressed
	OUT     (KEY_OUT), A		    ; Put current line to register
	IN      A, (KEY_IN)		        ; Input Keys
	AND     $3F                     ; only 6 bits
	SLA     H                       ; Next line
    INC     B
    CP      0                       ; Was key zero?
    JP      Z, NEXTKEY              ; Then try again with next lines
    LD      D, 0                    ; In D will be the number of the key
LOGARITHM:      
    INC     D	                    ; Add one per shift
    SRL     A                       ; Shift key right
    JP      NZ, LOGARITHM		    ; If not zero shift again
    DEC     D                       ; Was too much
	IN      A, (KEY_IN)
    AND     $80                     ; Check if first bit set (shift key pressed)
    JP      NZ, LOADSHIFT		    ; Then jump to read with shift
    LD      A, D                    ; Put read key into accu
    ADD     A, KEYMAP               ; Add base of key map array
    JP      ADDOFFSET               ; Jump to load key
LOADSHIFT:
    LD      A, D
    ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
ADDOFFSET:
    ADD     A, 6                    ; Add 6 for every line
    DJNZ    ADDOFFSET               ; Jump back (do while loop)
	SUB     6                       ; Since do while is one too much
TRANSKEY:
    XOR     B                       ; Empty B
	LD      C, A                    ; A will be address in BC
	LD      A, (BC)	                ; Load key
	CP      E                       ; Same key?
	JP      Z, READKEY              ; Then from beginning
	LD      E, A                    ; Otherwise save new key
	JP      READKEY	                ; And restart
KEYOUT:
    LD      A, E
    LD      E, 0                    ; empty it
    OR      A	                    ; Was a key read?
    JP      Z, READKEY              ; If not restart
    POP     HL
    POP     DE
    POP     BC
    RET
#include "LCDGraphic.asm"
; -----------------------------------------------------------------------------
;   LCD DRIVER
; -----------------------------------------------------------------------------
; INIT_LCD - Inicia o lcd em mode texto
; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
; lcd_clear - Limpa buffer do lcd
; enable_grafic - Coloca o LCD em modo grafico
; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
; cls_TXT - Limpa LCD mode text
; cls_GRAPHIC - Limpa LCD modo grafico

INIT_LCD:
    ;Initialisation
	ld a, 30H
	call lcd_send_command

	ld a, 0b00100000
	call lcd_send_command

	ld a, 30H
	call lcd_send_command

	ld a, 0CH
	call lcd_send_command

	ld a, 01H
	call lcd_send_command_clear ;; clear

	ld a, 02H
	call lcd_send_command
    RET



INIT_TXT_LCD:
    ld a, 0
    ld (LCD_TXT_X), a
    ld (LCD_TXT_Y), a
    ld (LCD_DELETE_CHAR), a
    ld (LCD_AUTO_X), a
    ld hl, 0
    ld (LCD_TXT_X_TMP), hl
    inc hl
    ld (LCD_TXT_Y_TMP), hl
    RET


DISPLAY_SCROLL_UP:
    ; cada linha tem 128 bytes
    ; temos 8 linhas
    ; total 1024 bytes

    ; display lines 0 to 7
    ; move line 1 to 0
    ld hl, DISPLAY+128
    ld de, DISPLAY
    ld bc, 127
    ldir

    ; move line 2 to 1
    ld hl, DISPLAY+256
    ld de, DISPLAY+128
    ld bc, 127
    ldir

    ; move line 3 to 2
    ld hl, DISPLAY+384
    ld de, DISPLAY+256
    ld bc, 127
    ldir

    ; move line 4 to 3
    ld hl, DISPLAY+512
    ld de, DISPLAY+384
    ld bc, 127
    ldir

    ; move line 5 to 4
    ld hl, DISPLAY+640
    ld de, DISPLAY+512
    ld bc, 127
    ldir

    ; move line 6 to 5
    ld hl, DISPLAY+768
    ld de, DISPLAY+640
    ld bc, 127
    ldir

    ; move line 7 to 6
    ld hl, DISPLAY+896
    ld de, DISPLAY+768
    ld bc, 127
    ldir

    ; clear line 7
    ; 896 to 1024
    ld hl, DISPLAY+896
    ld e,l
    ld d,h
    inc de
    ld (hl), 0
    ld bc, 127
    ldir
    RET

;---------------
; OUTPUT A SPACE
;---------------
OUTSP:  LD    A, ' '
       CALL  PRINTCHAR
       RET

;-------------      
; OUTPUT CRLF (NEW LINE)
;------------
TXCRLF: LD   A,CR
       CALL PRINTCHAR   
       RET
       

DELETE_CHAR:
    POP HL ; retorno do call
    LD A, 0
    LD (LCD_DELETE_CHAR), A
    LD A, (LCD_TXT_X)
    DEC A
    LD (LCD_TXT_X), A

    LD A, $FF
    LD (LCD_AUTO_X), A

    POP AF
    LD A, ' '
    LD (LCD_CHAR), A
    PUSH AF
    PUSH HL ; call
    RET


; Print char in buffer and show to lcd
; char in A
PRINTCHAR:
    PUSH AF
    PUSH BC
    PUSH DE
    PUSH HL
    CALL PrintBufferChar
    LD HL, DISPLAY
    CALL print_image
    POP HL
    POP DE
    POP BC
    POP AF
    RET


; Print char in buffer lcd (without show to lcd)
; char in A
PrintBufferChar:
    LD (LCD_CHAR), A ; save char to print

    PUSH AF
    PUSH BC
    PUSH DE
    PUSH HL

    PUSH AF
    LD A, $0
    LD (LCD_AUTO_X), A
    POP AF


ver_delete:
    PUSH AF
    LD A, (LCD_DELETE_CHAR)
    or a
    CP $FF
    call z, DELETE_CHAR
    POP AF
    or a
    CP $0
    jr nz, ver_enter
    LD A, $FF ; delete proximo char
    LD (LCD_DELETE_CHAR), A
    jp print_char_fim

    ; Verificar Enter, clear, etc... SEM PERDER O reg. A
ver_enter:       

                ; trata dados para o lcd
                CP      CR                     ; compara com ENTER
                jr      nz, ver_limpa

                LD A,0
                LD (LCD_TXT_X), A ; ajusta X para o inicio da linha

                LD A, (LCD_TXT_Y)
                inc a
                cp 8
                jp nz, ver_enter_incYOK
                
                CALL DISPLAY_SCROLL_UP
                ;ld hl, DISPLAY
                ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                
                jp print_char_fim

ver_enter_incYOK:
                ld (LCD_TXT_Y), a
                jp print_char_fim


ver_limpa:
                CP      $0C                     ; compara com limpar tela
                jr      NZ, ver_line
                
                ;call    clear_lcd_screen
                ;call    show_lcd_screen
                call lcd_clear
                ;ld hl, DISPLAY
                ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                LD A, 0
                LD (LCD_TXT_X), A
                LD (LCD_TXT_Y), A

                JP print_char_fim

ver_line:
                CP      LF                     ; retorna começo da linha
                jr      NZ, print_lcd      

                    ;----- verificar se precisa add algo aqui
                ;call    shift_lcd_up
                ;call    show_lcd_screen
                JP print_char_fim

print_lcd:
    ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
    ld H, 0
    ld L, A
    ADD HL, HL ; hl x 8
    ADD HL, HL
    ADD HL, HL

    LD D, H
    LD E, L
    ld hl, TABLE
    add hl, de
    ld (LCD_CHAR_POINT), HL ; table


    ; ajusta X
    ld b, 6
    ld a, (LCD_TXT_X)
    or A
    jp z, ajustX
    ld c, a
    call multiplication
    jp ajustXOK
    
ajustX:
    ld hl, 0
ajustXOK:
    ld (LCD_TXT_X_TMP), HL 



    ; ajuste Y
    ld d, 4
    ld e, 0 ; = 128x8 proxima linha
    ld hl, (LCD_TXT_Y_TMP)
    ld a, (LCD_TXT_Y)
    or a
    JP Z, multYfim
    ld hl, 0
    ld b, a
multY:
    add hl, de
    DJNZ multY

    ld (LCD_TXT_Y_TMP), HL
    jp multYfimok

multYfim:
    ld hl, 0
    ld (LCD_TXT_Y_TMP), HL

multYfimok:

    ld hl, (LCD_TXT_Y_TMP)
    ld de, (LCD_TXT_X_TMP)

    add hl, de  ; hl tem pos do pix 0-8191

    ld (LCD_TMP_POINT), hl


    ld a, 8 ; altura do caracter
    ld (LCD_CHAR_H), a
printchar_loopH:
    ld hl, (LCD_CHAR_POINT)
    ld a, (HL)
    ld (LCD_TEMP), a

    ld a, 6 ; largura do caracter
    ld (LCD_CHAR_W), a
printchar_loopW:
    ld a, (LCD_TEMP)
    and 128
    cp 0
    jp z, printchar_loopWC
    ld hl, (LCD_TMP_POINT)
    call lcd_setPixel
    JP printchar_loopWE

printchar_loopWC:
    ld hl, (LCD_TMP_POINT)
    call lcd_clearPixel

printchar_loopWE:
    ld a, (LCD_TEMP)
    sla a
    ld (LCD_TEMP), a
    
    ld hl, (LCD_TMP_POINT)
    inc hl
    ld (LCD_TMP_POINT), hl

    ld a, (LCD_CHAR_W)
    dec A
    ld (LCD_CHAR_W), a
    cp 0
    JP NZ, printchar_loopW


    ld hl, (LCD_TMP_POINT)
    dec hl
    dec hl
    dec hl
    dec hl
    dec hl
    dec hl

    ld d, 0
    ld e, 128
    add hl, de
    ld (LCD_TMP_POINT), HL

    ld hl, (LCD_CHAR_POINT)
    inc hl
    ld (LCD_CHAR_POINT), hl


    ld a, (LCD_CHAR_H)
    dec A
    ld (LCD_CHAR_H), a
    cp 0
    jp NZ, printchar_loopH

    ;ld hl, DISPLAY
    ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


    ; check auto x
    LD A, (LCD_AUTO_X)
    OR A
    CP $FF
    JP Z, print_char_fim

    ; increment X, Y
    ld a, (LCD_TXT_X)
    inc a
    cp 21
    jp nz, incXOK
    ld a, 0
    ld (LCD_TXT_X), a
    ld a, (LCD_TXT_Y)
    inc a
    cp 8
    jp nz, incYOK
    CALL DISPLAY_SCROLL_UP
    ;ld hl, DISPLAY
    ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    ld a, 0
    ld (LCD_TXT_X), a
    jp print_char_fim

incYOK:
    ld (LCD_TXT_Y), a
    jp print_char_fim

incXOK:
    ld (LCD_TXT_X), a

print_char_fim:
    ;ld hl, DISPLAY
    ;CALL print_image
    POP HL
    POP DE
    POP BC
    POP AF
    RET
;-------- FIM PRINTCHAR ------------------




; =========================================================
; Delay
; =========================================================
delay:
	push bc                       ; 2.75 us
    ld b, 1                     ; 1.75 us
delay_loop_b:
	ld c, 255                     ; 1.75 us
delay_loop:
	dec c                         ; 1 us
    jp nz, delay_loop             ; true = 3 us, false 1.75 us
    dec b                         ; 1 us
    jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
    pop bc                        ; 2.50 us
    ret   




; pixel index in HL
lcd_setPixel:
    push hl
    push bc
    push de
    push af
    xor A
    ld (LCD_BIT_INDEX), A
    ld (LCD_BYTE_INDEX), A

    ld d, 8
    call Div_HL_D
    ld (LCD_BIT_INDEX), A
    ld (LCD_BYTE_INDEX), HL
    ld BC, (LCD_BYTE_INDEX)
    ld hl, DISPLAY
    add hl, bc
    
    ld b, 128 ; 1000 0000
    ld a, (LCD_BIT_INDEX) ;
    cp 0
    jp z, lcd_setPixel_fim
lcd_setPixel_bit:
    srl B
    dec A
    jp z, lcd_setPixel_fim
    
    jp lcd_setPixel_bit
lcd_setPixel_fim
    ld a, (hl)
    or b
    ld (hl), a

    pop af
    pop bc
    pop de
    pop hl
    ret

;===============================
; pixel index in HL
lcd_clearPixel:
    push hl
    push bc
    push de
    push af
    xor A
    ld (LCD_BIT_INDEX), A
    ld (LCD_BYTE_INDEX), A
    ld d, 8
    call Div_HL_D
    ld (LCD_BIT_INDEX), A
    ld (LCD_BYTE_INDEX), HL
    ld BC, (LCD_BYTE_INDEX)
    ld hl, DISPLAY
    add hl, bc
    
    ld b, 128 ; 1000 0000
    ld a, (LCD_BIT_INDEX) ;
    cp 0
    jp z, lcd_clearPixel_fim
lcd_clearPixel_bit:
    srl B
    dec A
    jp z, lcd_clearPixel_fim
    
    jp lcd_clearPixel_bit
lcd_clearPixel_fim
    ld a, b
    cpl     ; NOT B
    ld b, a

    ld a, (hl)
    and b
    ld (hl), a

    pop af
    pop bc
    pop de
    pop hl
    ret


;;--------------------------------------------------
lcd_clear:
    PUSH HL
    PUSH DE
    ;; HL = start address of block
    ld hl, DISPLAY

    ;; DE = HL + 1
    ld e,l
    ld d,h
    inc de

    ;; initialise first byte of block
    ;; with data byte (&00)
    ld (hl), 0
        
    ;; BC = length of block in bytes
    ;; HL+BC-1 = end address of block

    ld bc, 1024

    ;; fill memory
    ldir
    POP DE
    POP HL
    ret


;===================

; grafic mode - enable
enable_grafic:
	ld a, 30H
	call lcd_send_command
	call delayLCD
	
	ld a, 34H
	call lcd_send_command
	call delayLCD
	
	ld a, 36H
	call lcd_send_command
	call delayLCD
    ret


;==========================
print_image:
        PUSH AF
        PUSH BC
        PUSH DE
        PUSH HL
PLOT_TO_LCD:	
        ;LD HL, DISPLAY
        LD C, 80H
PLOT_ROW:	
        LD A, C
        AND 9FH
        OUT (LCDCTRL), A ;Vertical
        CALL DELAY_US
        LD A, 80H
        BIT 5, C
        JR Z, $ + 4
        OR 08H
        OUT (LCDCTRL), A ;Horizontal
        CALL DELAY_US
        
        LD B, 10H 		;send eight double bytes (16 bytes)
PLOT_COLUMN:	
        LD A, (HL)
        OUT (LCDDATA), A ;Byte 1
        CALL DELAY_US
        INC HL
        DJNZ PLOT_COLUMN
        INC C
        BIT 6, C 		;Is Row = 64?
        JR Z, PLOT_ROW

        POP HL
        POP DE
        POP BC
        POP AF
        RET
        

; Delay for LCD write
DELAY_US:	
        LD DE, $0004 ;DELAY BETWEEN, was 0010H
DELAY_MS:	
        DEC DE 			;EACH BYTE
        LD A, D 		;AS PER
        OR E 			;LCD MANUFACTER'S
        JR NZ, DELAY_MS ;INSTRUCTIONS
        RET


; ======================
cls_TXT:
	; # CLEAR DISPLAY IN TEXT MODE # 
	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
	call lcd_send_command_clear		; CLEAR DISPLAY	

    ; # CLEAR DISPLAY IN TEXT MODE # 
	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
	call lcd_send_command_clear		; CLEAR DISPLAY	
    ret

; ========================

cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
					;	Graphic RAM (GDRAM) use :
					;	1. Set vertical address (Y) for GDRAM
					;	2. Set horizontal address (X) for GDRAM
					;	3. Write D15~D8 to GDRAM (first byte)
					;	4. Write D7~D0 to GDRAM (second byte)
	push bc
	push de

	ld e,$20						; e = 32 
	ld d,$0							; d = 0
Boucle32X:
		ld a,d
		OR $80
		call lcd_send_command
		
		ld a,$80					; Set horizontal address（X） for GDRAM = 0 ($80)
		call lcd_send_command
		
		xor a							 	
		ld b,$10							; b = 17
		
Boucle16X:	 
			call lcd_send_data 			; Write D15〜D8 to GDRAM (first byte)
			call lcd_send_data 			; Write D7〜D0 to GDRAM (second byte)
											; Address counter will automatically increase by one for the next two-byte data												
			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
		
		dec e 
		inc d
		xor a							; a = 0
		or e
		jp nz,Boucle32X

	pop de
	pop bc
	
    ret



;******************
;Send a command byte to the LCD
;Entry: A= command byte
;Exit: All preserved
;******************
lcd_send_command:
	push bc				;Preserve
	ld c, LCDCTRL   	;Command port
	
	call delayLCD
	
	out (c),a			;Send command
	pop bc				;Restore
	ret


;******************
;Send a command byte to the LCD
;Entry: A= command byte
;Exit: All preserved
;******************
lcd_send_command_clear:
	push bc				;Preserve
	
	call delayLCDclear
	
    ld c, LCDCTRL   	;Command port
	out (c),a			;Send command
	pop bc				;Restore
	ret
	
;******************
;Send a data byte to the LCD
;Entry: A= data byte
;Exit: All preserved
;******************
lcd_send_data:
	push bc				;Preserve
	
    ;Busy wait
	call delayLCD

	ld c, LCDDATA	;Data port $71
	out (c),a			;Send data
	pop bc				;Restore
	ret




;******************
;Send an asciiz string to the LCD
;Entry: HL=address of string
;Exit: HL=address of ending zero of the string. All others preserved
;******************
lcd_send_asciiz:
	push af
	push bc				;Preserve
lcd_asciiz_char_loop:
	ld c, LCDCTRL   	;Command port
	
lcd_asciiz_wait_loop:	;Busy wait
	call delayLCD
	
	ld a,(hl)			;Get character
	and a				;Is it zero?
	jr z,lcd_asciiz_done	;If so, we're done
	
	ld c, LCDDATA	;Data port
	out (c),a			;Send data
	inc hl				;Next char
	jr lcd_asciiz_char_loop
	
lcd_asciiz_done:
	pop bc				;Restore
	pop af
	ret

; =========================================================
; Delay LCD
; =========================================================
delayLCD:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    ret

delayLCDclear:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    NOP
    ret

;-----------------------------------------
; SEND AN ASCII STRING OUT LCD
;-----------------------------------------
; 
; SENDS A ZERO TERMINATED STRING OR 
; 128 CHARACTERS MAX. OUT LCD
;
;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
;      EXIT  : NONE
;
;       MODIFIES : A,B,C
;          
SNDLCDMSG:
    LD    B,128         ;128 CHARS MAX
SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
    CP    00H          ;ZERO TERMINATOR?
    JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
    CALL PrintBufferChar         ;TRANSMIT THE CHAR
    INC   HL
    DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
SDLCDMSG2: 
    LD HL, DISPLAY
    CALL print_image
    RET


;-----------------------------------------
; SEND AN ASCII STRING TO BUFFER
;-----------------------------------------
; 
; SENDS A ZERO TERMINATED STRING OR 
; 128 CHARACTERS MAX. TO BUFFER (NOT SHOW LCD)
;
;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
;      EXIT  : NONE
;
;       MODIFIES : A,B,C
;          
SNDBUFFERMSG:
    LD    B,128         ;128 CHARS MAX
SDBUFFERMSG1: LD    A,(HL)        ;GET THE CHAR
    CP    00H          ;ZERO TERMINATOR?
    JR    Z,SDBUFFERMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
    CALL PrintBufferChar         ;TRANSMIT THE CHAR
    INC   HL
    DJNZ  SDBUFFERMSG1        ;128 CHARS MAX!    
SDBUFFERMSG2: 
    RET


; Fill 8x8 with zero
; Print in buffer only
; A = X Y
Clear8x8:
    PUSH AF ; save A
    ; GET X
    AND $0F
    LD B, 0
    LD C, A
    LD HL, DISPLAY
    ADD HL, BC
    ; GET Y
    POP AF ; recupera A
    RRA
    RRA
    RRA
    RRA
    AND $0F
    JP Z, clear8x8_Y_OK
    LD B, A
    LD DE, $0080
clear8x8_Y:
    ADD HL, DE
    DJNZ clear8x8_Y
; Start print
clear8x8_Y_OK:
    LD A, $00 ; byte to clear
    LD (HL), A
    LD B, 7
clear8x8_loop:
    LD DE, $0010 ; soma 16 bytes
    ADD HL, DE ; next line
    LD A, $00 ; byte to clear
    LD (HL), A
    DJNZ clear8x8_loop
    RET



; Print 8x8 bits in buffer
; A = Y[7b-4b] X[3b-0b]
; DE = Image pointer
Print8x8:
    PUSH DE ; save image pointer DE
    PUSH AF ; save A
    ; GET X
    AND $0F
    LD B, 0
    LD C, A
    LD HL, DISPLAY
    ADD HL, BC
    ; GET Y
    POP AF ; recupera A
    RRA
    RRA
    RRA
    RRA
    AND $0F
    JP Z, print8x8_Y_OK
    LD B, A
    LD DE, $0080
print8x8_Y:
    ADD HL, DE
    DJNZ print8x8_Y
; Start print
print8x8_Y_OK:
    POP DE
    LD A, (DE)
    LD (HL), A
    LD B, 7
print8x8_loop:
    PUSH DE
    LD DE, $0010 ; soma 16 bytes
    ADD HL, DE ; next line
    POP DE
    INC DE ; next byte
    LD A, (DE)
    LD (HL), A
    DJNZ print8x8_loop
    ;CALL show_lcd
    RET








TABLE:
.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
.db $00, $00, $00, $00, $00, $00, $00, $00 ; US

; DEC 32
.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @

; DEC 65 Maiusculas
.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z

; DEC 91
.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
.db $40, $20, $10, $00, $00, $00, $00, $00 ; `

; DEC 97 "Minusculas"
.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z

; DEC 123
.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
#include "LoaderIntel.asm"
;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------       
INTHEX: 
       LD HL, MSG_ILOAD
       CALL  SNDLCDMSG

       LD HL, MSG_ILOAD
       CALL  SNDMSG
       

       CALL  INTELH
       JR    NZ,ITHEX1      

       LD    HL,FILEOK
       CALL  SNDLCDMSG   ;GOT FILE OK LCD
       LD    HL,FILEOK
       CALL  SNDMSG      ;GOT FILE OK Serial
       
       RET
ITHEX1: LD    HL,CSUMERR
       CALL  SNDLCDMSG

       LD    HL,CSUMERR
       CALL  SNDMSG      ;CHECKSUM ERROR
       
       RET  





;-----------------------
; RECEIVE INTEL HEX FILE
;-----------------------
INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
;
; WAIT FOR RECORD MARK
;
INTEL1:	XOR	A
	LD	(IX+3),A	;CLEAR CHECKSUM
	CALL	RXDATA	;WAIT FOR THE RECORD MARK
	CP	':'	;TO BE TRANSMITTED
	JR	NZ,INTEL1	;NOT RECORD MARK
;
; GET RECORD LENGTH
;
	CALL	GETBYT
	LD	(IX+0),A	;NUMBER OF DATA BYTES
;
; GET ADDRESS FIELD
;
	CALL	GETBYT
	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
	CALL	GETBYT
	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
;
; GET RECORD TYPE
;
	CALL	GETBYT
	JR	NZ,INTEL4	;END OF FILE RECORD
;
; READ IN THE DATA
;
	LD	B,(IX+0)	;NUMBER OF DATA BYTES
	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE

INTEL2:	CALL	GETBYT	;GET DATA BYTE
	LD	(HL),A	;STORE DATA BYTE
	INC	HL
	DJNZ	INTEL2	;LOAD MORE BYTES
;
; GET CHECKSUM AND COMPARE
;
	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE RECORD CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
    RET             ;NZ=CHECKSUM ERROR
;
; END OF FILE RECORD
;
INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
	NEG		;TWO'S COMPLEMENT
	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
	CALL	GETBYT
	LD	(IX+3),A	;SAVE EOF CHECKSUM
	CP	(IX+4)	;COMPARE CHECKSUM
	RET  	    ;NZ=CHECKSUM ERROR
;--------------------------
; GET BYTE FROM SERIAL PORT
;--------------------------
GETBYT:	PUSH	BC
	CALL	RXDATA
	BIT	6,A
	JR	Z,GETBT1
	ADD	A,09H
GETBT1:	AND	0FH
	SLA 	A
	SLA	A
	SLA	A
	SLA	A
	LD	C,A
;
; GET LOW NYBBLE
;
	CALL	RXDATA
	BIT	6,A
	JR	Z,GETBT2
	ADD	A,09H
GETBT2:	AND	0FH
	OR	C
	LD	B,A
	ADD	A,(IX+3)
	LD	(IX+3),A	;ADD TO CHECKSUM
	LD	A,B
	AND	A	;CLEAR CARRY
    POP	BC
	RET
#include "I2C.asm"
; **********************************************************************
; I2C support functions

; I2C bus open device
;   On entry: A = Device address (bit zero is read flag)
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             BC DE HL IX IY preserved
I2C_Open:   PUSH AF
            CALL I2C_Start      ;Output start condition
            POP  AF
            JR   I2C_Write      ;Write data byte


; I2C bus close device
;   On entry: SCL = unknown, SDA = unknown
;   On exit:  If successfully A=0 and Z flagged
;             If unsuccessfully A=Error and NZ flagged
;             SCL = hi, SDA = hi
;             BC DE HL IX IY preserved
I2C_Close:  JP   I2C_Stop       ;Output stop condition


; **********************************************************************
; **********************************************************************
; I2C bus master driver
; **********************************************************************
; **********************************************************************

; Functions provided are:
;     I2C_Start
;     I2C_Stop
;     I2C_Read
;     I2C_Write
;
; This code has delays between all I/O operations to ensure it works
; with the slowest I2C devices
;
; I2C transfer sequence
;   +-------+  +---------+  +---------+     +---------+  +-------+
;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
;   +-------+  +---------+  +---------+     +---------+  +-------+
;
;
; Start condition                     Stop condition
; Output by master device             Output by master device
;       ----+                                      +----
; SDA       |                         SDA          |
;           +-------                        -------+
;       -------+                                +-------
; SCL          |                      SCL       |
;              +----                        ----+
;
;
; Address frame
; Clock and data output from master device
; Receiving device outputs acknowledge 
;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
;
;
; Data frame 
; Clock output by master device
; Data output by transmitting device
; Receiving device outputs acknowledge 
;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
;


; **********************************************************************
; I2C constants


; I2C bus master interface
; The default device option is for SC126 or compatible

I2C_PORT:   .EQU $21           ;Host I2C port address
I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value


; I2C support constants
ERR_NONE:   .EQU 0              ;Error = None
ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
ERR_TOUT:   .EQU 3              ;Error = Timeout


; **********************************************************************
; Hardware dependent I2C bus functions


; I2C bus transmit frame (address or data)
;   On entry: A = Data byte, or
;                 Address byte (bit zero is read flag)
;             SCL = low, SDA = low
;   On exit:  If successful A=0 and Z flagged
;                SCL = lo, SDA = lo
;             If unsuccessful A=Error and NZ flagged
;                SCL = high, SDA = high, I2C closed
;             BC DE HL IX IY preserved
I2C_Write:  PUSH BC             ;Preserve registers
            PUSH DE
            LD   D,A            ;Store byte to be written
            LD   B,8            ;8 data bits, bit 7 first
I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
            JR   C,I2C_WriteBit_Hi      ;High, so skip
            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
            JR   I2C_WriteBit_Clk
I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
            DJNZ I2C_WriteWr_Loop
; Test for acknowledge from slave (receiver)
; On arriving here, SCL = lo, SDA = data bit
            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
            CALL I2C_RdPort     ;Read SDA input
            LD   B,A
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
            BIT  I2C_SDA_RD,B
            JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
            POP  DE             ;Restore registers
            POP  BC
            XOR  A              ;Return success A=0 and Z flagged
            RET
; I2C STOP required as no acknowledge
; On arriving here, SCL = lo, SDA = hi
I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
            POP  DE             ;Restore registers
            POP  BC
            LD   A,ERR_NOACK    ;Return error = No Acknowledge
            OR   A              ;  and NZ flagged
            RET


; I2C bus receive frame (data)
;   On entry: A = Acknowledge flag
;               If A != 0 the read is acknowledged
;             SCL low, SDA low
;   On exit:  If successful A = data byte and Z flagged
;               SCL = low, SDA = low
;             If unsuccessul* A = Error and NZ flagged
;               SCL = low, SDA = low
;             BC DE HL IX IY preserved
; *This function always returns successful
I2C_Read:   PUSH BC             ;Preserve registers
            PUSH DE
            LD   E,A            ;Store acknowledge flag
            LD   B,8            ;8 data bits, 7 first
            CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
            CALL I2C_RdPort     ;Read SDA input bit
            SCF                 ;Set carry flag
            BIT  I2C_SDA_RD,A   ;SDA input high?
            JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
            CCF                 ;Clear carry flag
I2C_ReadRotate:    RL   D              ;Rotate result into D
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
            DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
; Acknowledge input byte
; On arriving here, SCL = lo, SDA = hi/input
            LD   A,E            ;Get acknowledge flag
            OR   A              ;A = 0? (indicates no acknowledge)
            JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
            CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
            LD   A,D            ;Get data byte received
            POP  DE             ;Restore registers
            POP  BC
            CP   A              ;Return success Z flagged
            RET


; I2C bus start
;   On entry: SCL = unknown, SDA = unknown
;   On exit:  SCL = low, SDA = low
;             A = 0 and Z flagged as we always succeed
;             BC DE HL IX IY preserved
; First ensure SDA and SCL are high
I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
; Generate I2C start condition
            CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
            XOR  A              ;Return success A=0 and Z flagged
            RET


; I2C bus stop 
;   On entry: SCL = unknown, SDA = unknown
;   On exit:  SCL = high, SDA = high
;             A = 0 and Z flagged as we always succeed
;             BC DE HL IX IY preserved
; First ensure SDA and SCL are low
I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
            CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
; Generate stop condition
            CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
            CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
            XOR  A              ;Return success A=0 and Z flagged
            RET


; **********************************************************************
; I2C bus simple I/O functions
;   On entry: No parameters required
;   On exit:  BC DE HL IX IY preserved

I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
            JR   I2C_WrPort

I2C_SCL_HI: LD   A,(I2C_RAMCPY)
            SET  I2C_SCL_WR,A
            JR   I2C_WrPort

I2C_SCL_LO: LD   A,(I2C_RAMCPY)
            RES  I2C_SCL_WR,A
            JR   I2C_WrPort

I2C_SDA_HI: LD   A,(I2C_RAMCPY)
            SET  I2C_SDA_WR,A
            JR   I2C_WrPort

I2C_SDA_LO: LD   A,(I2C_RAMCPY)
            RES  I2C_SDA_WR,A

I2C_WrPort: PUSH BC             ;Preserve registers
            LD   B,0            ;Set up BC for 16-bit
            LD   C,I2C_PORT     ;  I/O address of I2C port
            OUT  (C),A          ;Write A to I2C I/O port
            LD   (I2C_RAMCPY),A ;Write A to RAM copy
            POP  BC             ;Restore registers
            RET

I2C_RdPort: PUSH BC             ;Preserve registers
            LD   B,0            ;Set up BC for 16-bit
            LD   C,I2C_PORT     ;  I/O address of I2C port
            IN   A,(C)          ;Read A from I/O port
            POP  BC             ;Restore registers
            RET



;==============================================================================
;==============================================================================
;==============================================================================
;===================       FUNCTIONS    =======================================
;==============================================================================
;==============================================================================




; **********************************************************************
; List devices found on the I2C bus
;
; Test each I2C device address and reports any that acknowledge

I2CLIST:       LD   DE,LISTMsg        ;Address of message string
            CALL StrOut         ;Output string
            LD   D,0            ;First I2C device address to test
LISTLOOP:      PUSH DE             ;Preserve DE
            LD   A,D            ;Get device address to be tested
            CALL LISTTEST          ;Test if device is present
            POP  DE             ;Restore DE
            JR   NZ,LISTNEXT       ;Skip if no acknowledge
            LD   A,D            ;Get address of device tested
            CALL HexOut         ;Output as two character hex 
            CALL SpaceOut       ;Output space character
LISTNEXT:      INC  D              ;Get next write address
            INC  D
            LD   A,D            ;Address of next device to test
            OR   A              ;Have we tested all addresses?
            JR   NZ,LISTLOOP       ;No, so loop again
            CALL LineOut        ;Output new line
            RET

; Test if device at I2C address A acknowledges
;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
;   On exit:  Z flagged if device acknowledges
;             NZ flagged if devices does not acknowledge
LISTTEST:      CALL I2C_Open       ;Open I2C device for write
            RET  NZ             ;Abort if failed to open
            CALL I2C_Close      ;Close I2C device 
            XOR  A              ;Return with Z flagged
            RET




; Copy a block from I2C memory to CPU memory
;   On entry: DE = First address in I2C memory
;             HL = First address in CPU memory
;             BC = Number of bytes to be copied
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             IX IY preserved
I2C_MemRd:  PUSH BC
            LD   BC,TIMEOUT     ;Timeout loop counter
I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
            CALL I2C_Open       ;Open for write
            JR   Z,I2C_MemRdReady       ;If open okay then skip on
            DEC  BC
            LD   A,B
            OR   C              ;Timeout?
            JR   NZ,I2C_MemRdRepeat     ;No, so go try again
            POP  BC
            LD   A,ERR_TOUT     ;Error code
            OR   A              ;Error, so NZ flagged
            RET                 ;Return with error
; Device opened okay
I2C_MemRdReady:     POP  BC             ;Restore byte counter
            LD   A,D            ;Address (hi) in I2C memory
            CALL I2C_Write      ;Write address
            LD   A,E            ;Address (lo) in I2C memory
            CALL I2C_Write      ;Write address
            LD   A,I2CA_BLOCK+1 ;I2C device to be read from
            CALL I2C_Open       ;Open for read
            RET  NZ             ;Abort if error
I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
            LD   A,B
            OR   C              ;Last byte to be read?
            CALL I2C_Read       ;Read byte with no ack on last byte
            LD   (HL),A         ;Write byte in CPU memory
            INC  HL             ;Increment CPU memory pointer
            LD   A,B
            OR   C              ;Finished?
            JR   NZ,I2C_MemRdRead       ;No, so go read next byte
            CALL I2C_Stop       ;Generate I2C stop
            XOR  A              ;Return with success (Z flagged)
            RET


; Copy a block from CPU memory to I2C memory
;   On entry: DE = First address in I2C memory
;             HL = First address in CPU memory
;             BC = Number of bytes to be copied
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             IX IY preserved
; The 24LC64 requires blocks of data to be written in 64 byte (or less)
; pages.
I2C_MemWr:  PUSH BC
            LD   BC,TIMEOUT     ;Timeout loop counter
I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
            CALL I2C_Open       ;Open for write
            JR   Z,I2C_MemWrReady       ;If open okay then skip on
            DEC  BC
            LD   A,B
            OR   C              ;Timeout?
            JR   NZ,I2C_MemWrRepeat     ;No, so go try again
            POP  BC
            LD   A,ERR_TOUT     ;Error code
            OR   A              ;Error, so NZ flagged
            RET                 ;Return with error
; Device opened okay
I2C_MemWrReady:     POP  BC             ;Restore byte counter
I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
            CALL I2C_Write      ;Write address
            LD   A,E            ;Address (lo) in I2C memory
            CALL I2C_Write      ;Write address
I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
            CALL I2C_Write      ;Read byte from I2C memory
            INC  HL             ;Increment CPU memory pointer
            INC  DE             ;Increment I2C memory pointer
            DEC  BC             ;Decrement byte counter
            LD   A,B
            OR   C              ;Finished?
            JR   Z,I2C_MemWrStore       ;Yes, so go store this page
            LD   A,E            ;Get address in I2C memory (lo byte)
            AND  63             ;64 byte page boundary?
            JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
            LD   A,B
            OR   C              ;Finished?
            JR   NZ,I2C_MemWr   ;No, so go write some more
            RET   


; Hex byte output to console
;   On entry: A = Byte to be output in hex
;   On exit:  BC DE HL IX IY preserved
HexOut:     PUSH AF             ;Preserve byte to be output
            RRA                 ;Shift top nibble to
            RRA                 ;  botom four bits..
            RRA
            RRA
            AND  $0F           ;Mask off unwanted bits
            CALL HexOutHex           ;Output hi nibble
            POP  AF             ;Restore byte to be output
            AND  $0F           ;Mask off unwanted bits
; Output nibble as ascii character
HexOutHex:       CP   $0A           ;Nibble > 10 ?
            JR   C,HexOutSkip        ;No, so skip
            ADD  A,7            ;Yes, so add 7
HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
            CALL $0008       ;Write character
            RET

#include "SoftSerial.asm"


INIT_SOFTSERIAL:
    ; init serial
    ; CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
    LD    HL,TXDATA
    LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
    LD    HL,RXDATA
    LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
    
    LD	HL,B4800
	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD

    LD A, $FF
    OUT (SERIAL_TX_PORT), A

    LD HL, WELLCOME
    CALL SNDMSG
    RET

;-----------------
; ONE SECOND DELAY
;-----------------
;
; ENTRY : NONE
; EXIT : FLAG REGISTER MODIFIED
;
DELONE:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	DE,0001H
	LD	HL,0870H
DELON1:	LD	B,92H
DELON2:	DJNZ	DELON2	;INNER LOOP
	SBC	HL,DE
	JP	NC,DELON1	;OUTER LOOP
	POP	HL
	POP	DE
	POP	BC
	RET

;-----------------------------------------
; SEND AN ASCII STRING OUT THE SERIAL PORT
;-----------------------------------------
; 
; SENDS A ZERO TERMINATED STRING OR 
; 128 CHARACTERS MAX. OUT THE SERIAL PORT
;
;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
;      EXIT  : NONE
;
;       MODIFIES : A,B,C
;          
SNDMSG: LD    B,128         ;128 CHARS MAX
SDMSG1: LD    A,(HL)        ;GET THE CHAR
       CP    00H          ;ZERO TERMINATOR?
       JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
       CALL  OUTCH         ;TRANSMIT THE CHAR
       INC   HL
       DJNZ  SDMSG1        ;128 CHARS MAX!    
SDMSG2: RET



;-----------------------------------
; OUTPUT A CHARACTER TO THE TERMINAL
;-----------------------------------       
OUTCH:  LD   IX,(PUTCH)
       JP   (IX)
;------------------------------------
; INPUT A CHARACTER FROM THE TERMINAL
;------------------------------------
INCH:  LD   IX,(GETCH)
      JP   (IX)



;------------------------
; SERIAL TRANSMIT ROUTINE
;------------------------
;TRANSMIT BYTE SERIALLY ON DOUT
;
; ENTRY : A = BYTE TO TRANSMIT
;  EXIT : NO REGISTERS MODIFIED
;
TXDATA:	PUSH	AF
	PUSH	BC
	PUSH	HL
	LD	HL,(BAUD)
	LD	C,A
;
; TRANSMIT START BIT
;
	XOR	A
	OUT	(SERIAL_TX_PORT),A
	CALL	BITIME
;
; TRANSMIT DATA
;
	LD	B,08H
	RRC	C
NXTBIT:	RRC	C	;SHIFT BITS TO D6,
	LD	A,C	;LSB FIRST AND OUTPUT
	AND	40H	;THEM FOR ONE BIT TIME.
	OUT	(SERIAL_TX_PORT),A
	CALL	BITIME
	DJNZ	NXTBIT
;
; SEND STOP BITS
;
	LD	A,40H
	OUT	(SERIAL_TX_PORT),A
	CALL	BITIME
	CALL	BITIME
	POP	HL
	POP	BC
	POP	AF
	RET
;-----------------------
; SERIAL RECEIVE ROUTINE
;-----------------------
;RECEIVE SERIAL BYTE FROM DIN
;
; ENTRY : NONE
;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
;
; REGISTERS MODIFIED A AND F
;
RXDATA:	PUSH	BC
	PUSH	HL
;
; WAIT FOR START BIT 
;
RXDAT1: IN	A,(SERIAL_RX_PORT)
	    BIT	7,A
	    JR	NZ,RXDAT1	;NO START BIT
;
; DETECTED START BIT
;
	LD	HL,(BAUD)
	SRL	H
	RR	L 	;DELAY FOR HALF BIT TIME
	CALL 	BITIME
	IN	A,(SERIAL_RX_PORT)
	BIT	7,A
	JR	NZ,RXDAT1	;START BIT NOT VALID
;
; DETECTED VALID START BIT,READ IN DATA
;
	LD	B,08H
RXDAT2:	LD	HL,(BAUD)
	CALL	BITIME	;DELAY ONE BIT TIME
	IN	A,(SERIAL_RX_PORT)
	RL	A
	RR	C	;SHIFT BIT INTO DATA REG
	DJNZ	RXDAT2
	LD	A,C
	OR	A	;CLEAR CARRY FLAG
    POP	HL
	POP	BC
	RET
;---------------
; BIT TIME DELAY
;---------------
;DELAY FOR ONE SERIAL BIT TIME
;ENTRY : HL = DELAY TIME
; NO REGISTERS MODIFIED
;
BITIME:	PUSH	HL
	PUSH	DE
	LD	DE,0001H
BITIM1:	SBC	HL,DE
	JP	NC,BITIM1
	POP	DE
	POP	HL
	RET
#include "Monitor.asm"
; -----------------------------------------------------------------------------
;   START_MONITOR
; -----------------------------------------------------------------------------
START_MONITOR:
    LD  SP, SYSTEM  ; Set stack point

    LD A, 0
    LD (PORT_OUT_VAL), A ; Set default value to port

    LD A, $c0
    LD (PORT_SET), A

    CALL INIT_SOFTSERIAL ; Initialize software serial

    ; Init LCD hardware
    CALL INIT_LCD
    call delay

    call cls_TXT
    call delay

    CALL enable_grafic
    call delay

    call cls_GRAPHIC
    call delay

RESET_WARM:
    call lcd_clear

    ; Init LCD logical
    call INIT_TXT_LCD ; set cursor X Y to 0

    LD HL, MSG_MONITOR
    CALL SNDLCDMSG

    LD A, '>'
    CALL PRINTCHAR

KEY:
    CALL KEYREADINIT

    CP 'H'
    CALL Z, SHOWHELP

    CP KF1
    JP Z, $8000

    CP KF2
    JP Z, INTEL_HEX

    CP 'B'
    JP Z, START_BASIC

    CP 'G'
    CALL Z, GOJUMP

    CP 'M'
    CALL Z, MODIFY

    CP 'D'
    CALL Z, DSPLAY

    CP 'O'
    CALL Z, OUTPORT

    CP 'I'
    CALL Z, INPORT_MON

    CP '1'
    CALL Z, I2CLIST

    CP '2'
    CALL Z, I2CCPUTOMEM

    CP '3'
    CALL Z, I2CMEMTOCPU

    CP '4'
    CALL Z, I2C_WR_DD

    CP '5'
    CALL Z, I2C_WR_RR_DD

    CP '6'
    CALL Z, I2C_RD

    CP '7'
    CALL Z, I2C_RD_RR

    CP '8'
    CALL Z, READ_MEM_FILES







    LD A, CR 
    CALL PRINTCHAR
    LD A, '>' 
    CALL PRINTCHAR

    JP  KEY



;--------------------------
; Start basic
;--------------------------
START_BASIC:
    LD A, CS
    CALL PRINTCHAR

    LD HL, MSG_BASIC
    CALL SNDLCDMSG
START_BASIC_KEY:
    CALL KEYREADINIT ; read key
    CP    'C' ; Cold
    JP    Z, BASIC
    CP    'W'  ; Warm
    JP    Z, BASIC_W
    JP START_BASIC_KEY



;--------------------------
; Read memory
;--------------------------
READ_MEM_FILES:
    LD DE, $0000 ; start "D"
READ_MEM_NEXT:
    CALL READ_IIC_DE
    OR A
    CP 'D'
    CALL Z, READ_FILE

    RET

READ_FILE:
    LD A, CR
    CALL PRINTCHAR ; new line
    LD A, CR
    CALL PRINTCHAR ; new line
    LD B, 16
READ_NAME:
    INC DE
    CALL READ_IIC_DE
    OR A
    CP 0
    CALL NZ, PRINTCHAR
    DEC B
    JP NZ, READ_NAME

READ_MEM_KEY:

    ; Show commands
    PUSH DE
    INC DE
    CALL READ_IIC_DE
    OR A
    CP 0
    CALL Z, SHOW_MSG_EXE
    CP 1
    CALL Z, SHOW_MSG_IMG
    CP 2
    CALL Z, SHOW_MSG_TXT
    POP DE

    ; wait command
    CALL KEYREADINIT ; read key
    CP    CTRLC ; key BK, read next
    JP    Z, READ_MEM_STEP
    CP    CR  ; key Enter, execute
    JP    NZ, READ_MEM_KEY

    ;read type
    INC DE
    CALL READ_IIC_DE
    OR A
    CP 0
    JP Z, READ_FILE_EXE
    CP 1
    JP Z, READ_FILE_IMG
    CP 2
    JP Z, READ_FILE_TXT
    RET

READ_MEM_STEP:
    INC DE ; type

    INC DE ; size H
    CALL READ_IIC_DE
    LD H, A

    INC DE ; size L
    CALL READ_IIC_DE
    LD L, A

READ_MEM_STEP_L:
    INC DE ; step file
    DEC HL
    LD A, H
    OR L
    JP NZ, READ_MEM_STEP_L
    INC DE ; end
    INC DE ; nex start
    JP READ_MEM_NEXT





READ_FILE_EXE:
    ; read size H
    INC DE
    CALL READ_IIC_DE
    LD B, A

    ; read size L
    INC DE
    CALL READ_IIC_DE
    LD C, A

    INC DE ; first byte file
    LD HL, $8000 ; memory user

    CALL I2C_MemRd
    POP HL ; return
    JP $8000

    RET

READ_FILE_IMG:
    ; read size H
    INC DE
    CALL READ_IIC_DE
    LD B, A

    ; read size L
    INC DE
    CALL READ_IIC_DE
    LD C, A

    INC DE ; first byte file
    LD HL, $8000 ; memory user

    CALL I2C_MemRd

    LD H, $80
    LD L, $00
    CALL print_image

READ_FILE_IMG_K:
    CALL KEYREADINIT ; read key
    CP    CTRLC ; key BK, read next
    JP    NZ, READ_FILE_IMG_K

    RET

READ_FILE_TXT:
    LD A, $0C ; clear screen
    CALL PRINTCHAR

    ; read size H
    INC DE
    CALL READ_IIC_DE
    LD B, A

    ; read size L
    INC DE
    CALL READ_IIC_DE
    LD C, A

    INC DE ; first byte file

READ_FILE_TXT_L:
    CALL READ_IIC_DE
    CALL PRINTCHAR
    INC DE ; step file
    DEC BC
    LD A, B
    OR C
    JP NZ, READ_FILE_TXT_L
    INC DE ; end
    INC DE ; nex start    
    RET


SHOW_MSG_EXE:
    LD HL, MSG_READFILE_EXE
    CALL SNDLCDMSG
    RET

SHOW_MSG_IMG:
    LD HL, MSG_READFILE_IMG
    CALL SNDLCDMSG
    RET

SHOW_MSG_TXT:
    LD HL, MSG_READFILE_TXT
    CALL SNDLCDMSG
    RET




; Read byte in i2c, address in DE, return byte in A
READ_IIC_DE:
    PUSH BC
    PUSH DE
    PUSH HL
    LD   A, I2CA_BLOCK   ;I2C address to write to
    CALL I2C_Open
    LD   A, D           ;Address (hi) in I2C memory
    CALL I2C_Write      ;Write address
    LD   A,E            ;Address (lo) in I2C memory
    CALL I2C_Write      ;Write address
    LD   A,I2CA_BLOCK+1 ;I2C device to be read from
    CALL I2C_Open       ;Open for read
    CALL I2C_Read
    PUSH AF
    CALL I2C_Stop       ;Generate I2C stop
    POP AF
    POP HL
    POP DE
    POP BC
    RET







;--------------------------
; D DISPLAY MEMORY LOCATION
;--------------------------
DSPLAY: LD A, 'D'
        CALL PRINTCHAR
        CALL  OUTSP       ;A SPACE
       CALL  GETCHR_KEYBOARD
       RET   C         
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR_KEYBOARD
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; WAIT FOR CR OR ESC
;
DPLAY1: CALL  KEYREADINIT
       CP    ESC
       RET   Z
       CP    CR
       JR    NZ,DPLAY1          
       CALL  TXCRLF      ;NEWLINE
;
; DISPLAY THE LINE
;
DPLAY2: CALL  DPLINE
       LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
;
; DISPLAY MORE LINES OR EXIT
;       
DPLAY3: CALL  KEYREADINIT
       JR    C,DPLAY3   
       CP    CR        ;ENTER DISPLAYS THE NEXT LINE
       JR    Z,DPLAY2
       CP    ESC         ;ESC EXITS (SHIFT + C)
       JR    NZ,DPLAY3     
       RET   
;-------------------------
; DISPLAY A LINE OF MEMORY
;-------------------------      
DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
       LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
;
; DISPLAY THE ADDRESS
;         
       CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
       CALL  SPCBUF        
;
; DISPLAY 4 BYTES
;
       LD    B,4 ;16
DLINE1: LD    A,(DE)
       CALL  BYTASC
       CALL  SPCBUF
       INC   DE        
       DJNZ  DLINE1
       ;CALL  SPCBUF
;
; NOW DISPLAY THE ASCII CHARACTER
; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
; BE DIFFERENT BETWEEN THE TWO PASSES!
;
       LD    DE,(ADDR)    
       LD    B,4 ; 4 bytes
DLINE2: LD    A,(DE)   
       CP    20H
       JR    C,DOT
       CP    7FH
       JR    NC,DOT
       JP    NDOT
DOT:    LD    A,'.'
NDOT:   CALL  INBUF
       INC   DE       
       DJNZ  DLINE2
;         
;TERMINATE AND DISPLAY STRING
;       
       CALL  BCRLF
       LD    A,00H
       LD    (HL),A
       LD    HL,MSGBUF
       CALL  SNDLCDMSG
       RET


;
; PUT A SPACE IN THE BUFFER
;
SPCBUF: LD    A, 8 ;20H(32dec)
INBUF:  LD    (HL),A
       INC   HL
       RET
;
; PUT A CR LF IN THE BUFFER
;        
BCRLF:  ;LD    A,CR  
       ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
       RET



;----------------------------------------------
; Output value to port
; O AA DD - Port address in AA, Data to out in DD
;----------------------------------------------
OUTPORT:
    LD A, 'O'
    CALL PrintBufferChar
    CALL OUTSP ; space and show lcd

    CALL  GETCHR_KEYBOARD 
    RET   C
    LD C, A

    CALL OUTSP

    CALL  GETCHR_KEYBOARD 
    RET   C
    OUT (C), A
    RET


;----------------------------------------------
; Read input port and show value to LCD
; I AA - Port address in AA
;----------------------------------------------
INPORT_MON:
    LD A, 'I'
    CALL PrintBufferChar
    CALL OUTSP ; space and show lcd

    CALL  GETCHR_KEYBOARD 
    RET   C
    LD C, A

    IN A, (C)

    LD B, A
    PUSH BC
    LD A, CR
    CALL PRINTCHAR
    POP BC
    LD A, B

    CALL CONV_A_HEX
    RET


; --------------------------------------
; I2C - Write one byte
; --------------------------------------
I2C_WR_DD:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    ; Show msg func
    LD HL, MSG_I2C_WR_DD
    CALL SNDLCDMSG

    ; Device Address
    CALL GET_DEV_ADDR ; get address

I2C_WR_DD_LOOP:
    ; Get Data
    CALL GET_DEV_DD   ; get data

    ; Send
    LD A, (I2C_ADDR) ; Open
    CALL I2C_Open

    LD A, (I2C_DD)  ; Data
    CALL I2C_Write
 
    CALL I2C_Close  ; Close

    JR I2C_WR_DD_LOOP

    RET



; --------------------------------------
; I2C - Write register one byte
; --------------------------------------
I2C_WR_RR_DD:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    ; Show msg func
    LD HL, MSG_I2C_WR_RR_DD
    CALL SNDLCDMSG

    ; Device Address
    CALL GET_DEV_ADDR ; get address

I2C_WR_RR_DD_LOOP:
    ; Get register
    CALL GET_DEV_RR ; get address

    ; Get Data
    CALL GET_DEV_DD   ; get data

    ; Send
    LD A, (I2C_ADDR) ; Open
    CALL I2C_Open

    LD A, (I2C_RR)  ; register
    CALL I2C_Write

    LD A, (I2C_DD)  ; Data
    CALL I2C_Write

    CALL I2C_Close  ; Close

    JR I2C_WR_RR_DD_LOOP

    RET


; --------------------------------------
; I2C - Read one byte
; --------------------------------------
I2C_RD:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    ; Show msg func
    LD HL, MSG_I2C_RD
    CALL SNDLCDMSG

    ; Device Address
    CALL GET_DEV_ADDR ; get address
    CALL TXCRLF ; new line

I2C_RD_LOOP:
    ; Send
    LD A, (I2C_ADDR) ; Open
    INC A ; To read address + 1 (flag)
    CALL I2C_Open

    CALL I2C_Read      ; Read
    PUSH AF

    CALL I2C_Close     ; Close

    ; Show
    POP AF
    CALL CONV_A_HEX ; Show A to (HEX) LCD
    CALL TXCRLF ; new line

    CALL KEYREADINIT
    CP CTRLC
    JP Z, RESET_WARM

    JR I2C_RD_LOOP
    RET


; --------------------------------------
; I2C - Read register one byte
; --------------------------------------
I2C_RD_RR:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    ; Show msg func
    LD HL, MSG_I2C_RD_RR
    CALL SNDLCDMSG

    ; Device Address
    CALL GET_DEV_ADDR ; get address

I2C_RD_RR_LOOP:
    ; Get register
    CALL GET_DEV_RR ; get address
    CALL TXCRLF ; new line

    ; Send
    LD A, (I2C_ADDR) ; Open
    CALL I2C_Open

    LD A, (I2C_RR)
    CALL I2C_Write ; Register to read

    LD A, (I2C_ADDR) ; Open
    INC A ; To read address + 1 (flag)
    CALL I2C_Open

    CALL I2C_Read ; Read register
    PUSH AF

    CALL I2C_Close ; Close

    ; Show
    POP AF
    CALL CONV_A_HEX ; Show A to (HEX) LCD

    JR I2C_RD_RR_LOOP
    RET


GET_DEV_ADDR:
    LD HL, MSG_DEV_ADDR
    CALL SNDLCDMSG
    CALL  GETCHR_KEYBOARD 
    RET   C
    LD (I2C_ADDR), A
    RET

GET_DEV_DD:
    LD HL, MSG_DEV_DATA
    CALL SNDLCDMSG

    CALL  GETCHR_KEYBOARD 
    RET   C
    LD (I2C_DD), A
    RET

GET_DEV_RR:
    LD HL, MSG_DEV_REG
    CALL SNDLCDMSG

    CALL  GETCHR_KEYBOARD 
    RET   C
    LD (I2C_RR), A
    RET




I2CMEMTOCPU:
    ; Get parameters to copy a block from I2C memory to CPU memory
;   On entry: DE = First address in I2C memory
;             HL = First address in CPU memory
;             BC = Number of bytes to be copied
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             IX IY preserved

    LD HL, MSG_MEM2CPU
    CALL SNDLCDMSG

    CALL GET_FROM_TO_SIZE

;    DE = First address in I2C memory
;    HL = First address in CPU memory
;    BC = Number of bytes to be copied

    LD DE, (ADDR_FROM)
    LD HL, (ADDR_TO)
    LD BC, (ADDR_SIZE)
I2CMEMTOCPU_BASIC:
    CALL I2C_MemRd  

    JP Z, I2CMEMTOCPU_OK
    LD HL, MSG_COPYFAIL
    CALL SNDLCDMSG
    RET
I2CMEMTOCPU_OK:
    LD HL, MSG_COPYOK
    CALL SNDLCDMSG
    RET


I2CCPUTOMEM:
; Get parameters to copy a block from CPU memory to I2C memory
;   On entry: DE = First address in I2C memory
;             HL = First address in CPU memory
;             BC = Number of bytes to be copied
;             SCL = unknown, SDA = unknown
;   On exit:  If successfully A = 0 and Z flagged
;             If unsuccessfully A = Error and NZ flagged
;             IX IY preserved
; The 24LC64 requires blocks of data to be written in 64 byte (or less)
; pages.
    LD HL, MSG_CPU2MEM
    CALL SNDLCDMSG

    CALL GET_FROM_TO_SIZE

;    DE = First address in I2C memory
;    HL = First address in CPU memory
;    BC = Number of bytes to be copied


    LD HL, (ADDR_FROM)
    LD DE, (ADDR_TO)
    LD BC, (ADDR_SIZE)
I2CCPUTOMEM_BASIC:
    CALL I2C_MemWr
    
    JP Z, I2CCPUTOMEM_OK
    LD HL, MSG_COPYFAIL
    CALL SNDLCDMSG
    RET
I2CCPUTOMEM_OK:
    LD HL, MSG_COPYOK
    CALL SNDLCDMSG
    RET






GET_FROM_TO_SIZE:
    ; FROM
    LD HL, MSG_FROM
    CALL SNDLCDMSG
    ;
    ;GET THE ADDRESS  FROM
    ;
    CALL  GETCHR_KEYBOARD 
    RET   C        
    LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
    CALL  GETCHR_KEYBOARD
    RET   C
    LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW

    CALL  KEYREADINIT
    CP    ESC         ;ESC KEY?
    RET   Z
    CP    CR
    JR Z, GET_FROM_TO_SIZE_TO
    LD A, CR
    CALL PRINTCHAR
    JP GET_FROM_TO_SIZE

GET_FROM_TO_SIZE_TO:
    ; TO
    LD HL, MSG_TO
    CALL SNDLCDMSG
    ;
    ;GET THE ADDRESS  TO
    ;
    CALL  GETCHR_KEYBOARD 
    RET   C        
    LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
    CALL  GETCHR_KEYBOARD
    RET   C
    LD    (ADDR_TO),A    ;SAVE ADDRESS LOW

    CALL  KEYREADINIT
    CP    ESC         ;ESC KEY?
    RET   Z
    CP    CR
    JR NZ, GET_FROM_TO_SIZE_TO

GET_FROM_TO_SIZE_SIZE:
    ; SIZE
    LD HL, MSG_SIZE
    CALL SNDLCDMSG
    ;
    ;GET THE SIZE
    ;
    CALL  GETCHR_KEYBOARD 
    RET   C        
    LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
    CALL  GETCHR_KEYBOARD
    RET   C
    LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW

    CALL  KEYREADINIT
    CP    ESC         ;ESC KEY?
    RET   Z
    CP    CR
    JR NZ, GET_FROM_TO_SIZE_SIZE
    RET


INTEL_HEX:
    CALL INTHEX
    CALL delay
    CALL delay
    JP START_MONITOR



BREAK_CONTINUE:
    LD HL, MSG_MENU_CONTINUE
    CALL SNDLCDMSG
BREAK_CONTINUE_LOOP:
    CALL  KEYREADINIT
    CP    CR         ;ENTER KEY?
    JP   NZ, BREAK_CONTINUE_LOOP
    RET


SHOWHELP:
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    LD HL, MSG_MENU0
    CALL SNDLCDMSG

    LD HL, MSG_MENU1
    CALL SNDLCDMSG

    LD HL, MSG_MENU2
    CALL SNDLCDMSG

    LD HL, MSG_MENU3
    CALL SNDLCDMSG

    LD HL, MSG_MENU4
    CALL SNDLCDMSG

    LD HL, MSG_MENU5
    CALL SNDLCDMSG

    LD HL, MSG_MENU6
    CALL SNDLCDMSG

    CALL BREAK_CONTINUE ; <------------
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    LD HL, MSG_MENU7
    CALL SNDLCDMSG

    LD HL, MSG_MENU8
    CALL SNDLCDMSG

    LD HL, MSG_MENU9
    CALL SNDLCDMSG

    LD HL, MSG_MENU10
    CALL SNDLCDMSG

    LD HL, MSG_MENU11
    CALL SNDLCDMSG

    LD HL, MSG_MENU12
    CALL SNDLCDMSG

    LD HL, MSG_MENU13
    CALL SNDLCDMSG

    CALL BREAK_CONTINUE ; <------------
    LD A, $0C ; limpar tela
    CALL PRINTCHAR

    LD HL, MSG_MENU14
    CALL SNDLCDMSG

    LD HL, MSG_MENU15
    CALL SNDLCDMSG

    RET



;----------------------     
; SEND ASCII HEX VALUES        
;----------------------
;
; OUTPUT THE 4 BYTE, WRDOUT
; THE 2 BYTE, BYTOUT
; OR THE SINGLE BYTE, NYBOUT
; ASCII STRING AT HL TO THE SERIAL PORT
;
WRDOUT: CALL  BYTOUT
BYTOUT: CALL  NYBOUT
NYBOUT: LD    A,(HL)
       CALL  PRINTCHAR
       INC   HL
       RET       



;----------------
;CONVERT TO ASCII 
;----------------
;
; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
;
;         ENTRY :  A = BINARY TO CONVERT
;                  HL = CHARACTER BUFFER ADDRESS   
;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
;   
;        MODIFIES : DE

WRDASC: LD    A,D         ;CONVERT AND
       CALL  BYTASC      ;OUTPUT D
       LD    A,E         ;THEN E
;
;CONVERT A BYTE TO ASCII 
;
BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
       RRCA              ;SHIFT HIGH NYBBLE ACROSS
       RRCA
       RRCA
       RRCA
       CALL NYBASC       ;CALL NYBBLE CONVERTER 
       POP AF            ;RESTORE LOW NYBBLE
;           
; CONVERT A NYBBLE TO ASCII
;
NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
       ADD   A,90H       ;CONVERT TO
       DAA               ;ASCII
       ADC   A,40H
       DAA
;            
; SAVE IN STRING
;
INSBUF: LD    (HL),A
       INC   HL 
       RET 




;----------------------------
; M DISPLAY AND MODIFY MEMORY
;----------------------------
MODIFY: LD A, 'M'
        CALL PRINTCHAR
     CALL  OUTSP
;
;GET THE ADDRESS        
;
       CALL  GETCHR_KEYBOARD 
       RET   C        
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR_KEYBOARD
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; DISPLAY ON A NEW LINE
;       
MDIFY1: CALL  TXCRLF       
       LD    DE,(ADDR)    
       LD    HL,MSGBUF   
       CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
       LD    HL,MSGBUF
       CALL  WRDOUT      ;OUTPUT THE ADDRESS
       CALL  OUTSP    
;      
;GET THE DATA AT THE ADDRESS        
;
        LD   HL,(ADDR)       
        LD   A,(HL)
;
; DISPLAY THE DATA
;        
       LD    HL,MSGBUF
       CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
       LD    HL,MSGBUF
       CALL  BYTOUT      ;OUTPUT THE BYTE
       CALL  OUTSP
;
; GET NEW DATA,EXIT OR CONTINUE
;
       CALL  GETCHR_KEYBOARD
       RET   C
       LD    B,A         ;SAVE IT FOR LATER
       LD    HL,(ADDR)
       LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
       LD    A,B
       CP    (HL)
       JR    Z,MDIFY2
       LD    A,'?'
       CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
;
; INCREMENT THE ADDRESS
;
MDIFY2: INC   HL
       LD    (ADDR),HL
       JP    MDIFY1



;------------------------------
; GO <ADDR>
; TRANSFERS EXECUTION TO <ADDR>
;------------------------------
GOJUMP_new:
    LD A, CR
    CALL PRINTCHAR

    LD A, '>'
    CALL PRINTCHAR

GOJUMP: LD A, 'G'
        CALL PRINTCHAR
       CALL  OUTSP       
       CALL  GETCHR_KEYBOARD      ;GET ADDRESS HIGH BYTE
       RET   C
       LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
       CALL  GETCHR_KEYBOARD      ;GET ADDRESS LOW BYTE
       RET   C
       LD    (ADDR),A    ;SAVE ADDRESS LOW 
;
; WAIT FOR A CR OR ESC
;       
GOJMP1: CALL  KEYREADINIT
       CP    ESC         ;ESC KEY?
       RET   Z
       CP    CR
       ;JR    NZ,GOJMP1
       JR NZ, GOJUMP_new
       CALL  TXCRLF
       POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
       LD    HL,(ADDR)
       JP    (HL)        ;GOOD LUCK WITH THAT!
#include "Utils.asm"
;----------------
;CONVERT A TO ASCII (HEX) AND SHOW LCD
;----------------
;
;CONVERT REG A BYTE TO ASCII 
;
CONV_A_HEX: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
       RRCA              ;SHIFT HIGH NYBBLE ACROSS
       RRCA
       RRCA
       RRCA
       CALL CONV_A_HEX_NYBASC       ;CALL NYBBLE CONVERTER 
       POP AF            ;RESTORE LOW NYBBLE
;           
; CONVERT A NYBBLE TO ASCII
;
CONV_A_HEX_NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
       ADD   A,90H       ;CONVERT TO
       DAA               ;ASCII
       ADC   A,40H
       DAA
;            
; Print inlcd
;
    CALL PRINTCHAR
    RET 


; Space character ouput to console
;   On entry: No parameters required
;   On exit:  BC DE HL IX IY preserved
SpaceOut:   
            LD   A,$20
            RST $08 ; output chat to lcd
            RET

; New line output to console device
;   On entry: No parameters required
;   On exit:  BC DE HL IX IY preserved
LineOut:    PUSH AF
            LD A, CR ; enter char
            RST $08
            RET


; String output to console device
;   On entry: DE = Address of string
;   On exit:  BC DE HL IX IY preserved
StrOut:     PUSH BC             ;Preserve registers
            PUSH DE
            PUSH HL
            LD H, D
            LD L, E
            CALL SNDLCDMSG
            POP  HL             ;Restore registers
            POP  DE
            POP  BC
            RET

            

; **********************************************************************
; Delay by DE milliseconds
;   On entry: DE = Delay time in milliseconds
;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
H_Delay:    PUSH AF
            PUSH BC
            PUSH DE
; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
LoopBC:    DEC  BC             ;[6]     [4]
            LD   A,C            ;[4]     [4]
            OR   B              ;[4]     [4]
            JP   NZ,LoopBC     ;[12/7]  [8/6] 
; Have we looped once for each millisecond requested?
            DEC  DE             ;[6]     [4]
            LD   A,E            ;[4]     [4]
            OR   D              ;[4]     [4]
            JR   NZ, LoopDE     ;[12/7]  [8/6]
            POP  DE
            POP  BC
            POP  AF
            RET


; ----------------------------------
; INPUT: THE VALUES IN REGISTER B EN C
; OUTPUT: HL = B * C
; CHANGES: AF,DE,HL,B
;
multiplication:
	LD HL,0
	LD A,B
	OR A
	RET Z
	LD D,0
	LD E,C
multiplicationLOOP:	ADD HL,DE
	DJNZ multiplicationLOOP
	RET 

;-----------------------------------
; Div_HL_D
;Inputs:
;   HL and D
;Outputs:
;   HL is the quotient (HL/D)
;   A is the remainder
;   B is 0
;   C,D,E are preserved
Div_HL_D:
    xor a         ; Clear upper eight bits of AHL
    ld b,16       ; Sixteen bits in dividend
_loop:
    add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
    rla           ; This moves the upper bits of the dividend into A
    jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
    cp d          ; Check if we can subtract the divisor
    jr c,_skip    ; Carry means A < D
_overflow:
    sub d         ; Do subtraction for real this time
    inc l         ; Set the next bit of the quotient (currently bit 0)
_skip:
    djnz _loop
    ret
#include "Strings.asm"
WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H

MSG_MENU0  .db "F1 RUN (JP $8000)",CR, 00H
MSG_MENU1  .db "F2 Intel hex loader",CR, 00H
MSG_MENU2  .db "B - Basic",CR, 00H
MSG_MENU3  .db "D AAAA - DISPLAY",CR,00H
MSG_MENU4  .db "M AAAA - MODIFY",CR,00H
MSG_MENU5  .db "G AAAA - GO TO",CR, 00H
MSG_MENU6  .db "O Out AA DD",CR, 00H
MSG_MENU7  .db "I In AA",CR, 00H
MSG_MENU8  .db "1 I2C Scan",CR, 00H
MSG_MENU9  .db "2 I2C PC -> MEM",CR, 00H
MSG_MENU10 .db "3 I2C MEM -> PC",CR, 00H
MSG_MENU11 .db "4 I2C WRITE DD",CR, 00H
MSG_MENU12 .db "5 I2C WRITE RR DD",CR, 00H
MSG_MENU13 .db "6 I2C READ ONE BYTE",CR, 00H
MSG_MENU14 .db "7 I2C READ RR BYTE", CR, 00H 
MSG_MENU15 .db "8 Read Memory", 00H ; ultimo não tem CR (nova linha)

MSG_MENU_CONTINUE .db "CONTINUE...", 00H


MSG_READFILE_EXE .db "_EXE", 00H
MSG_READFILE_IMG .db "_IMG", 00H
MSG_READFILE_TXT .db "_TXT", 00H

LISTMsg:    .DB  CS,"I2C device found at:",CR,0
MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H

MSG_I2C_WR_DD    .db CS,"WRITE ONE BYTE",CR, 00H
MSG_I2C_WR_RR_DD .db CS,"WRITE REG ONE BYTE",CR, 00H
MSG_I2C_RD       .db CS,"READ ONE BYTE",CR, 00H
MSG_I2C_RD_RR    .db CS,"READ REG ONE BYTE",CR, 00H

MSG_FROM    .db "FROM: ", 00H
MSG_TO      .db CR,"TO: ", 00H
MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
MSG_COPYOK  .db CR,"COPY OK", 00H
MSG_COPYFAIL  .db CR,"COPY FAIL", 00H

MSG_DEV_ADDR  .db CR,"DEVICE ADDR(AA): ", 00H
MSG_DEV_REG   .db CR,"REGISTER(RR): ", 00H
MSG_DEV_DATA  .db CR,"DATA(DD): ", 00H

MSG_BASIC .db "(C)old or (w)arm ?",CR, 00H

MSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
FILEOK    .DB      "FILE RECEIVED OK",CR,00H
CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
#include "basicV2.asm"
;==================================================================================
; The updates to the original BASIC within this file are copyright Grant Searle
;
; You have permission to use this for NON COMMERCIAL USE ONLY
; If you wish to use it elsewhere, please include an acknowledgement to myself.
;
; http://searle.hostei.com/grant/index.html
;
; eMail: home.micros01@btinternet.com
;
; If the above don't work, please perform an Internet search to see if I have
; updated the web page hosting service.
;
;==================================================================================

; GENERAL EQUATES

CTRLC   .EQU    03H             ; Control "C"
CTRLG   .EQU    07H             ; Control "G"
BKSP    .EQU    08H             ; Back space
LF      .EQU    0AH             ; Line feed
CS      .EQU    0CH             ; Clear screen
CR      .EQU    0DH             ; Carriage return
CTRLO   .EQU    0FH             ; Control "O"
CTRLQ	.EQU	11H		        ; Control "Q"
CTRLR   .EQU    12H             ; Control "R"
CTRLS   .EQU    13H             ; Control "S"
CTRLU   .EQU    15H             ; Control "U"
ESC     .EQU    1BH             ; Escape
DEL     .EQU    7FH             ; Delete


; BASIC WORK SPACE LOCATIONS

WRKSPC  .EQU    8000H             ; BASIC Work space |32768|
USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
OTPORT  .EQU    WRKSPC+7H           ; Port (p)
DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
DIV1    .EQU    WRKSPC+0AH           ; <- Values
DIV2    .EQU    WRKSPC+0EH           ; <-   to
DIV3    .EQU    WRKSPC+12H           ; <-   be
DIV4    .EQU    WRKSPC+15H           ; <-inserted
SEED    .EQU    WRKSPC+17H           ; Random number seed
LSTRND  .EQU    WRKSPC+3AH           ; Last random number
INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
NULLS   .EQU    WRKSPC+41H           ; Number of nulls
LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
COMMAN  .EQU    WRKSPC+43H           ; Width for commas
NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
LINESC  .EQU    WRKSPC+46H           ; Lines counter
LINESN  .EQU    WRKSPC+48H           ; Lines number
CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
LINEAT  .EQU    WRKSPC+5CH           ; Current line number
BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
BUFFER  .EQU    WRKSPC+61H           ; Input buffer
STACK   .EQU    WRKSPC+66H           ; Initial stack
CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
PROGND  .EQU    WRKSPC+0D6H          ; End of program
VAREND  .EQU    WRKSPC+0D8H          ; End of variables
ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
FPEXP   .EQU    FPREG+3         ; Floating point exponent
SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area |33280 + 249 = 33529|
STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test

; BASIC ERROR CODE VALUES

NF      .EQU    00H             ; NEXT without FOR
SN      .EQU    02H             ; Syntax error
RG      .EQU    04H             ; RETURN without GOSUB
OD      .EQU    06H             ; Out of DATA
FC      .EQU    08H             ; Function call error
OV      .EQU    0AH             ; Overflow
OM      .EQU    0CH             ; Out of memory
UL      .EQU    0EH             ; Undefined line number
BS      .EQU    10H             ; Bad subscript
DD      .EQU    12H             ; Re-DIMensioned array
DZ      .EQU    14H             ; Division by zero (/0)
ID      .EQU    16H             ; Illegal direct
TM      .EQU    18H             ; Type miss-match
OS      .EQU    1AH             ; Out of string space
LS      .EQU    1CH             ; String too long
ST      .EQU    1EH             ; String formula too complex
CN      .EQU    20H             ; Can't CONTinue
UF      .EQU    22H             ; UnDEFined FN function
MO      .EQU    24H             ; Missing operand
HX      .EQU    26H             ; HEX error
BN      .EQU    28H             ; BIN error

        .ORG    $6000

COLD:   JP      STARTB          ; Jump for cold start
WARM:   JP      WARMST          ; Jump for warm start
STARTB: 
        LD      IX,0            ; Flag cold start
        JP      CSTART          ; Jump to initialise

        .WORD   DEINT           ; Get integer -32768 to 32767
        .WORD   ABPASS          ; Return integer in AB


CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
        LD      SP,HL           ; Set up a temporary stack
        JP      INITST          ; Go to initialise

INIT:   LD      DE,INITAB       ; Initialise workspace
        LD      B,INITBE-INITAB+3; Bytes to copy
        LD      HL,WRKSPC       ; Into workspace RAM
COPY:   LD      A,(DE)          ; Get source
        LD      (HL),A          ; To destination
        INC     HL              ; Next destination
        INC     DE              ; Next source
        DEC     B               ; Count bytes
        JP      NZ,COPY         ; More to move
        LD      SP,HL           ; Temporary stack
        CALL    CLREG           ; Clear registers and stack
        CALL    PRNTCRLF        ; Output CRLF
        LD      (BUFFER+72+1),A ; Mark end of buffer
        LD      (PROGST),A      ; Initialise program area
MSIZE:  LD      HL,MEMMSG       ; Point to message
        CALL    PRS             ; Output "Memory size"
        CALL    PROMPT          ; Get input with '?'
        CALL    GETCHR          ; Get next character
        OR      A               ; Set flags
        JP      NZ,TSTMEM       ; If number - Test if RAM there
        LD      HL,STLOOK       ; Point to start of RAM
MLOOP:  INC     HL              ; Next byte
        LD      A,H             ; Above address FFFF ?
        OR      L
        JP      Z,SETTOP        ; Yes - 64K RAM
        LD      A,(HL)          ; Get contents
        LD      B,A             ; Save it
        CPL                     ; Flip all bits
        LD      (HL),A          ; Put it back
        CP      (HL)            ; RAM there if same
        LD      (HL),B          ; Restore old contents
        JP      Z,MLOOP         ; If RAM - test next byte
        JP      SETTOP          ; Top of RAM found

TSTMEM: CALL    ATOH            ; Get high memory into DE
        OR      A               ; Set flags on last byte
        JP      NZ,SNERR        ; ?SN Error if bad character
        EX      DE,HL           ; Address into HL
        DEC     HL              ; Back one byte
        LD      A,11011001B     ; Test byte
        LD      B,(HL)          ; Get old contents
        LD      (HL),A          ; Load test byte
        CP      (HL)            ; RAM there if same
        LD      (HL),B          ; Restore old contents
        JP      NZ,MSIZE        ; Ask again if no RAM

SETTOP: DEC     HL              ; Back one byte
        LD      DE,STLOOK-1     ; See if enough RAM
        CALL    CPDEHL          ; Compare DE with HL
        JP      C,MSIZE         ; Ask again if not enough RAM
        LD      DE,0-50         ; 50 Bytes string space
        LD      (LSTRAM),HL     ; Save last available RAM
        ADD     HL,DE           ; Allocate string space
        LD      (STRSPC),HL     ; Save string space
        CALL    CLRPTR          ; Clear program area
        LD      HL,(STRSPC)     ; Get end of memory
        LD      DE,0-17         ; Offset for free bytes
        ADD     HL,DE           ; Adjust HL
        LD      DE,PROGST       ; Start of program text
        LD      A,L             ; Get LSB
        SUB     E               ; Adjust it
        LD      L,A             ; Re-save
        LD      A,H             ; Get MSB
        SBC     A,D             ; Adjust it
        LD      H,A             ; Re-save
        PUSH    HL              ; Save bytes free
        LD      HL,SIGNON       ; Sign-on message
        CALL    PRS             ; Output string
        POP     HL              ; Get bytes free back
        CALL    PRNTHL          ; Output amount of free memory
        LD      HL,BFREE        ; " Bytes free" message
        CALL    PRS             ; Output string

WARMST: LD      SP,STACK        ; Temporary stack
BRKRET: CALL    CLREG           ; Clear registers and stack
        JP      PRNTOK          ; Go to get command line

BFREE:  .BYTE   " Bytes free",CR,LF,0,0

SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
        .BYTE   "Copyright ",40,"C",41
        .BYTE   " 1978 by Microsoft",CR,LF,0,0

MEMMSG: .BYTE   "Memory top",0

; FUNCTION ADDRESS TABLE

FNCTAB: .WORD   SGN
        .WORD   INT
        .WORD   ABS
        .WORD   USR
        .WORD   FRE
        .WORD   INP
        .WORD   POS
        .WORD   SQR
        .WORD   RND
        .WORD   LOG
        .WORD   EXP
        .WORD   COS
        .WORD   SIN
        .WORD   TAN
        .WORD   ATN
        .WORD   PEEK
        .WORD   DEEK
        .WORD   POINT
        .WORD   LEN
        .WORD   STR
        .WORD   VAL
        .WORD   ASC
        .WORD   CHR
        .WORD   HEX
        .WORD   BIN
        .WORD   LEFT
        .WORD   RIGHT
        .WORD   MID
        .WORD   DIEGO ; DIEGO
        

; RESERVED WORD LIST

WORDS:  .BYTE   'E'+80H,"ND"
        .BYTE   'F'+80H,"OR"
        .BYTE   'N'+80H,"EXT"
        .BYTE   'D'+80H,"ATA"
        .BYTE   'I'+80H,"NPUT"
        .BYTE   'D'+80H,"IM"
        .BYTE   'R'+80H,"EAD"
        .BYTE   'L'+80H,"ET"
        .BYTE   'G'+80H,"OTO"
        .BYTE   'R'+80H,"UN"
        .BYTE   'I'+80H,"F"
        .BYTE   'R'+80H,"ESTORE"
        .BYTE   'G'+80H,"OSUB"
        .BYTE   'R'+80H,"ETURN"
        .BYTE   'R'+80H,"EM"
        .BYTE   'S'+80H,"TOP"
        .BYTE   'O'+80H,"UT"
        .BYTE   'O'+80H,"N"
        .BYTE   'N'+80H,"ULL"
        .BYTE   'W'+80H,"AIT"
        .BYTE   'D'+80H,"EF"
        .BYTE   'P'+80H,"OKE"
        .BYTE   'D'+80H,"OKE"
        .BYTE   'T'+80H,"IME" ; time i2c
        .BYTE   'L'+80H,"INES"
        .BYTE   'C'+80H,"LS"
        .BYTE   'W'+80H,"IDTH"
        .BYTE   'M'+80H,"ONITOR"
        .BYTE   'S'+80H,"ET"
        .BYTE   'R'+80H,"ESET"
        .BYTE   'P'+80H,"RINT"
        .BYTE   'C'+80H,"ONT"
        .BYTE   'L'+80H,"IST"
        .BYTE   'C'+80H,"LEAR"
        .BYTE   'C'+80H,"LOAD"
        .BYTE   'C'+80H,"SAVE"
        .BYTE   'N'+80H,"EW"
        

        .BYTE   'T'+80H,"AB("
        .BYTE   'T'+80H,"O"
        .BYTE   'F'+80H,"N"
        .BYTE   'S'+80H,"PC("
        .BYTE   'T'+80H,"HEN"
        .BYTE   'N'+80H,"OT"
        .BYTE   'S'+80H,"TEP"

        .BYTE   '+'+80H
        .BYTE   '-'+80H
        .BYTE   '*'+80H
        .BYTE   '/'+80H
        .BYTE   '^'+80H
        .BYTE   'A'+80H,"ND"
        .BYTE   'O'+80H,"R"
        .BYTE   '>'+80H
        .BYTE   '='+80H
        .BYTE   '<'+80H

        .BYTE   'S'+80H,"GN"
        .BYTE   'I'+80H,"NT"
        .BYTE   'A'+80H,"BS"
        .BYTE   'U'+80H,"SR"
        .BYTE   'F'+80H,"RE"
        .BYTE   'I'+80H,"NP"
        .BYTE   'P'+80H,"OS"
        .BYTE   'S'+80H,"QR"
        .BYTE   'R'+80H,"ND"
        .BYTE   'L'+80H,"OG"
        .BYTE   'E'+80H,"XP"
        .BYTE   'C'+80H,"OS"
        .BYTE   'S'+80H,"IN"
        .BYTE   'T'+80H,"AN"
        .BYTE   'A'+80H,"TN"
        .BYTE   'P'+80H,"EEK"
        .BYTE   'D'+80H,"EEK"
        .BYTE   'P'+80H,"OINT"
        .BYTE   'L'+80H,"EN"
        .BYTE   'S'+80H,"TR$"
        .BYTE   'V'+80H,"AL"
        .BYTE   'A'+80H,"SC"
        .BYTE   'C'+80H,"HR$"
        .BYTE   'H'+80H,"EX$"
        .BYTE   'B'+80H,"IN$"
        .BYTE   'L'+80H,"EFT$"
        .BYTE   'R'+80H,"IGHT$"
        .BYTE   'M'+80H,"ID$"
        .BYTE   'D'+80H,"IEGO" ; DIEGO 37 (A5)
        .BYTE   80H             ; End of list marker

; KEYWORD ADDRESS TABLE

WORDTB: .WORD   PEND
        .WORD   FOR
        .WORD   NEXT
        .WORD   DATA
        .WORD   INPUT
        .WORD   DIM
        .WORD   READ
        .WORD   LET
        .WORD   GOTO
        .WORD   RUN
        .WORD   IF
        .WORD   RESTOR
        .WORD   GOSUB
        .WORD   RETURN
        .WORD   REM
        .WORD   STOP
        .WORD   POUT
        .WORD   ON
        .WORD   NULL
        .WORD   WAIT
        .WORD   DEF
        .WORD   POKE
        .WORD   DOKE
        .WORD   TIME
        .WORD   LINES
        .WORD   CLS
        .WORD   WIDTH
        .WORD   MONITR
        .WORD   PSET
        .WORD   RESET
        .WORD   PRINT
        .WORD   CONT
        .WORD   LIST
        .WORD   CLEAR
        .WORD   EELOAD ; LOAD
        .WORD   EESAVE ; SAVE
        .WORD   NEW
        

; RESERVED WORD TOKEN VALUES

ZEND    .EQU    080H            ; END
ZFOR    .EQU    081H            ; FOR
ZDATA   .EQU    083H            ; DATA
ZGOTO   .EQU    088H            ; GOTO
ZGOSUB  .EQU    08CH            ; GOSUB
ZREM    .EQU    08EH            ; REM
ZPRINT  .EQU    09EH            ; PRINT
ZNEW    .EQU    0A4H            ; NEW

ZTAB    .EQU    0A5H            ; TAB
ZTO     .EQU    0A6H            ; TO
ZFN     .EQU    0A7H            ; FN
ZSPC    .EQU    0A8H            ; SPC
ZTHEN   .EQU    0A9H            ; THEN
ZNOT    .EQU    0AAH            ; NOT
ZSTEP   .EQU    0ABH            ; STEP

ZPLUS   .EQU    0ACH            ; +
ZMINUS  .EQU    0ADH            ; -
ZTIMES  .EQU    0AEH            ; *
ZDIV    .EQU    0AFH            ; /
ZOR     .EQU    0B2H            ; OR
ZGTR    .EQU    0B3H            ; >
ZEQUAL  .EQU    0B4H            ; M
ZLTH    .EQU    0B5H            ; <
ZSGN    .EQU    0B6H            ; SGN
ZPOINT  .EQU    0C7H            ; POINT
ZLEFT   .EQU    0CDH +2         ; LEFT$

; ARITHMETIC PRECEDENCE TABLE

PRITAB: .BYTE   79H             ; Precedence value
        .WORD   PADD            ; FPREG = <last> + FPREG

        .BYTE   79H             ; Precedence value
        .WORD   PSUB            ; FPREG = <last> - FPREG

        .BYTE   7CH             ; Precedence value
        .WORD   MULT            ; PPREG = <last> * FPREG

        .BYTE   7CH             ; Precedence value
        .WORD   DIV             ; FPREG = <last> / FPREG

        .BYTE   7FH             ; Precedence value
        .WORD   POWER           ; FPREG = <last> ^ FPREG

        .BYTE   50H             ; Precedence value
        .WORD   PAND            ; FPREG = <last> AND FPREG

        .BYTE   46H             ; Precedence value
        .WORD   POR             ; FPREG = <last> OR FPREG

; BASIC ERROR CODE LIST

ERRORS: .BYTE   "NF"            ; NEXT without FOR
        .BYTE   "SN"            ; Syntax error
        .BYTE   "RG"            ; RETURN without GOSUB
        .BYTE   "OD"            ; Out of DATA
        .BYTE   "FC"            ; Illegal function call
        .BYTE   "OV"            ; Overflow error
        .BYTE   "OM"            ; Out of memory
        .BYTE   "UL"            ; Undefined line
        .BYTE   "BS"            ; Bad subscript
        .BYTE   "DD"            ; Re-DIMensioned array
        .BYTE   "/0"            ; Division by zero
        .BYTE   "ID"            ; Illegal direct
        .BYTE   "TM"            ; Type mis-match
        .BYTE   "OS"            ; Out of string space
        .BYTE   "LS"            ; String too long
        .BYTE   "ST"            ; String formula too complex
        .BYTE   "CN"            ; Can't CONTinue
        .BYTE   "UF"            ; Undefined FN function
        .BYTE   "MO"            ; Missing operand
        .BYTE   "HX"            ; HEX error
        .BYTE   "BN"            ; BIN error

; INITIALISATION TABLE -------------------------------------------------------

INITAB: JP      WARMST          ; Warm start jump
        JP      FCERR           ; "USR (X)" jump (Set to Error)
        OUT     (0),A           ; "OUT p,n" skeleton
        RET
        SUB     0               ; Division support routine
        LD      L,A
        LD      A,H
        SBC     A,0
        LD      H,A
        LD      A,B
        SBC     A,0
        LD      B,A
        LD      A,0
        RET
        .BYTE   0,0,0                   ; Random number seed table used by RND
        .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
        .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
        .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
        .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
        .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
        .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
        .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
        .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
        .BYTE   052H,0C7H,04FH,080H     ; Last random number
        IN      A,(0)           ; INP (x) skeleton
        RET
        .BYTE   1               ; POS (x) number (1)
        .BYTE   255             ; Terminal width (255 = no auto CRLF)
        .BYTE   28              ; Width for commas (3 columns)
        .BYTE   0               ; No nulls after input bytes
        .BYTE   0               ; Output enabled (^O off)
        .WORD   20              ; Initial lines counter
        .WORD   20              ; Initial lines number
        .WORD   0               ; Array load/save check sum
        .BYTE   0               ; Break not by NMI
        .BYTE   0               ; Break flag
        JP      TTYLIN          ; Input reflection (set to TTY)
        JP      $0000           ; POINT reflection unused
        JP      $0000           ; SET reflection
        JP      $0000          	; RESET reflection
        .WORD   STLOOK          ; Temp string space
        .WORD   -2              ; Current line number (cold)
        .WORD   PROGST+1        ; Start of program text
INITBE:                         

; END OF INITIALISATION TABLE ---------------------------------------------------

ERRMSG: .BYTE   " Error",0
INMSG:  .BYTE   " in ",0
ZERBYT  .EQU    $-1             ; A zero byte
OKMSG:  .BYTE   "Ok",CR,LF,0,0
BRKMSG: .BYTE   "Break",0

BAKSTK: LD      HL,4            ; Look for "FOR" block with
        ADD     HL,SP           ; same index as specified
LOKFOR: LD      A,(HL)          ; Get block ID
        INC     HL              ; Point to index address
        CP      ZFOR            ; Is it a "FOR" token
        RET     NZ              ; No - exit
        LD      C,(HL)          ; BC = Address of "FOR" index
        INC     HL
        LD      B,(HL)
        INC     HL              ; Point to sign of STEP
        PUSH    HL              ; Save pointer to sign
        LD      L,C             ; HL = address of "FOR" index
        LD      H,B
        LD      A,D             ; See if an index was specified
        OR      E               ; DE = 0 if no index specified
        EX      DE,HL           ; Specified index into HL
        JP      Z,INDFND        ; Skip if no index given
        EX      DE,HL           ; Index back into DE
        CALL    CPDEHL          ; Compare index with one given
INDFND: LD      BC,16-3         ; Offset to next block
        POP     HL              ; Restore pointer to sign
        RET     Z               ; Return if block found
        ADD     HL,BC           ; Point to next block
        JP      LOKFOR          ; Keep on looking

MOVUP:  CALL    ENFMEM          ; See if enough memory
MOVSTR: PUSH    BC              ; Save end of source
        EX      (SP),HL         ; Swap source and dest" end
        POP     BC              ; Get end of destination
MOVLP:  CALL    CPDEHL          ; See if list moved
        LD      A,(HL)          ; Get byte
        LD      (BC),A          ; Move it
        RET     Z               ; Exit if all done
        DEC     BC              ; Next byte to move to
        DEC     HL              ; Next byte to move
        JP      MOVLP           ; Loop until all bytes moved

CHKSTK: PUSH    HL              ; Save code string address
        LD      HL,(ARREND)     ; Lowest free memory
        LD      B,0             ; BC = Number of levels to test
        ADD     HL,BC           ; 2 Bytes for each level
        ADD     HL,BC
        .BYTE   3EH             ; Skip "PUSH HL"
ENFMEM: PUSH    HL              ; Save code string address
        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
        SUB     L
        LD      L,A
        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
        SBC     A,H
        JP      C,OMERR         ; Not enough - ?OM Error
        LD      H,A
        ADD     HL,SP           ; Test if stack is overflowed
        POP     HL              ; Restore code string address
        RET     C               ; Return if enough mmory
OMERR:  LD      E,OM            ; ?OM Error
        JP      ERROR

DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
        LD      (LINEAT),HL     ; Save as current line
SNERR:  LD      E,SN            ; ?SN Error
        .BYTE   01H             ; Skip "LD E,DZ"
DZERR:  LD      E,DZ            ; ?/0 Error
        .BYTE   01H             ; Skip "LD E,NF"
NFERR:  LD      E,NF            ; ?NF Error
        .BYTE   01H             ; Skip "LD E,DD"
DDERR:  LD      E,DD            ; ?DD Error
        .BYTE   01H             ; Skip "LD E,UF"
UFERR:  LD      E,UF            ; ?UF Error
        .BYTE   01H             ; Skip "LD E,OV
OVERR:  LD      E,OV            ; ?OV Error
        .BYTE   01H             ; Skip "LD E,TM"
TMERR:  LD      E,TM            ; ?TM Error

ERROR:  
        CALL    CLREG           ; Clear registers and stack
        LD      (CTLOFG),A      ; Enable output (A is 0)
        CALL    STTLIN          ; Start new line
        LD      HL,ERRORS       ; Point to error codes
        LD      D,A             ; D = 0 (A is 0)
        LD      A,'?'
        CALL    OUTC            ; Output '?'
        ADD     HL,DE           ; Offset to correct error code
        LD      A,(HL)          ; First character
        CALL    OUTC            ; Output it
        CALL    GETCHR          ; Get next character
        CALL    OUTC            ; Output it
        LD      HL,ERRMSG       ; "Error" message
ERRIN:  CALL    PRS             ; Output message
        LD      HL,(LINEAT)     ; Get line of error
        LD      DE,-2           ; Cold start error if -2
        CALL    CPDEHL          ; See if cold start error
        JP      Z,CSTART        ; Cold start error - Restart
        LD      A,H             ; Was it a direct error?
        AND     L               ; Line = -1 if direct error
        INC     A
        CALL    NZ,LINEIN       ; No - output line of error
        .BYTE   3EH             ; Skip "POP BC"
POPNOK: POP     BC              ; Drop address in input buffer

PRNTOK: 
        XOR     A               ; Output "Ok" and get command
        LD      (CTLOFG),A      ; Enable output
        CALL    STTLIN          ; Start new line
        LD      HL,OKMSG        ; "Ok" message
        CALL    PRS             ; Output "Ok"
GETCMD: LD      HL,-1           ; Flag direct mode
        LD      (LINEAT),HL     ; Save as current line
        CALL    GETLIN          ; Get an input line
        JP      C,GETCMD        ; Get line again if break
        CALL    GETCHR          ; Get first character
        INC     A               ; Test if end of line
        DEC     A               ; Without affecting Carry
        JP      Z,GETCMD        ; Nothing entered - Get another
        PUSH    AF              ; Save Carry status
        CALL    ATOH            ; Get line number into DE
        PUSH    DE              ; Save line number
        CALL    CRUNCH          ; Tokenise rest of line
        LD      B,A             ; Length of tokenised line
        POP     DE              ; Restore line number
        POP     AF              ; Restore Carry
        JP      NC,EXCUTE       ; No line number - Direct mode
        PUSH    DE              ; Save line number
        PUSH    BC              ; Save length of tokenised line
        XOR     A
        LD      (LSTBIN),A      ; Clear last byte input
        CALL    GETCHR          ; Get next character
        OR      A               ; Set flags
        PUSH    AF              ; And save them
        CALL    SRCHLN          ; Search for line number in DE
        JP      C,LINFND        ; Jump if line found
        POP     AF              ; Get status
        PUSH    AF              ; And re-save
        JP      Z,ULERR         ; Nothing after number - Error
        OR      A               ; Clear Carry
LINFND: PUSH    BC              ; Save address of line in prog
        JP      NC,INEWLN       ; Line not found - Insert new
        EX      DE,HL           ; Next line address in DE
        LD      HL,(PROGND)     ; End of program
SFTPRG: LD      A,(DE)          ; Shift rest of program down
        LD      (BC),A
        INC     BC              ; Next destination
        INC     DE              ; Next source
        CALL    CPDEHL          ; All done?
        JP      NZ,SFTPRG       ; More to do
        LD      H,B             ; HL - New end of program
        LD      L,C
        LD      (PROGND),HL     ; Update end of program

INEWLN: POP     DE              ; Get address of line,
        POP     AF              ; Get status
        JP      Z,SETPTR        ; No text - Set up pointers
        LD      HL,(PROGND)     ; Get end of program
        EX      (SP),HL         ; Get length of input line
        POP     BC              ; End of program to BC
        ADD     HL,BC           ; Find new end
        PUSH    HL              ; Save new end
        CALL    MOVUP           ; Make space for line
        POP     HL              ; Restore new end
        LD      (PROGND),HL     ; Update end of program pointer
        EX      DE,HL           ; Get line to move up in HL
        LD      (HL),H          ; Save MSB
        POP     DE              ; Get new line number
        INC     HL              ; Skip pointer
        INC     HL
        LD      (HL),E          ; Save LSB of line number
        INC     HL
        LD      (HL),D          ; Save MSB of line number
        INC     HL              ; To first byte in line
        LD      DE,BUFFER       ; Copy buffer to program
MOVBUF: LD      A,(DE)          ; Get source
        LD      (HL),A          ; Save destinations
        INC     HL              ; Next source
        INC     DE              ; Next destination
        OR      A               ; Done?
        JP      NZ,MOVBUF       ; No - Repeat
SETPTR: CALL    RUNFST          ; Set line pointers
        INC     HL              ; To LSB of pointer
        EX      DE,HL           ; Address to DE
PTRLP:  LD      H,D             ; Address to HL
        LD      L,E
        LD      A,(HL)          ; Get LSB of pointer
        INC     HL              ; To MSB of pointer
        OR      (HL)            ; Compare with MSB pointer
        JP      Z,GETCMD        ; Get command line if end
        INC     HL              ; To LSB of line number
        INC     HL              ; Skip line number
        INC     HL              ; Point to first byte in line
        XOR     A               ; Looking for 00 byte
FNDEND: CP      (HL)            ; Found end of line?
        INC     HL              ; Move to next byte
        JP      NZ,FNDEND       ; No - Keep looking
        EX      DE,HL           ; Next line address to HL
        LD      (HL),E          ; Save LSB of pointer
        INC     HL
        LD      (HL),D          ; Save MSB of pointer
        JP      PTRLP           ; Do next line

SRCHLN: LD      HL,(BASTXT)     ; Start of program text
SRCHLP: LD      B,H             ; BC = Address to look at
        LD      C,L
        LD      A,(HL)          ; Get address of next line
        INC     HL
        OR      (HL)            ; End of program found?
        DEC     HL
        RET     Z               ; Yes - Line not found
        INC     HL
        INC     HL
        LD      A,(HL)          ; Get LSB of line number
        INC     HL
        LD      H,(HL)          ; Get MSB of line number
        LD      L,A
        CALL    CPDEHL          ; Compare with line in DE
        LD      H,B             ; HL = Start of this line
        LD      L,C
        LD      A,(HL)          ; Get LSB of next line address
        INC     HL
        LD      H,(HL)          ; Get MSB of next line address
        LD      L,A             ; Next line to HL
        CCF
        RET     Z               ; Lines found - Exit
        CCF
        RET     NC              ; Line not found,at line after
        JP      SRCHLP          ; Keep looking

NEW:    RET     NZ              ; Return if any more on line
CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
        XOR     A               ; Set program area to empty
        LD      (HL),A          ; Save LSB = 00
        INC     HL
        LD      (HL),A          ; Save MSB = 00
        INC     HL
        LD      (PROGND),HL     ; Set program end

RUNFST: LD      HL,(BASTXT)     ; Clear all variables
        DEC     HL

INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
        LD      HL,(LSTRAM)     ; Get end of RAM
        LD      (STRBOT),HL     ; Clear string space
        XOR     A
        CALL    RESTOR          ; Reset DATA pointers
        LD      HL,(PROGND)     ; Get end of program
        LD      (VAREND),HL     ; Clear variables
        LD      (ARREND),HL     ; Clear arrays

CLREG:  POP     BC              ; Save return address
        LD      HL,(STRSPC)     ; Get end of working RAN
        LD      SP,HL           ; Set stack
        LD      HL,TMSTPL       ; Temporary string pool
        LD      (TMSTPT),HL     ; Reset temporary string ptr
        XOR     A               ; A = 00
        LD      L,A             ; HL = 0000
        LD      H,A
        LD      (CONTAD),HL     ; No CONTinue
        LD      (FORFLG),A      ; Clear FOR flag
        LD      (FNRGNM),HL     ; Clear FN argument
        PUSH    HL              ; HL = 0000
        PUSH    BC              ; Put back return
DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
        RET                     ; Return to execution driver

PROMPT: LD      A,'?'           ; '?'
        CALL    OUTC            ; Output character
        LD      A,' '           ; Space
        CALL    OUTC            ; Output character
        JP      RINPUT          ; Get input line

CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
        LD      (DATFLG),A      ; Reset literal flag
        LD      C,2+3           ; 2 byte number and 3 nulls
        LD      DE,BUFFER       ; Start of input buffer
CRNCLP: LD      A,(HL)          ; Get byte
        CP      ' '             ; Is it a space?
        JP      Z,MOVDIR        ; Yes - Copy direct
        LD      B,A             ; Save character
        CP      '"'             ; Is it a quote?
        JP      Z,CPYLIT        ; Yes - Copy literal string
        OR      A               ; Is it end of buffer?
        JP      Z,ENDBUF        ; Yes - End buffer
        LD      A,(DATFLG)      ; Get data type
        OR      A               ; Literal?
        LD      A,(HL)          ; Get byte to copy
        JP      NZ,MOVDIR       ; Literal - Copy direct
        CP      '?'             ; Is it '?' short for PRINT
        LD      A,ZPRINT        ; "PRINT" token
        JP      Z,MOVDIR        ; Yes - replace it
        LD      A,(HL)          ; Get byte again
        CP      '0'             ; Is it less than '0'
        JP      C,FNDWRD        ; Yes - Look for reserved words
        CP      60; ";"+1           ; Is it "0123456789:;" ?
        JP      C,MOVDIR        ; Yes - copy it direct
FNDWRD: PUSH    DE              ; Look for reserved words
        LD      DE,WORDS-1      ; Point to table
        PUSH    BC              ; Save count
        LD      BC,RETNAD       ; Where to return to
        PUSH    BC              ; Save return address
        LD      B,ZEND-1        ; First token value -1
        LD      A,(HL)          ; Get byte
        CP      'a'             ; Less than 'a' ?
        JP      C,SEARCH        ; Yes - search for words
        CP      'z'+1           ; Greater than 'z' ?
        JP      NC,SEARCH       ; Yes - search for words
        AND     01011111B       ; Force upper case
        LD      (HL),A          ; Replace byte
SEARCH: LD      C,(HL)          ; Search for a word
        EX      DE,HL
GETNXT: INC     HL              ; Get next reserved word
        OR      (HL)            ; Start of word?
        JP      P,GETNXT        ; No - move on
        INC     B               ; Increment token value
        LD      A, (HL)         ; Get byte from table
        AND     01111111B       ; Strip bit 7
        RET     Z               ; Return if end of list
        CP      C               ; Same character as in buffer?
        JP      NZ,GETNXT       ; No - get next word
        EX      DE,HL
        PUSH    HL              ; Save start of word

NXTBYT: INC     DE              ; Look through rest of word
        LD      A,(DE)          ; Get byte from table
        OR      A               ; End of word ?
        JP      M,MATCH         ; Yes - Match found
        LD      C,A             ; Save it
        LD      A,B             ; Get token value
        CP      ZGOTO           ; Is it "GOTO" token ?
        JP      NZ,NOSPC        ; No - Don't allow spaces
        CALL    GETCHR          ; Get next character
        DEC     HL              ; Cancel increment from GETCHR
NOSPC:  INC     HL              ; Next byte
        LD      A,(HL)          ; Get byte
        CP      'a'             ; Less than 'a' ?
        JP      C,NOCHNG        ; Yes - don't change
        AND     01011111B       ; Make upper case
NOCHNG: CP      C               ; Same as in buffer ?
        JP      Z,NXTBYT        ; Yes - keep testing
        POP     HL              ; Get back start of word
        JP      SEARCH          ; Look at next word

MATCH:  LD      C,B             ; Word found - Save token value
        POP     AF              ; Throw away return
        EX      DE,HL
        RET                     ; Return to "RETNAD"
RETNAD: EX      DE,HL           ; Get address in string
        LD      A,C             ; Get token value
        POP     BC              ; Restore buffer length
        POP     DE              ; Get destination address
MOVDIR: INC     HL              ; Next source in buffer
        LD      (DE),A          ; Put byte in buffer
        INC     DE              ; Move up buffer
        INC     C               ; Increment length of buffer
        SUB     ':'             ; End of statement?
        JP      Z,SETLIT        ; Jump if multi-statement line
        CP      ZDATA-3AH       ; Is it DATA statement ?
        JP      NZ,TSTREM       ; No - see if REM
SETLIT: LD      (DATFLG),A      ; Set literal flag
TSTREM: SUB     ZREM-3AH        ; Is it REM?
        JP      NZ,CRNCLP       ; No - Leave flag
        LD      B,A             ; Copy rest of buffer
NXTCHR: LD      A,(HL)          ; Get byte
        OR      A               ; End of line ?
        JP      Z,ENDBUF        ; Yes - Terminate buffer
        CP      B               ; End of statement ?
        JP      Z,MOVDIR        ; Yes - Get next one
CPYLIT: INC     HL              ; Move up source string
        LD      (DE),A          ; Save in destination
        INC     C               ; Increment length
        INC     DE              ; Move up destination
        JP      NXTCHR          ; Repeat

ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
        LD      (DE),A          ; Mark end of buffer (A = 00)
        INC     DE
        LD      (DE),A          ; A = 00
        INC     DE
        LD      (DE),A          ; A = 00
        RET

DODEL:  LD      A,(NULFLG)      ; Get null flag status
        OR      A               ; Is it zero?
        LD      A,0             ; Zero A - Leave flags
        LD      (NULFLG),A      ; Zero null flag
        JP      NZ,ECHDEL       ; Set - Echo it
        DEC     B               ; Decrement length
        JP      Z,GETLIN        ; Get line again if empty
        CALL    OUTC            ; Output null character
        .BYTE   3EH             ; Skip "DEC B"
ECHDEL: DEC     B               ; Count bytes in buffer
        DEC     HL              ; Back space buffer
        JP      Z,OTKLN         ; No buffer - Try again
        LD      A,(HL)          ; Get deleted byte
        CALL    OUTC            ; Echo it
        JP      MORINP          ; Get more input

DELCHR: DEC     B               ; Count bytes in buffer
        DEC     HL              ; Back space buffer
        CALL    OUTC            ; Output character in A
        JP      NZ,MORINP       ; Not end - Get more
OTKLN:  CALL    OUTC            ; Output character in A
KILIN:  CALL    PRNTCRLF        ; Output CRLF
        JP      TTYLIN          ; Get line again

GETLIN:
TTYLIN: LD      HL,BUFFER       ; Get a line by character
        LD      B,1             ; Set buffer as empty
        XOR     A
        LD      (NULFLG),A      ; Clear null flag
MORINP: CALL    CLOTST          ; Get character and test ^O
        LD      C,A             ; Save character in C
        CP      DEL             ; Delete character?
        JP      Z,DODEL         ; Yes - Process it
        LD      A,(NULFLG)      ; Get null flag
        OR      A               ; Test null flag status
        JP      Z,PROCES        ; Reset - Process character
        LD      A,0             ; Set a null
        CALL    OUTC            ; Output null
        XOR     A               ; Clear A
        LD      (NULFLG),A      ; Reset null flag
PROCES: LD      A,C             ; Get character
        CP      CTRLG           ; Bell?
        JP      Z,PUTCTL        ; Yes - Save it
        CP      CTRLC           ; Is it control "C"?
        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
        SCF                     ; Flag break
        RET     Z               ; Return if control "C"
        CP      CR              ; Is it enter?
        JP      Z,ENDINP        ; Yes - Terminate input
        CP      CTRLU           ; Is it control "U"?
        JP      Z,KILIN         ; Yes - Get another line
        CP      '@'             ; Is it "kill line"?
        JP      Z,OTKLN         ; Yes - Kill line
        CP      '_'             ; Is it delete?
        JP      Z,DELCHR        ; Yes - Delete character
        CP      BKSP            ; Is it backspace?
        JP      Z,DELCHR        ; Yes - Delete character
        CP      CTRLR           ; Is it control "R"?
        JP      NZ,PUTBUF       ; No - Put in buffer
        PUSH    BC              ; Save buffer length
        PUSH    DE              ; Save DE
        PUSH    HL              ; Save buffer address
        LD      (HL),0          ; Mark end of buffer
        CALL    OUTNCR          ; Output and do CRLF
        LD      HL,BUFFER       ; Point to buffer start
        CALL    PRS             ; Output buffer
        POP     HL              ; Restore buffer address
        POP     DE              ; Restore DE
        POP     BC              ; Restore buffer length
        JP      MORINP          ; Get another character

PUTBUF: CP      ' '             ; Is it a control code?
        JP      C,MORINP        ; Yes - Ignore
PUTCTL: LD      A,B             ; Get number of bytes in buffer
        CP      72+1            ; Test for line overflow
        LD      A,CTRLG         ; Set a bell
        JP      NC,OUTNBS       ; Ring bell if buffer full
        LD      A,C             ; Get character
        LD      (HL),C          ; Save in buffer
        LD      (LSTBIN),A      ; Save last input byte
        INC     HL              ; Move up buffer
        INC     B               ; Increment length
OUTIT:  CALL    OUTC            ; Output the character entered
        JP      MORINP          ; Get another character

OUTNBS: CALL    OUTC            ; Output bell and back over it
        LD      A,BKSP          ; Set back space
        JP      OUTIT           ; Output it and get more

CPDEHL: LD      A,H             ; Get H
        SUB     D               ; Compare with D
        RET     NZ              ; Different - Exit
        LD      A,L             ; Get L
        SUB     E               ; Compare with E
        RET                     ; Return status

CHKSYN: LD      A,(HL)          ; Check syntax of character
        EX      (SP),HL         ; Address of test byte
        CP      (HL)            ; Same as in code string?
        INC     HL              ; Return address
        EX      (SP),HL         ; Put it back
        JP      Z,GETCHR        ; Yes - Get next character
        JP      SNERR           ; Different - ?SN Error

OUTC:   PUSH    AF              ; Save character
        LD      A,(CTLOFG)      ; Get control "O" flag
        OR      A               ; Is it set?
        JP      NZ,POPAF        ; Yes - don't output
        POP     AF              ; Restore character
        PUSH    BC              ; Save buffer length
        PUSH    AF              ; Save character
        CP      ' '             ; Is it a control code?
        JP      C,DINPOS        ; Yes - Don't INC POS(X)
        LD      A,(LWIDTH)      ; Get line width
        LD      B,A             ; To B
        LD      A,(CURPOS)      ; Get cursor position
        INC     B               ; Width 255?
        JP      Z,INCLEN        ; Yes - No width limit
        DEC     B               ; Restore width
        CP      B               ; At end of line?
        CALL    Z,PRNTCRLF      ; Yes - output CRLF
INCLEN: INC     A               ; Move on one character
        LD      (CURPOS),A      ; Save new position
DINPOS: POP     AF              ; Restore character
        POP     BC              ; Restore buffer length
        CALL    MONOUT          ; Send it
        RET

CLOTST: CALL    GETINP          ; Get input character
        AND     01111111B       ; Strip bit 7
        CP      CTRLO           ; Is it control "O"?
        RET     NZ              ; No don't flip flag
        LD      A,(CTLOFG)      ; Get flag
        CPL                     ; Flip it
        LD      (CTLOFG),A      ; Put it back
        XOR     A               ; Null character
        RET

LIST:   CALL    ATOH            ; ASCII number to DE
        RET     NZ              ; Return if anything extra
        POP     BC              ; Rubbish - Not needed
        CALL    SRCHLN          ; Search for line number in DE
        PUSH    BC              ; Save address of line
        CALL    SETLIN          ; Set up lines counter
LISTLP: POP     HL              ; Restore address of line
        LD      C,(HL)          ; Get LSB of next line
        INC     HL
        LD      B,(HL)          ; Get MSB of next line
        INC     HL
        LD      A,B             ; BC = 0 (End of program)?
        OR      C
        JP      Z,PRNTOK        ; Yes - Go to command mode
        CALL    COUNT           ; Count lines
        CALL    TSTBRK          ; Test for break key
        PUSH    BC              ; Save address of next line
        CALL    PRNTCRLF        ; Output CRLF
        LD      E,(HL)          ; Get LSB of line number
        INC     HL
        LD      D,(HL)          ; Get MSB of line number
        INC     HL
        PUSH    HL              ; Save address of line start
        EX      DE,HL           ; Line number to HL
        CALL    PRNTHL          ; Output line number in decimal
        LD      A,' '           ; Space after line number
        POP     HL              ; Restore start of line address
LSTLP2: CALL    OUTC            ; Output character in A
LSTLP3: LD      A,(HL)          ; Get next byte in line
        OR      A               ; End of line?
        INC     HL              ; To next byte in line
        JP      Z,LISTLP        ; Yes - get next line
        JP      P,LSTLP2        ; No token - output it
        SUB     ZEND-1          ; Find and output word
        LD      C,A             ; Token offset+1 to C
        LD      DE,WORDS        ; Reserved word list
FNDTOK: LD      A,(DE)          ; Get character in list
        INC     DE              ; Move on to next
        OR      A               ; Is it start of word?
        JP      P,FNDTOK        ; No - Keep looking for word
        DEC     C               ; Count words
        JP      NZ,FNDTOK       ; Not there - keep looking
OUTWRD: AND     01111111B       ; Strip bit 7
        CALL    OUTC            ; Output first character
        LD      A,(DE)          ; Get next character
        INC     DE              ; Move on to next
        OR      A               ; Is it end of word?
        JP      P,OUTWRD        ; No - output the rest
        JP      LSTLP3          ; Next byte in line

SETLIN: PUSH    HL              ; Set up LINES counter
        LD      HL,(LINESN)     ; Get LINES number
        LD      (LINESC),HL     ; Save in LINES counter
        POP     HL
        RET

COUNT:  PUSH    HL              ; Save code string address
        PUSH    DE
        LD      HL,(LINESC)     ; Get LINES counter
        LD      DE,-1
        ADC     HL,DE           ; Decrement
        LD      (LINESC),HL     ; Put it back
        POP     DE
        POP     HL              ; Restore code string address
        RET     P               ; Return if more lines to go
        PUSH    HL              ; Save code string address
        LD      HL,(LINESN)     ; Get LINES number
        LD      (LINESC),HL     ; Reset LINES counter
        CALL    GETINP          ; Get input character
        CP      CTRLC           ; Is it control "C"?
        JP      Z,RSLNBK        ; Yes - Reset LINES and break
        POP     HL              ; Restore code string address
        JP      COUNT           ; Keep on counting

RSLNBK: LD      HL,(LINESN)     ; Get LINES number
        LD      (LINESC),HL     ; Reset LINES counter
        JP      BRKRET          ; Go and output "Break"

FOR:    LD      A,64H           ; Flag "FOR" assignment
        LD      (FORFLG),A      ; Save "FOR" flag
        CALL    LET             ; Set up initial index
        POP     BC              ; Drop RETurn address
        PUSH    HL              ; Save code string address
        CALL    DATA            ; Get next statement address
        LD      (LOOPST),HL     ; Save it for start of loop
        LD      HL,2            ; Offset for "FOR" block
        ADD     HL,SP           ; Point to it
FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
        POP     DE              ; Get code string address
        JP      NZ,FORFND       ; No nesting found
        ADD     HL,BC           ; Move into "FOR" block
        PUSH    DE              ; Save code string address
        DEC     HL
        LD      D,(HL)          ; Get MSB of loop statement
        DEC     HL
        LD      E,(HL)          ; Get LSB of loop statement
        INC     HL
        INC     HL
        PUSH    HL              ; Save block address
        LD      HL,(LOOPST)     ; Get address of loop statement
        CALL    CPDEHL          ; Compare the FOR loops
        POP     HL              ; Restore block address
        JP      NZ,FORSLP       ; Different FORs - Find another
        POP     DE              ; Restore code string address
        LD      SP,HL           ; Remove all nested loops

FORFND: EX      DE,HL           ; Code string address to HL
        LD      C,8
        CALL    CHKSTK          ; Check for 8 levels of stack
        PUSH    HL              ; Save code string address
        LD      HL,(LOOPST)     ; Get first statement of loop
        EX      (SP),HL         ; Save and restore code string
        PUSH    HL              ; Re-save code string address
        LD      HL,(LINEAT)     ; Get current line number
        EX      (SP),HL         ; Save and restore code string
        CALL    TSTNUM          ; Make sure it's a number
        CALL    CHKSYN          ; Make sure "TO" is next
        .BYTE   ZTO          ; "TO" token
        CALL    GETNUM          ; Get "TO" expression value
        PUSH    HL              ; Save code string address
        CALL    BCDEFP          ; Move "TO" value to BCDE
        POP     HL              ; Restore code string address
        PUSH    BC              ; Save "TO" value in block
        PUSH    DE
        LD      BC,8100H        ; BCDE - 1 (default STEP)
        LD      D,C             ; C=0
        LD      E,D             ; D=0
        LD      A,(HL)          ; Get next byte in code string
        CP      ZSTEP           ; See if "STEP" is stated
        LD      A,1             ; Sign of step = 1
        JP      NZ,SAVSTP       ; No STEP given - Default to 1
        CALL    GETCHR          ; Jump over "STEP" token
        CALL    GETNUM          ; Get step value
        PUSH    HL              ; Save code string address
        CALL    BCDEFP          ; Move STEP to BCDE
        CALL    TSTSGN          ; Test sign of FPREG
        POP     HL              ; Restore code string address
SAVSTP: PUSH    BC              ; Save the STEP value in block
        PUSH    DE
        PUSH    AF              ; Save sign of STEP
        INC     SP              ; Don't save flags
        PUSH    HL              ; Save code string address
        LD      HL,(BRKLIN)     ; Get address of index variable
        EX      (SP),HL         ; Save and restore code string
PUTFID: LD      B,ZFOR          ; "FOR" block marker
        PUSH    BC              ; Save it
        INC     SP              ; Don't save C

RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
        LD      (BRKLIN),HL     ; Save code address for break
        LD      A,(HL)          ; Get next byte in code string
        CP      ':'             ; Multi statement line?
        JP      Z,EXCUTE        ; Yes - Execute it
        OR      A               ; End of line?
        JP      NZ,SNERR        ; No - Syntax error
        INC     HL              ; Point to address of next line
        LD      A,(HL)          ; Get LSB of line pointer
        INC     HL
        OR      (HL)            ; Is it zero (End of prog)?
        JP      Z,ENDPRG        ; Yes - Terminate execution
        INC     HL              ; Point to line number
        LD      E,(HL)          ; Get LSB of line number
        INC     HL
        LD      D,(HL)          ; Get MSB of line number
        EX      DE,HL           ; Line number to HL
        LD      (LINEAT),HL     ; Save as current line number
        EX      DE,HL           ; Line number back to DE
EXCUTE: CALL    GETCHR          ; Get key word
        LD      DE,RUNCNT       ; Where to RETurn to
        PUSH    DE              ; Save for RETurn
IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
ONJMP:  SUB     ZEND            ; Is it a token?
        JP      C,LET           ; No - try to assign it
        CP      ZNEW+1-ZEND     ; END to NEW ?
        JP      NC,SNERR        ; Not a key word - ?SN Error
        RLCA                    ; Double it
        LD      C,A             ; BC = Offset into table
        LD      B,0
        EX      DE,HL           ; Save code string address
        LD      HL,WORDTB       ; Keyword address table
        ADD     HL,BC           ; Point to routine address
        LD      C,(HL)          ; Get LSB of routine address
        INC     HL
        LD      B,(HL)          ; Get MSB of routine address
        PUSH    BC              ; Save routine address
        EX      DE,HL           ; Restore code string address

GETCHR: INC     HL              ; Point to next character
        LD      A,(HL)          ; Get next code string byte
        CP      ':'             ; Z if ':'
        RET     NC              ; NC if > "9"
        CP      ' '
        JP      Z,GETCHR        ; Skip over spaces
        CP      '0'
        CCF                     ; NC if < '0'
        INC     A               ; Test for zero - Leave carry
        DEC     A               ; Z if Null
        RET

RESTOR: EX      DE,HL           ; Save code string address
        LD      HL,(BASTXT)     ; Point to start of program
        JP      Z,RESTNL        ; Just RESTORE - reset pointer
        EX      DE,HL           ; Restore code string address
        CALL    ATOH            ; Get line number to DE
        PUSH    HL              ; Save code string address
        CALL    SRCHLN          ; Search for line number in DE
        LD      H,B             ; HL = Address of line
        LD      L,C
        POP     DE              ; Restore code string address
        JP      NC,ULERR        ; ?UL Error if not found
RESTNL: DEC     HL              ; Byte before DATA statement
UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
        EX      DE,HL           ; Restore code string address
        RET


TSTBRK: RST     18H             ; Check input status
        RET     Z               ; No key, go back
        RST     10H             ; Get the key into A
        CP      ESC             ; Escape key?
        JR      Z,BRK           ; Yes, break
        CP      CTRLC           ; <Ctrl-C>
        JR      Z,BRK           ; Yes, break
        CP      CTRLS           ; Stop scrolling?
        RET     NZ              ; Other key, ignore


STALL:  RST     10H             ; Wait for key
        CP      CTRLQ           ; Resume scrolling?
        RET      Z              ; Release the chokehold
        CP      CTRLC           ; Second break?
        JR      Z,STOP          ; Break during hold exits prog
        JR      STALL           ; Loop until <Ctrl-Q> or <brk>

BRK     LD      A,$FF           ; Set BRKFLG
        LD      (BRKFLG),A      ; Store it


STOP:   RET     NZ              ; Exit if anything else
        .BYTE   0F6H            ; Flag "STOP"
PEND:   RET     NZ              ; Exit if anything else
        LD      (BRKLIN),HL     ; Save point of break
        .BYTE   21H             ; Skip "OR 11111111B"
INPBRK: OR      11111111B       ; Flag "Break" wanted
        POP     BC              ; Return not needed and more
ENDPRG: LD      HL,(LINEAT)     ; Get current line number
        PUSH    AF              ; Save STOP / END status
        LD      A,L             ; Is it direct break?
        AND     H
        INC     A               ; Line is -1 if direct break
        JP      Z,NOLIN         ; Yes - No line number
        LD      (ERRLIN),HL     ; Save line of break
        LD      HL,(BRKLIN)     ; Get point of break
        LD      (CONTAD),HL     ; Save point to CONTinue
NOLIN:  XOR     A
        LD      (CTLOFG),A      ; Enable output
        CALL    STTLIN          ; Start a new line
        POP     AF              ; Restore STOP / END status
        LD      HL,BRKMSG       ; "Break" message
        JP      NZ,ERRIN        ; "in line" wanted?
        JP      PRNTOK          ; Go to command mode

CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
        LD      A,H             ; Is it zero?
        OR      L
        LD      E,CN            ; ?CN Error
        JP      Z,ERROR         ; Yes - output "?CN Error"
        EX      DE,HL           ; Save code string address
        LD      HL,(ERRLIN)     ; Get line of last break
        LD      (LINEAT),HL     ; Set up current line number
        EX      DE,HL           ; Restore code string address
        RET                     ; CONTinue where left off

NULL:   CALL    GETINT          ; Get integer 0-255
        RET     NZ              ; Return if bad value
        LD      (NULLS),A       ; Set nulls number
        RET


ACCSUM: PUSH    HL              ; Save address in array
        LD      HL,(CHKSUM)     ; Get check sum
        LD      B,0             ; BC - Value of byte
        LD      C,A
        ADD     HL,BC           ; Add byte to check sum
        LD      (CHKSUM),HL     ; Re-save check sum
        POP     HL              ; Restore address in array
        RET

CHKLTR: LD      A,(HL)          ; Get byte
        CP      'A'             ; < 'a' ?
        RET     C               ; Carry set if not letter
        CP      'Z'+1           ; > 'z' ?
        CCF
        RET                     ; Carry set if not letter

FPSINT: CALL    GETCHR          ; Get next character
POSINT: CALL    GETNUM          ; Get integer 0 to 32767
DEPINT: CALL    TSTSGN          ; Test sign of FPREG
        JP      M,FCERR         ; Negative - ?FC Error
DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
        CP      80H+16          ; Exponent in range (16 bits)?
        JP      C,FPINT         ; Yes - convert it
        LD      BC,9080H        ; BCDE = -32768
        LD      DE,0000
        PUSH    HL              ; Save code string address
        CALL    CMPNUM          ; Compare FPREG with BCDE
        POP     HL              ; Restore code string address
        LD      D,C             ; MSB to D
        RET     Z               ; Return if in range
FCERR:  LD      E,FC            ; ?FC Error
        JP      ERROR           ; Output error-

ATOH:   DEC     HL              ; ASCII number to DE binary
GETLN:  LD      DE,0            ; Get number to DE
GTLNLP: CALL    GETCHR          ; Get next character
        RET     NC              ; Exit if not a digit
        PUSH    HL              ; Save code string address
        PUSH    AF              ; Save digit
        LD      HL,65529/10     ; Largest number 65529
        CALL    CPDEHL          ; Number in range?
        JP      C,SNERR         ; No - ?SN Error
        LD      H,D             ; HL = Number
        LD      L,E
        ADD     HL,DE           ; Times 2
        ADD     HL,HL           ; Times 4
        ADD     HL,DE           ; Times 5
        ADD     HL,HL           ; Times 10
        POP     AF              ; Restore digit
        SUB     '0'             ; Make it 0 to 9
        LD      E,A             ; DE = Value of digit
        LD      D,0
        ADD     HL,DE           ; Add to number
        EX      DE,HL           ; Number to DE
        POP     HL              ; Restore code string address
        JP      GTLNLP          ; Go to next character

CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
        CALL    POSINT          ; Get integer 0 to 32767 to DE
        DEC     HL              ; Cancel increment
        CALL    GETCHR          ; Get next character
        PUSH    HL              ; Save code string address
        LD      HL,(LSTRAM)     ; Get end of RAM
        JP      Z,STORED        ; No value given - Use stored
        POP     HL              ; Restore code string address
        CALL    CHKSYN          ; Check for comma
        .BYTE      ','
        PUSH    DE              ; Save number
        CALL    POSINT          ; Get integer 0 to 32767
        DEC     HL              ; Cancel increment
        CALL    GETCHR          ; Get next character
        JP      NZ,SNERR        ; ?SN Error if more on line
        EX      (SP),HL         ; Save code string address
        EX      DE,HL           ; Number to DE
STORED: LD      A,L             ; Get LSB of new RAM top
        SUB     E               ; Subtract LSB of string space
        LD      E,A             ; Save LSB
        LD      A,H             ; Get MSB of new RAM top
        SBC     A,D             ; Subtract MSB of string space
        LD      D,A             ; Save MSB
        JP      C,OMERR         ; ?OM Error if not enough mem
        PUSH    HL              ; Save RAM top
        LD      HL,(PROGND)     ; Get program end
        LD      BC,40           ; 40 Bytes minimum working RAM
        ADD     HL,BC           ; Get lowest address
        CALL    CPDEHL          ; Enough memory?
        JP      NC,OMERR        ; No - ?OM Error
        EX      DE,HL           ; RAM top to HL
        LD      (STRSPC),HL     ; Set new string space
        POP     HL              ; End of memory to use
        LD      (LSTRAM),HL     ; Set new top of RAM
        POP     HL              ; Restore code string address
        JP      INTVAR          ; Initialise variables

RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
        CALL    INTVAR          ; Initialise variables
        LD      BC,RUNCNT       ; Execution driver loop
        JP      RUNLIN          ; RUN from line number

GOSUB:  LD      C,3             ; 3 Levels of stack needed
        CALL    CHKSTK          ; Check for 3 levels of stack
        POP     BC              ; Get return address
        PUSH    HL              ; Save code string for RETURN
        PUSH    HL              ; And for GOSUB routine
        LD      HL,(LINEAT)     ; Get current line
        EX      (SP),HL         ; Into stack - Code string out
        LD      A,ZGOSUB        ; "GOSUB" token
        PUSH    AF              ; Save token
        INC     SP              ; Don't save flags

RUNLIN: PUSH    BC              ; Save return address
GOTO:   CALL    ATOH            ; ASCII number to DE binary
        CALL    REM             ; Get end of line
        PUSH    HL              ; Save end of line
        LD      HL,(LINEAT)     ; Get current line
        CALL    CPDEHL          ; Line after current?
        POP     HL              ; Restore end of line
        INC     HL              ; Start of next line
        CALL    C,SRCHLP        ; Line is after current line
        CALL    NC,SRCHLN       ; Line is before current line
        LD      H,B             ; Set up code string address
        LD      L,C
        DEC     HL              ; Incremented after
        RET     C               ; Line found
ULERR:  LD      E,UL            ; ?UL Error
        JP      ERROR           ; Output error message

RETURN: RET     NZ              ; Return if not just RETURN
        LD      D,-1            ; Flag "GOSUB" search
        CALL    BAKSTK          ; Look "GOSUB" block
        LD      SP,HL           ; Kill all FORs in subroutine
        CP      ZGOSUB          ; Test for "GOSUB" token
        LD      E,RG            ; ?RG Error
        JP      NZ,ERROR        ; Error if no "GOSUB" found
        POP     HL              ; Get RETURN line number
        LD      (LINEAT),HL     ; Save as current
        INC     HL              ; Was it from direct statement?
        LD      A,H
        OR      L               ; Return to line
        JP      NZ,RETLIN       ; No - Return to line
        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
        OR      A               ; If so buffer is corrupted
        JP      NZ,POPNOK       ; Yes - Go to command mode
RETLIN: LD      HL,RUNCNT       ; Execution driver loop
        EX      (SP),HL         ; Into stack - Code string out
        .BYTE      3EH             ; Skip "POP HL"
NXTDTA: POP     HL              ; Restore code string address

DATA:   .BYTE      01H,3AH         ; ':' End of statement
REM:    LD      C,0             ; 00  End of statement
        LD      B,0
NXTSTL: LD      A,C             ; Statement and byte
        LD      C,B
        LD      B,A             ; Statement end byte
NXTSTT: LD      A,(HL)          ; Get byte
        OR      A               ; End of line?
        RET     Z               ; Yes - Exit
        CP      B               ; End of statement?
        RET     Z               ; Yes - Exit
        INC     HL              ; Next byte
        CP      '"'             ; Literal string?
        JP      Z,NXTSTL        ; Yes - Look for another '"'
        JP      NXTSTT          ; Keep looking

LET:    CALL    GETVAR          ; Get variable name
        CALL    CHKSYN          ; Make sure "=" follows
        .BYTE      ZEQUAL          ; "=" token
        PUSH    DE              ; Save address of variable
        LD      A,(TYPE)        ; Get data type
        PUSH    AF              ; Save type
        CALL    EVAL            ; Evaluate expression
        POP     AF              ; Restore type
        EX      (SP),HL         ; Save code - Get var addr
        LD      (BRKLIN),HL     ; Save address of variable
        RRA                     ; Adjust type
        CALL    CHKTYP          ; Check types are the same
        JP      Z,LETNUM        ; Numeric - Move value
LETSTR: PUSH    HL              ; Save address of string var
        LD      HL,(FPREG)      ; Pointer to string entry
        PUSH    HL              ; Save it on stack
        INC     HL              ; Skip over length
        INC     HL
        LD      E,(HL)          ; LSB of string address
        INC     HL
        LD      D,(HL)          ; MSB of string address
        LD      HL,(BASTXT)     ; Point to start of program
        CALL    CPDEHL          ; Is string before program?
        JP      NC,CRESTR       ; Yes - Create string entry
        LD      HL,(STRSPC)     ; Point to string space
        CALL    CPDEHL          ; Is string literal in program?
        POP     DE              ; Restore address of string
        JP      NC,MVSTPT       ; Yes - Set up pointer
        LD      HL,TMPSTR       ; Temporary string pool
        CALL    CPDEHL          ; Is string in temporary pool?
        JP      NC,MVSTPT       ; No - Set up pointer
        .BYTE   3EH             ; Skip "POP DE"
CRESTR: POP     DE              ; Restore address of string
        CALL    BAKTMP          ; Back to last tmp-str entry
        EX      DE,HL           ; Address of string entry
        CALL    SAVSTR          ; Save string in string area
MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
        POP     HL              ; Get string pointer
        CALL    DETHL4          ; Move string pointer to var
        POP     HL              ; Restore code string address
        RET

LETNUM: PUSH    HL              ; Save address of variable
        CALL    FPTHL           ; Move value to variable
        POP     DE              ; Restore address of variable
        POP     HL              ; Restore code string address
        RET

ON:     CALL    GETINT          ; Get integer 0-255
        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
        LD      B,A             ; Save in B
        CP      ZGOSUB          ; "GOSUB" token?
        JP      Z,ONGO          ; Yes - Find line number
        CALL    CHKSYN          ; Make sure it's "GOTO"
        .BYTE   ZGOTO           ; "GOTO" token
        DEC     HL              ; Cancel increment
ONGO:   LD      C,E             ; Integer of branch value
ONGOLP: DEC     C               ; Count branches
        LD      A,B             ; Get "GOTO" or "GOSUB" token
        JP      Z,ONJMP         ; Go to that line if right one
        CALL    GETLN           ; Get line number to DE
        CP      ','             ; Another line number?
        RET     NZ              ; No - Drop through
        JP      ONGOLP          ; Yes - loop

IF:     CALL    EVAL            ; Evaluate expression
        LD      A,(HL)          ; Get token
        CP      ZGOTO           ; "GOTO" token?
        JP      Z,IFGO          ; Yes - Get line
        CALL    CHKSYN          ; Make sure it's "THEN"
        .BYTE      ZTHEN           ; "THEN" token
        DEC     HL              ; Cancel increment
IFGO:   CALL    TSTNUM          ; Make sure it's numeric
        CALL    TSTSGN          ; Test state of expression
        JP      Z,REM           ; False - Drop through
        CALL    GETCHR          ; Get next character
        JP      C,GOTO          ; Number - GOTO that line
        JP      IFJMP           ; Otherwise do statement

MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
PRNTLP: RET     Z               ; End of list - Exit
        CP      ZTAB            ; "TAB(" token?
        JP      Z,DOTAB         ; Yes - Do TAB routine
        CP      ZSPC            ; "SPC(" token?
        JP      Z,DOTAB         ; Yes - Do SPC routine
        PUSH    HL              ; Save code string address
        CP      ','             ; Comma?
        JP      Z,DOCOM         ; Yes - Move to next zone
        CP      59 ;";"         ; Semi-colon?
        JP      Z,NEXITM        ; Do semi-colon routine
        POP     BC              ; Code string address to BC
        CALL    EVAL            ; Evaluate expression
        PUSH    HL              ; Save code string address
        LD      A,(TYPE)        ; Get variable type
        OR      A               ; Is it a string variable?
        JP      NZ,PRNTST       ; Yes - Output string contents
        CALL    NUMASC          ; Convert number to text
        CALL    CRTST           ; Create temporary string
        LD      (HL),' '        ; Followed by a space
        LD      HL,(FPREG)      ; Get length of output
        INC     (HL)            ; Plus 1 for the space
        LD      HL,(FPREG)      ; < Not needed >
        LD      A,(LWIDTH)      ; Get width of line
        LD      B,A             ; To B
        INC     B               ; Width 255 (No limit)?
        JP      Z,PRNTNB        ; Yes - Output number string
        INC     B               ; Adjust it
        LD      A,(CURPOS)      ; Get cursor position
        ADD     A,(HL)          ; Add length of string
        DEC     A               ; Adjust it
        CP      B               ; Will output fit on this line?
        CALL    NC,PRNTCRLF     ; No - CRLF first
PRNTNB: CALL    PRS1            ; Output string at (HL)
        XOR     A               ; Skip CALL by setting 'z' flag
PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
        POP     HL              ; Restore code string address
        JP      MRPRNT          ; See if more to PRINT

STTLIN: LD      A,(CURPOS)      ; Make sure on new line
        OR      A               ; Already at start?
        RET     Z               ; Yes - Do nothing
        JP      PRNTCRLF        ; Start a new line

ENDINP: LD      (HL),0          ; Mark end of buffer
        LD      HL,BUFFER-1     ; Point to buffer
PRNTCRLF: LD    A,CR            ; Load a CR
        CALL    OUTC            ; Output character
        LD      A,LF            ; Load a LF
        CALL    OUTC            ; Output character
DONULL: XOR     A               ; Set to position 0
        LD      (CURPOS),A      ; Store it
        LD      A,(NULLS)       ; Get number of nulls
NULLP:  DEC     A               ; Count them
        RET     Z               ; Return if done
        PUSH    AF              ; Save count
        XOR     A               ; Load a null
        CALL    OUTC            ; Output it
        POP     AF              ; Restore count
        JP      NULLP           ; Keep counting

DOCOM:  LD      A,(COMMAN)      ; Get comma width
        LD      B,A             ; Save in B
        LD      A,(CURPOS)      ; Get current position
        CP      B               ; Within the limit?
        CALL    NC,PRNTCRLF     ; No - output CRLF
        JP      NC,NEXITM       ; Get next item
ZONELP: SUB     14              ; Next zone of 14 characters
        JP      NC,ZONELP       ; Repeat if more zones
        CPL                     ; Number of spaces to output
        JP      ASPCS           ; Output them

DOTAB:  PUSH    AF              ; Save token
        CALL    FNDNUM          ; Evaluate expression
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE   ")"
        DEC     HL              ; Back space on to ")"
        POP     AF              ; Restore token
        SUB     ZSPC            ; Was it "SPC(" ?
        PUSH    HL              ; Save code string address
        JP      Z,DOSPC         ; Yes - Do 'E' spaces
        LD      A,(CURPOS)      ; Get current position
DOSPC:  CPL                     ; Number of spaces to print to
        ADD     A,E             ; Total number to print
        JP      NC,NEXITM       ; TAB < Current POS(X)
ASPCS:  INC     A               ; Output A spaces
        LD      B,A             ; Save number to print
        LD      A,' '           ; Space
SPCLP:  CALL    OUTC            ; Output character in A
        DEC     B               ; Count them
        JP      NZ,SPCLP        ; Repeat if more
NEXITM: POP     HL              ; Restore code string address
        CALL    GETCHR          ; Get next character
        JP      PRNTLP          ; More to print

REDO:   .BYTE   "?Redo from start",CR,LF,0

BADINP: LD      A,(READFG)      ; READ or INPUT?
        OR      A
        JP      NZ,DATSNR       ; READ - ?SN Error
        POP     BC              ; Throw away code string addr
        LD      HL,REDO         ; "Redo from start" message
        CALL    PRS             ; Output string
        JP      DOAGN           ; Do last INPUT again

INPUT:  CALL    IDTEST          ; Test for illegal direct
        LD      A,(HL)          ; Get character after "INPUT"
        CP      '"'             ; Is there a prompt string?
        LD      A,0             ; Clear A and leave flags
        LD      (CTLOFG),A      ; Enable output
        JP      NZ,NOPMPT       ; No prompt - get input
        CALL    QTSTR           ; Get string terminated by '"'
        CALL    CHKSYN          ; Check for ';' after prompt
        .BYTE   ';'
        PUSH    HL              ; Save code string address
        CALL    PRS1            ; Output prompt string
        .BYTE   3EH             ; Skip "PUSH HL"
NOPMPT: PUSH    HL              ; Save code string address
        CALL    PROMPT          ; Get input with "? " prompt
        POP     BC              ; Restore code string address
        JP      C,INPBRK        ; Break pressed - Exit
        INC     HL              ; Next byte
        LD      A,(HL)          ; Get it
        OR      A               ; End of line?
        DEC     HL              ; Back again
        PUSH    BC              ; Re-save code string address
        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
        LD      (HL),','        ; Store comma as separator
        JP      NXTITM          ; Get next item

READ:   PUSH    HL              ; Save code string address
        LD      HL,(NXTDAT)     ; Next DATA statement
        .BYTE   0F6H            ; Flag "READ"
NXTITM: XOR     A               ; Flag "INPUT"
        LD      (READFG),A      ; Save "READ"/"INPUT" flag
        EX      (SP),HL         ; Get code str' , Save pointer
        JP      GTVLUS          ; Get values

NEDMOR: CALL    CHKSYN          ; Check for comma between items
        .BYTE      ','
GTVLUS: CALL    GETVAR          ; Get variable name
        EX      (SP),HL         ; Save code str" , Get pointer
        PUSH    DE              ; Save variable address
        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
        CP      ','             ; Comma?
        JP      Z,ANTVLU        ; Yes - Get another value
        LD      A,(READFG)      ; Is it READ?
        OR      A
        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
        LD      A,'?'           ; More INPUT needed
        CALL    OUTC            ; Output character
        CALL    PROMPT          ; Get INPUT with prompt
        POP     DE              ; Variable address
        POP     BC              ; Code string address
        JP      C,INPBRK        ; Break pressed
        INC     HL              ; Point to next DATA byte
        LD      A,(HL)          ; Get byte
        OR      A               ; Is it zero (No input) ?
        DEC     HL              ; Back space INPUT pointer
        PUSH    BC              ; Save code string address
        JP      Z,NXTDTA        ; Find end of buffer
        PUSH    DE              ; Save variable address
ANTVLU: LD      A,(TYPE)        ; Check data type
        OR      A               ; Is it numeric?
        JP      Z,INPBIN        ; Yes - Convert to binary
        CALL    GETCHR          ; Get next character
        LD      D,A             ; Save input character
        LD      B,A             ; Again
        CP      '"'             ; Start of literal sting?
        JP      Z,STRENT        ; Yes - Create string entry
        LD      A,(READFG)      ; "READ" or "INPUT" ?
        OR      A
        LD      D,A             ; Save 00 if "INPUT"
        JP      Z,ITMSEP        ; "INPUT" - End with 00
        LD      D,':'           ; "DATA" - End with 00 or ':'
ITMSEP: LD      B,','           ; Item separator
        DEC     HL              ; Back space for DTSTR
STRENT: CALL    DTSTR           ; Get string terminated by D
        EX      DE,HL           ; String address to DE
        LD      HL,LTSTND       ; Where to go after LETSTR
        EX      (SP),HL         ; Save HL , get input pointer
        PUSH    DE              ; Save address of string
        JP      LETSTR          ; Assign string to variable

INPBIN: CALL    GETCHR          ; Get next character
        CALL    ASCTFP          ; Convert ASCII to FP number
        EX      (SP),HL         ; Save input ptr, Get var addr
        CALL    FPTHL           ; Move FPREG to variable
        POP     HL              ; Restore input pointer
LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        JP      Z,MORDT         ; End of line - More needed?
        CP      ','             ; Another value?
        JP      NZ,BADINP       ; No - Bad input
MORDT:  EX      (SP),HL         ; Get code string address
        DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        JP      NZ,NEDMOR       ; More needed - Get it
        POP     DE              ; Restore DATA pointer
        LD      A,(READFG)      ; "READ" or "INPUT" ?
        OR      A
        EX      DE,HL           ; DATA pointer to HL
        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
        PUSH    DE              ; Save code string address
        OR      (HL)            ; More input given?
        LD      HL,EXTIG        ; "?Extra ignored" message
        CALL    NZ,PRS          ; Output string if extra given
        POP     HL              ; Restore code string address
        RET

EXTIG:  .BYTE   "?Extra ignored",CR,LF,0

FDTLP:  CALL    DATA            ; Get next statement
        OR      A               ; End of line?
        JP      NZ,FANDT        ; No - See if DATA statement
        INC     HL
        LD      A,(HL)          ; End of program?
        INC     HL
        OR      (HL)            ; 00 00 Ends program
        LD      E,OD            ; ?OD Error
        JP      Z,ERROR         ; Yes - Out of DATA
        INC     HL
        LD      E,(HL)          ; LSB of line number
        INC     HL
        LD      D,(HL)          ; MSB of line number
        EX      DE,HL
        LD      (DATLIN),HL     ; Set line of current DATA item
        EX      DE,HL
FANDT:  CALL    GETCHR          ; Get next character
        CP      ZDATA           ; "DATA" token
        JP      NZ,FDTLP        ; No "DATA" - Keep looking
        JP      ANTVLU          ; Found - Convert input

NEXT:   LD      DE,0            ; In case no index given
NEXT1:  CALL    NZ,GETVAR       ; Get index address
        LD      (BRKLIN),HL     ; Save code string address
        CALL    BAKSTK          ; Look for "FOR" block
        JP      NZ,NFERR        ; No "FOR" - ?NF Error
        LD      SP,HL           ; Clear nested loops
        PUSH    DE              ; Save index address
        LD      A,(HL)          ; Get sign of STEP
        INC     HL
        PUSH    AF              ; Save sign of STEP
        PUSH    DE              ; Save index address
        CALL    PHLTFP          ; Move index value to FPREG
        EX      (SP),HL         ; Save address of TO value
        PUSH    HL              ; Save address of index
        CALL    ADDPHL          ; Add STEP to index value
        POP     HL              ; Restore address of index
        CALL    FPTHL           ; Move value to index variable
        POP     HL              ; Restore address of TO value
        CALL    LOADFP          ; Move TO value to BCDE
        PUSH    HL              ; Save address of line of FOR
        CALL    CMPNUM          ; Compare index with TO value
        POP     HL              ; Restore address of line num
        POP     BC              ; Address of sign of STEP
        SUB     B               ; Compare with expected sign
        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
        JP      Z,KILFOR        ; Loop finished - Terminate it
        EX      DE,HL           ; Loop statement line number
        LD      (LINEAT),HL     ; Set loop line number
        LD      L,C             ; Set code string to loop
        LD      H,B
        JP      PUTFID          ; Put back "FOR" and continue

KILFOR: LD      SP,HL           ; Remove "FOR" block
        LD      HL,(BRKLIN)     ; Code string after "NEXT"
        LD      A,(HL)          ; Get next byte in code string
        CP      ','             ; More NEXTs ?
        JP      NZ,RUNCNT       ; No - Do next statement
        CALL    GETCHR          ; Position to index name
        CALL    NEXT1           ; Re-enter NEXT routine
; < will not RETurn to here , Exit to RUNCNT or Loop >

GETNUM: CALL    EVAL            ; Get a numeric expression
TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
TSTSTR: SCF                     ; Set carry (string)
CHKTYP: LD      A,(TYPE)        ; Check types match
        ADC     A,A             ; Expected + actual
        OR      A               ; Clear carry , set parity
        RET     PE              ; Even parity - Types match
        JP      TMERR           ; Different types - Error

OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
        .BYTE   "("
EVAL:   DEC     HL              ; Evaluate expression & save
        LD      D,0             ; Precedence value
EVAL1:  PUSH    DE              ; Save precedence
        LD      C,1
        CALL    CHKSTK          ; Check for 1 level of stack
        CALL    OPRND           ; Get next expression value
EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
        POP     BC              ; Precedence value and operator
        LD      A,B             ; Get precedence value
        CP      78H             ; "AND" or "OR" ?
        CALL    NC,TSTNUM       ; No - Make sure it's a number
        LD      A,(HL)          ; Get next operator / function
        LD      D,0             ; Clear Last relation
RLTLP:  SUB     ZGTR            ; ">" Token
        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
        CP      ZLTH+1-ZGTR     ; < = >
        JP      NC,FOPRND       ; Function - Call it
        CP      ZEQUAL-ZGTR     ; "="
        RLA                     ; <- Test for legal
        XOR     D               ; <- combinations of < = >
        CP      D               ; <- by combining last token
        LD      D,A             ; <- with current one
        JP      C,SNERR         ; Error if "<<' '==" or ">>"
        LD      (CUROPR),HL     ; Save address of current token
        CALL    GETCHR          ; Get next character
        JP      RLTLP           ; Treat the two as one

FOPRND: LD      A,D             ; < = > found ?
        OR      A
        JP      NZ,TSTRED       ; Yes - Test for reduction
        LD      A,(HL)          ; Get operator token
        LD      (CUROPR),HL     ; Save operator address
        SUB     ZPLUS           ; Operator or function?
        RET     C               ; Neither - Exit
        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
        RET     NC              ; No - Exit
        LD      E,A             ; Coded operator
        LD      A,(TYPE)        ; Get data type
        DEC     A               ; FF = numeric , 00 = string
        OR      E               ; Combine with coded operator
        LD      A,E             ; Get coded operator
        JP      Z,CONCAT        ; String concatenation
        RLCA                    ; Times 2
        ADD     A,E             ; Times 3
        LD      E,A             ; To DE (D is 0)
        LD      HL,PRITAB       ; Precedence table
        ADD     HL,DE           ; To the operator concerned
        LD      A,B             ; Last operator precedence
        LD      D,(HL)          ; Get evaluation precedence
        CP      D               ; Compare with eval precedence
        RET     NC              ; Exit if higher precedence
        INC     HL              ; Point to routine address
        CALL    TSTNUM          ; Make sure it's a number

STKTHS: PUSH    BC              ; Save last precedence & token
        LD      BC,EVAL3        ; Where to go on prec' break
        PUSH    BC              ; Save on stack for return
        LD      B,E             ; Save operator
        LD      C,D             ; Save precedence
        CALL    STAKFP          ; Move value to stack
        LD      E,B             ; Restore operator
        LD      D,C             ; Restore precedence
        LD      C,(HL)          ; Get LSB of routine address
        INC     HL
        LD      B,(HL)          ; Get MSB of routine address
        INC     HL
        PUSH    BC              ; Save routine address
        LD      HL,(CUROPR)     ; Address of current operator
        JP      EVAL1           ; Loop until prec' break

OPRND:  XOR     A               ; Get operand routine
        LD      (TYPE),A        ; Set numeric expected
        CALL    GETCHR          ; Get next character
        LD      E,MO            ; ?MO Error
        JP      Z,ERROR         ; No operand - Error
        JP      C,ASCTFP        ; Number - Get value
        CALL    CHKLTR          ; See if a letter
        JP      NC,CONVAR       ; Letter - Find variable
        CP		'&'				; &H = HEX, &B = BINARY
        JR		NZ, NOTAMP
        CALL    GETCHR          ; Get next character
        CP      'H'             ; Hex number indicated? [function added]
        JP      Z,HEXTFP        ; Convert Hex to FPREG
        CP      'B'             ; Binary number indicated? [function added]
        JP      Z,BINTFP        ; Convert Bin to FPREG
        LD      E,SN            ; If neither then a ?SN Error
        JP      Z,ERROR         ; 
NOTAMP: CP      ZPLUS           ; '+' Token ?
        JP      Z,OPRND         ; Yes - Look for operand
        CP      '.'             ; '.' ?
        JP      Z,ASCTFP        ; Yes - Create FP number
        CP      ZMINUS          ; '-' Token ?
        JP      Z,MINUS         ; Yes - Do minus
        CP      '"'             ; Literal string ?
        JP      Z,QTSTR         ; Get string terminated by '"'
        CP      ZNOT            ; "NOT" Token ?
        JP      Z,EVNOT         ; Yes - Eval NOT expression
        CP      ZFN             ; "FN" Token ?
        JP      Z,DOFN          ; Yes - Do FN routine
        SUB     ZSGN            ; Is it a function?
        JP      NC,FNOFST       ; Yes - Evaluate function
EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE   ")"
        RET

MINUS:  LD      D,7DH           ; '-' precedence
        CALL    EVAL1           ; Evaluate until prec' break
        LD      HL,(NXTOPR)     ; Get next operator address
        PUSH    HL              ; Save next operator address
        CALL    INVSGN          ; Negate value
RETNUM: CALL    TSTNUM          ; Make sure it's a number
        POP     HL              ; Restore next operator address
        RET

CONVAR: CALL    GETVAR          ; Get variable address to DE
FRMEVL: PUSH    HL              ; Save code string address
        EX      DE,HL           ; Variable address to HL
        LD      (FPREG),HL      ; Save address of variable
        LD      A,(TYPE)        ; Get type
        OR      A               ; Numeric?
        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
        POP     HL              ; Restore code string address
        RET

FNOFST: LD      B,0             ; Get address of function
        RLCA                    ; Double function offset
        LD      C,A             ; BC = Offset in function table
        PUSH    BC              ; Save adjusted token value
        CALL    GETCHR          ; Get next character
        LD      A,C             ; Get adjusted token value
        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
        JP      C,FNVAL         ; No - Do function
        CALL    OPNPAR          ; Evaluate expression  (X,...
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    TSTSTR          ; Make sure it's a string
        EX      DE,HL           ; Save code string address
        LD      HL,(FPREG)      ; Get address of string
        EX      (SP),HL         ; Save address of string
        PUSH    HL              ; Save adjusted token value
        EX      DE,HL           ; Restore code string address
        CALL    GETINT          ; Get integer 0-255
        EX      DE,HL           ; Save code string address
        EX      (SP),HL         ; Save integer,HL = adj' token
        JP      GOFUNC          ; Jump to string function

FNVAL:  CALL    EVLPAR          ; Evaluate expression
        EX      (SP),HL         ; HL = Adjusted token value
        LD      DE,RETNUM       ; Return number from function
        PUSH    DE              ; Save on stack
GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
        ADD     HL,BC           ; Point to right address
        LD      C,(HL)          ; Get LSB of address
        INC     HL              ;
        LD      H,(HL)          ; Get MSB of address
        LD      L,C             ; Address to HL
        JP      (HL)            ; Jump to function

SGNEXP: DEC     D               ; Dee to flag negative exponent
        CP      ZMINUS          ; '-' token ?
        RET     Z               ; Yes - Return
        CP      '-'             ; '-' ASCII ?
        RET     Z               ; Yes - Return
        INC     D               ; Inc to flag positive exponent
        CP      '+'             ; '+' ASCII ?
        RET     Z               ; Yes - Return
        CP      ZPLUS           ; '+' token ?
        RET     Z               ; Yes - Return
        DEC     HL              ; DEC 'cos GETCHR INCs
        RET                     ; Return "NZ"

POR:    .BYTE      0F6H            ; Flag "OR"
PAND:   XOR     A               ; Flag "AND"
        PUSH    AF              ; Save "AND" / "OR" flag
        CALL    TSTNUM          ; Make sure it's a number
        CALL    DEINT           ; Get integer -32768 to 32767
        POP     AF              ; Restore "AND" / "OR" flag
        EX      DE,HL           ; <- Get last
        POP     BC              ; <-  value
        EX      (SP),HL         ; <-  from
        EX      DE,HL           ; <-  stack
        CALL    FPBCDE          ; Move last value to FPREG
        PUSH    AF              ; Save "AND" / "OR" flag
        CALL    DEINT           ; Get integer -32768 to 32767
        POP     AF              ; Restore "AND" / "OR" flag
        POP     BC              ; Get value
        LD      A,C             ; Get LSB
        LD      HL,ACPASS       ; Address of save AC as current
        JP      NZ,POR1         ; Jump if OR
        AND     E               ; "AND" LSBs
        LD      C,A             ; Save LSB
        LD      A,B             ; Get MBS
        AND     D               ; "AND" MSBs
        JP      (HL)            ; Save AC as current (ACPASS)

POR1:   OR      E               ; "OR" LSBs
        LD      C,A             ; Save LSB
        LD      A,B             ; Get MSB
        OR      D               ; "OR" MSBs
        JP      (HL)            ; Save AC as current (ACPASS)

TSTRED: LD      HL,CMPLOG       ; Logical compare routine
        LD      A,(TYPE)        ; Get data type
        RRA                     ; Carry set = string
        LD      A,D             ; Get last precedence value
        RLA                     ; Times 2 plus carry
        LD      E,A             ; To E
        LD      D,64H           ; Relational precedence
        LD      A,B             ; Get current precedence
        CP      D               ; Compare with last
        RET     NC              ; Eval if last was rel' or log'
        JP      STKTHS          ; Stack this one and get next

CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
CMPLG1: LD      A,C             ; Get data type
        OR      A
        RRA
        POP     BC              ; Get last expression to BCDE
        POP     DE
        PUSH    AF              ; Save status
        CALL    CHKTYP          ; Check that types match
        LD      HL,CMPRES       ; Result to comparison
        PUSH    HL              ; Save for RETurn
        JP      Z,CMPNUM        ; Compare values if numeric
        XOR     A               ; Compare two strings
        LD      (TYPE),A        ; Set type to numeric
        PUSH    DE              ; Save string name
        CALL    GSTRCU          ; Get current string
        LD      A,(HL)          ; Get length of string
        INC     HL
        INC     HL
        LD      C,(HL)          ; Get LSB of address
        INC     HL
        LD      B,(HL)          ; Get MSB of address
        POP     DE              ; Restore string name
        PUSH    BC              ; Save address of string
        PUSH    AF              ; Save length of string
        CALL    GSTRDE          ; Get second string
        CALL    LOADFP          ; Get address of second string
        POP     AF              ; Restore length of string 1
        LD      D,A             ; Length to D
        POP     HL              ; Restore address of string 1
CMPSTR: LD      A,E             ; Bytes of string 2 to do
        OR      D               ; Bytes of string 1 to do
        RET     Z               ; Exit if all bytes compared
        LD      A,D             ; Get bytes of string 1 to do
        SUB     1
        RET     C               ; Exit if end of string 1
        XOR     A
        CP      E               ; Bytes of string 2 to do
        INC     A
        RET     NC              ; Exit if end of string 2
        DEC     D               ; Count bytes in string 1
        DEC     E               ; Count bytes in string 2
        LD      A,(BC)          ; Byte in string 2
        CP      (HL)            ; Compare to byte in string 1
        INC     HL              ; Move up string 1
        INC     BC              ; Move up string 2
        JP      Z,CMPSTR        ; Same - Try next bytes
        CCF                     ; Flag difference (">" or "<")
        JP      FLGDIF          ; "<" gives -1 , ">" gives +1

CMPRES: INC     A               ; Increment current value
        ADC     A,A             ; Double plus carry
        POP     BC              ; Get other value
        AND     B               ; Combine them
        ADD     A,-1            ; Carry set if different
        SBC     A,A             ; 00 - Equal , FF - Different
        JP      FLGREL          ; Set current value & continue

EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
        CALL    EVAL1           ; Eval until precedence break
        CALL    TSTNUM          ; Make sure it's a number
        CALL    DEINT           ; Get integer -32768 - 32767
        LD      A,E             ; Get LSB
        CPL                     ; Invert LSB
        LD      C,A             ; Save "NOT" of LSB
        LD      A,D             ; Get MSB
        CPL                     ; Invert MSB
        CALL    ACPASS          ; Save AC as current
        POP     BC              ; Clean up stack
        JP      EVAL3           ; Continue evaluation

DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        RET     Z               ; End of DIM statement
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
        PUSH    BC              ; Save on stack
        .BYTE      0F6H            ; Flag "Create" variable
GETVAR: XOR     A               ; Find variable address,to DE
        LD      (LCRFLG),A      ; Set locate / create flag
        LD      B,(HL)          ; Get First byte of name
GTFNAM: CALL    CHKLTR          ; See if a letter
        JP      C,SNERR         ; ?SN Error if not a letter
        XOR     A
        LD      C,A             ; Clear second byte of name
        LD      (TYPE),A        ; Set type to numeric
        CALL    GETCHR          ; Get next character
        JP      C,SVNAM2        ; Numeric - Save in name
        CALL    CHKLTR          ; See if a letter
        JP      C,CHARTY        ; Not a letter - Check type
SVNAM2: LD      C,A             ; Save second byte of name
ENDNAM: CALL    GETCHR          ; Get next character
        JP      C,ENDNAM        ; Numeric - Get another
        CALL    CHKLTR          ; See if a letter
        JP      NC,ENDNAM       ; Letter - Get another
CHARTY: SUB     '$'             ; String variable?
        JP      NZ,NOTSTR       ; No - Numeric variable
        INC     A               ; A = 1 (string type)
        LD      (TYPE),A        ; Set type to string
        RRCA                    ; A = 80H , Flag for string
        ADD     A,C             ; 2nd byte of name has bit 7 on
        LD      C,A             ; Resave second byte on name
        CALL    GETCHR          ; Get next character
NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
        DEC     A
        JP      Z,ARLDSV        ; Yes - Get array name
        JP      P,NSCFOR        ; No array with "FOR" or "FN"
        LD      A,(HL)          ; Get byte again
        SUB     '('             ; Subscripted variable?
        JP      Z,SBSCPT        ; Yes - Sort out subscript

NSCFOR: XOR     A               ; Simple variable
        LD      (FORFLG),A      ; Clear "FOR" flag
        PUSH    HL              ; Save code string address
        LD      D,B             ; DE = Variable name to find
        LD      E,C
        LD      HL,(FNRGNM)     ; FN argument name
        CALL    CPDEHL          ; Is it the FN argument?
        LD      DE,FNARG        ; Point to argument value
        JP      Z,POPHRT        ; Yes - Return FN argument value
        LD      HL,(VAREND)     ; End of variables
        EX      DE,HL           ; Address of end of search
        LD      HL,(PROGND)     ; Start of variables address
FNDVAR: CALL    CPDEHL          ; End of variable list table?
        JP      Z,CFEVAL        ; Yes - Called from EVAL?
        LD      A,C             ; Get second byte of name
        SUB     (HL)            ; Compare with name in list
        INC     HL              ; Move on to first byte
        JP      NZ,FNTHR        ; Different - Find another
        LD      A,B             ; Get first byte of name
        SUB     (HL)            ; Compare with name in list
FNTHR:  INC     HL              ; Move on to LSB of value
        JP      Z,RETADR        ; Found - Return address
        INC     HL              ; <- Skip
        INC     HL              ; <- over
        INC     HL              ; <- F.P.
        INC     HL              ; <- value
        JP      FNDVAR          ; Keep looking

CFEVAL: POP     HL              ; Restore code string address
        EX      (SP),HL         ; Get return address
        PUSH    DE              ; Save address of variable
        LD      DE,FRMEVL       ; Return address in EVAL
        CALL    CPDEHL          ; Called from EVAL ?
        POP     DE              ; Restore address of variable
        JP      Z,RETNUL        ; Yes - Return null variable
        EX      (SP),HL         ; Put back return
        PUSH    HL              ; Save code string address
        PUSH    BC              ; Save variable name
        LD      BC,6            ; 2 byte name plus 4 byte data
        LD      HL,(ARREND)     ; End of arrays
        PUSH    HL              ; Save end of arrays
        ADD     HL,BC           ; Move up 6 bytes
        POP     BC              ; Source address in BC
        PUSH    HL              ; Save new end address
        CALL    MOVUP           ; Move arrays up
        POP     HL              ; Restore new end address
        LD      (ARREND),HL     ; Set new end address
        LD      H,B             ; End of variables to HL
        LD      L,C
        LD      (VAREND),HL     ; Set new end address

ZEROLP: DEC     HL              ; Back through to zero variable
        LD      (HL),0          ; Zero byte in variable
        CALL    CPDEHL          ; Done them all?
        JP      NZ,ZEROLP       ; No - Keep on going
        POP     DE              ; Get variable name
        LD      (HL),E          ; Store second character
        INC     HL
        LD      (HL),D          ; Store first character
        INC     HL
RETADR: EX      DE,HL           ; Address of variable in DE
        POP     HL              ; Restore code string address
        RET

RETNUL: LD      (FPEXP),A       ; Set result to zero
        LD      HL,ZERBYT       ; Also set a null string
        LD      (FPREG),HL      ; Save for EVAL
        POP     HL              ; Restore code string address
        RET

SBSCPT: PUSH    HL              ; Save code string address
        LD      HL,(LCRFLG)     ; Locate/Create and Type
        EX      (SP),HL         ; Save and get code string
        LD      D,A             ; Zero number of dimensions
SCPTLP: PUSH    DE              ; Save number of dimensions
        PUSH    BC              ; Save array name
        CALL    FPSINT          ; Get subscript (0-32767)
        POP     BC              ; Restore array name
        POP     AF              ; Get number of dimensions
        EX      DE,HL
        EX      (SP),HL         ; Save subscript value
        PUSH    HL              ; Save LCRFLG and TYPE
        EX      DE,HL
        INC     A               ; Count dimensions
        LD      D,A             ; Save in D
        LD      A,(HL)          ; Get next byte in code string
        CP      ','             ; Comma (more to come)?
        JP      Z,SCPTLP        ; Yes - More subscripts
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE      ")"
        LD      (NXTOPR),HL     ; Save code string address
        POP     HL              ; Get LCRFLG and TYPE
        LD      (LCRFLG),HL     ; Restore Locate/create & type
        LD      E,0             ; Flag not CSAVE* or CLOAD*
        PUSH    DE              ; Save number of dimensions (D)
        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'

ARLDSV: PUSH    HL              ; Save code string address
        PUSH    AF              ; A = 00 , Flags set = Z,N
        LD      HL,(VAREND)     ; Start of arrays
        .BYTE      3EH             ; Skip "ADD HL,DE"
FNDARY: ADD     HL,DE           ; Move to next array start
        EX      DE,HL
        LD      HL,(ARREND)     ; End of arrays
        EX      DE,HL           ; Current array pointer
        CALL    CPDEHL          ; End of arrays found?
        JP      Z,CREARY        ; Yes - Create array
        LD      A,(HL)          ; Get second byte of name
        CP      C               ; Compare with name given
        INC     HL              ; Move on
        JP      NZ,NXTARY       ; Different - Find next array
        LD      A,(HL)          ; Get first byte of name
        CP      B               ; Compare with name given
NXTARY: INC     HL              ; Move on
        LD      E,(HL)          ; Get LSB of next array address
        INC     HL
        LD      D,(HL)          ; Get MSB of next array address
        INC     HL
        JP      NZ,FNDARY       ; Not found - Keep looking
        LD      A,(LCRFLG)      ; Found Locate or Create it?
        OR      A
        JP      NZ,DDERR        ; Create - ?DD Error
        POP     AF              ; Locate - Get number of dim'ns
        LD      B,H             ; BC Points to array dim'ns
        LD      C,L
        JP      Z,POPHRT        ; Jump if array load/save
        SUB     (HL)            ; Same number of dimensions?
        JP      Z,FINDEL        ; Yes - Find element
BSERR:  LD      E,BS            ; ?BS Error
        JP      ERROR           ; Output error

CREARY: LD      DE,4            ; 4 Bytes per entry
        POP     AF              ; Array to save or 0 dim'ns?
        JP      Z,FCERR         ; Yes - ?FC Error
        LD      (HL),C          ; Save second byte of name
        INC     HL
        LD      (HL),B          ; Save first byte of name
        INC     HL
        LD      C,A             ; Number of dimensions to C
        CALL    CHKSTK          ; Check if enough memory
        INC     HL              ; Point to number of dimensions
        INC     HL
        LD      (CUROPR),HL     ; Save address of pointer
        LD      (HL),C          ; Set number of dimensions
        INC     HL
        LD      A,(LCRFLG)      ; Locate of Create?
        RLA                     ; Carry set = Create
        LD      A,C             ; Get number of dimensions
CRARLP: LD      BC,10+1         ; Default dimension size 10
        JP      NC,DEFSIZ       ; Locate - Set default size
        POP     BC              ; Get specified dimension size
        INC     BC              ; Include zero element
DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
        INC     HL
        LD      (HL),B          ; Save MSB of dimension size
        INC     HL
        PUSH    AF              ; Save num' of dim'ns an status
        PUSH    HL              ; Save address of dim'n size
        CALL    MLDEBC          ; Multiply DE by BC to find
        EX      DE,HL           ; amount of mem needed (to DE)
        POP     HL              ; Restore address of dimension
        POP     AF              ; Restore number of dimensions
        DEC     A               ; Count them
        JP      NZ,CRARLP       ; Do next dimension if more
        PUSH    AF              ; Save locate/create flag
        LD      B,D             ; MSB of memory needed
        LD      C,E             ; LSB of memory needed
        EX      DE,HL
        ADD     HL,DE           ; Add bytes to array start
        JP      C,OMERR         ; Too big - Error
        CALL    ENFMEM          ; See if enough memory
        LD      (ARREND),HL     ; Save new end of array

ZERARY: DEC     HL              ; Back through array data
        LD      (HL),0          ; Set array element to zero
        CALL    CPDEHL          ; All elements zeroed?
        JP      NZ,ZERARY       ; No - Keep on going
        INC     BC              ; Number of bytes + 1
        LD      D,A             ; A=0
        LD      HL,(CUROPR)     ; Get address of array
        LD      E,(HL)          ; Number of dimensions
        EX      DE,HL           ; To HL
        ADD     HL,HL           ; Two bytes per dimension size
        ADD     HL,BC           ; Add number of bytes
        EX      DE,HL           ; Bytes needed to DE
        DEC     HL
        DEC     HL
        LD      (HL),E          ; Save LSB of bytes needed
        INC     HL
        LD      (HL),D          ; Save MSB of bytes needed
        INC     HL
        POP     AF              ; Locate / Create?
        JP      C,ENDDIM        ; A is 0 , End if create
FINDEL: LD      B,A             ; Find array element
        LD      C,A
        LD      A,(HL)          ; Number of dimensions
        INC     HL
        .BYTE      16H             ; Skip "POP HL"
FNDELP: POP     HL              ; Address of next dim' size
        LD      E,(HL)          ; Get LSB of dim'n size
        INC     HL
        LD      D,(HL)          ; Get MSB of dim'n size
        INC     HL
        EX      (SP),HL         ; Save address - Get index
        PUSH    AF              ; Save number of dim'ns
        CALL    CPDEHL          ; Dimension too large?
        JP      NC,BSERR        ; Yes - ?BS Error
        PUSH    HL              ; Save index
        CALL    MLDEBC          ; Multiply previous by size
        POP     DE              ; Index supplied to DE
        ADD     HL,DE           ; Add index to pointer
        POP     AF              ; Number of dimensions
        DEC     A               ; Count them
        LD      B,H             ; MSB of pointer
        LD      C,L             ; LSB of pointer
        JP      NZ,FNDELP       ; More - Keep going
        ADD     HL,HL           ; 4 Bytes per element
        ADD     HL,HL
        POP     BC              ; Start of array
        ADD     HL,BC           ; Point to element
        EX      DE,HL           ; Address of element to DE
ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
        RET

FRE:    LD      HL,(ARREND)     ; Start of free memory
        EX      DE,HL           ; To DE
        LD      HL,0            ; End of free memory
        ADD     HL,SP           ; Current stack value
        LD      A,(TYPE)        ; Dummy argument type
        OR      A
        JP      Z,FRENUM        ; Numeric - Free variable space
        CALL    GSTRCU          ; Current string to pool
        CALL    GARBGE          ; Garbage collection
        LD      HL,(STRSPC)     ; Bottom of string space in use
        EX      DE,HL           ; To DE
        LD      HL,(STRBOT)     ; Bottom of string space
FRENUM: LD      A,L             ; Get LSB of end
        SUB     E               ; Subtract LSB of beginning
        LD      C,A             ; Save difference if C
        LD      A,H             ; Get MSB of end
        SBC     A,D             ; Subtract MSB of beginning
ACPASS: LD      B,C             ; Return integer AC
ABPASS: LD      D,B             ; Return integer AB
        LD      E,0
        LD      HL,TYPE         ; Point to type
        LD      (HL),E          ; Set type to numeric
        LD      B,80H+16        ; 16 bit integer
        JP      RETINT          ; Return the integr

POS:    LD      A,(CURPOS)      ; Get cursor position
PASSA:  LD      B,A             ; Put A into AB
        XOR     A               ; Zero A
        JP      ABPASS          ; Return integer AB

DEF:    CALL    CHEKFN          ; Get "FN" and name
        CALL    IDTEST          ; Test for illegal direct
        LD      BC,DATA         ; To get next statement
        PUSH    BC              ; Save address for RETurn
        PUSH    DE              ; Save address of function ptr
        CALL    CHKSYN          ; Make sure "(" follows
        .BYTE      "("
        CALL    GETVAR          ; Get argument variable name
        PUSH    HL              ; Save code string address
        EX      DE,HL           ; Argument address to HL
        DEC     HL
        LD      D,(HL)          ; Get first byte of arg name
        DEC     HL
        LD      E,(HL)          ; Get second byte of arg name
        POP     HL              ; Restore code string address
        CALL    TSTNUM          ; Make sure numeric argument
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE      ")"
        CALL    CHKSYN          ; Make sure "=" follows
        .BYTE      ZEQUAL          ; "=" token
        LD      B,H             ; Code string address to BC
        LD      C,L
        EX      (SP),HL         ; Save code str , Get FN ptr
        LD      (HL),C          ; Save LSB of FN code string
        INC     HL
        LD      (HL),B          ; Save MSB of FN code string
        JP      SVSTAD          ; Save address and do function

DOFN:   CALL    CHEKFN          ; Make sure FN follows
        PUSH    DE              ; Save function pointer address
        CALL    EVLPAR          ; Evaluate expression in "()"
        CALL    TSTNUM          ; Make sure numeric result
        EX      (SP),HL         ; Save code str , Get FN ptr
        LD      E,(HL)          ; Get LSB of FN code string
        INC     HL
        LD      D,(HL)          ; Get MSB of FN code string
        INC     HL
        LD      A,D             ; And function DEFined?
        OR      E
        JP      Z,UFERR         ; No - ?UF Error
        LD      A,(HL)          ; Get LSB of argument address
        INC     HL
        LD      H,(HL)          ; Get MSB of argument address
        LD      L,A             ; HL = Arg variable address
        PUSH    HL              ; Save it
        LD      HL,(FNRGNM)     ; Get old argument name
        EX      (SP),HL ;       ; Save old , Get new
        LD      (FNRGNM),HL     ; Set new argument name
        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
        PUSH    HL              ; Save it
        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
        PUSH    HL              ; Save it
        LD      HL,FNARG        ; HL = Value of argument
        PUSH    DE              ; Save FN code string address
        CALL    FPTHL           ; Move FPREG to argument
        POP     HL              ; Get FN code string address
        CALL    GETNUM          ; Get value from function
        DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        JP      NZ,SNERR        ; Bad character in FN - Error
        POP     HL              ; Get MSB,EXP of old arg
        LD      (FNARG),HL      ; Restore it
        POP     HL              ; Get LSB,NLSB of old arg
        LD      (FNARG+2),HL    ; Restore it
        POP     HL              ; Get name of old arg
        LD      (FNRGNM),HL     ; Restore it
        POP     HL              ; Restore code string address
        RET

IDTEST: PUSH    HL              ; Save code string address
        LD      HL,(LINEAT)     ; Get current line number
        INC     HL              ; -1 means direct statement
        LD      A,H
        OR      L
        POP     HL              ; Restore code string address
        RET     NZ              ; Return if in program
        LD      E,ID            ; ?ID Error
        JP      ERROR

CHEKFN: CALL    CHKSYN          ; Make sure FN follows
        .BYTE      ZFN             ; "FN" token
        LD      A,80H
        LD      (FORFLG),A      ; Flag FN name to find
        OR      (HL)            ; FN name has bit 7 set
        LD      B,A             ; in first byte of name
        CALL    GTFNAM          ; Get FN name
        JP      TSTNUM          ; Make sure numeric function

STR:    CALL    TSTNUM          ; Make sure it's a number
        CALL    NUMASC          ; Turn number into text
STR1:   CALL    CRTST           ; Create string entry for it
        CALL    GSTRCU          ; Current string to pool
        LD      BC,TOPOOL       ; Save in string pool
        PUSH    BC              ; Save address on stack

SAVSTR: LD      A,(HL)          ; Get string length
        INC     HL
        INC     HL
        PUSH    HL              ; Save pointer to string
        CALL    TESTR           ; See if enough string space
        POP     HL              ; Restore pointer to string
        LD      C,(HL)          ; Get LSB of address
        INC     HL
        LD      B,(HL)          ; Get MSB of address
        CALL    CRTMST          ; Create string entry
        PUSH    HL              ; Save pointer to MSB of addr
        LD      L,A             ; Length of string
        CALL    TOSTRA          ; Move to string area
        POP     DE              ; Restore pointer to MSB
        RET

MKTMST: CALL    TESTR           ; See if enough string space
CRTMST: LD      HL,TMPSTR       ; Temporary string
        PUSH    HL              ; Save it
        LD      (HL),A          ; Save length of string
        INC     HL
SVSTAD: INC     HL
        LD      (HL),E          ; Save LSB of address
        INC     HL
        LD      (HL),D          ; Save MSB of address
        POP     HL              ; Restore pointer
        RET

CRTST:  DEC     HL              ; DEC - INCed after
QTSTR:  LD      B,'"'           ; Terminating quote
        LD      D,B             ; Quote to D
DTSTR:  PUSH    HL              ; Save start
        LD      C,-1            ; Set counter to -1
QTSTLP: INC     HL              ; Move on
        LD      A,(HL)          ; Get byte
        INC     C               ; Count bytes
        OR      A               ; End of line?
        JP      Z,CRTSTE        ; Yes - Create string entry
        CP      D               ; Terminator D found?
        JP      Z,CRTSTE        ; Yes - Create string entry
        CP      B               ; Terminator B found?
        JP      NZ,QTSTLP       ; No - Keep looking
CRTSTE: CP      '"'             ; End with '"'?
        CALL    Z,GETCHR        ; Yes - Get next character
        EX      (SP),HL         ; Starting quote
        INC     HL              ; First byte of string
        EX      DE,HL           ; To DE
        LD      A,C             ; Get length
        CALL    CRTMST          ; Create string entry
TSTOPL: LD      DE,TMPSTR       ; Temporary string
        LD      HL,(TMSTPT)     ; Temporary string pool pointer
        LD      (FPREG),HL      ; Save address of string ptr
        LD      A,1
        LD      (TYPE),A        ; Set type to string
        CALL    DETHL4          ; Move string to pool
        CALL    CPDEHL          ; Out of string pool?
        LD      (TMSTPT),HL     ; Save new pointer
        POP     HL              ; Restore code string address
        LD      A,(HL)          ; Get next code byte
        RET     NZ              ; Return if pool OK
        LD      E,ST            ; ?ST Error
        JP      ERROR           ; String pool overflow

PRNUMS: INC     HL              ; Skip leading space
PRS:    CALL    CRTST           ; Create string entry for it
PRS1:   CALL    GSTRCU          ; Current string to pool
        CALL    LOADFP          ; Move string block to BCDE
        INC     E               ; Length + 1
PRSLP:  DEC     E               ; Count characters
        RET     Z               ; End of string
        LD      A,(BC)          ; Get byte to output
        CALL    OUTC            ; Output character in A
        CP      CR              ; Return?
        CALL    Z,DONULL        ; Yes - Do nulls
        INC     BC              ; Next byte in string
        JP      PRSLP           ; More characters to output

TESTR:  OR      A               ; Test if enough room
        .BYTE      0EH             ; No garbage collection done
GRBDON: POP     AF              ; Garbage collection done
        PUSH    AF              ; Save status
        LD      HL,(STRSPC)     ; Bottom of string space in use
        EX      DE,HL           ; To DE
        LD      HL,(STRBOT)     ; Bottom of string area
        CPL                     ; Negate length (Top down)
        LD      C,A             ; -Length to BC
        LD      B,-1            ; BC = -ve length of string
        ADD     HL,BC           ; Add to bottom of space in use
        INC     HL              ; Plus one for 2's complement
        CALL    CPDEHL          ; Below string RAM area?
        JP      C,TESTOS        ; Tidy up if not done else err
        LD      (STRBOT),HL     ; Save new bottom of area
        INC     HL              ; Point to first byte of string
        EX      DE,HL           ; Address to DE
POPAF:  POP     AF              ; Throw away status push
        RET

TESTOS: POP     AF              ; Garbage collect been done?
        LD      E,OS            ; ?OS Error
        JP      Z,ERROR         ; Yes - Not enough string apace
        CP      A               ; Flag garbage collect done
        PUSH    AF              ; Save status
        LD      BC,GRBDON       ; Garbage collection done
        PUSH    BC              ; Save for RETurn
GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
GARBLP: LD      (STRBOT),HL     ; Reset string pointer
        LD      HL,0
        PUSH    HL              ; Flag no string found
        LD      HL,(STRSPC)     ; Get bottom of string space
        PUSH    HL              ; Save bottom of string space
        LD      HL,TMSTPL       ; Temporary string pool
GRBLP:  EX      DE,HL
        LD      HL,(TMSTPT)     ; Temporary string pool pointer
        EX      DE,HL
        CALL    CPDEHL          ; Temporary string pool done?
        LD      BC,GRBLP        ; Loop until string pool done
        JP      NZ,STPOOL       ; No - See if in string area
        LD      HL,(PROGND)     ; Start of simple variables
SMPVAR: EX      DE,HL
        LD      HL,(VAREND)     ; End of simple variables
        EX      DE,HL
        CALL    CPDEHL          ; All simple strings done?
        JP      Z,ARRLP         ; Yes - Do string arrays
        LD      A,(HL)          ; Get type of variable
        INC     HL
        INC     HL
        OR      A               ; "S" flag set if string
        CALL    STRADD          ; See if string in string area
        JP      SMPVAR          ; Loop until simple ones done

GNXARY: POP     BC              ; Scrap address of this array
ARRLP:  EX      DE,HL
        LD      HL,(ARREND)     ; End of string arrays
        EX      DE,HL
        CALL    CPDEHL          ; All string arrays done?
        JP      Z,SCNEND        ; Yes - Move string if found
        CALL    LOADFP          ; Get array name to BCDE
        LD      A,E             ; Get type of array     
        PUSH    HL              ; Save address of num of dim'ns
        ADD     HL,BC           ; Start of next array
        OR      A               ; Test type of array
        JP      P,GNXARY        ; Numeric array - Ignore it
        LD      (CUROPR),HL     ; Save address of next array
        POP     HL              ; Get address of num of dim'ns
        LD      C,(HL)          ; BC = Number of dimensions
        LD      B,0
        ADD     HL,BC           ; Two bytes per dimension size
        ADD     HL,BC
        INC     HL              ; Plus one for number of dim'ns
GRBARY: EX      DE,HL
        LD      HL,(CUROPR)     ; Get address of next array
        EX      DE,HL
        CALL    CPDEHL          ; Is this array finished?
        JP      Z,ARRLP         ; Yes - Get next one
        LD      BC,GRBARY       ; Loop until array all done
STPOOL: PUSH    BC              ; Save return address
        OR      80H             ; Flag string type
STRADD: LD      A,(HL)          ; Get string length
        INC     HL
        INC     HL
        LD      E,(HL)          ; Get LSB of string address
        INC     HL
        LD      D,(HL)          ; Get MSB of string address
        INC     HL
        RET     P               ; Not a string - Return
        OR      A               ; Set flags on string length
        RET     Z               ; Null string - Return
        LD      B,H             ; Save variable pointer
        LD      C,L
        LD      HL,(STRBOT)     ; Bottom of new area
        CALL    CPDEHL          ; String been done?
        LD      H,B             ; Restore variable pointer
        LD      L,C
        RET     C               ; String done - Ignore
        POP     HL              ; Return address
        EX      (SP),HL         ; Lowest available string area
        CALL    CPDEHL          ; String within string area?
        EX      (SP),HL         ; Lowest available string area
        PUSH    HL              ; Re-save return address
        LD      H,B             ; Restore variable pointer
        LD      L,C
        RET     NC              ; Outside string area - Ignore
        POP     BC              ; Get return , Throw 2 away
        POP     AF              ; 
        POP     AF              ; 
        PUSH    HL              ; Save variable pointer
        PUSH    DE              ; Save address of current
        PUSH    BC              ; Put back return address
        RET                     ; Go to it

SCNEND: POP     DE              ; Addresses of strings
        POP     HL              ; 
        LD      A,L             ; HL = 0 if no more to do
        OR      H
        RET     Z               ; No more to do - Return
        DEC     HL
        LD      B,(HL)          ; MSB of address of string
        DEC     HL
        LD      C,(HL)          ; LSB of address of string
        PUSH    HL              ; Save variable address
        DEC     HL
        DEC     HL
        LD      L,(HL)          ; HL = Length of string
        LD      H,0
        ADD     HL,BC           ; Address of end of string+1
        LD      D,B             ; String address to DE
        LD      E,C
        DEC     HL              ; Last byte in string
        LD      B,H             ; Address to BC
        LD      C,L
        LD      HL,(STRBOT)     ; Current bottom of string area
        CALL    MOVSTR          ; Move string to new address
        POP     HL              ; Restore variable address
        LD      (HL),C          ; Save new LSB of address
        INC     HL
        LD      (HL),B          ; Save new MSB of address
        LD      L,C             ; Next string area+1 to HL
        LD      H,B
        DEC     HL              ; Next string area address
        JP      GARBLP          ; Look for more strings

CONCAT: PUSH    BC              ; Save prec' opr & code string
        PUSH    HL              ; 
        LD      HL,(FPREG)      ; Get first string
        EX      (SP),HL         ; Save first string
        CALL    OPRND           ; Get second string
        EX      (SP),HL         ; Restore first string
        CALL    TSTSTR          ; Make sure it's a string
        LD      A,(HL)          ; Get length of second string
        PUSH    HL              ; Save first string
        LD      HL,(FPREG)      ; Get second string
        PUSH    HL              ; Save second string
        ADD     A,(HL)          ; Add length of second string
        LD      E,LS            ; ?LS Error
        JP      C,ERROR         ; String too long - Error
        CALL    MKTMST          ; Make temporary string
        POP     DE              ; Get second string to DE
        CALL    GSTRDE          ; Move to string pool if needed
        EX      (SP),HL         ; Get first string
        CALL    GSTRHL          ; Move to string pool if needed
        PUSH    HL              ; Save first string
        LD      HL,(TMPSTR+2)   ; Temporary string address
        EX      DE,HL           ; To DE
        CALL    SSTSA           ; First string to string area
        CALL    SSTSA           ; Second string to string area
        LD      HL,EVAL2        ; Return to evaluation loop
        EX      (SP),HL         ; Save return,get code string
        PUSH    HL              ; Save code string address
        JP      TSTOPL          ; To temporary string to pool

SSTSA:  POP     HL              ; Return address
        EX      (SP),HL         ; Get string block,save return
        LD      A,(HL)          ; Get length of string
        INC     HL
        INC     HL
        LD      C,(HL)          ; Get LSB of string address
        INC     HL
        LD      B,(HL)          ; Get MSB of string address
        LD      L,A             ; Length to L
TOSTRA: INC     L               ; INC - DECed after
TSALP:  DEC     L               ; Count bytes moved
        RET     Z               ; End of string - Return
        LD      A,(BC)          ; Get source
        LD      (DE),A          ; Save destination
        INC     BC              ; Next source
        INC     DE              ; Next destination
        JP      TSALP           ; Loop until string moved

GETSTR: CALL    TSTSTR          ; Make sure it's a string
GSTRCU: LD      HL,(FPREG)      ; Get current string
GSTRHL: EX      DE,HL           ; Save DE
GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
        EX      DE,HL           ; Restore DE
        RET     NZ              ; No - Return
        PUSH    DE              ; Save string
        LD      D,B             ; String block address to DE
        LD      E,C
        DEC     DE              ; Point to length
        LD      C,(HL)          ; Get string length
        LD      HL,(STRBOT)     ; Current bottom of string area
        CALL    CPDEHL          ; Last one in string area?
        JP      NZ,POPHL        ; No - Return
        LD      B,A             ; Clear B (A=0)
        ADD     HL,BC           ; Remove string from str' area
        LD      (STRBOT),HL     ; Save new bottom of str' area
POPHL:  POP     HL              ; Restore string
        RET

BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
        DEC     HL              ; Back
        LD      B,(HL)          ; Get MSB of address
        DEC     HL              ; Back
        LD      C,(HL)          ; Get LSB of address
        DEC     HL              ; Back
        DEC     HL              ; Back
        CALL    CPDEHL          ; String last in string pool?
        RET     NZ              ; Yes - Leave it
        LD      (TMSTPT),HL     ; Save new string pool top
        RET

LEN:    LD      BC,PASSA        ; To return integer A
        PUSH    BC              ; Save address
GETLEN: CALL    GETSTR          ; Get string and its length
        XOR     A
        LD      D,A             ; Clear D
        LD      (TYPE),A        ; Set type to numeric
        LD      A,(HL)          ; Get length of string
        OR      A               ; Set status flags
        RET

ASC:    LD      BC,PASSA        ; To return integer A
        PUSH    BC              ; Save address
GTFLNM: CALL    GETLEN          ; Get length of string
        JP      Z,FCERR         ; Null string - Error
        INC     HL
        INC     HL
        LD      E,(HL)          ; Get LSB of address
        INC     HL
        LD      D,(HL)          ; Get MSB of address
        LD      A,(DE)          ; Get first byte of string
        RET

CHR:    LD      A,1             ; One character string
        CALL    MKTMST          ; Make a temporary string
        CALL    MAKINT          ; Make it integer A
        LD      HL,(TMPSTR+2)   ; Get address of string
        LD      (HL),E          ; Save character
TOPOOL: POP     BC              ; Clean up stack
        JP      TSTOPL          ; Temporary string to pool

LEFT:   CALL    LFRGNM          ; Get number and ending ")"
        XOR     A               ; Start at first byte in string
RIGHT1: EX      (SP),HL         ; Save code string,Get string
        LD      C,A             ; Starting position in string
MID1:   PUSH    HL              ; Save string block address
        LD      A,(HL)          ; Get length of string
        CP      B               ; Compare with number given
        JP      C,ALLFOL        ; All following bytes required
        LD      A,B             ; Get new length
        .BYTE      11H             ; Skip "LD C,0"
ALLFOL: LD      C,0             ; First byte of string
        PUSH    BC              ; Save position in string
        CALL    TESTR           ; See if enough string space
        POP     BC              ; Get position in string
        POP     HL              ; Restore string block address
        PUSH    HL              ; And re-save it
        INC     HL
        INC     HL
        LD      B,(HL)          ; Get LSB of address
        INC     HL
        LD      H,(HL)          ; Get MSB of address
        LD      L,B             ; HL = address of string
        LD      B,0             ; BC = starting address
        ADD     HL,BC           ; Point to that byte
        LD      B,H             ; BC = source string
        LD      C,L
        CALL    CRTMST          ; Create a string entry
        LD      L,A             ; Length of new string
        CALL    TOSTRA          ; Move string to string area
        POP     DE              ; Clear stack
        CALL    GSTRDE          ; Move to string pool if needed
        JP      TSTOPL          ; Temporary string to pool

RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
        POP     DE              ; Get string length
        PUSH    DE              ; And re-save
        LD      A,(DE)          ; Get length
        SUB     B               ; Move back N bytes
        JP      RIGHT1          ; Go and get sub-string

MID:    EX      DE,HL           ; Get code string address
        LD      A,(HL)          ; Get next byte ',' or ")"
        CALL    MIDNUM          ; Get number supplied
        INC     B               ; Is it character zero?
        DEC     B
        JP      Z,FCERR         ; Yes - Error
        PUSH    BC              ; Save starting position
        LD      E,255           ; All of string
        CP      ')'             ; Any length given?
        JP      Z,RSTSTR        ; No - Rest of string
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    GETINT          ; Get integer 0-255
RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
        .BYTE      ")"
        POP     AF              ; Restore starting position
        EX      (SP),HL         ; Get string,8ave code string
        LD      BC,MID1         ; Continuation of MID$ routine
        PUSH    BC              ; Save for return
        DEC     A               ; Starting position-1
        CP      (HL)            ; Compare with length
        LD      B,0             ; Zero bytes length
        RET     NC              ; Null string if start past end
        LD      C,A             ; Save starting position-1
        LD      A,(HL)          ; Get length of string
        SUB     C               ; Subtract start
        CP      E               ; Enough string for it?
        LD      B,A             ; Save maximum length available
        RET     C               ; Truncate string if needed
        LD      B,E             ; Set specified length
        RET                     ; Go and create string

VAL:    CALL    GETLEN          ; Get length of string
        JP      Z,RESZER        ; Result zero
        LD      E,A             ; Save length
        INC     HL
        INC     HL
        LD      A,(HL)          ; Get LSB of address
        INC     HL
        LD      H,(HL)          ; Get MSB of address
        LD      L,A             ; HL = String address
        PUSH    HL              ; Save string address
        ADD     HL,DE
        LD      B,(HL)          ; Get end of string+1 byte
        LD      (HL),D          ; Zero it to terminate
        EX      (SP),HL         ; Save string end,get start
        PUSH    BC              ; Save end+1 byte
        LD      A,(HL)          ; Get starting byte
    CP	'$'		; Hex number indicated? [function added]
    JP	NZ,VAL1
    CALL	HEXTFP		; Convert Hex to FPREG
    JR	VAL3
VAL1:	CP	'%'		; Binary number indicated? [function added]
    JP	NZ,VAL2
    CALL	BINTFP		; Convert Bin to FPREG
    JR	VAL3
VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
VAL3:   POP     BC              ; Restore end+1 byte
        POP     HL              ; Restore end+1 address
        LD      (HL),B          ; Put back original byte
        RET

LFRGNM: EX      DE,HL           ; Code string address to HL
        CALL    CHKSYN          ; Make sure ")" follows
        .BYTE      ")"
MIDNUM: POP     BC              ; Get return address
        POP     DE              ; Get number supplied
        PUSH    BC              ; Re-save return address
        LD      B,E             ; Number to B
        RET

INP:    CALL    MAKINT          ; Make it integer A
        LD      (INPORT),A      ; Set input port
        CALL    INPSUB          ; Get input from port
        JP      PASSA           ; Return integer A

POUT:   CALL    SETIO           ; Set up port number
        JP      OUTSUB          ; Output data and return

WAIT:   CALL    SETIO           ; Set up port number
        PUSH    AF              ; Save AND mask
        LD      E,0             ; Assume zero if none given
        DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        JP      Z,NOXOR         ; No XOR byte given
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    GETINT          ; Get integer 0-255 to XOR with
NOXOR:  POP     BC              ; Restore AND mask
WAITLP: CALL    INPSUB          ; Get input
        XOR     E               ; Flip selected bits
        AND     B               ; Result non-zero?
        JP      Z,WAITLP        ; No = keep waiting
        RET

SETIO:  CALL    GETINT          ; Get integer 0-255
        LD      (INPORT),A      ; Set input port
        LD      (OTPORT),A      ; Set output port
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        JP      GETINT          ; Get integer 0-255 and return

FNDNUM: CALL    GETCHR          ; Get next character
GETINT: CALL    GETNUM          ; Get a number from 0 to 255
MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
        LD      A,D             ; Get MSB of number
        OR      A               ; Zero?
        JP      NZ,FCERR        ; No - Error
        DEC     HL              ; DEC 'cos GETCHR INCs
        CALL    GETCHR          ; Get next character
        LD      A,E             ; Get number to A
        RET

PEEK:   CALL    DEINT           ; Get memory address
        LD      A,(DE)          ; Get byte in memory
        JP      PASSA           ; Return integer A

POKE:   CALL    GETNUM          ; Get memory address
        CALL    DEINT           ; Get integer -32768 to 3276
        PUSH    DE              ; Save memory address
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    GETINT          ; Get integer 0-255
        POP     DE              ; Restore memory address
        LD      (DE),A          ; Load it into memory
        RET

ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
        JP      FPADD           ; Add BCDE to FPREG

SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
        .BYTE      21H             ; Skip "POP BC" and "POP DE"
PSUB:   POP     BC              ; Get FP number from stack
        POP     DE
SUBCDE: CALL    INVSGN          ; Negate FPREG
FPADD:  LD      A,B             ; Get FP exponent
        OR      A               ; Is number zero?
        RET     Z               ; Yes - Nothing to add
        LD      A,(FPEXP)       ; Get FPREG exponent
        OR      A               ; Is this number zero?
        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
        SUB     B               ; BCDE number larger?
        JP      NC,NOSWAP       ; No - Don't swap them
        CPL                     ; Two's complement
        INC     A               ;  FP exponent
        EX      DE,HL
        CALL    STAKFP          ; Put FPREG on stack
        EX      DE,HL
        CALL    FPBCDE          ; Move BCDE to FPREG
        POP     BC              ; Restore number from stack
        POP     DE
NOSWAP: CP      24+1            ; Second number insignificant?
        RET     NC              ; Yes - First number is result
        PUSH    AF              ; Save number of bits to scale
        CALL    SIGNS           ; Set MSBs & sign of result
        LD      H,A             ; Save sign of result
        POP     AF              ; Restore scaling factor
        CALL    SCALE           ; Scale BCDE to same exponent
        OR      H               ; Result to be positive?
        LD      HL,FPREG        ; Point to FPREG
        JP      P,MINCDE        ; No - Subtract FPREG from CDE
        CALL    PLUCDE          ; Add FPREG to CDE
        JP      NC,RONDUP       ; No overflow - Round it up
        INC     HL              ; Point to exponent
        INC     (HL)            ; Increment it
        JP      Z,OVERR         ; Number overflowed - Error
        LD      L,1             ; 1 bit to shift right
        CALL    SHRT1           ; Shift result right
        JP      RONDUP          ; Round it up

MINCDE: XOR     A               ; Clear A and carry
        SUB     B               ; Negate exponent
        LD      B,A             ; Re-save exponent
        LD      A,(HL)          ; Get LSB of FPREG
        SBC     A, E            ; Subtract LSB of BCDE
        LD      E,A             ; Save LSB of BCDE
        INC     HL
        LD      A,(HL)          ; Get NMSB of FPREG
        SBC     A,D             ; Subtract NMSB of BCDE
        LD      D,A             ; Save NMSB of BCDE
        INC     HL
        LD      A,(HL)          ; Get MSB of FPREG
        SBC     A,C             ; Subtract MSB of BCDE
        LD      C,A             ; Save MSB of BCDE
CONPOS: CALL    C,COMPL         ; Overflow - Make it positive

BNORM:  LD      L,B             ; L = Exponent
        LD      H,E             ; H = LSB
        XOR     A
BNRMLP: LD      B,A             ; Save bit count
        LD      A,C             ; Get MSB
        OR      A               ; Is it zero?
        JP      NZ,PNORM        ; No - Do it bit at a time
        LD      C,D             ; MSB = NMSB
        LD      D,H             ; NMSB= LSB
        LD      H,L             ; LSB = VLSB
        LD      L,A             ; VLSB= 0
        LD      A,B             ; Get exponent
        SUB     8               ; Count 8 bits
        CP      -24-8           ; Was number zero?
        JP      NZ,BNRMLP       ; No - Keep normalising
RESZER: XOR     A               ; Result is zero
SAVEXP: LD      (FPEXP),A       ; Save result as zero
        RET

NORMAL: DEC     B               ; Count bits
        ADD     HL,HL           ; Shift HL left
        LD      A,D             ; Get NMSB
        RLA                     ; Shift left with last bit
        LD      D,A             ; Save NMSB
        LD      A,C             ; Get MSB
        ADC     A,A             ; Shift left with last bit
        LD      C,A             ; Save MSB
PNORM:  JP      P,NORMAL        ; Not done - Keep going
        LD      A,B             ; Number of bits shifted
        LD      E,H             ; Save HL in EB
        LD      B,L
        OR      A               ; Any shifting done?
        JP      Z,RONDUP        ; No - Round it up
        LD      HL,FPEXP        ; Point to exponent
        ADD     A,(HL)          ; Add shifted bits
        LD      (HL),A          ; Re-save exponent
        JP      NC,RESZER       ; Underflow - Result is zero
        RET     Z               ; Result is zero
RONDUP: LD      A,B             ; Get VLSB of number
RONDB:  LD      HL,FPEXP        ; Point to exponent
        OR      A               ; Any rounding?
        CALL    M,FPROND        ; Yes - Round number up
        LD      B,(HL)          ; B = Exponent
        INC     HL
        LD      A,(HL)          ; Get sign of result
        AND     10000000B       ; Only bit 7 needed
        XOR     C               ; Set correct sign
        LD      C,A             ; Save correct sign in number
        JP      FPBCDE          ; Move BCDE to FPREG

FPROND: INC     E               ; Round LSB
        RET     NZ              ; Return if ok
        INC     D               ; Round NMSB
        RET     NZ              ; Return if ok
        INC     C               ; Round MSB
        RET     NZ              ; Return if ok
        LD      C,80H           ; Set normal value
        INC     (HL)            ; Increment exponent
        RET     NZ              ; Return if ok
        JP      OVERR           ; Overflow error

PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
        ADD     A,E             ; Add LSB of BCDE
        LD      E,A             ; Save LSB of BCDE
        INC     HL
        LD      A,(HL)          ; Get NMSB of FPREG
        ADC     A,D             ; Add NMSB of BCDE
        LD      D,A             ; Save NMSB of BCDE
        INC     HL
        LD      A,(HL)          ; Get MSB of FPREG
        ADC     A,C             ; Add MSB of BCDE
        LD      C,A             ; Save MSB of BCDE
        RET

COMPL:  LD      HL,SGNRES       ; Sign of result
        LD      A,(HL)          ; Get sign of result
        CPL                     ; Negate it
        LD      (HL),A          ; Put it back
        XOR     A
        LD      L,A             ; Set L to zero
        SUB     B               ; Negate exponent,set carry
        LD      B,A             ; Re-save exponent
        LD      A,L             ; Load zero
        SBC     A,E             ; Negate LSB
        LD      E,A             ; Re-save LSB
        LD      A,L             ; Load zero
        SBC     A,D             ; Negate NMSB
        LD      D,A             ; Re-save NMSB
        LD      A,L             ; Load zero
        SBC     A,C             ; Negate MSB
        LD      C,A             ; Re-save MSB
        RET

SCALE:  LD      B,0             ; Clear underflow
SCALLP: SUB     8               ; 8 bits (a whole byte)?
        JP      C,SHRITE        ; No - Shift right A bits
        LD      B,E             ; <- Shift
        LD      E,D             ; <- right
        LD      D,C             ; <- eight
        LD      C,0             ; <- bits
        JP      SCALLP          ; More bits to shift

SHRITE: ADD     A,8+1           ; Adjust count
        LD      L,A             ; Save bits to shift
SHRLP:  XOR     A               ; Flag for all done
        DEC     L               ; All shifting done?
        RET     Z               ; Yes - Return
        LD      A,C             ; Get MSB
SHRT1:  RRA                     ; Shift it right
        LD      C,A             ; Re-save
        LD      A,D             ; Get NMSB
        RRA                     ; Shift right with last bit
        LD      D,A             ; Re-save it
        LD      A,E             ; Get LSB
        RRA                     ; Shift right with last bit
        LD      E,A             ; Re-save it
        LD      A,B             ; Get underflow
        RRA                     ; Shift right with last bit
        LD      B,A             ; Re-save underflow
        JP      SHRLP           ; More bits to do

UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000

LOGTAB: .BYTE      3                       ; Table used by LOG
        .BYTE      0AAH,056H,019H,080H     ; 0.59898
        .BYTE      0F1H,022H,076H,080H     ; 0.96147
        .BYTE      045H,0AAH,038H,082H     ; 2.88539

LOG:    CALL    TSTSGN          ; Test sign of value
        OR      A
        JP      PE,FCERR        ; ?FC Error if <= zero
        LD      HL,FPEXP        ; Point to exponent
        LD      A,(HL)          ; Get exponent
        LD      BC,8035H        ; BCDE = SQR(1/2)
        LD      DE,04F3H
        SUB     B               ; Scale value to be < 1
        PUSH    AF              ; Save scale factor
        LD      (HL),B          ; Save new exponent
        PUSH    DE              ; Save SQR(1/2)
        PUSH    BC
        CALL    FPADD           ; Add SQR(1/2) to value
        POP     BC              ; Restore SQR(1/2)
        POP     DE
        INC     B               ; Make it SQR(2)
        CALL    DVBCDE          ; Divide by SQR(2)
        LD      HL,UNITY        ; Point to 1.
        CALL    SUBPHL          ; Subtract FPREG from 1
        LD      HL,LOGTAB       ; Coefficient table
        CALL    SUMSER          ; Evaluate sum of series
        LD      BC,8080H        ; BCDE = -0.5
        LD      DE,0000H
        CALL    FPADD           ; Subtract 0.5 from FPREG
        POP     AF              ; Restore scale factor
        CALL    RSCALE          ; Re-scale number
MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
        LD      DE,7218H
        .BYTE      21H             ; Skip "POP BC" and "POP DE"

MULT:   POP     BC              ; Get number from stack
        POP     DE
FPMULT: CALL    TSTSGN          ; Test sign of FPREG
        RET     Z               ; Return zero if zero
        LD      L,0             ; Flag add exponents
        CALL    ADDEXP          ; Add exponents
        LD      A,C             ; Get MSB of multiplier
        LD      (MULVAL),A      ; Save MSB of multiplier
        EX      DE,HL
        LD      (MULVAL+1),HL   ; Save rest of multiplier
        LD      BC,0            ; Partial product (BCDE) = zero
        LD      D,B
        LD      E,B
        LD      HL,BNORM        ; Address of normalise
        PUSH    HL              ; Save for return
        LD      HL,MULT8        ; Address of 8 bit multiply
        PUSH    HL              ; Save for NMSB,MSB
        PUSH    HL              ; 
        LD      HL,FPREG        ; Point to number
MULT8:  LD      A,(HL)          ; Get LSB of number
        INC     HL              ; Point to NMSB
        OR      A               ; Test LSB
        JP      Z,BYTSFT        ; Zero - shift to next byte
        PUSH    HL              ; Save address of number
        LD      L,8             ; 8 bits to multiply by
MUL8LP: RRA                     ; Shift LSB right
        LD      H,A             ; Save LSB
        LD      A,C             ; Get MSB
        JP      NC,NOMADD       ; Bit was zero - Don't add
        PUSH    HL              ; Save LSB and count
        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
        ADD     HL,DE           ; Add NMSB and LSB
        EX      DE,HL           ; Leave sum in DE
        POP     HL              ; Restore MSB and count
        LD      A,(MULVAL)      ; Get MSB of multiplier
        ADC     A,C             ; Add MSB
NOMADD: RRA                     ; Shift MSB right
        LD      C,A             ; Re-save MSB
        LD      A,D             ; Get NMSB
        RRA                     ; Shift NMSB right
        LD      D,A             ; Re-save NMSB
        LD      A,E             ; Get LSB
        RRA                     ; Shift LSB right
        LD      E,A             ; Re-save LSB
        LD      A,B             ; Get VLSB
        RRA                     ; Shift VLSB right
        LD      B,A             ; Re-save VLSB
        DEC     L               ; Count bits multiplied
        LD      A,H             ; Get LSB of multiplier
        JP      NZ,MUL8LP       ; More - Do it
POPHRT: POP     HL              ; Restore address of number
        RET

BYTSFT: LD      B,E             ; Shift partial product left
        LD      E,D
        LD      D,C
        LD      C,A
        RET

DIV10:  CALL    STAKFP          ; Save FPREG on stack
        LD      BC,8420H        ; BCDE = 10.
        LD      DE,0000H
        CALL    FPBCDE          ; Move 10 to FPREG

DIV:    POP     BC              ; Get number from stack
        POP     DE
DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
        JP      Z,DZERR         ; Error if division by zero
        LD      L,-1            ; Flag subtract exponents
        CALL    ADDEXP          ; Subtract exponents
        INC     (HL)            ; Add 2 to exponent to adjust
        INC     (HL)
        DEC     HL              ; Point to MSB
        LD      A,(HL)          ; Get MSB of dividend
        LD      (DIV3),A        ; Save for subtraction
        DEC     HL
        LD      A,(HL)          ; Get NMSB of dividend
        LD      (DIV2),A        ; Save for subtraction
        DEC     HL
        LD      A,(HL)          ; Get MSB of dividend
        LD      (DIV1),A        ; Save for subtraction
        LD      B,C             ; Get MSB
        EX      DE,HL           ; NMSB,LSB to HL
        XOR     A
        LD      C,A             ; Clear MSB of quotient
        LD      D,A             ; Clear NMSB of quotient
        LD      E,A             ; Clear LSB of quotient
        LD      (DIV4),A        ; Clear overflow count
DIVLP:  PUSH    HL              ; Save divisor
        PUSH    BC
        LD      A,L             ; Get LSB of number
        CALL    DIVSUP          ; Subt' divisor from dividend
        SBC     A,0             ; Count for overflows
        CCF
        JP      NC,RESDIV       ; Restore divisor if borrow
        LD      (DIV4),A        ; Re-save overflow count
        POP     AF              ; Scrap divisor
        POP     AF
        SCF                     ; Set carry to
        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"

RESDIV: POP     BC              ; Restore divisor
        POP     HL
        LD      A,C             ; Get MSB of quotient
        INC     A
        DEC     A
        RRA                     ; Bit 0 to bit 7
        JP      M,RONDB         ; Done - Normalise result
        RLA                     ; Restore carry
        LD      A,E             ; Get LSB of quotient
        RLA                     ; Double it
        LD      E,A             ; Put it back
        LD      A,D             ; Get NMSB of quotient
        RLA                     ; Double it
        LD      D,A             ; Put it back
        LD      A,C             ; Get MSB of quotient
        RLA                     ; Double it
        LD      C,A             ; Put it back
        ADD     HL,HL           ; Double NMSB,LSB of divisor
        LD      A,B             ; Get MSB of divisor
        RLA                     ; Double it
        LD      B,A             ; Put it back
        LD      A,(DIV4)        ; Get VLSB of quotient
        RLA                     ; Double it
        LD      (DIV4),A        ; Put it back
        LD      A,C             ; Get MSB of quotient
        OR      D               ; Merge NMSB
        OR      E               ; Merge LSB
        JP      NZ,DIVLP        ; Not done - Keep dividing
        PUSH    HL              ; Save divisor
        LD      HL,FPEXP        ; Point to exponent
        DEC     (HL)            ; Divide by 2
        POP     HL              ; Restore divisor
        JP      NZ,DIVLP        ; Ok - Keep going
        JP      OVERR           ; Overflow error

ADDEXP: LD      A,B             ; Get exponent of dividend
        OR      A               ; Test it
        JP      Z,OVTST3        ; Zero - Result zero
        LD      A,L             ; Get add/subtract flag
        LD      HL,FPEXP        ; Point to exponent
        XOR     (HL)            ; Add or subtract it
        ADD     A,B             ; Add the other exponent
        LD      B,A             ; Save new exponent
        RRA                     ; Test exponent for overflow
        XOR     B
        LD      A,B             ; Get exponent
        JP      P,OVTST2        ; Positive - Test for overflow
        ADD     A,80H           ; Add excess 128
        LD      (HL),A          ; Save new exponent
        JP      Z,POPHRT        ; Zero - Result zero
        CALL    SIGNS           ; Set MSBs and sign of result
        LD      (HL),A          ; Save new exponent
        DEC     HL              ; Point to MSB
        RET

OVTST1: CALL    TSTSGN          ; Test sign of FPREG
        CPL                     ; Invert sign
        POP     HL              ; Clean up stack
OVTST2: OR      A               ; Test if new exponent zero
OVTST3: POP     HL              ; Clear off return address
        JP      P,RESZER        ; Result zero
        JP      OVERR           ; Overflow error

MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
        LD      A,B             ; Get exponent
        OR      A               ; Is it zero?
        RET     Z               ; Yes - Result is zero
        ADD     A,2             ; Multiply by 4
        JP      C,OVERR         ; Overflow - ?OV Error
        LD      B,A             ; Re-save exponent
        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
        LD      HL,FPEXP        ; Point to exponent
        INC     (HL)            ; Double number (Times 10)
        RET     NZ              ; Ok - Return
        JP      OVERR           ; Overflow error

TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
        OR      A
        RET     Z               ; RETurn if number is zero
        LD      A,(FPREG+2)     ; Get MSB of FPREG
        .BYTE      0FEH            ; Test sign
RETREL: CPL                     ; Invert sign
        RLA                     ; Sign bit to carry
FLGDIF: SBC     A,A             ; Carry to all bits of A
        RET     NZ              ; Return -1 if negative
        INC     A               ; Bump to +1
        RET                     ; Positive - Return +1

SGN:    CALL    TSTSGN          ; Test sign of FPREG
FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
        LD      DE,0            ; Zero NMSB and LSB
RETINT: LD      HL,FPEXP        ; Point to exponent
        LD      C,A             ; CDE = MSB,NMSB and LSB
        LD      (HL),B          ; Save exponent
        LD      B,0             ; CDE = integer to normalise
        INC     HL              ; Point to sign of result
        LD      (HL),80H        ; Set sign of result
        RLA                     ; Carry = sign of integer
        JP      CONPOS          ; Set sign of result

ABS:    CALL    TSTSGN          ; Test sign of FPREG
        RET     P               ; Return if positive
INVSGN: LD      HL,FPREG+2      ; Point to MSB
        LD      A,(HL)          ; Get sign of mantissa
        XOR     80H             ; Invert sign of mantissa
        LD      (HL),A          ; Re-save sign of mantissa
        RET

STAKFP: EX      DE,HL           ; Save code string address
        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
        EX      (SP),HL         ; Stack them,get return
        PUSH    HL              ; Re-save return
        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
        EX      (SP),HL         ; Stack them,get return
        PUSH    HL              ; Re-save return
        EX      DE,HL           ; Restore code string address
        RET

PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
FPBCDE: EX      DE,HL           ; Save code string address
        LD      (FPREG),HL      ; Save LSB,NLSB of number
        LD      H,B             ; Exponent of number
        LD      L,C             ; MSB of number
        LD      (FPREG+2),HL    ; Save MSB and exponent
        EX      DE,HL           ; Restore code string address
        RET

BCDEFP: LD      HL,FPREG        ; Point to FPREG
LOADFP: LD      E,(HL)          ; Get LSB of number
        INC     HL
        LD      D,(HL)          ; Get NMSB of number
        INC     HL
        LD      C,(HL)          ; Get MSB of number
        INC     HL
        LD      B,(HL)          ; Get exponent of number
INCHL:  INC     HL              ; Used for conditional "INC HL"
        RET

FPTHL:  LD      DE,FPREG        ; Point to FPREG
DETHL4: LD      B,4             ; 4 bytes to move
DETHLB: LD      A,(DE)          ; Get source
        LD      (HL),A          ; Save destination
        INC     DE              ; Next source
        INC     HL              ; Next destination
        DEC     B               ; Count bytes
        JP      NZ,DETHLB       ; Loop if more
        RET

SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
        LD      A,(HL)          ; Get MSB
        RLCA                    ; Old sign to carry
        SCF                     ; Set MSBit
        RRA                     ; Set MSBit of MSB
        LD      (HL),A          ; Save new MSB
        CCF                     ; Complement sign
        RRA                     ; Old sign to carry
        INC     HL
        INC     HL
        LD      (HL),A          ; Set sign of result
        LD      A,C             ; Get MSB
        RLCA                    ; Old sign to carry
        SCF                     ; Set MSBit
        RRA                     ; Set MSBit of MSB
        LD      C,A             ; Save MSB
        RRA
        XOR     (HL)            ; New sign of result
        RET

CMPNUM: LD      A,B             ; Get exponent of number
        OR      A
        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
        LD      HL,RETREL       ; Return relation routine
        PUSH    HL              ; Save for return
        CALL    TSTSGN          ; Test sign of FPREG
        LD      A,C             ; Get MSB of number
        RET     Z               ; FPREG zero - Number's MSB
        LD      HL,FPREG+2      ; MSB of FPREG
        XOR     (HL)            ; Combine signs
        LD      A,C             ; Get MSB of number
        RET     M               ; Exit if signs different
        CALL    CMPFP           ; Compare FP numbers
        RRA                     ; Get carry to sign
        XOR     C               ; Combine with MSB of number
        RET

CMPFP:  INC     HL              ; Point to exponent
        LD      A,B             ; Get exponent
        CP      (HL)            ; Compare exponents
        RET     NZ              ; Different
        DEC     HL              ; Point to MBS
        LD      A,C             ; Get MSB
        CP      (HL)            ; Compare MSBs
        RET     NZ              ; Different
        DEC     HL              ; Point to NMSB
        LD      A,D             ; Get NMSB
        CP      (HL)            ; Compare NMSBs
        RET     NZ              ; Different
        DEC     HL              ; Point to LSB
        LD      A,E             ; Get LSB
        SUB     (HL)            ; Compare LSBs
        RET     NZ              ; Different
        POP     HL              ; Drop RETurn
        POP     HL              ; Drop another RETurn
        RET

FPINT:  LD      B,A             ; <- Move
        LD      C,A             ; <- exponent
        LD      D,A             ; <- to all
        LD      E,A             ; <- bits
        OR      A               ; Test exponent
        RET     Z               ; Zero - Return zero
        PUSH    HL              ; Save pointer to number
        CALL    BCDEFP          ; Move FPREG to BCDE
        CALL    SIGNS           ; Set MSBs & sign of result
        XOR     (HL)            ; Combine with sign of FPREG
        LD      H,A             ; Save combined signs
        CALL    M,DCBCDE        ; Negative - Decrement BCDE
        LD      A,80H+24        ; 24 bits
        SUB     B               ; Bits to shift
        CALL    SCALE           ; Shift BCDE
        LD      A,H             ; Get combined sign
        RLA                     ; Sign to carry
        CALL    C,FPROND        ; Negative - Round number up
        LD      B,0             ; Zero exponent
        CALL    C,COMPL         ; If negative make positive
        POP     HL              ; Restore pointer to number
        RET

DCBCDE: DEC     DE              ; Decrement BCDE
        LD      A,D             ; Test LSBs
        AND     E
        INC     A
        RET     NZ              ; Exit if LSBs not FFFF
        DEC     BC              ; Decrement MSBs
        RET

INT:    LD      HL,FPEXP        ; Point to exponent
        LD      A,(HL)          ; Get exponent
        CP      80H+24          ; Integer accuracy only?
        LD      A,(FPREG)       ; Get LSB
        RET     NC              ; Yes - Already integer
        LD      A,(HL)          ; Get exponent
        CALL    FPINT           ; F.P to integer
        LD      (HL),80H+24     ; Save 24 bit integer
        LD      A,E             ; Get LSB of number
        PUSH    AF              ; Save LSB
        LD      A,C             ; Get MSB of number
        RLA                     ; Sign to carry
        CALL    CONPOS          ; Set sign of result
        POP     AF              ; Restore LSB of number
        RET

MLDEBC: LD      HL,0            ; Clear partial product
        LD      A,B             ; Test multiplier
        OR      C
        RET     Z               ; Return zero if zero
        LD      A,16            ; 16 bits
MLDBLP: ADD     HL,HL           ; Shift P.P left
        JP      C,BSERR         ; ?BS Error if overflow
        EX      DE,HL
        ADD     HL,HL           ; Shift multiplier left
        EX      DE,HL
        JP      NC,NOMLAD       ; Bit was zero - No add
        ADD     HL,BC           ; Add multiplicand
        JP      C,BSERR         ; ?BS Error if overflow
NOMLAD: DEC     A               ; Count bits
        JP      NZ,MLDBLP       ; More
        RET

ASCTFP: CP      '-'             ; Negative?
        PUSH    AF              ; Save it and flags
        JP      Z,CNVNUM        ; Yes - Convert number
        CP      '+'             ; Positive?
        JP      Z,CNVNUM        ; Yes - Convert number
        DEC     HL              ; DEC 'cos GETCHR INCs
CNVNUM: CALL    RESZER          ; Set result to zero
        LD      B,A             ; Digits after point counter
        LD      D,A             ; Sign of exponent
        LD      E,A             ; Exponent of ten
        CPL
        LD      C,A             ; Before or after point flag
MANLP:  CALL    GETCHR          ; Get next character
        JP      C,ADDIG         ; Digit - Add to number
        CP      '.'
        JP      Z,DPOINT        ; '.' - Flag point
        CP      'E'
        JP      NZ,CONEXP       ; Not 'E' - Scale number
        CALL    GETCHR          ; Get next character
        CALL    SGNEXP          ; Get sign of exponent
EXPLP:  CALL    GETCHR          ; Get next character
        JP      C,EDIGIT        ; Digit - Add to exponent
        INC     D               ; Is sign negative?
        JP      NZ,CONEXP       ; No - Scale number
        XOR     A
        SUB     E               ; Negate exponent
        LD      E,A             ; And re-save it
        INC     C               ; Flag end of number
DPOINT: INC     C               ; Flag point passed
        JP      Z,MANLP         ; Zero - Get another digit
CONEXP: PUSH    HL              ; Save code string address
        LD      A,E             ; Get exponent
        SUB     B               ; Subtract digits after point
SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
        JP      P,ENDCON        ; Positive - All done
        PUSH    AF              ; Save number of times to /10
        CALL    DIV10           ; Divide by 10
        POP     AF              ; Restore count
        INC     A               ; Count divides

ENDCON: JP      NZ,SCALMI       ; More to do
        POP     DE              ; Restore code string address
        POP     AF              ; Restore sign of number
        CALL    Z,INVSGN        ; Negative - Negate number
        EX      DE,HL           ; Code string address to HL
        RET

SCALPL: RET     Z               ; Exit if no scaling needed
MULTEN: PUSH    AF              ; Save count
        CALL    MLSP10          ; Multiply number by 10
        POP     AF              ; Restore count
        DEC     A               ; Count multiplies
        RET

ADDIG:  PUSH    DE              ; Save sign of exponent
        LD      D,A             ; Save digit
        LD      A,B             ; Get digits after point
        ADC     A,C             ; Add one if after point
        LD      B,A             ; Re-save counter
        PUSH    BC              ; Save point flags
        PUSH    HL              ; Save code string address
        PUSH    DE              ; Save digit
        CALL    MLSP10          ; Multiply number by 10
        POP     AF              ; Restore digit
        SUB     '0'             ; Make it absolute
        CALL    RSCALE          ; Re-scale number
        POP     HL              ; Restore code string address
        POP     BC              ; Restore point flags
        POP     DE              ; Restore sign of exponent
        JP      MANLP           ; Get another digit

RSCALE: CALL    STAKFP          ; Put number on stack
        CALL    FLGREL          ; Digit to add to FPREG
PADD:   POP     BC              ; Restore number
        POP     DE
        JP      FPADD           ; Add BCDE to FPREG and return

EDIGIT: LD      A,E             ; Get digit
        RLCA                    ; Times 2
        RLCA                    ; Times 4
        ADD     A,E             ; Times 5
        RLCA                    ; Times 10
        ADD     A,(HL)          ; Add next digit
        SUB     '0'             ; Make it absolute
        LD      E,A             ; Save new digit
        JP      EXPLP           ; Look for another digit

LINEIN: PUSH    HL              ; Save code string address
        LD      HL,INMSG        ; Output " in "
        CALL    PRS             ; Output string at HL
        POP     HL              ; Restore code string address
PRNTHL: EX      DE,HL           ; Code string address to DE
        XOR     A
        LD      B,80H+24        ; 24 bits
        CALL    RETINT          ; Return the integer
        LD      HL,PRNUMS       ; Print number string
        PUSH    HL              ; Save for return
NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
        PUSH    HL              ; Save for return
        CALL    TSTSGN          ; Test sign of FPREG
        LD      (HL),' '        ; Space at start
        JP      P,SPCFST        ; Positive - Space to start
        LD      (HL),'-'        ; '-' sign at start
SPCFST: INC     HL              ; First byte of number
        LD      (HL),'0'        ; '0' if zero
        JP      Z,JSTZER        ; Return '0' if zero
        PUSH    HL              ; Save buffer address
        CALL    M,INVSGN        ; Negate FPREG if negative
        XOR     A               ; Zero A
        PUSH    AF              ; Save it
        CALL    RNGTST          ; Test number is in range
SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
        LD      DE,4FF8H
        CALL    CMPNUM          ; Compare numbers
        OR      A
        JP      PO,INRNG        ; > 99999.9 - Sort it out
        POP     AF              ; Restore count
        CALL    MULTEN          ; Multiply by ten
        PUSH    AF              ; Re-save count
        JP      SIXDIG          ; Test it again

GTSIXD: CALL    DIV10           ; Divide by 10
        POP     AF              ; Get count
        INC     A               ; Count divides
        PUSH    AF              ; Re-save count
        CALL    RNGTST          ; Test number is in range
INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
        INC     A
        CALL    FPINT           ; F.P to integer
        CALL    FPBCDE          ; Move BCDE to FPREG
        LD      BC,0306H        ; 1E+06 to 1E-03 range
        POP     AF              ; Restore count
        ADD     A,C             ; 6 digits before point
        INC     A               ; Add one
        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
        CP      6+1+1           ; More than 999999 ?
        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
        INC     A               ; Adjust for exponent
        LD      B,A             ; Exponent of number
        LD      A,2             ; Make it zero after

MAKNUM: DEC     A               ; Adjust for digits to do
        DEC     A
        POP     HL              ; Restore buffer address
        PUSH    AF              ; Save count
        LD      DE,POWERS       ; Powers of ten
        DEC     B               ; Count digits before point
        JP      NZ,DIGTXT       ; Not zero - Do number
        LD      (HL),'.'        ; Save point
        INC     HL              ; Move on
        LD      (HL),'0'        ; Save zero
        INC     HL              ; Move on
DIGTXT: DEC     B               ; Count digits before point
        LD      (HL),'.'        ; Save point in case
        CALL    Z,INCHL         ; Last digit - move on
        PUSH    BC              ; Save digits before point
        PUSH    HL              ; Save buffer address
        PUSH    DE              ; Save powers of ten
        CALL    BCDEFP          ; Move FPREG to BCDE
        POP     HL              ; Powers of ten table
        LD      B, '0'-1        ; ASCII '0' - 1
TRYAGN: INC     B               ; Count subtractions
        LD      A,E             ; Get LSB
        SUB     (HL)            ; Subtract LSB
        LD      E,A             ; Save LSB
        INC     HL
        LD      A,D             ; Get NMSB
        SBC     A,(HL)          ; Subtract NMSB
        LD      D,A             ; Save NMSB
        INC     HL
        LD      A,C             ; Get MSB
        SBC     A,(HL)          ; Subtract MSB
        LD      C,A             ; Save MSB
        DEC     HL              ; Point back to start
        DEC     HL
        JP      NC,TRYAGN       ; No overflow - Try again
        CALL    PLUCDE          ; Restore number
        INC     HL              ; Start of next number
        CALL    FPBCDE          ; Move BCDE to FPREG
        EX      DE,HL           ; Save point in table
        POP     HL              ; Restore buffer address
        LD      (HL),B          ; Save digit in buffer
        INC     HL              ; And move on
        POP     BC              ; Restore digit count
        DEC     C               ; Count digits
        JP      NZ,DIGTXT       ; More - Do them
        DEC     B               ; Any decimal part?
        JP      Z,DOEBIT        ; No - Do 'E' bit
SUPTLZ: DEC     HL              ; Move back through buffer
        LD      A,(HL)          ; Get character
        CP      '0'             ; '0' character?
        JP      Z,SUPTLZ        ; Yes - Look back for more
        CP      '.'             ; A decimal point?
        CALL    NZ,INCHL        ; Move back over digit

DOEBIT: POP     AF              ; Get 'E' flag
        JP      Z,NOENED        ; No 'E' needed - End buffer
        LD      (HL),'E'        ; Put 'E' in buffer
        INC     HL              ; And move on
        LD      (HL),'+'        ; Put '+' in buffer
        JP      P,OUTEXP        ; Positive - Output exponent
        LD      (HL),'-'        ; Put '-' in buffer
        CPL                     ; Negate exponent
        INC     A
OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
EXPTEN: INC     B               ; Count subtractions
        SUB     10              ; Tens digit
        JP      NC,EXPTEN       ; More to do
        ADD     A,'0'+10        ; Restore and make ASCII
        INC     HL              ; Move on
        LD      (HL),B          ; Save MSB of exponent
JSTZER: INC     HL              ;
        LD      (HL),A          ; Save LSB of exponent
        INC     HL
NOENED: LD      (HL),C          ; Mark end of buffer
        POP     HL              ; Restore code string address
        RET

RNGTST: LD      BC,9474H        ; BCDE = 999999.
        LD      DE,23F7H
        CALL    CMPNUM          ; Compare numbers
        OR      A
        POP     HL              ; Return address to HL
        JP      PO,GTSIXD       ; Too big - Divide by ten
        JP      (HL)            ; Otherwise return to caller

HALF:   .BYTE      00H,00H,00H,80H ; 0.5

POWERS: .BYTE      0A0H,086H,001H  ; 100000
        .BYTE      010H,027H,000H  ;  10000
        .BYTE      0E8H,003H,000H  ;   1000
        .BYTE      064H,000H,000H  ;    100
        .BYTE      00AH,000H,000H  ;     10
        .BYTE      001H,000H,000H  ;      1

NEGAFT: LD  HL,INVSGN           ; Negate result
        EX      (SP),HL         ; To be done after caller
        JP      (HL)            ; Return to caller

SQR:    CALL    STAKFP          ; Put value on stack
        LD      HL,HALF         ; Set power to 1/2
        CALL    PHLTFP          ; Move 1/2 to FPREG

POWER:  POP     BC              ; Get base
        POP     DE
        CALL    TSTSGN          ; Test sign of power
        LD      A,B             ; Get exponent of base
        JP      Z,EXP           ; Make result 1 if zero
        JP      P,POWER1        ; Positive base - Ok
        OR      A               ; Zero to negative power?
        JP      Z,DZERR         ; Yes - ?/0 Error
POWER1: OR      A               ; Base zero?
        JP      Z,SAVEXP        ; Yes - Return zero
        PUSH    DE              ; Save base
        PUSH    BC
        LD      A,C             ; Get MSB of base
        OR      01111111B       ; Get sign status
        CALL    BCDEFP          ; Move power to BCDE
        JP      P,POWER2        ; Positive base - Ok
        PUSH    DE              ; Save power
        PUSH    BC
        CALL    INT             ; Get integer of power
        POP     BC              ; Restore power
        POP     DE
        PUSH    AF              ; MSB of base
        CALL    CMPNUM          ; Power an integer?
        POP     HL              ; Restore MSB of base
        LD      A,H             ; but don't affect flags
        RRA                     ; Exponent odd or even?
POWER2: POP     HL              ; Restore MSB and exponent
        LD      (FPREG+2),HL    ; Save base in FPREG
        POP     HL              ; LSBs of base
        LD      (FPREG),HL      ; Save in FPREG
        CALL    C,NEGAFT        ; Odd power - Negate result
        CALL    Z,INVSGN        ; Negative base - Negate it
        PUSH    DE              ; Save power
        PUSH    BC
        CALL    LOG             ; Get LOG of base
        POP     BC              ; Restore power
        POP     DE
        CALL    FPMULT          ; Multiply LOG by power

EXP:    CALL    STAKFP          ; Put value on stack
        LD      BC,08138H       ; BCDE = 1/Ln(2)
        LD      DE,0AA3BH
        CALL    FPMULT          ; Multiply value by 1/LN(2)
        LD      A,(FPEXP)       ; Get exponent
        CP      80H+8           ; Is it in range?
        JP      NC,OVTST1       ; No - Test for overflow
        CALL    INT             ; Get INT of FPREG
        ADD     A,80H           ; For excess 128
        ADD     A,2             ; Exponent > 126?
        JP      C,OVTST1        ; Yes - Test for overflow
        PUSH    AF              ; Save scaling factor
        LD      HL,UNITY        ; Point to 1.
        CALL    ADDPHL          ; Add 1 to FPREG
        CALL    MULLN2          ; Multiply by LN(2)
        POP     AF              ; Restore scaling factor
        POP     BC              ; Restore exponent
        POP     DE
        PUSH    AF              ; Save scaling factor
        CALL    SUBCDE          ; Subtract exponent from FPREG
        CALL    INVSGN          ; Negate result
        LD      HL,EXPTAB       ; Coefficient table
        CALL    SMSER1          ; Sum the series
        LD      DE,0            ; Zero LSBs
        POP     BC              ; Scaling factor
        LD      C,D             ; Zero MSB
        JP      FPMULT          ; Scale result to correct value

EXPTAB: .BYTE      8                       ; Table used by EXP
        .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
        .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
        .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
        .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
        .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
        .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
        .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
        .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)

SUMSER: CALL    STAKFP          ; Put FPREG on stack
        LD      DE,MULT         ; Multiply by "X"
        PUSH    DE              ; To be done after
        PUSH    HL              ; Save address of table
        CALL    BCDEFP          ; Move FPREG to BCDE
        CALL    FPMULT          ; Square the value
        POP     HL              ; Restore address of table
SMSER1: CALL    STAKFP          ; Put value on stack
        LD      A,(HL)          ; Get number of coefficients
        INC     HL              ; Point to start of table
        CALL    PHLTFP          ; Move coefficient to FPREG
        .BYTE      06H             ; Skip "POP AF"
SUMLP:  POP     AF              ; Restore count
        POP     BC              ; Restore number
        POP     DE
        DEC     A               ; Cont coefficients
        RET     Z               ; All done
        PUSH    DE              ; Save number
        PUSH    BC
        PUSH    AF              ; Save count
        PUSH    HL              ; Save address in table
        CALL    FPMULT          ; Multiply FPREG by BCDE
        POP     HL              ; Restore address in table
        CALL    LOADFP          ; Number at HL to BCDE
        PUSH    HL              ; Save address in table
        CALL    FPADD           ; Add coefficient to FPREG
        POP     HL              ; Restore address in table
        JP      SUMLP           ; More coefficients

RND:    CALL    TSTSGN          ; Test sign of FPREG
        LD      HL,SEED+2       ; Random number seed
        JP      M,RESEED        ; Negative - Re-seed
        LD      HL,LSTRND       ; Last random number
        CALL    PHLTFP          ; Move last RND to FPREG
        LD      HL,SEED+2       ; Random number seed
        RET     Z               ; Return if RND(0)
        ADD     A,(HL)          ; Add (SEED)+2)
        AND     00000111B       ; 0 to 7
        LD      B,0
        LD      (HL),A          ; Re-save seed
        INC     HL              ; Move to coefficient table
        ADD     A,A             ; 4 bytes
        ADD     A,A             ; per entry
        LD      C,A             ; BC = Offset into table
        ADD     HL,BC           ; Point to coefficient
        CALL    LOADFP          ; Coefficient to BCDE
        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
        LD      A,(SEED+1)      ; Get (SEED+1)
        INC     A               ; Add 1
        AND     00000011B       ; 0 to 3
        LD      B,0
        CP      1               ; Is it zero?
        ADC     A,B             ; Yes - Make it 1
        LD      (SEED+1),A      ; Re-save seed
        LD      HL,RNDTAB-4     ; Addition table
        ADD     A,A             ; 4 bytes
        ADD     A,A             ; per entry
        LD      C,A             ; BC = Offset into table
        ADD     HL,BC           ; Point to value
        CALL    ADDPHL          ; Add value to FPREG
RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
        LD      A,E             ; Get LSB
        LD      E,C             ; LSB = MSB
        XOR     01001111B       ; Fiddle around
        LD      C,A             ; New MSB
        LD      (HL),80H        ; Set exponent
        DEC     HL              ; Point to MSB
        LD      B,(HL)          ; Get MSB
        LD      (HL),80H        ; Make value -0.5
        LD      HL,SEED         ; Random number seed
        INC     (HL)            ; Count seed
        LD      A,(HL)          ; Get seed
        SUB     171             ; Do it modulo 171
        JP      NZ,RND2         ; Non-zero - Ok
        LD      (HL),A          ; Zero seed
        INC     C               ; Fillde about
        DEC     D               ; with the
        INC     E               ; number
RND2:   CALL    BNORM           ; Normalise number
        LD      HL,LSTRND       ; Save random number
        JP      FPTHL           ; Move FPREG to last and return

RESEED: LD      (HL),A          ; Re-seed random numbers
        DEC     HL
        LD      (HL),A
        DEC     HL
        LD      (HL),A
        JP      RND1            ; Return RND seed

RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
        .BYTE   099H,0E9H,092H,069H
        .BYTE   010H,0D1H,075H,068H

COS:    LD      HL,HALFPI       ; Point to PI/2
        CALL    ADDPHL          ; Add it to PPREG
SIN:    CALL    STAKFP          ; Put angle on stack
        LD      BC,8349H        ; BCDE = 2 PI
        LD      DE,0FDBH
        CALL    FPBCDE          ; Move 2 PI to FPREG
        POP     BC              ; Restore angle
        POP     DE
        CALL    DVBCDE          ; Divide angle by 2 PI
        CALL    STAKFP          ; Put it on stack
        CALL    INT             ; Get INT of result
        POP     BC              ; Restore number
        POP     DE
        CALL    SUBCDE          ; Make it 0 <= value < 1
        LD      HL,QUARTR       ; Point to 0.25
        CALL    SUBPHL          ; Subtract value from 0.25
        CALL    TSTSGN          ; Test sign of value
        SCF                     ; Flag positive
        JP      P,SIN1          ; Positive - Ok
        CALL    ROUND           ; Add 0.5 to value
        CALL    TSTSGN          ; Test sign of value
        OR      A               ; Flag negative
SIN1:   PUSH    AF              ; Save sign
        CALL    P,INVSGN        ; Negate value if positive
        LD      HL,QUARTR       ; Point to 0.25
        CALL    ADDPHL          ; Add 0.25 to value
        POP     AF              ; Restore sign
        CALL    NC,INVSGN       ; Negative - Make positive
        LD      HL,SINTAB       ; Coefficient table
        JP      SUMSER          ; Evaluate sum of series

HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)

QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25

SINTAB: .BYTE   5                       ; Table used by SIN
        .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
        .BYTE   064H,026H,099H,087H     ;-76.575
        .BYTE   058H,034H,023H,087H     ; 81.602
        .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
        .BYTE   0DAH,00FH,049H,083H     ;  6.2832

TAN:    CALL    STAKFP          ; Put angle on stack
        CALL    SIN             ; Get SIN of angle
        POP     BC              ; Restore angle
        POP     HL
        CALL    STAKFP          ; Save SIN of angle
        EX      DE,HL           ; BCDE = Angle
        CALL    FPBCDE          ; Angle to FPREG
        CALL    COS             ; Get COS of angle
        JP      DIV             ; TAN = SIN / COS

ATN:    CALL    TSTSGN          ; Test sign of value
        CALL    M,NEGAFT        ; Negate result after if -ve
        CALL    M,INVSGN        ; Negate value if -ve
        LD      A,(FPEXP)       ; Get exponent
        CP      81H             ; Number less than 1?
        JP      C,ATN1          ; Yes - Get arc tangnt
        LD      BC,8100H        ; BCDE = 1
        LD      D,C
        LD      E,C
        CALL    DVBCDE          ; Get reciprocal of number
        LD      HL,SUBPHL       ; Sub angle from PI/2
        PUSH    HL              ; Save for angle > 1
ATN1:   LD      HL,ATNTAB       ; Coefficient table
        CALL    SUMSER          ; Evaluate sum of series
        LD      HL,HALFPI       ; PI/2 - angle in case > 1
        RET                     ; Number > 1 - Sub from PI/2

ATNTAB: .BYTE   9                       ; Table used by ATN
        .BYTE   04AH,0D7H,03BH,078H     ; 1/17
        .BYTE   002H,06EH,084H,07BH     ;-1/15
        .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
        .BYTE   074H,031H,09AH,07DH     ;-1/11
        .BYTE   084H,03DH,05AH,07DH     ; 1/9
        .BYTE   0C8H,07FH,091H,07EH     ;-1/7
        .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
        .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
        .BYTE   000H,000H,000H,081H     ; 1/1


ARET:   RET                     ; A RETurn instruction

GETINP: RST	    10H             ;input a character
        RET

CLS: 
        LD      A,CS            ; ASCII Clear screen
        JP      MONOUT          ; Output character

WIDTH:  CALL    GETINT          ; Get integer 0-255
        LD      A,E             ; Width to A
        LD      (LWIDTH),A      ; Set width
        RET

LINES:  CALL    GETNUM          ; Get a number
        CALL    DEINT           ; Get integer -32768 to 32767
        LD      (LINESC),DE     ; Set lines counter
        LD      (LINESN),DE     ; Set lines number
        RET

DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
        PUSH    DE              ; Save number
        POP     HL              ; Number to HL
        LD      B,(HL)          ; Get LSB of contents
        INC     HL
        LD      A,(HL)          ; Get MSB of contents
        JP      ABPASS          ; Return integer AB

DOKE:   CALL    GETNUM          ; Get a number
        CALL    DEINT           ; Get integer -32768 to 32767
        PUSH    DE              ; Save address
        CALL    CHKSYN          ; Make sure ',' follows
        .BYTE      ','
        CALL    GETNUM          ; Get a number
        CALL    DEINT           ; Get integer -32768 to 32767
        EX      (SP),HL         ; Save value,get address
        LD      (HL),E          ; Save LSB of value
        INC     HL
        LD      (HL),D          ; Save MSB of value
        POP     HL              ; Restore code string address
        RET


; HEX$(nn) Convert 16 bit number to Hexadecimal string

HEX: 	CALL	TSTNUM          ; Verify it's a number
        CALL	DEINT           ; Get integer -32768 to 32767
        PUSH	BC              ; Save contents of BC
        LD	    HL,PBUFF
        LD	    A,D             ; Get high order into A
        CP      $0
		JR      Z,HEX2          ; Skip output if both high digits are zero
        CALL    BYT2ASC         ; Convert D to ASCII
		LD      A,B
		CP      '0'
		JR      Z,HEX1          ; Don't store high digit if zero
        LD	    (HL),B          ; Store it to PBUFF
        INC	    HL              ; Next location
HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
        INC     HL              ; Next location
HEX2:   LD	    A,E             ; Get lower byte
        CALL    BYT2ASC         ; Convert E to ASCII
		LD      A,D
        CP      $0
		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
		LD      A,B
		CP      '0'             ; If high digit of lower byte is zero then don't print
		JR      Z,HEX4
HEX3:   LD      (HL),B          ; to PBUFF+2
        INC     HL              ; Next location
HEX4:   LD      (HL),C          ; to PBUFF+3
        INC     HL              ; PBUFF+4 to zero
        XOR     A               ; Terminating character
        LD      (HL),A          ; Store zero to terminate
        INC     HL              ; Make sure PBUFF is terminated
        LD      (HL),A          ; Store the double zero there
        POP     BC              ; Get BC back
        LD      HL,PBUFF        ; Reset to start of PBUFF
        JP      STR1            ; Convert the PBUFF to a string and return it

BYT2ASC	LD      B,A             ; Save original value
        AND     $0F             ; Strip off upper nybble
        CP      $0A             ; 0-9?
        JR      C,ADD30         ; If A-F, add 7 more
        ADD     A,$07           ; Bring value up to ASCII A-F
ADD30	ADD     A,$30           ; And make ASCII
        LD      C,A             ; Save converted char to C
        LD      A,B             ; Retrieve original value
        RRCA                    ; and Rotate it right
        RRCA
        RRCA
        RRCA
        AND     $0F             ; Mask off upper nybble
        CP      $0A             ; 0-9? < A hex?
        JR      C,ADD301        ; Skip Add 7
        ADD     A,$07           ; Bring it up to ASCII A-F
ADD301	ADD     A,$30           ; And make it full ASCII
        LD      B,A             ; Store high order byte
        RET	

; Convert "&Hnnnn" to FPREG
; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
HEXTFP  EX      DE,HL           ; Move code string pointer to DE
        LD      HL,$0000        ; Zero out the value
        CALL    GETHEX          ; Check the number for valid hex
        JP      C,HXERR         ; First value wasn't hex, HX error
        JR      HEXLP1          ; Convert first character
HEXLP   CALL    GETHEX          ; Get second and addtional characters
        JR      C,HEXIT         ; Exit if not a hex character
HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
        ADD     HL,HL
        ADD     HL,HL
        ADD     HL,HL
        OR      L               ; Add in D0-D3 into L
        LD      L,A             ; Save new value
        JR      HEXLP           ; And continue until all hex characters are in

GETHEX  INC     DE              ; Next location
        LD      A,(DE)          ; Load character at pointer
        CP      ' '
        JP      Z,GETHEX        ; Skip spaces
        SUB     $30             ; Get absolute value
        RET     C               ; < "0", error
        CP      $0A
        JR      C,NOSUB7        ; Is already in the range 0-9
        SUB     $07             ; Reduce to A-F
        CP      $0A             ; Value should be $0A-$0F at this point
        RET     C               ; CY set if was :            ; < = > ? @
NOSUB7  CP      $10             ; > Greater than "F"?
        CCF
        RET                     ; CY set if it wasn't valid hex
    
HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
        LD      A,D             ; Load DE into AC
        LD      C,E             ; For prep to 
        PUSH    HL
        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
        POP     HL
        RET

HXERR:  LD      E,HX            ; ?HEX Error
        JP      ERROR

; BIN$(NN) Convert integer to a 1-16 char binary string
BIN:    CALL    TSTNUM          ; Verify it's a number
        CALL    DEINT           ; Get integer -32768 to 32767
BIN2:   PUSH    BC              ; Save contents of BC
        LD      HL,PBUFF
        LD      B,17            ; One higher than max char count
ZEROSUP:                        ; Suppress leading zeros
        DEC     B               ; Max 16 chars
        LD      A,B
        CP      $01
        JR      Z,BITOUT        ; Always output at least one character
        RL      E
        RL      D
        JR      NC,ZEROSUP
        JR      BITOUT2
BITOUT:      
        RL      E
        RL      D               ; Top bit now in carry
BITOUT2:
        LD      A,'0'           ; Char for '0'
        ADC     A,0             ; If carry set then '0' --> '1'
        LD      (HL),A
        INC     HL
        DEC     B
        JR      NZ,BITOUT
        XOR     A               ; Terminating character
        LD      (HL),A          ; Store zero to terminate
        INC     HL              ; Make sure PBUFF is terminated
        LD      (HL),A          ; Store the double zero there
        POP     BC
        LD      HL,PBUFF
        JP      STR1

; Convert "&Bnnnn" to FPREG
; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
BINTFP: EX      DE,HL           ; Move code string pointer to DE
        LD      HL,$0000        ; Zero out the value
        CALL    CHKBIN          ; Check the number for valid bin
        JP      C,BINERR        ; First value wasn't bin, HX error
BINIT:  SUB     '0'
        ADD     HL,HL           ; Rotate HL left
        OR      L
        LD      L,A
        CALL    CHKBIN          ; Get second and addtional characters
        JR      NC,BINIT        ; Process if a bin character
        EX      DE,HL           ; Value into DE, Code string into HL
        LD      A,D             ; Load DE into AC
        LD      C,E             ; For prep to 
        PUSH    HL
        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
        POP     HL
        RET

; Char is in A, NC if char is 0 or 1
CHKBIN: INC     DE
        LD      A,(DE)
        CP      ' '
        JP      Z,CHKBIN        ; Skip spaces
        CP      '0'             ; Set C if < '0'
        RET     C
        CP      '2'
        CCF                     ; Set C if > '1'
        RET

BINERR: LD      E,BN            ; ?BIN Error
        JP      ERROR


JJUMP1: 
        LD      IX,-1           ; Flag cold start
        JP      CSTART          ; Go and initialise

MONOUT: 
        JP      $0008           ; output a char


MONITR: 
        JP      $0000           ; Restart (Normally Monitor Start)


INITST: LD      A,0             ; Clear break flag
        LD      (BRKFLG),A
        JP      INIT

ARETN:  RETN                    ; Return from NMI


TSTBIT: PUSH    AF              ; Save bit mask
        AND     B               ; Get common bits
        POP     BC              ; Restore bit mask
        CP      B               ; Same bit set?
        LD      A,0             ; Return 0 in A
        RET

OUTNCR: CALL    OUTC            ; Output character in A
        JP      PRNTCRLF        ; Output CRLF


DIEGO:
        PUSH AF
        PUSH HL
        PUSH DE
        PUSH BC

        LD A, 'C'
        CALL MONOUT

        LD A, 'R'
        CALL MONOUT

        LD A, 'U'
        CALL MONOUT

        LD A, 'Z'
        CALL MONOUT

        LD A, ' '
        CALL MONOUT

        LD A, ';'
        CALL MONOUT

        LD A, ')'
        CALL MONOUT

        LD A, CR ; new line
        CALL MONOUT

        POP BC
        POP DE
        POP HL
        POP AF 
        RET


EELOAD:
        PUSH AF
        PUSH HL
        PUSH DE
        PUSH BC

        LD DE, $0000
        LD HL, $8000 ; BASIC
        LD BC, $2000 ; copy 8kb from EEPROM I2C
        CALL I2CMEMTOCPU_BASIC

        LD A, CR ; new line
        CALL MONOUT

        POP BC
        POP DE
        POP HL
        POP AF 
        RET


EESAVE:
        PUSH AF
        PUSH HL
        PUSH DE
        PUSH BC

        LD HL, $8000
        LD DE, $0000
        LD BC, $2000 ; save 8kb to EEPROM I2C
        CALL I2CCPUTOMEM_BASIC

        LD A, CR ; new line
        CALL MONOUT

        POP BC
        POP DE
        POP HL
        POP AF
        RET

TIME:
        PUSH AF
        PUSH HL
        PUSH DE
        PUSH BC
        ; Hora
        LD A, $64 ; To read is equal address +1
        LD C, $10 ; I2C open, device id in A
        RST $30 
    
        LD A, $20  ; register
        LD C, $13
        RST $30 ;I2C Write, value in A
        
        LD A, $64+1 ; To read is equal address +1
        LD C, $10 ; I2C open, device id in A
        RST $30 
        
        LD C, $12 ; I2C Read, return in A
        RST $30 
        
        PUSH AF
        
        LD C, $11 ; I2C Close
        RST $30  
        
        POP AF
        
        CALL lcd_print_data ; send A to display
        LD A, ':'
        CALL display ; send
        
        
        ;Minutos
        LD A, $64 ; To read is equal address +1
        LD C, $10 ; I2C open, device id in A
        RST $30 
        
        LD A, $10  ; register
        LD C, $13
        RST $30 ;I2C Write, value in A
        
        LD A, $64+1 ; To read is equal address +1
        LD C, $10 ; I2C open, device id in A
        RST $30 
        
        LD C, $12 ; I2C Read, return in A
        RST $30 
        
        PUSH AF
        
        LD C, $11 ; I2C Close
        RST $30  
        
        POP AF
        
        CALL lcd_print_data ; send A to display
        LD A, ':'
        CALL display ; send
        
        
        ;segundos
        LD A, $64 ; To read is equal address +1
        LD C, $10 ; I2C open, device id in A
        RST $30 
        
        LD A, $00  ; register
        LD C, $13
        RST $30 ;I2C Write, value in A
        
        LD A, $64+1 ; To read is equal address +1
        LD C, $10 ; I2C open, device id in A
        RST $30 
        
        LD C, $12 ; I2C Read, return in A
        RST $30 
        
        PUSH AF
        
        LD C, $11 ; I2C Close
        RST $30  
        
        POP AF
        
        CALL lcd_print_data ; send A to display

        LD C, $0C
        RST $30 ;  show buffer to LCD

        LD A, CR ; new line
        CALL MONOUT

        POP BC
        POP DE
        POP HL
        POP AF
        RET



lcd_print_data:
	push bc
        push af
        ld b, a
        and 11110000b
        rlca
        rlca
        rlca
        rlca
        add a, '0'
        cp '9' + 1
        jr c, print_12
        add a, 'A' - '0' - 10
print_12:
        CALL display ; send to lcd
        ld a, b
        and 00001111b
        add a, '0'
        cp '9' + 1
        jr c, print_22
        add a, 'A' - '0' - 10
print_22:
        CALL display ; send to lcd
        pop bc
        pop af
        ret
    
display:
        PUSH AF
        PUSH BC
        
        LD C, $09
        RST $30 ; send to lcd
        
        POP BC
        POP AF
        RET


.end

.end


; +++ segments +++

#CODE          = $0000 =     0,  size = $7D63 = 32099

; +++ global symbols +++

ABPASS         = $7032 = 28722          basicV2.asm:2415
ABS            = $767E = 30334          basicV2.asm:3438
AC2HEX1        = $0234 =   564          Keyboard.asm:58
AC2HEX2        = $0236 =   566          Keyboard.asm:61
AC2HEX3        = $0242 =   578          Keyboard.asm:67
ACCSUM         = $689B = 26779          basicV2.asm:1317 (unused)
ACPASS         = $7031 = 28721          basicV2.asm:2414
ADD30          = $7B90 = 31632          basicV2.asm:4186
ADD301         = $7BA0 = 31648          basicV2.asm:4197
ADDEXP         = $7617 = 30231          basicV2.asm:3373
ADDIG          = $77BD = 30653          basicV2.asm:3661
ADDOFFSET      = $0292 =   658          Keyboard.asm:128
ADDPHL         = $7404 = 29700          basicV2.asm:3020
ADDR           = $F425 = 62501          bootV2.asm:133
ADDR_FROM      = $F427 = 62503          bootV2.asm:134
ADDR_SIZE      = $F42B = 62507          bootV2.asm:136
ADDR_TO        = $F429 = 62505          bootV2.asm:135
ALLFOL         = $7300 = 29440          basicV2.asm:2862
ANTVLU         = $6B9B = 27547          basicV2.asm:1724
API            = $00C8 =   200          bootV2.asm:208 (unused)
APIHandler     = $0142 =   322          API.asm:40
APITable       = $0154 =   340          API.asm:60
ARET           = $7B0E = 31502          basicV2.asm:4101 (unused)
ARETN          = $7C59 = 31833          basicV2.asm:4329 (unused)
ARLDSV         = $6F52 = 28498          basicV2.asm:2270
ARREND         = $80DA = 32986          basicV2.asm:88
ARRLP          = $71CB = 29131          basicV2.asm:2653
ASC            = $72D1 = 29393          basicV2.asm:2832
ASC2HEX        = $022A =   554          Keyboard.asm:53
ASCTFP         = $7760 = 30560          basicV2.asm:3607
ASPCS          = $6AFD = 27389          basicV2.asm:1647
ATN            = $7AC2 = 31426          basicV2.asm:4072
ATN1           = $7ADF = 31455          basicV2.asm:4084
ATNTAB         = $7AE9 = 31465          basicV2.asm:4089
ATOH           = $68D6 = 26838          basicV2.asm:1350
B1200          = $0080 =   128          bootV2.asm:91 (unused)
B2400          = $003F =    63          bootV2.asm:92 (unused)
B300           = $0220 =   544          bootV2.asm:90 (unused)
B4800          = $001B =    27          bootV2.asm:93
B9600          = $000B =    11          bootV2.asm:94 (unused)
BADINP         = $6B22 = 27426          basicV2.asm:1659
BAKSTK         = $635B = 25435          basicV2.asm:523
BAKTMP         = $72B1 = 29361          basicV2.asm:2810
BASIC          = $6000 = 24576          bootV2.asm:81
BASIC_W        = $6002 = 24578          bootV2.asm:82
BASTXT         = $805E = 32862          basicV2.asm:64
BAUD           = $F430 = 62512          bootV2.asm:140
BCDEFP         = $76A5 = 30373          basicV2.asm:3465
BCRLF          = $0FBF =  4031          Monitor.asm:431
BFREE          = $60AD = 24749          basicV2.asm:217
BIN            = $7BE2 = 31714          basicV2.asm:4246
BIN2           = $7BE8 = 31720          basicV2.asm:4248 (unused)
BINERR         = $7C3F = 31807          basicV2.asm:4309
BINIT          = $7C1E = 31774          basicV2.asm:4284
BINTFP         = $7C14 = 31764          basicV2.asm:4280
BITIM1         = $0D7E =  3454          SoftSerial.asm:172
BITIME         = $0D79 =  3449          SoftSerial.asm:169
BITOUT         = $7BFC = 31740          basicV2.asm:4260
BITOUT2        = $7C00 = 31744          basicV2.asm:4263
BKSP           = $0008 =     8          bootV2.asm:39
BN             = $0028 =    40          basicV2.asm:122
BNORM          = $7464 = 29796          basicV2.asm:3079
BNRMLP         = $7467 = 29799          basicV2.asm:3082
BREAK_CONTINUE = $1191 =  4497          Monitor.asm:815
BREAK_CONTINUE_LOOP = $1197 =  4503          Monitor.asm:818
BRK            = $684D = 26701          basicV2.asm:1272
BRKFLG         = $804D = 32845          basicV2.asm:57
BRKLIN         = $80CE = 32974          basicV2.asm:82
BRKMSG         = $6355 = 25429          basicV2.asm:521
BRKRET         = $60A7 = 24743          basicV2.asm:214
BS             = $0010 =    16          basicV2.asm:110
BSERR          = $6F85 = 28549          basicV2.asm:2301
BUFFER         = $8061 = 32865          basicV2.asm:65
BYT2ASC        = $7B87 = 31623          basicV2.asm:4181
BYTASC         = $1227 =  4647          Monitor.asm:925
BYTOUT         = $1219 =  4633          Monitor.asm:899
BYTSFT         = $759C = 30108          basicV2.asm:3290
Boucle16X      = $05D1 =  1489          LCDGraphic.asm:643
Boucle32X      = $05C3 =  1475          LCDGraphic.asm:632
BufferImage128x64 = $01B6 =   438          API.asm:134
CFEVAL         = $6EE8 = 28392          basicV2.asm:2201
CHARTY         = $6E96 = 28310          basicV2.asm:2157
CHEKFN         = $70C9 = 28873          basicV2.asm:2506
CHKBIN         = $7C31 = 31793          basicV2.asm:4299
CHKKEY         = $0245 =   581          Keyboard.asm:74
CHKLTR         = $68A8 = 26792          basicV2.asm:1326
CHKSTK         = $638F = 25487          basicV2.asm:560
CHKSUM         = $804A = 32842          basicV2.asm:55
CHKSYN         = $6680 = 26240          basicV2.asm:996
CHKTYP         = $6C7C = 27772          basicV2.asm:1839
CHR            = $72E2 = 29410          basicV2.asm:2844
CLEAR          = $68FB = 26875          basicV2.asm:1374
CLOTST         = $66B5 = 26293          basicV2.asm:1028
CLREG          = $64E4 = 25828          basicV2.asm:768
CLRPTR         = $64BF = 25791          basicV2.asm:748
CLS            = $7B11 = 31505          basicV2.asm:4106
CMPFP          = $76EE = 30446          basicV2.asm:3523
CMPLG1         = $6DFC = 28156          basicV2.asm:2063
CMPLOG         = $6DFA = 28154          basicV2.asm:2062
CMPNUM         = $76D4 = 30420          basicV2.asm:3506
CMPRES         = $6E3E = 28222          basicV2.asm:2111
CMPSTR         = $6E26 = 28198          basicV2.asm:2091
CN             = $0020 =    32          basicV2.asm:118
CNVNUM         = $776C = 30572          basicV2.asm:3613
COLD           = $6000 = 24576          basicV2.asm:126 (unused)
COMMAN         = $8043 = 32835          basicV2.asm:50
COMPL          = $74C4 = 29892          basicV2.asm:3153
CONCAT         = $7246 = 29254          basicV2.asm:2743
CONEXP         = $779C = 30620          basicV2.asm:3637
CONPOS         = $7461 = 29793          basicV2.asm:3077
CONT           = $6880 = 26752          basicV2.asm:1300
CONTAD         = $80D4 = 32980          basicV2.asm:85
CONVAR         = $6D67 = 28007          basicV2.asm:1963
CONV_A_HEX     = $12C5 =  4805          Utils.asm:7
CONV_A_HEX_NYBASC = $12CE =  4814          Utils.asm:17
COPY           = $6020 = 24608          basicV2.asm:143
COS            = $7A46 = 31302          basicV2.asm:4020
COUNT          = $6725 = 26405          basicV2.asm:1094
CPDEHL         = $667A = 26234          basicV2.asm:989
CPYLIT         = $65B6 = 26038          basicV2.asm:886
CR             = $000D =    13          bootV2.asm:43
CRARLP         = $6FA5 = 28581          basicV2.asm:2321
CREARY         = $6F8A = 28554          basicV2.asm:2304
CRESTR         = $69FA = 27130          basicV2.asm:1513
CRNCLP         = $6517 = 25879          basicV2.asm:794
CRTMST         = $7102 = 28930          basicV2.asm:2539
CRTST          = $710E = 28942          basicV2.asm:2550
CRTSTE         = $7124 = 28964          basicV2.asm:2564
CRUNCH         = $650E = 25870          basicV2.asm:790
CS             = $000C =    12          bootV2.asm:42
CSTART         = $6011 = 24593          basicV2.asm:136
CSUMERR        = $1594 =  5524          Strings.asm:51
CTLOFG         = $8045 = 32837          basicV2.asm:52
CTRLC          = $0003 =     3          bootV2.asm:37
CTRLG          = $0007 =     7          bootV2.asm:38
CTRLO          = $000F =    15          bootV2.asm:44
CTRLQ          = $0011 =    17          bootV2.asm:45
CTRLR          = $0012 =    18          bootV2.asm:46
CTRLS          = $0013 =    19          bootV2.asm:47
CTRLU          = $0015 =    21          bootV2.asm:48
CUROPR         = $80C5 = 32965          basicV2.asm:76
CURPOS         = $80AB = 32939          basicV2.asm:67
Clear8x8       = $065C =  1628          LCDGraphic.asm:836
ClearDisplayBuffer = $01C1 =   449          API.asm:143
ClearDisplayBufferEnd = $01D2 =   466          API.asm:152
DATA           = $69A1 = 27041          basicV2.asm:1465
DATABYTE       = $F420 = 62496          bootV2.asm:128
DATFLG         = $80AE = 32942          basicV2.asm:70
DATLIN         = $80C9 = 32969          basicV2.asm:78
DATSNR         = $63AC = 25516          basicV2.asm:580
DCBCDE         = $7725 = 30501          basicV2.asm:3566
DD             = $0012 =    18          basicV2.asm:111
DDERR          = $63BB = 25531          basicV2.asm:588
DEEK           = $7B2D = 31533          basicV2.asm:4121
DEF            = $7046 = 28742          basicV2.asm:2427
DEFSIZ         = $6FAD = 28589          basicV2.asm:2325
DEINT          = $68BC = 26812          basicV2.asm:1337
DEL            = $007F =   127          bootV2.asm:50
DELAY_MS       = $05AC =  1452          LCDGraphic.asm:600
DELAY_US       = $05A9 =  1449          LCDGraphic.asm:598
DELCHR         = $65E6 = 26086          basicV2.asm:916
DELETE_CHAR    = $034D =   845          LCDGraphic.asm:123
DELON1         = $0CFA =  3322          SoftSerial.asm:33
DELON2         = $0CFC =  3324          SoftSerial.asm:34
DELONE         = $0CF1 =  3313          SoftSerial.asm:28 (unused)
DEPINT         = $68B6 = 26806          basicV2.asm:1335
DETHL4         = $76B4 = 30388          basicV2.asm:3477
DETHLB         = $76B6 = 30390          basicV2.asm:3478
DIEGO          = $7C68 = 31848          basicV2.asm:4343
DIGTXT         = $7866 = 30822          basicV2.asm:3759
DIM            = $6E68 = 28264          basicV2.asm:2137
DIMRET         = $6E5F = 28255          basicV2.asm:2132
DINPOS         = $66AF = 26287          basicV2.asm:1023
DISPLAY        = $F000 = 61440          bootV2.asm:126
DISPLAY_SCROLL_UP = $02E6 =   742          LCDGraphic.asm:49
DIV            = $75AD = 30125          basicV2.asm:3301
DIV1           = $800A = 32778          basicV2.asm:40
DIV10          = $75A1 = 30113          basicV2.asm:3296
DIV2           = $800E = 32782          basicV2.asm:41
DIV3           = $8012 = 32786          basicV2.asm:42
DIV4           = $8015 = 32789          basicV2.asm:43
DIVLP          = $75D4 = 30164          basicV2.asm:3325
DIVSUP         = $8009 = 32777          basicV2.asm:39
DLINE1         = $0F89 =  3977          Monitor.asm:387
DLINE2         = $0F99 =  3993          Monitor.asm:400
DOAGN          = $64FD = 25853          basicV2.asm:781
DOCOM          = $6ACE = 27342          basicV2.asm:1623
DODEL          = $65C6 = 26054          basicV2.asm:900
DOEBIT         = $78A6 = 30886          basicV2.asm:3802
DOFN           = $7073 = 28787          basicV2.asm:2455
DOKE           = $7B38 = 31544          basicV2.asm:4129
DONULL         = $6ABC = 27324          basicV2.asm:1612
DOSPC          = $6AF8 = 27384          basicV2.asm:1644
DOT            = $0FA5 =  4005          Monitor.asm:406
DOTAB          = $6AE5 = 27365          basicV2.asm:1634
DPLAY1         = $0F58 =  3928          Monitor.asm:352
DPLAY2         = $0F65 =  3941          Monitor.asm:361
DPLAY3         = $0F6C =  3948          Monitor.asm:366
DPLINE         = $0F7A =  3962          Monitor.asm:376
DPOINT         = $7798 = 30616          basicV2.asm:3635
DSPLAY         = $0F42 =  3906          Monitor.asm:340
DTSTR          = $7112 = 28946          basicV2.asm:2553
DVBCDE         = $75AF = 30127          basicV2.asm:3303
DZ             = $0014 =    20          basicV2.asm:112
DZERR          = $63B5 = 25525          basicV2.asm:584
DisplayImage128x64 = $01A9 =   425          API.asm:125
Div_HL_D       = $1311 =  4881          Utils.asm:112
ECHDEL         = $65DA = 26074          basicV2.asm:909
EDIGIT         = $77DF = 30687          basicV2.asm:3684
EELOAD         = $7C99 = 31897          basicV2.asm:4380
EESAVE         = $7CB3 = 31923          basicV2.asm:4401
ENDBUF         = $65BD = 26045          basicV2.asm:892
ENDCON         = $77AB = 30635          basicV2.asm:3647
ENDDIM         = $700C = 28684          basicV2.asm:2394
ENDINP         = $6AAD = 27309          basicV2.asm:1606
ENDNAM         = $6E8A = 28298          basicV2.asm:2153
ENDPRG         = $685C = 26716          basicV2.asm:1283
ENFMEM         = $6398 = 25496          basicV2.asm:566
ERRIN          = $63E6 = 25574          basicV2.asm:610
ERRLIN         = $80D2 = 32978          basicV2.asm:84
ERRMSG         = $6343 = 25411          basicV2.asm:517
ERROR          = $63C6 = 25542          basicV2.asm:596
ERRORS         = $62B9 = 25273          basicV2.asm:446
ERR_JAM        = $0001 =     1          I2C.asm:98 (unused)
ERR_NOACK      = $0002 =     2          I2C.asm:99
ERR_NONE       = $0000 =     0          I2C.asm:97 (unused)
ERR_TOUT       = $0003 =     3          I2C.asm:100
ESC            = $001B =    27          bootV2.asm:49
EVAL           = $6C89 = 27785          basicV2.asm:1847
EVAL1          = $6C8C = 27788          basicV2.asm:1849
EVAL2          = $6C95 = 27797          basicV2.asm:1853
EVAL3          = $6C98 = 27800          basicV2.asm:1854
EVLPAR         = $6D4E = 27982          basicV2.asm:1949
EVNOT          = $6E48 = 28232          basicV2.asm:2119
EXCUTE         = $67EA = 26602          basicV2.asm:1205
EXP            = $7940 = 31040          basicV2.asm:3889
EXPLP          = $778A = 30602          basicV2.asm:3627
EXPTAB         = $7980 = 31104          basicV2.asm:3917
EXPTEN         = $78B8 = 30904          basicV2.asm:3812
EXTIG          = $6BF7 = 27639          basicV2.asm:1772
FANDT          = $6C21 = 27681          basicV2.asm:1790
FC             = $0008 =     8          basicV2.asm:106
FCERR          = $68D1 = 26833          basicV2.asm:1347
FDTLP          = $6C08 = 27656          basicV2.asm:1774
FILEOK         = $1582 =  5506          Strings.asm:50
FINDEL         = $6FE8 = 28648          basicV2.asm:2366
FLGDIF         = $7664 = 30308          basicV2.asm:3421
FLGREL         = $766B = 30315          basicV2.asm:3427
FNARG          = $80E0 = 32992          basicV2.asm:91
FNCTAB         = $60FE = 24830          basicV2.asm:227
FNDARY         = $6F58 = 28504          basicV2.asm:2274
FNDELP         = $6FED = 28653          basicV2.asm:2371
FNDEND         = $6492 = 25746          basicV2.asm:711
FNDNUM         = $73D5 = 29653          basicV2.asm:2994
FNDTOK         = $6704 = 26372          basicV2.asm:1074
FNDVAR         = $6ECF = 28367          basicV2.asm:2185
FNDWRD         = $6541 = 25921          basicV2.asm:814
FNOFST         = $6D78 = 28024          basicV2.asm:1973
FNRGNM         = $80DE = 32990          basicV2.asm:90
FNTHR          = $6EDD = 28381          basicV2.asm:2193
FNVAL          = $6D9F = 28063          basicV2.asm:1995
FOPRND         = $6CC1 = 27841          basicV2.asm:1875
FOR            = $6751 = 26449          basicV2.asm:1116
FORFLG         = $80CB = 32971          basicV2.asm:79
FORFND         = $6781 = 26497          basicV2.asm:1144
FORSLP         = $6765 = 26469          basicV2.asm:1125
FPADD          = $7413 = 29715          basicV2.asm:3028
FPBCDE         = $769A = 30362          basicV2.asm:3457
FPEXP          = $80E7 = 32999          basicV2.asm:93
FPINT          = $7701 = 30465          basicV2.asm:3543
FPMULT         = $754E = 30030          basicV2.asm:3239
FPREG          = $80E4 = 32996          basicV2.asm:92
FPROND         = $74AB = 29867          basicV2.asm:3129
FPSINT         = $68B0 = 26800          basicV2.asm:1333
FPTHL          = $76B1 = 30385          basicV2.asm:3476
FRE            = $7010 = 28688          basicV2.asm:2397
FRENUM         = $702C = 28716          basicV2.asm:2409
FRMEVL         = $6D6A = 28010          basicV2.asm:1964
GARBGE         = $7193 = 29075          basicV2.asm:2626
GARBLP         = $7196 = 29078          basicV2.asm:2627
GETBT1         = $0B44 =  2884          LoaderIntel.asm:102
GETBT2         = $0B58 =  2904          LoaderIntel.asm:115
GETBYT         = $0B3A =  2874          LoaderIntel.asm:97
GETCH          = $F434 = 62516          bootV2.asm:142
GETCHR         = $680A = 26634          basicV2.asm:1225
GETCHR_KEYBOARD = $01F0 =   496          Keyboard.asm:7
GETCMD         = $640A = 25610          basicV2.asm:628
GETHEX         = $7BBD = 31677          basicV2.asm:4219
GETINP         = $7B0F = 31503          basicV2.asm:4103
GETINT         = $73D8 = 29656          basicV2.asm:2995
GETLEN         = $72C6 = 29382          basicV2.asm:2824
GETLIN         = $65F7 = 26103          basicV2.asm:924
GETLN          = $68D7 = 26839          basicV2.asm:1351
GETNUM         = $6C77 = 27767          basicV2.asm:1836
GETNXT         = $655C = 25948          basicV2.asm:829
GETNYB         = $020A =   522          Keyboard.asm:20
GETOUT         = $0228 =   552          Keyboard.asm:35
GETSTR         = $7290 = 29328          basicV2.asm:2790
GETVAR         = $6E6D = 28269          basicV2.asm:2140
GET_DEV_ADDR   = $10A8 =  4264          Monitor.asm:637
GET_DEV_DD     = $10B6 =  4278          Monitor.asm:645
GET_DEV_RR     = $10C4 =  4292          Monitor.asm:654
GET_FROM_TO_SIZE = $1122 =  4386          Monitor.asm:742
GET_FROM_TO_SIZE_SIZE = $1166 =  4454          Monitor.asm:785
GET_FROM_TO_SIZE_TO = $1148 =  4424          Monitor.asm:765
GNXARY         = $71CA = 29130          basicV2.asm:2652
GOFUNC         = $6DA7 = 28071          basicV2.asm:1999
GOJMP1         = $12B3 =  4787          Monitor.asm:1033 (unused)
GOJUMP         = $129D =  4765          Monitor.asm:1021
GOJUMP_new     = $1293 =  4755          Monitor.asm:1014
GOSUB          = $694D = 26957          basicV2.asm:1416
GOTO           = $695E = 26974          basicV2.asm:1428
GRBARY         = $71EA = 29162          basicV2.asm:2671
GRBDON         = $716B = 29035          basicV2.asm:2601
GRBLP          = $71A4 = 29092          basicV2.asm:2633
GRET           = $0255 =   597          Keyboard.asm:82
GSTRCU         = $7293 = 29331          basicV2.asm:2791
GSTRDE         = $7297 = 29335          basicV2.asm:2793
GSTRHL         = $7296 = 29334          basicV2.asm:2792
GTFLNM         = $72D5 = 29397          basicV2.asm:2834 (unused)
GTFNAM         = $6E72 = 28274          basicV2.asm:2143
GTLNLP         = $68DA = 26842          basicV2.asm:1352
GTSIXD         = $7830 = 30768          basicV2.asm:3728
GTVLUS         = $6B73 = 27507          basicV2.asm:1702
HALF           = $78D7 = 30935          basicV2.asm:3833
HALFPI         = $7A90 = 31376          basicV2.asm:4051
HEX            = $7B4F = 31567          basicV2.asm:4146
HEX1           = $7B68 = 31592          basicV2.asm:4159
HEX2           = $7B6A = 31594          basicV2.asm:4161
HEX3           = $7B78 = 31608          basicV2.asm:4169
HEX4           = $7B7A = 31610          basicV2.asm:4171
HEXIT          = $7BD4 = 31700          basicV2.asm:4234
HEXLP          = $7BB0 = 31664          basicV2.asm:4209
HEXLP1         = $7BB5 = 31669          basicV2.asm:4211
HEXTFP         = $7BA4 = 31652          basicV2.asm:4204
HX             = $0026 =    38          basicV2.asm:121
HXERR          = $7BDD = 31709          basicV2.asm:4242
H_Delay        = $12EF =  4847          Utils.asm:66
HexOut         = $0CBB =  3259          I2C.asm:404
HexOutHex      = $0CC8 =  3272          I2C.asm:414
HexOutSkip     = $0CCE =  3278          I2C.asm:417
I2CA_BLOCK     = $00AE =   174          bootV2.asm:107
I2CCPUTOMEM    = $10FA =  4346          Monitor.asm:701
I2CCPUTOMEM_BASIC = $110E =  4366          Monitor.asm:725
I2CCPUTOMEM_OK = $111B =  4379          Monitor.asm:732
I2CClose       = $01DC =   476          API.asm:162
I2CLIST        = $0C26 =  3110          I2C.asm:278
I2CMEMTOCPU    = $10D2 =  4306          Monitor.asm:666
I2CMEMTOCPU_BASIC = $10E6 =  4326          Monitor.asm:688
I2CMEMTOCPU_OK = $10F3 =  4339          Monitor.asm:695
I2COpen        = $01D9 =   473          API.asm:159
I2CRead        = $01DF =   479          API.asm:165
I2CWrite       = $01E2 =   482          API.asm:168
I2C_ADDR       = $F422 = 62498          bootV2.asm:130
I2C_Close      = $0B6D =  2925          I2C.asm:22
I2C_DD         = $F424 = 62500          bootV2.asm:132
I2C_INIT       = $0BF3 =  3059          I2C.asm:228
I2C_MemRd      = $0C50 =  3152          I2C.asm:318
I2C_MemRdRead  = $0C74 =  3188          I2C.asm:340
I2C_MemRdReady = $0C65 =  3173          I2C.asm:332
I2C_MemRdRepeat = $0C54 =  3156          I2C.asm:320
I2C_MemWr      = $0C85 =  3205          I2C.asm:364
I2C_MemWrBlock = $0C9B =  3227          I2C.asm:379 (unused)
I2C_MemWrReady = $0C9A =  3226          I2C.asm:378
I2C_MemWrRepeat = $0C89 =  3209          I2C.asm:366
I2C_MemWrStore = $0CB3 =  3251          I2C.asm:394
I2C_MemWrWrite = $0CA3 =  3235          I2C.asm:383
I2C_Open       = $0B66 =  2918          I2C.asm:10
I2C_PORT       = $0021 =    33          I2C.asm:88
I2C_QUIES      = $0081 =   129          I2C.asm:93
I2C_RAMCPY     = $F421 = 62497          bootV2.asm:129
I2C_RD         = $1042 =  4162          Monitor.asm:558
I2C_RD_LOOP    = $1053 =  4179          Monitor.asm:570
I2C_RD_RR      = $1073 =  4211          Monitor.asm:597
I2C_RD_RR_LOOP = $1081 =  4225          Monitor.asm:608
I2C_RR         = $F423 = 62499          bootV2.asm:131
I2C_RdPort     = $0C1D =  3101          I2C.asm:254
I2C_Read       = $0BAD =  2989          I2C.asm:163
I2C_ReadNoAck  = $0BCF =  3023          I2C.asm:183
I2C_ReadRd_Loop = $0BB5 =  2997          I2C.asm:168
I2C_ReadRotate = $0BC1 =  3009          I2C.asm:174
I2C_SCL_HI     = $0BF7 =  3063          I2C.asm:231
I2C_SCL_LO     = $0BFE =  3070          I2C.asm:235
I2C_SCL_RD     = $0000 =     0          I2C.asm:92 (unused)
I2C_SCL_WR     = $0000 =     0          I2C.asm:91
I2C_SDA_HI     = $0C05 =  3077          I2C.asm:239
I2C_SDA_LO     = $0C0C =  3084          I2C.asm:243
I2C_SDA_RD     = $0007 =     7          I2C.asm:90
I2C_SDA_WR     = $0007 =     7          I2C.asm:89
I2C_Start      = $0BDA =  3034          I2C.asm:198
I2C_Stop       = $0BE5 =  3045          I2C.asm:214
I2C_WR_DD      = $0FF3 =  4083          Monitor.asm:487
I2C_WR_DD_LOOP = $1001 =  4097          Monitor.asm:498
I2C_WR_RR_DD   = $1016 =  4118          Monitor.asm:520
I2C_WR_RR_DD_LOOP = $1024 =  4132          Monitor.asm:531
I2C_WrPort     = $0C11 =  3089          I2C.asm:246
I2C_Write      = $0B70 =  2928          I2C.asm:116
I2C_WriteBit_Clk = $0B81 =  2945          I2C.asm:125
I2C_WriteBit_Hi = $0B7E =  2942          I2C.asm:124
I2C_WriteNoAck = $0B9E =  2974          I2C.asm:143
I2C_WriteWr_Loop = $0B75 =  2933          I2C.asm:120
ID             = $0016 =    22          basicV2.asm:113
IDTEST         = $70BB = 28859          basicV2.asm:2496
IF             = $6A30 = 27184          basicV2.asm:1546
IFGO           = $6A3E = 27198          basicV2.asm:1553
IFJMP          = $67F1 = 26609          basicV2.asm:1208
INBUF          = $0FBC =  4028          Monitor.asm:425
INCH           = $0D1B =  3355          SoftSerial.asm:73 (unused)
INCHL          = $76AF = 30383          basicV2.asm:3473
INCLEN         = $66AB = 26283          basicV2.asm:1021
INDFND         = $6375 = 25461          basicV2.asm:542
INEWLN         = $645A = 25690          basicV2.asm:671
INIT           = $6018 = 24600          basicV2.asm:140
INITAB         = $62E3 = 25315          basicV2.asm:470
INITBE         = $6343 = 25411          basicV2.asm:513
INITST         = $7C51 = 31825          basicV2.asm:4325
INIT_LCD       = $02AE =   686          LCDGraphic.asm:13
INIT_SOFTSERIAL = $0CD4 =  3284          SoftSerial.asm:3
INIT_TXT_LCD   = $02CD =   717          LCDGraphic.asm:36
INMSG          = $634A = 25418          basicV2.asm:518
INP            = $7395 = 29589          basicV2.asm:2963
INPBIN         = $6BC5 = 27589          basicV2.asm:1746
INPBRK         = $6859 = 26713          basicV2.asm:1281
INPORT         = $803F = 32831          basicV2.asm:47
INPORT_MON     = $0FD7 =  4055          Monitor.asm:462
INPSUB         = $803E = 32830          basicV2.asm:46
INPUT          = $6B33 = 27443          basicV2.asm:1667
INRNG          = $7839 = 30777          basicV2.asm:3733
INSBUF         = $1238 =  4664          Monitor.asm:943 (unused)
INT            = $772C = 30508          basicV2.asm:3574
INTEL1         = $0AE2 =  2786          LoaderIntel.asm:40
INTEL2         = $0B0D =  2829          LoaderIntel.asm:69
INTEL4         = $0B28 =  2856          LoaderIntel.asm:87
INTELH         = $0ADE =  2782          LoaderIntel.asm:36
INTEL_HEX      = $1185 =  4485          Monitor.asm:807
INTHEX         = $0AB3 =  2739          LoaderIntel.asm:4
INTVAR         = $64CE = 25806          basicV2.asm:759
INVSGN         = $7682 = 30338          basicV2.asm:3440
ITHEX1         = $0AD1 =  2769          LoaderIntel.asm:21
ITMSEP         = $6BB6 = 27574          basicV2.asm:1737
InputCharKey   = $0183 =   387          API.asm:92
JJUMP1         = $7C44 = 31812          basicV2.asm:4313 (unused)
JSTZER         = $78C2 = 30914          basicV2.asm:3818
KDOWN          = $00B6 =   182          bootV2.asm:58
KEY            = $0DBF =  3519          Monitor.asm:40
KEYMAP         = $0068 =   104          bootV2.asm:194
KEYOUT         = $02A3 =   675          Keyboard.asm:140
KEYREADINIT    = $025A =   602          Keyboard.asm:92
KEY_IN         = $0040 =    64          bootV2.asm:31
KEY_OUT        = $0040 =    64          bootV2.asm:32
KF1            = $0080 =   128          bootV2.asm:59
KF2            = $0081 =   129          bootV2.asm:60
KF3            = $0082 =   130          bootV2.asm:61
KF4            = $0083 =   131          bootV2.asm:62
KF5            = $0084 =   132          bootV2.asm:63
KF6            = $0085 =   133          bootV2.asm:64
KF7            = $0086 =   134          bootV2.asm:65
KF8            = $0087 =   135          bootV2.asm:66
KILFOR         = $6C67 = 27751          basicV2.asm:1827
KILIN          = $65F1 = 26097          basicV2.asm:921
KLEFT          = $00B4 =   180          bootV2.asm:55
KRIGHT         = $00B7 =   183          bootV2.asm:56
KUP            = $00B5 =   181          bootV2.asm:57
LCDCTRL        = $0070 =   112          bootV2.asm:29
LCDDATA        = $0071 =   113          bootV2.asm:30
LCD_AUTO_X     = $F446 = 62534          bootV2.asm:155
LCD_BIT_INDEX  = $F43C = 62524          bootV2.asm:148
LCD_BYTE_INDEX = $F43A = 62522          bootV2.asm:147
LCD_CHAR       = $F435 = 62517          bootV2.asm:143
LCD_CHAR_H     = $F441 = 62529          bootV2.asm:151
LCD_CHAR_POINT = $F436 = 62518          bootV2.asm:144
LCD_CHAR_W     = $F442 = 62530          bootV2.asm:152
LCD_COOX       = $F448 = 62536          bootV2.asm:157 (unused)
LCD_COOY       = $F449 = 62537          bootV2.asm:158 (unused)
LCD_DATA       = $F42F = 62511          bootV2.asm:139 (unused)
LCD_DELETE_CHAR = $F445 = 62533          bootV2.asm:154
LCD_LINE1      = $0080 =   128          bootV2.asm:114 (unused)
LCD_LINE2      = $0090 =   144          bootV2.asm:115 (unused)
LCD_LINE3      = $0088 =   136          bootV2.asm:116 (unused)
LCD_LINE4      = $0098 =   152          bootV2.asm:117 (unused)
LCD_PRINT_H    = $F44A = 62538          bootV2.asm:159 (unused)
LCD_PRINT_IMAGE = $F44C = 62540          bootV2.asm:161 (unused)
LCD_PRINT_W    = $F44B = 62539          bootV2.asm:160 (unused)
LCD_TEMP       = $F447 = 62535          bootV2.asm:156
LCD_TMP_POINT  = $F443 = 62531          bootV2.asm:153
LCD_TXT_X      = $F438 = 62520          bootV2.asm:145
LCD_TXT_X_TMP  = $F43D = 62525          bootV2.asm:149
LCD_TXT_Y      = $F439 = 62521          bootV2.asm:146
LCD_TXT_Y_TMP  = $F43F = 62527          bootV2.asm:150
LCRFLG         = $80AC = 32940          basicV2.asm:68
LEFT           = $72F2 = 29426          basicV2.asm:2852
LEN            = $72C2 = 29378          basicV2.asm:2822
LET            = $69B8 = 27064          basicV2.asm:1481
LETNUM         = $6A0B = 27147          basicV2.asm:1523
LETSTR         = $69D3 = 27091          basicV2.asm:1494
LF             = $000A =    10          bootV2.asm:40
LFRGNM         = $738B = 29579          basicV2.asm:2954
LINEAT         = $805C = 32860          basicV2.asm:63
LINEIN         = $77EB = 30699          basicV2.asm:3694
LINES          = $7B1E = 31518          basicV2.asm:4115
LINESC         = $8046 = 32838          basicV2.asm:53
LINESN         = $8048 = 32840          basicV2.asm:54
LINFND         = $6443 = 25667          basicV2.asm:657
LIST           = $66C6 = 26310          basicV2.asm:1038
LISTLOOP       = $0C2E =  3118          I2C.asm:281
LISTLP         = $66D2 = 26322          basicV2.asm:1044
LISTMsg        = $146C =  5228          Strings.asm:28
LISTNEXT       = $0C3D =  3133          I2C.asm:289
LISTTEST       = $0C47 =  3143          I2C.asm:301
LOADFP         = $76A8 = 30376          basicV2.asm:3466
LOADSHIFT      = $028F =   655          Keyboard.asm:125
LOG            = $750D = 29965          basicV2.asm:3207
LOGARITHM      = $027B =   635          Keyboard.asm:114
LOGTAB         = $7500 = 29952          basicV2.asm:3202
LOKFOR         = $635F = 25439          basicV2.asm:525
LOOPST         = $80C7 = 32967          basicV2.asm:77
LS             = $001C =    28          basicV2.asm:116
LSTBIN         = $80CC = 32972          basicV2.asm:80
LSTLP2         = $66F2 = 26354          basicV2.asm:1065
LSTLP3         = $66F5 = 26357          basicV2.asm:1066
LSTRAM         = $80AF = 32943          basicV2.asm:71
LSTRND         = $803A = 32826          basicV2.asm:45
LTSTND         = $6BD0 = 27600          basicV2.asm:1751
LWIDTH         = $8042 = 32834          basicV2.asm:49
LcdSetCXY      = $01E5 =   485          API.asm:171
LineOut        = $12DE =  4830          Utils.asm:40
LoopBC         = $12F5 =  4853          Utils.asm:72
LoopDE         = $12F2 =  4850          Utils.asm:70
MAKINT         = $73DB = 29659          basicV2.asm:2996
MAKNUM         = $7855 = 30805          basicV2.asm:3748
MANLP          = $7774 = 30580          basicV2.asm:3619
MATCH          = $658E = 25998          basicV2.asm:861
MDIFY1         = $1251 =  4689          Monitor.asm:968
MDIFY2         = $128C =  4748          Monitor.asm:1004
MEMMSG         = $60F3 = 24819          basicV2.asm:223
MID            = $732C = 29484          basicV2.asm:2892
MID1           = $72F8 = 29432          basicV2.asm:2856
MIDNUM         = $7390 = 29584          basicV2.asm:2957
MINCDE         = $7453 = 29779          basicV2.asm:3063
MINUS          = $6D56 = 27990          basicV2.asm:1954
MKTMST         = $70FF = 28927          basicV2.asm:2538
MLDBLP         = $774D = 30541          basicV2.asm:3595
MLDEBC         = $7745 = 30533          basicV2.asm:3590
MLOOP          = $6048 = 24648          basicV2.asm:161
MLSP10         = $7642 = 30274          basicV2.asm:3401
MO             = $0024 =    36          basicV2.asm:120
MODIFY         = $123B =  4667          Monitor.asm:953
MONITR         = $7C4E = 31822          basicV2.asm:4321
MONOUT         = $7C4B = 31819          basicV2.asm:4317
MORDT          = $6BDC = 27612          basicV2.asm:1756
MORINP         = $6600 = 26112          basicV2.asm:929
MOVBUF         = $6479 = 25721          basicV2.asm:692
MOVDIR         = $6596 = 26006          basicV2.asm:869
MOVLP          = $6384 = 25476          basicV2.asm:552
MOVSTR         = $6381 = 25473          basicV2.asm:549
MOVUP          = $637E = 25470          basicV2.asm:548
MRPRNT         = $6A50 = 27216          basicV2.asm:1560
MSGBUF         = $F401 = 62465          bootV2.asm:127
MSG_BASIC      = $1558 =  5464          Strings.asm:47
MSG_COPYFAIL   = $151E =  5406          Strings.asm:41
MSG_COPYOK     = $1515 =  5397          Strings.asm:40
MSG_CPU2MEM    = $1499 =  5273          Strings.asm:30
MSG_DEV_ADDR   = $1529 =  5417          Strings.asm:43
MSG_DEV_DATA   = $154C =  5452          Strings.asm:45
MSG_DEV_REG    = $153C =  5436          Strings.asm:44
MSG_FROM       = $14F9 =  5369          Strings.asm:37
MSG_I2C_RD     = $14D5 =  5333          Strings.asm:34
MSG_I2C_RD_RR  = $14E5 =  5349          Strings.asm:35
MSG_I2C_WR_DD  = $14AF =  5295          Strings.asm:32
MSG_I2C_WR_RR_DD = $14C0 =  5312          Strings.asm:33
MSG_ILOAD      = $156C =  5484          Strings.asm:49
MSG_MEM2CPU    = $1483 =  5251          Strings.asm:29
MSG_MENU0      = $134D =  4941          Strings.asm:4
MSG_MENU1      = $1360 =  4960          Strings.asm:5
MSG_MENU10     = $13E6 =  5094          Strings.asm:14
MSG_MENU11     = $13F7 =  5111          Strings.asm:15
MSG_MENU12     = $1407 =  5127          Strings.asm:16
MSG_MENU13     = $141A =  5146          Strings.asm:17
MSG_MENU14     = $142F =  5167          Strings.asm:18
MSG_MENU15     = $1443 =  5187          Strings.asm:19
MSG_MENU2      = $1375 =  4981          Strings.asm:6
MSG_MENU3      = $1380 =  4992          Strings.asm:7
MSG_MENU4      = $1392 =  5010          Strings.asm:8
MSG_MENU5      = $13A3 =  5027          Strings.asm:9
MSG_MENU6      = $13B3 =  5043          Strings.asm:10
MSG_MENU7      = $13C0 =  5056          Strings.asm:11
MSG_MENU8      = $13C9 =  5065          Strings.asm:12
MSG_MENU9      = $13D5 =  5077          Strings.asm:13
MSG_MENU_CONTINUE = $1451 =  5201          Strings.asm:21
MSG_MONITOR    = $1338 =  4920          Strings.asm:2
MSG_READFILE_EXE = $145D =  5213          Strings.asm:24
MSG_READFILE_IMG = $1462 =  5218          Strings.asm:25
MSG_READFILE_TXT = $1467 =  5223          Strings.asm:26
MSG_SIZE       = $1506 =  5382          Strings.asm:39
MSG_TO         = $1500 =  5376          Strings.asm:38
MSIZE          = $6035 = 24629          basicV2.asm:154
MUL8LP         = $7579 = 30073          basicV2.asm:3262
MULLN2         = $7545 = 30021          basicV2.asm:3233
MULT           = $754C = 30028          basicV2.asm:3237
MULT8          = $7570 = 30064          basicV2.asm:3256
MULTEN         = $77B6 = 30646          basicV2.asm:3655
MULVAL         = $80F6 = 33014          basicV2.asm:96
MVSTPT         = $6A02 = 27138          basicV2.asm:1517
NDOT           = $0FA7 =  4007          Monitor.asm:407
NEDMOR         = $6B6F = 27503          basicV2.asm:1700
NEGAFT         = $78ED = 30957          basicV2.asm:3842
NEW            = $64BE = 25790          basicV2.asm:747
NEXITM         = $6B08 = 27400          basicV2.asm:1653
NEXT           = $6C2C = 27692          basicV2.asm:1795
NEXT1          = $6C2F = 27695          basicV2.asm:1796
NEXTKEY        = $0265 =   613          Keyboard.asm:102
NF             = $0000 =     0          basicV2.asm:102
NFERR          = $63B8 = 25528          basicV2.asm:586
NMIFLG         = $804C = 32844          basicV2.asm:56 (unused)
NOCHNG         = $6586 = 25990          basicV2.asm:856
NOENED         = $78C5 = 30917          basicV2.asm:3821
NOLIN          = $686F = 26735          basicV2.asm:1292
NOMADD         = $758A = 30090          basicV2.asm:3273
NOMLAD         = $775B = 30555          basicV2.asm:3603
NOPMPT         = $6B4D = 27469          basicV2.asm:1679
NORMAL         = $747E = 29822          basicV2.asm:3098
NOSPC          = $657D = 25981          basicV2.asm:851
NOSUB7         = $7BD0 = 31696          basicV2.asm:4230
NOSWAP         = $742D = 29741          basicV2.asm:3044
NOTAMP         = $6D2B = 27947          basicV2.asm:1935
NOTSTR         = $6EA5 = 28325          basicV2.asm:2165
NOXOR          = $73BB = 29627          basicV2.asm:2980
NSCFOR         = $6EB5 = 28341          basicV2.asm:2173
NULFLG         = $8044 = 32836          basicV2.asm:51
NULL           = $6893 = 26771          basicV2.asm:1311
NULLP          = $6AC3 = 27331          basicV2.asm:1615
NULLS          = $8041 = 32833          basicV2.asm:48
NUMASC         = $77FE = 30718          basicV2.asm:3704
NXTARY         = $6F6C = 28524          basicV2.asm:2286
NXTBIT         = $0D32 =  3378          SoftSerial.asm:102
NXTBYT         = $656C = 25964          basicV2.asm:841
NXTCHR         = $65AD = 26029          basicV2.asm:881
NXTDAT         = $80DC = 32988          basicV2.asm:89
NXTDTA         = $69A0 = 27040          basicV2.asm:1463
NXTITM         = $6B67 = 27495          basicV2.asm:1695
NXTOPR         = $80D0 = 32976          basicV2.asm:83
NXTSTL         = $69A7 = 27047          basicV2.asm:1468
NXTSTT         = $69AA = 27050          basicV2.asm:1471
NYBASC         = $1230 =  4656          Monitor.asm:935
NYBOUT         = $121C =  4636          Monitor.asm:900
OD             = $0006 =     6          basicV2.asm:105
OKMSG          = $634F = 25423          basicV2.asm:520
OM             = $000C =    12          basicV2.asm:108
OMERR          = $63A7 = 25511          basicV2.asm:577
ON             = $6A12 = 27154          basicV2.asm:1529
ONGO           = $6A21 = 27169          basicV2.asm:1537
ONGOLP         = $6A22 = 27170          basicV2.asm:1538
ONJMP          = $67F2 = 26610          basicV2.asm:1209
OPNPAR         = $6C85 = 27781          basicV2.asm:1845
OPRND          = $6D00 = 27904          basicV2.asm:1918
OS             = $001A =    26          basicV2.asm:115
OTKLN          = $65EE = 26094          basicV2.asm:920
OTPORT         = $8007 = 32775          basicV2.asm:38
OUTC           = $668B = 26251          basicV2.asm:1004
OUTCH          = $0D15 =  3349          SoftSerial.asm:68
OUTEXP         = $78B6 = 30902          basicV2.asm:3811
OUTIT          = $666C = 26220          basicV2.asm:982
OUTNBS         = $6672 = 26226          basicV2.asm:985
OUTNCR         = $7C62 = 31842          basicV2.asm:4339
OUTPORT        = $0FC0 =  4032          Monitor.asm:441
OUTSP          = $0341 =   833          LCDGraphic.asm:111
OUTSUB         = $8006 = 32774          basicV2.asm:37
OUTWRD         = $670E = 26382          basicV2.asm:1080
OV             = $000A =    10          basicV2.asm:107
OVERR          = $63C1 = 25537          basicV2.asm:592
OVTST1         = $7635 = 30261          basicV2.asm:3393
OVTST2         = $763A = 30266          basicV2.asm:3396
OVTST3         = $763B = 30267          basicV2.asm:3397
OutLcdChar     = $0186 =   390          API.asm:95
OutLcdNewLine  = $0189 =   393          API.asm:98
PADD           = $77DA = 30682          basicV2.asm:3680
PAND           = $6DC1 = 28097          basicV2.asm:2021
PASSA          = $7041 = 28737          basicV2.asm:2423
PBUFF          = $80E9 = 33001          basicV2.asm:95
PEEK           = $73E9 = 29673          basicV2.asm:3005
PEND           = $6854 = 26708          basicV2.asm:1278
PHLTFP         = $7697 = 30359          basicV2.asm:3456
PLOT_COLUMN    = $0596 =  1430          LCDGraphic.asm:580
PLOT_ROW       = $057F =  1407          LCDGraphic.asm:567
PLOT_TO_LCD    = $057D =  1405          LCDGraphic.asm:564 (unused)
PLUCDE         = $74B8 = 29880          basicV2.asm:3140
PNORM          = $7486 = 29830          basicV2.asm:3106
POINT          = $8051 = 32849          basicV2.asm:59
POKE           = $73F0 = 29680          basicV2.asm:3009
POPAF          = $7185 = 29061          basicV2.asm:2616
POPHL          = $72AF = 29359          basicV2.asm:2807
POPHRT         = $759A = 30106          basicV2.asm:3287
POPNOK         = $63FC = 25596          basicV2.asm:620
POR            = $6DC0 = 28096          basicV2.asm:2020
POR1           = $6DE3 = 28131          basicV2.asm:2044
PORT_OUT_VAL   = $F42E = 62510          bootV2.asm:138
PORT_SET       = $F42D = 62509          bootV2.asm:137
POS            = $703E = 28734          basicV2.asm:2422
POSINT         = $68B3 = 26803          basicV2.asm:1334
POUT           = $73A1 = 29601          basicV2.asm:2968
POWER          = $78FB = 30971          basicV2.asm:3850
POWER1         = $790B = 30987          basicV2.asm:3858
POWER2         = $7928 = 31016          basicV2.asm:3876
POWERS         = $78DB = 30939          basicV2.asm:3835
PRINT          = $6A54 = 27220          basicV2.asm:1562
PRINTCHAR      = $0368 =   872          LCDGraphic.asm:144
PRITAB         = $62A4 = 25252          basicV2.asm:423
PRNTCRLF       = $6AB2 = 27314          basicV2.asm:1608
PRNTHL         = $77F3 = 30707          basicV2.asm:3698
PRNTLP         = $6A57 = 27223          basicV2.asm:1563
PRNTNB         = $6A9A = 27290          basicV2.asm:1595
PRNTOK         = $63FD = 25597          basicV2.asm:622
PRNTST         = $6A9E = 27294          basicV2.asm:1597
PRNUMS         = $714F = 29007          basicV2.asm:2585
PROCES         = $6619 = 26137          basicV2.asm:940
PROGND         = $80D6 = 32982          basicV2.asm:86
PROGST         = $80F9 = 33017          basicV2.asm:97
PROMPT         = $6501 = 25857          basicV2.asm:784
PRS            = $7150 = 29008          basicV2.asm:2586
PRS1           = $7153 = 29011          basicV2.asm:2587
PRSLP          = $715A = 29018          basicV2.asm:2590
PSET           = $8054 = 32852          basicV2.asm:60
PSUB           = $740E = 29710          basicV2.asm:3025
PTRLP          = $6486 = 25734          basicV2.asm:701
PUTBUF         = $6658 = 26200          basicV2.asm:971
PUTCH          = $F432 = 62514          bootV2.asm:141
PUTCTL         = $665D = 26205          basicV2.asm:973
PUTFID         = $67C6 = 26566          basicV2.asm:1182
Print8x8       = $0686 =  1670          LCDGraphic.asm:875
PrintBufferChar = $037A =   890          LCDGraphic.asm:161
PrtIRd         = $01A2 =   418          API.asm:119
PrtORd         = $019E =   414          API.asm:115
PrtOWr         = $0192 =   402          API.asm:106
PrtSet         = $018E =   398          API.asm:102
QTSTLP         = $7115 = 28949          basicV2.asm:2555
QTSTR          = $710F = 28943          basicV2.asm:2551
QUARTR         = $7A94 = 31380          basicV2.asm:4053
READ           = $6B62 = 27490          basicV2.asm:1692
READFG         = $80CD = 32973          basicV2.asm:81
READKEY        = $025F =   607          Keyboard.asm:97
READ_FILE      = $0E4C =  3660          Monitor.asm:141
READ_FILE_EXE  = $0EB5 =  3765          Monitor.asm:215
READ_FILE_IMG  = $0ECB =  3787          Monitor.asm:235
READ_FILE_IMG_K = $0EE3 =  3811          Monitor.asm:255
READ_FILE_TXT  = $0EEC =  3820          Monitor.asm:262
READ_FILE_TXT_L = $0EFC =  3836          Monitor.asm:278
READ_IIC_DE    = $0F21 =  3873          Monitor.asm:310
READ_MEM_FILES = $0E3F =  3647          Monitor.asm:131
READ_MEM_KEY   = $0E66 =  3686          Monitor.asm:156
READ_MEM_NEXT  = $0E42 =  3650          Monitor.asm:133
READ_MEM_STEP  = $0E9E =  3742          Monitor.asm:190
READ_MEM_STEP_L = $0EA9 =  3753          Monitor.asm:201
READ_NAME      = $0E58 =  3672          Monitor.asm:147
REDO           = $6B0F = 27407          basicV2.asm:1657
REM            = $69A3 = 27043          basicV2.asm:1466
RESDIV         = $75E7 = 30183          basicV2.asm:3338
RESEED         = $7A32 = 31282          basicV2.asm:4009
RESET          = $8057 = 32855          basicV2.asm:61
RESET_WARM     = $0DAE =  3502          Monitor.asm:28
RESTNL         = $682F = 26671          basicV2.asm:1248
RESTOR         = $681A = 26650          basicV2.asm:1237
RESZER         = $7479 = 29817          basicV2.asm:3094
RETADR         = $6F1C = 28444          basicV2.asm:2233
RETINT         = $7670 = 30320          basicV2.asm:3429
RETLIN         = $699B = 27035          basicV2.asm:1460
RETNAD         = $6592 = 26002          basicV2.asm:865
RETNUL         = $6F1F = 28447          basicV2.asm:2237
RETNUM         = $6D62 = 28002          basicV2.asm:1959
RETREL         = $7662 = 30306          basicV2.asm:3419
RETURN         = $697C = 27004          basicV2.asm:1444
RG             = $0004 =     4          basicV2.asm:104
RIGHT          = $7322 = 29474          basicV2.asm:2885
RIGHT1         = $72F6 = 29430          basicV2.asm:2854
RINPUT         = $804E = 32846          basicV2.asm:58
RLTLP          = $6CA5 = 27813          basicV2.asm:1861
RND            = $79D1 = 31185          basicV2.asm:3956
RND1           = $7A0D = 31245          basicV2.asm:3987
RND2           = $7A29 = 31273          basicV2.asm:4005
RNDTAB         = $7A3A = 31290          basicV2.asm:4016
RNGTST         = $78C8 = 30920          basicV2.asm:3825
RONDB          = $749A = 29850          basicV2.asm:3118
RONDUP         = $7499 = 29849          basicV2.asm:3117
ROUND          = $7401 = 29697          basicV2.asm:3019
RSCALE         = $77D4 = 30676          basicV2.asm:3678
RSLNBK         = $6748 = 26440          basicV2.asm:1112
RST00          = $0000 =     0          bootV2.asm:165 (unused)
RST08          = $0008 =     8          bootV2.asm:169 (unused)
RST10          = $0010 =    16          bootV2.asm:172 (unused)
RST18          = $0018 =    24          bootV2.asm:175 (unused)
RST20          = $001B =    27          bootV2.asm:177 (unused)
RST28          = $0021 =    33          bootV2.asm:180 (unused)
RST30          = $0030 =    48          bootV2.asm:184 (unused)
RST38          = $0033 =    51          bootV2.asm:186 (unused)
RST66          = $003A =    58          bootV2.asm:189 (unused)
RSTSTR         = $7345 = 29509          basicV2.asm:2905
RUN            = $6941 = 26945          basicV2.asm:1411
RUNCNT         = $67CA = 26570          basicV2.asm:1186
RUNFST         = $64CA = 25802          basicV2.asm:756
RUNLIN         = $695D = 26973          basicV2.asm:1427
RXDAT1         = $0D4E =  3406          SoftSerial.asm:134
RXDAT2         = $0D66 =  3430          SoftSerial.asm:151
RXDATA         = $0D4C =  3404          SoftSerial.asm:129
SAVEXP         = $747A = 29818          basicV2.asm:3095
SAVSTP         = $67BD = 26557          basicV2.asm:1175
SAVSTR         = $70EA = 28906          basicV2.asm:2522
SBSCPT         = $6F2A = 28458          basicV2.asm:2243
SCALE          = $74D8 = 29912          basicV2.asm:3172
SCALLP         = $74DA = 29914          basicV2.asm:3173
SCALMI         = $779F = 30623          basicV2.asm:3640
SCALPL         = $77B5 = 30645          basicV2.asm:3654
SCNEND         = $7221 = 29217          basicV2.asm:2712
SCPTLP         = $6F30 = 28464          basicV2.asm:2247
SDBUFFERMSG1   = $0650 =  1616          LCDGraphic.asm:823
SDBUFFERMSG2   = $065B =  1627          LCDGraphic.asm:829
SDLCDMSG1      = $063C =  1596          LCDGraphic.asm:797
SDLCDMSG2      = $0647 =  1607          LCDGraphic.asm:803
SDMSG1         = $0D09 =  3337          SoftSerial.asm:55
SDMSG2         = $0D14 =  3348          SoftSerial.asm:61
SEARCH         = $655A = 25946          basicV2.asm:827
SEED           = $8017 = 32791          basicV2.asm:44
SERIAL_RX_PORT = $00C0 =   192          bootV2.asm:96
SERIAL_TX_PORT = $00C0 =   192          bootV2.asm:97
SETIO          = $73C5 = 29637          basicV2.asm:2987
SETLIN         = $671C = 26396          basicV2.asm:1088
SETLIT         = $65A4 = 26020          basicV2.asm:877
SETPTR         = $6481 = 25729          basicV2.asm:698
SETTOP         = $606C = 24684          basicV2.asm:186
SFTPRG         = $644B = 25675          basicV2.asm:661
SGN            = $7668 = 30312          basicV2.asm:3426
SGNEXP         = $6DB0 = 28080          basicV2.asm:2007
SGNRES         = $80E8 = 33000          basicV2.asm:94
SHIFTKEYMAP    = $0098 =   152          bootV2.asm:200
SHOWHELP       = $11A0 =  4512          Monitor.asm:825
SHOW_MSG_EXE   = $0F0C =  3852          Monitor.asm:291
SHOW_MSG_IMG   = $0F13 =  3859          Monitor.asm:296
SHOW_MSG_TXT   = $0F1A =  3866          Monitor.asm:301
SHRITE         = $74E7 = 29927          basicV2.asm:3181
SHRLP          = $74EA = 29930          basicV2.asm:3183
SHRT1          = $74EE = 29934          basicV2.asm:3187
SIGNON         = $60BC = 24764          basicV2.asm:219
SIGNS          = $76BF = 30399          basicV2.asm:3486
SIN            = $7A4C = 31308          basicV2.asm:4022
SIN1           = $7A7C = 31356          basicV2.asm:4042
SINTAB         = $7A98 = 31384          basicV2.asm:4055
SIXDIG         = $781B = 30747          basicV2.asm:3718
SMPVAR         = $71B5 = 29109          basicV2.asm:2640
SMSER1         = $79B0 = 31152          basicV2.asm:3934
SN             = $0002 =     2          basicV2.asm:103
SNDBUFFERMSG   = $064E =  1614          LCDGraphic.asm:821 (unused)
SNDLCDMSG      = $063A =  1594          LCDGraphic.asm:795
SNDMSG         = $0D07 =  3335          SoftSerial.asm:54
SNERR          = $63B2 = 25522          basicV2.asm:582
SPCBUF         = $0FBA =  4026          Monitor.asm:424
SPCFST         = $780C = 30732          basicV2.asm:3710
SPCLP          = $6B01 = 27393          basicV2.asm:1650
SQR            = $78F2 = 30962          basicV2.asm:3846
SRCHLN         = $649E = 25758          basicV2.asm:720
SRCHLP         = $64A1 = 25761          basicV2.asm:721
SSTSA          = $727D = 29309          basicV2.asm:2772
ST             = $001E =    30          basicV2.asm:117
STACK          = $8066 = 32870          basicV2.asm:66
STAKFP         = $768A = 30346          basicV2.asm:3446
STALL          = $6843 = 26691          basicV2.asm:1265
STARTB         = $6006 = 24582          basicV2.asm:128
START_BASIC    = $0E24 =  3620          Monitor.asm:112
START_BASIC_KEY = $0E2F =  3631          Monitor.asm:118
START_MONITOR  = $0D86 =  3462          Monitor.asm:4
STKTHS         = $6CE9 = 27881          basicV2.asm:1902
STLOOK         = $815D = 33117          basicV2.asm:98
STOP           = $6852 = 26706          basicV2.asm:1276
STORED         = $691E = 26910          basicV2.asm:1391
STPOOL         = $71F8 = 29176          basicV2.asm:2677
STR            = $70DA = 28890          basicV2.asm:2515
STR1           = $70E0 = 28896          basicV2.asm:2517
STRADD         = $71FB = 29179          basicV2.asm:2679
STRBOT         = $80C3 = 32963          basicV2.asm:75
STRENT         = $6BB9 = 27577          basicV2.asm:1739
STRSPC         = $805A = 32858          basicV2.asm:62
STTLIN         = $6AA5 = 27301          basicV2.asm:1601
SUBCDE         = $7410 = 29712          basicV2.asm:3027
SUBPHL         = $740A = 29706          basicV2.asm:3023
SUMLP          = $79B9 = 31161          basicV2.asm:3939
SUMSER         = $79A1 = 31137          basicV2.asm:3927
SUPTLZ         = $789A = 30874          basicV2.asm:3795
SVNAM2         = $6E89 = 28297          basicV2.asm:2152
SVSTAD         = $7108 = 28936          basicV2.asm:2543
SYSTEM         = $FFF0 = 65520          bootV2.asm:102
ShowBufferDisplay = $01D3 =   467          API.asm:155
SpaceOut       = $12DA =  4826          Utils.asm:32
StrOut         = $12E3 =  4835          Utils.asm:49
SysReset       = $0180 =   384          API.asm:89
TABLE          = $06B3 =  1715          LCDGraphic.asm:922
TAN            = $7AAD = 31405          basicV2.asm:4062
TESTOS         = $7187 = 29063          basicV2.asm:2619
TESTR          = $7169 = 29033          basicV2.asm:2599
TIME           = $7CCD = 31949          basicV2.asm:4421
TIMEOUT        = $2710 = 10000          bootV2.asm:108
TM             = $0018 =    24          basicV2.asm:114
TMERR          = $63C4 = 25540          basicV2.asm:594
TMPSTR         = $80BF = 32959          basicV2.asm:74
TMSTPL         = $80B3 = 32947          basicV2.asm:73
TMSTPT         = $80B1 = 32945          basicV2.asm:72
TOPOOL         = $72EE = 29422          basicV2.asm:2849
TOSTRA         = $7286 = 29318          basicV2.asm:2781
TRANSKEY       = $0298 =   664          Keyboard.asm:132 (unused)
TRYAGN         = $7875 = 30837          basicV2.asm:3768
TSALP          = $7287 = 29319          basicV2.asm:2782
TSTBIT         = $7C5B = 31835          basicV2.asm:4332 (unused)
TSTBRK         = $6835 = 26677          basicV2.asm:1254
TSTMEM         = $605A = 24666          basicV2.asm:174
TSTNUM         = $6C7A = 27770          basicV2.asm:1837
TSTOPL         = $7130 = 28976          basicV2.asm:2571
TSTRED         = $6DE8 = 28136          basicV2.asm:2050
TSTREM         = $65A7 = 26023          basicV2.asm:878
TSTSGN         = $7659 = 30297          basicV2.asm:3414
TSTSTR         = $6C7B = 27771          basicV2.asm:1838
TTYLIN         = $65F7 = 26103          basicV2.asm:925
TXCRLF         = $0347 =   839          LCDGraphic.asm:118
TXDATA         = $0D21 =  3361          SoftSerial.asm:86
TYPE           = $80AD = 32941          basicV2.asm:69
UF             = $0022 =    34          basicV2.asm:119
UFERR          = $63BE = 25534          basicV2.asm:590
UL             = $000E =    14          basicV2.asm:109
ULERR          = $6977 = 26999          basicV2.asm:1441
UNITY          = $74FC = 29948          basicV2.asm:3200
UPDATA         = $6830 = 26672          basicV2.asm:1249
USR            = $8003 = 32771          basicV2.asm:36
VAL            = $735C = 29532          basicV2.asm:2924
VAL1           = $737A = 29562          basicV2.asm:2944
VAL2           = $7384 = 29572          basicV2.asm:2948
VAL3           = $7387 = 29575          basicV2.asm:2949
VAREND         = $80D8 = 32984          basicV2.asm:87
VT             = $000B =    11          bootV2.asm:41 (unused)
WAIT           = $73A7 = 29607          basicV2.asm:2971
WAITLP         = $73BC = 29628          basicV2.asm:2981
WARM           = $6003 = 24579          basicV2.asm:127 (unused)
WARMST         = $60A4 = 24740          basicV2.asm:213
WELLCOME       = $1320 =  4896          Strings.asm:1
WIDTH          = $7B16 = 31510          basicV2.asm:4110
WORDS          = $6138 = 24888          basicV2.asm:260
WORDTB         = $625A = 25178          basicV2.asm:351
WRDASC         = $1222 =  4642          Monitor.asm:919
WRDOUT         = $1216 =  4630          Monitor.asm:898
WRKSPC         = $8000 = 32768          basicV2.asm:35
ZDATA          = $0083 =   131          basicV2.asm:394
ZDIV           = $00AF =   175          basicV2.asm:412 (unused)
ZEND           = $0080 =   128          basicV2.asm:392
ZEQUAL         = $00B4 =   180          basicV2.asm:415
ZERARY         = $6FCB = 28619          basicV2.asm:2346
ZERBYT         = $634E = 25422          basicV2.asm:519
ZEROLP         = $6F0E = 28430          basicV2.asm:2224
ZEROSUP        = $7BEE = 31726          basicV2.asm:4251
ZFN            = $00A7 =   167          basicV2.asm:403
ZFOR           = $0081 =   129          basicV2.asm:393
ZGOSUB         = $008C =   140          basicV2.asm:396
ZGOTO          = $0088 =   136          basicV2.asm:395
ZGTR           = $00B3 =   179          basicV2.asm:414
ZLEFT          = $00CF =   207          basicV2.asm:419
ZLTH           = $00B5 =   181          basicV2.asm:416
ZMINUS         = $00AD =   173          basicV2.asm:410
ZNEW           = $00A4 =   164          basicV2.asm:399
ZNOT           = $00AA =   170          basicV2.asm:406
ZONELP         = $6ADC = 27356          basicV2.asm:1629
ZOR            = $00B2 =   178          basicV2.asm:413
ZPLUS          = $00AC =   172          basicV2.asm:409
ZPOINT         = $00C7 =   199          basicV2.asm:418 (unused)
ZPRINT         = $009E =   158          basicV2.asm:398
ZREM           = $008E =   142          basicV2.asm:397
ZSGN           = $00B6 =   182          basicV2.asm:417
ZSPC           = $00A8 =   168          basicV2.asm:404
ZSTEP          = $00AB =   171          basicV2.asm:407
ZTAB           = $00A5 =   165          basicV2.asm:401
ZTHEN          = $00A9 =   169          basicV2.asm:405
ZTIMES         = $00AE =   174          basicV2.asm:411 (unused)
ZTO            = $00A6 =   166          basicV2.asm:402
_end           = $7D63 = 32099          bootV2.asm:164 (unused)
_loop          = $1314 =  4884          Utils.asm:115
_overflow      = $131B =  4891          Utils.asm:121
_size          = $7D63 = 32099          bootV2.asm:164 (unused)
_skip          = $131D =  4893          Utils.asm:124
_z80_          = $0001 =     1          bootV2.asm:1 (unused)
ajustX         = $03F6 =  1014          LCDGraphic.asm:263
ajustXOK       = $03F9 =  1017          LCDGraphic.asm:265
clear8x8_Y     = $0674 =  1652          LCDGraphic.asm:854
clear8x8_Y_OK  = $0677 =  1655          LCDGraphic.asm:858
clear8x8_loop  = $067C =  1660          LCDGraphic.asm:862
cls_GRAPHIC    = $05BD =  1469          LCDGraphic.asm:621
cls_TXT        = $05B2 =  1458          LCDGraphic.asm:609
delay          = $04CA =  1226          LCDGraphic.asm:413
delayLCD       = $0616 =  1558          LCDGraphic.asm:743
delayLCDclear  = $0624 =  1572          LCDGraphic.asm:759
delay_loop     = $04CF =  1231          LCDGraphic.asm:418
delay_loop_b   = $04CD =  1229          LCDGraphic.asm:416
display        = $7D5B = 32091          basicV2.asm:4548
enable_grafic  = $0560 =  1376          LCDGraphic.asm:543
incXOK         = $04C2 =  1218          LCDGraphic.asm:394
incYOK         = $04BC =  1212          LCDGraphic.asm:390
kAPILast       = $0015 =    21          API.asm:82
kCPUClock      = $0900 =4000000          bootV2.asm:71
kDelayCnt      = $0098 =   152          bootV2.asm:76
kDelayLP       = $001A =    26          bootV2.asm:73
kDelayOH       = $0024 =    36          bootV2.asm:72
kDelayTA       = $0FA0 =  4000          bootV2.asm:74
kDelayTB       = $0F7C =  3964          bootV2.asm:75
lcd_asciiz_char_loop = $0603 =  1539          LCDGraphic.asm:720
lcd_asciiz_done = $0613 =  1555          LCDGraphic.asm:735
lcd_asciiz_wait_loop = $0605 =  1541          LCDGraphic.asm:723 (unused)
lcd_clear      = $054E =  1358          LCDGraphic.asm:513
lcd_clearPixel = $0512 =  1298          LCDGraphic.asm:470
lcd_clearPixel_bit = $053A =  1338          LCDGraphic.asm:490
lcd_clearPixel_fim = $0543 =  1347          LCDGraphic.asm:496
lcd_print_data = $7D36 = 32054          basicV2.asm:4521
lcd_send_asciiz = $0601 =  1537          LCDGraphic.asm:717 (unused)
lcd_send_command = $05E3 =  1507          LCDGraphic.asm:667
lcd_send_command_clear = $05ED =  1517          LCDGraphic.asm:683
lcd_send_data  = $05F7 =  1527          LCDGraphic.asm:698
lcd_setPixel   = $04D9 =  1241          LCDGraphic.asm:430
lcd_setPixel_bit = $0501 =  1281          LCDGraphic.asm:451
lcd_setPixel_fim = $050A =  1290          LCDGraphic.asm:457
multY          = $040E =  1038          LCDGraphic.asm:279
multYfim       = $0417 =  1047          LCDGraphic.asm:286
multYfimok     = $041D =  1053          LCDGraphic.asm:290
multiplication = $1304 =  4868          Utils.asm:92
multiplicationLOOP = $130D =  4877          Utils.asm:99
print8x8_Y     = $069F =  1695          LCDGraphic.asm:894
print8x8_Y_OK  = $06A2 =  1698          LCDGraphic.asm:898
print8x8_loop  = $06A7 =  1703          LCDGraphic.asm:903
print_12       = $7D47 = 32071          basicV2.asm:4534
print_22       = $7D55 = 32085          basicV2.asm:4542
print_char_fim = $04C5 =  1221          LCDGraphic.asm:397
print_image    = $0579 =  1401          LCDGraphic.asm:559
print_lcd      = $03D7 =   983          LCDGraphic.asm:239
printchar_loopH = $042D =  1069          LCDGraphic.asm:302
printchar_loopW = $0439 =  1081          LCDGraphic.asm:309
printchar_loopWC = $044C =  1100          LCDGraphic.asm:318
printchar_loopWE = $0452 =  1106          LCDGraphic.asm:322
ver_delete     = $0388 =   904          LCDGraphic.asm:175 (unused)
ver_enter      = $03A0 =   928          LCDGraphic.asm:190
ver_enter_incYOK = $03B8 =   952          LCDGraphic.asm:210
ver_limpa      = $03BE =   958          LCDGraphic.asm:215
ver_line       = $03D0 =   976          LCDGraphic.asm:230


total time: 0.0596 sec.
no errors
