0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; GENERAL EQUATES
0017   0000             
0018   0000             CTRLC   .EQU    03H             ; Control "C"
0019   0000             CTRLG   .EQU    07H             ; Control "G"
0020   0000             BKSP    .EQU    08H             ; Back space
0021   0000             LF      .EQU    0AH             ; Line feed
0022   0000             CS      .EQU    0CH             ; Clear screen
0023   0000             CR      .EQU    0DH             ; Carriage return
0024   0000             CTRLO   .EQU    0FH             ; Control "O"
0025   0000             CTRLQ	.EQU	11H		        ; Control "Q"
0026   0000             CTRLR   .EQU    12H             ; Control "R"
0027   0000             CTRLS   .EQU    13H             ; Control "S"
0028   0000             CTRLU   .EQU    15H             ; Control "U"
0029   0000             ESC     .EQU    1BH             ; Escape
0030   0000             DEL     .EQU    7FH             ; Delete
0031   0000             
0032   0000             
0033   0000             ; BASIC WORK SPACE LOCATIONS
0034   0000             
0035   0000             WRKSPC  .EQU    9000H             ; BASIC Work space |36864|
0036   0000             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0037   0000             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0038   0000             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0039   0000             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0040   0000             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0041   0000             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0042   0000             DIV3    .EQU    WRKSPC+12H           ; <-   be
0043   0000             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0044   0000             SEED    .EQU    WRKSPC+17H           ; Random number seed
0045   0000             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0046   0000             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0047   0000             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0048   0000             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0049   0000             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0050   0000             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0051   0000             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0052   0000             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0053   0000             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0054   0000             LINESN  .EQU    WRKSPC+48H           ; Lines number
0055   0000             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0056   0000             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0057   0000             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0058   0000             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0059   0000             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0060   0000             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0061   0000             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0062   0000             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0063   0000             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0064   0000             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0065   0000             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0066   0000             STACK   .EQU    WRKSPC+66H           ; Initial stack
0067   0000             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0068   0000             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0069   0000             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0070   0000             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0071   0000             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0072   0000             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0073   0000             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0074   0000             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0075   0000             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0076   0000             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0077   0000             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0078   0000             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0079   0000             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0080   0000             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0081   0000             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0082   0000             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0083   0000             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0084   0000             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0085   0000             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0086   0000             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0087   0000             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0088   0000             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0089   0000             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0090   0000             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0091   0000             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0092   0000             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0093   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0094   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0095   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0096   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0097   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area |33280 + 249 = 33529|
0098   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0099   0000             
0100   0000             ; BASIC ERROR CODE VALUES
0101   0000             
0102   0000             NF      .EQU    00H             ; NEXT without FOR
0103   0000             SN      .EQU    02H             ; Syntax error
0104   0000             RG      .EQU    04H             ; RETURN without GOSUB
0105   0000             OD      .EQU    06H             ; Out of DATA
0106   0000             FC      .EQU    08H             ; Function call error
0107   0000             OV      .EQU    0AH             ; Overflow
0108   0000             OM      .EQU    0CH             ; Out of memory
0109   0000             UL      .EQU    0EH             ; Undefined line number
0110   0000             BS      .EQU    10H             ; Bad subscript
0111   0000             DD      .EQU    12H             ; Re-DIMensioned array
0112   0000             DZ      .EQU    14H             ; Division by zero (/0)
0113   0000             ID      .EQU    16H             ; Illegal direct
0114   0000             TM      .EQU    18H             ; Type miss-match
0115   0000             OS      .EQU    1AH             ; Out of string space
0116   0000             LS      .EQU    1CH             ; String too long
0117   0000             ST      .EQU    1EH             ; String formula too complex
0118   0000             CN      .EQU    20H             ; Can't CONTinue
0119   0000             UF      .EQU    22H             ; UnDEFined FN function
0120   0000             MO      .EQU    24H             ; Missing operand
0121   0000             HX      .EQU    26H             ; HEX error
0122   0000             BN      .EQU    28H             ; BIN error
0123   0000             
0124   6000                     .ORG    $6000
0125   6000             
0126   6000 C3 06 60    COLD:   JP      STARTB          ; Jump for cold start
0127   6003 C3 A4 60    WARM:   JP      WARMST          ; Jump for warm start
0128   6006             STARTB: 
0129   6006 DD 21 00 00         LD      IX,0            ; Flag cold start
0130   600A C3 11 60            JP      CSTART          ; Jump to initialise
0131   600D             
0132   600D B7 68               .WORD   DEINT           ; Get integer -32768 to 32767
0133   600F 2D 70               .WORD   ABPASS          ; Return integer in AB
0134   6011             
0135   6011             
0136   6011 21 00 90    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0137   6014 F9                  LD      SP,HL           ; Set up a temporary stack
0138   6015 C3 4C 7C            JP      INITST          ; Go to initialise
0139   6018             
0140   6018 11 DE 62    INIT:   LD      DE,INITAB       ; Initialise workspace
0141   601B 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0142   601D 21 00 90            LD      HL,WRKSPC       ; Into workspace RAM
0143   6020 1A          COPY:   LD      A,(DE)          ; Get source
0144   6021 77                  LD      (HL),A          ; To destination
0145   6022 23                  INC     HL              ; Next destination
0146   6023 13                  INC     DE              ; Next source
0147   6024 05                  DEC     B               ; Count bytes
0148   6025 C2 20 60            JP      NZ,COPY         ; More to move
0149   6028 F9                  LD      SP,HL           ; Temporary stack
0150   6029 CD DF 64            CALL    CLREG           ; Clear registers and stack
0151   602C CD AD 6A            CALL    PRNTCRLF        ; Output CRLF
0152   602F 32 AA 90            LD      (BUFFER+72+1),A ; Mark end of buffer
0153   6032 32 F9 90            LD      (PROGST),A      ; Initialise program area
0154   6035 21 F3 60    MSIZE:  LD      HL,MEMMSG       ; Point to message
0155   6038 CD 4B 71            CALL    PRS             ; Output "Memory size"
0156   603B CD FC 64            CALL    PROMPT          ; Get input with '?'
0157   603E CD 05 68            CALL    GETCHR          ; Get next character
0158   6041 B7                  OR      A               ; Set flags
0159   6042 C2 5A 60            JP      NZ,TSTMEM       ; If number - Test if RAM there
0160   6045 21 5D 91            LD      HL,STLOOK       ; Point to start of RAM
0161   6048 23          MLOOP:  INC     HL              ; Next byte
0162   6049 7C                  LD      A,H             ; Above address FFFF ?
0163   604A B5                  OR      L
0164   604B CA 6C 60            JP      Z,SETTOP        ; Yes - 64K RAM
0165   604E 7E                  LD      A,(HL)          ; Get contents
0166   604F 47                  LD      B,A             ; Save it
0167   6050 2F                  CPL                     ; Flip all bits
0168   6051 77                  LD      (HL),A          ; Put it back
0169   6052 BE                  CP      (HL)            ; RAM there if same
0170   6053 70                  LD      (HL),B          ; Restore old contents
0171   6054 CA 48 60            JP      Z,MLOOP         ; If RAM - test next byte
0172   6057 C3 6C 60            JP      SETTOP          ; Top of RAM found
0173   605A             
0174   605A CD D1 68    TSTMEM: CALL    ATOH            ; Get high memory into DE
0175   605D B7                  OR      A               ; Set flags on last byte
0176   605E C2 AD 63            JP      NZ,SNERR        ; ?SN Error if bad character
0177   6061 EB                  EX      DE,HL           ; Address into HL
0178   6062 2B                  DEC     HL              ; Back one byte
0179   6063 3E D9               LD      A,11011001B     ; Test byte
0180   6065 46                  LD      B,(HL)          ; Get old contents
0181   6066 77                  LD      (HL),A          ; Load test byte
0182   6067 BE                  CP      (HL)            ; RAM there if same
0183   6068 70                  LD      (HL),B          ; Restore old contents
0184   6069 C2 35 60            JP      NZ,MSIZE        ; Ask again if no RAM
0185   606C             
0186   606C 2B          SETTOP: DEC     HL              ; Back one byte
0187   606D 11 5C 91            LD      DE,STLOOK-1     ; See if enough RAM
0188   6070 CD 75 66            CALL    CPDEHL          ; Compare DE with HL
0189   6073 DA 35 60            JP      C,MSIZE         ; Ask again if not enough RAM
0190   6076 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0191   6079 22 AF 90            LD      (LSTRAM),HL     ; Save last available RAM
0192   607C 19                  ADD     HL,DE           ; Allocate string space
0193   607D 22 5A 90            LD      (STRSPC),HL     ; Save string space
0194   6080 CD BA 64            CALL    CLRPTR          ; Clear program area
0195   6083 2A 5A 90            LD      HL,(STRSPC)     ; Get end of memory
0196   6086 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0197   6089 19                  ADD     HL,DE           ; Adjust HL
0198   608A 11 F9 90            LD      DE,PROGST       ; Start of program text
0199   608D 7D                  LD      A,L             ; Get LSB
0200   608E 93                  SUB     E               ; Adjust it
0201   608F 6F                  LD      L,A             ; Re-save
0202   6090 7C                  LD      A,H             ; Get MSB
0203   6091 9A                  SBC     A,D             ; Adjust it
0204   6092 67                  LD      H,A             ; Re-save
0205   6093 E5                  PUSH    HL              ; Save bytes free
0206   6094 21 BC 60            LD      HL,SIGNON       ; Sign-on message
0207   6097 CD 4B 71            CALL    PRS             ; Output string
0208   609A E1                  POP     HL              ; Get bytes free back
0209   609B CD EE 77            CALL    PRNTHL          ; Output amount of free memory
0210   609E 21 AD 60            LD      HL,BFREE        ; " Bytes free" message
0211   60A1 CD 4B 71            CALL    PRS             ; Output string
0212   60A4             
0213   60A4 31 66 90    WARMST: LD      SP,STACK        ; Temporary stack
0214   60A7 CD DF 64    BRKRET: CALL    CLREG           ; Clear registers and stack
0215   60AA C3 F8 63            JP      PRNTOK          ; Go to get command line
0216   60AD             
0217   60AD 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0217   60B3 20667265650D0A0000
0218   60BC             
0219   60BC 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0219   60C2 5349432056657220342E37620D0A
0220   60D0 436F70797269        .BYTE   "Copyright ",40,"C",41
0220   60D6 67687420284329
0221   60DD 203139373820        .BYTE   " 1978 by Microsoft",CR,LF,0,0
0221   60E3 6279204D6963726F736F66740D0A0000
0222   60F3             
0223   60F3 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0223   60F9 20746F7000
0224   60FE             
0225   60FE             ; FUNCTION ADDRESS TABLE
0226   60FE             
0227   60FE 63 76       FNCTAB: .WORD   SGN
0228   6100 27 77               .WORD   INT
0229   6102 79 76               .WORD   ABS
0230   6104 03 90               .WORD   USR
0231   6106 0B 70               .WORD   FRE
0232   6108 90 73               .WORD   INP
0233   610A 39 70               .WORD   POS
0234   610C ED 78               .WORD   SQR
0235   610E CC 79               .WORD   RND
0236   6110 08 75               .WORD   LOG
0237   6112 3B 79               .WORD   EXP
0238   6114 41 7A               .WORD   COS
0239   6116 47 7A               .WORD   SIN
0240   6118 A8 7A               .WORD   TAN
0241   611A BD 7A               .WORD   ATN
0242   611C E4 73               .WORD   PEEK
0243   611E 28 7B               .WORD   DEEK
0244   6120 51 90               .WORD   POINT
0245   6122 BD 72               .WORD   LEN
0246   6124 D5 70               .WORD   STR
0247   6126 57 73               .WORD   VAL
0248   6128 CC 72               .WORD   ASC
0249   612A DD 72               .WORD   CHR
0250   612C 4A 7B               .WORD   HEX
0251   612E DD 7B               .WORD   BIN
0252   6130 ED 72               .WORD   LEFT
0253   6132 1D 73               .WORD   RIGHT
0254   6134 27 73               .WORD   MID
0255   6136             
0256   6136             ; RESERVED WORD LIST
0257   6136             
0258   6136 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0259   6139 C6 4F 52            .BYTE   'F'+80H,"OR"
0260   613C CE 45 58 54         .BYTE   'N'+80H,"EXT"
0261   6140 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0262   6144 C94E505554          .BYTE   'I'+80H,"NPUT"
0263   6149 C4 49 4D            .BYTE   'D'+80H,"IM"
0264   614C D2 45 41 44         .BYTE   'R'+80H,"EAD"
0265   6150 CC 45 54            .BYTE   'L'+80H,"ET"
0266   6153 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0267   6157 D2 55 4E            .BYTE   'R'+80H,"UN"
0268   615A C9 46               .BYTE   'I'+80H,"F"
0269   615C D24553544F52        .BYTE   'R'+80H,"ESTORE"
0269   6162 45
0270   6163 C74F535542          .BYTE   'G'+80H,"OSUB"
0271   6168 D2455455524E        .BYTE   'R'+80H,"ETURN"
0272   616E D2 45 4D            .BYTE   'R'+80H,"EM"
0273   6171 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0274   6175 CF 55 54            .BYTE   'O'+80H,"UT"
0275   6178 CF 4E               .BYTE   'O'+80H,"N"
0276   617A CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0277   617E D7 41 49 54         .BYTE   'W'+80H,"AIT"
0278   6182 C4 45 46            .BYTE   'D'+80H,"EF"
0279   6185 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0280   6189 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0281   618D D3435245454E        .BYTE   'S'+80H,"CREEN"
0282   6193 CC494E4553          .BYTE   'L'+80H,"INES"
0283   6198 C3 4C 53            .BYTE   'C'+80H,"LS"
0284   619B D749445448          .BYTE   'W'+80H,"IDTH"
0285   61A0 CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0285   61A6 52
0286   61A7 D3 45 54            .BYTE   'S'+80H,"ET"
0287   61AA D245534554          .BYTE   'R'+80H,"ESET"
0288   61AF D052494E54          .BYTE   'P'+80H,"RINT"
0289   61B4 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0290   61B8 CC 49 53 54         .BYTE   'L'+80H,"IST"
0291   61BC C34C454152          .BYTE   'C'+80H,"LEAR"
0292   61C1 C34C4F4144          .BYTE   'C'+80H,"LOAD"
0293   61C6 C353415645          .BYTE   'C'+80H,"SAVE"
0294   61CB CE 45 57            .BYTE   'N'+80H,"EW"
0295   61CE             
0296   61CE D4 41 42 28         .BYTE   'T'+80H,"AB("
0297   61D2 D4 4F               .BYTE   'T'+80H,"O"
0298   61D4 C6 4E               .BYTE   'F'+80H,"N"
0299   61D6 D3 50 43 28         .BYTE   'S'+80H,"PC("
0300   61DA D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0301   61DE CE 4F 54            .BYTE   'N'+80H,"OT"
0302   61E1 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0303   61E5             
0304   61E5 AB                  .BYTE   '+'+80H
0305   61E6 AD                  .BYTE   '-'+80H
0306   61E7 AA                  .BYTE   '*'+80H
0307   61E8 AF                  .BYTE   '/'+80H
0308   61E9 DE                  .BYTE   '^'+80H
0309   61EA C1 4E 44            .BYTE   'A'+80H,"ND"
0310   61ED CF 52               .BYTE   'O'+80H,"R"
0311   61EF BE                  .BYTE   '>'+80H
0312   61F0 BD                  .BYTE   '='+80H
0313   61F1 BC                  .BYTE   '<'+80H
0314   61F2             
0315   61F2 D3 47 4E            .BYTE   'S'+80H,"GN"
0316   61F5 C9 4E 54            .BYTE   'I'+80H,"NT"
0317   61F8 C1 42 53            .BYTE   'A'+80H,"BS"
0318   61FB D5 53 52            .BYTE   'U'+80H,"SR"
0319   61FE C6 52 45            .BYTE   'F'+80H,"RE"
0320   6201 C9 4E 50            .BYTE   'I'+80H,"NP"
0321   6204 D0 4F 53            .BYTE   'P'+80H,"OS"
0322   6207 D3 51 52            .BYTE   'S'+80H,"QR"
0323   620A D2 4E 44            .BYTE   'R'+80H,"ND"
0324   620D CC 4F 47            .BYTE   'L'+80H,"OG"
0325   6210 C5 58 50            .BYTE   'E'+80H,"XP"
0326   6213 C3 4F 53            .BYTE   'C'+80H,"OS"
0327   6216 D3 49 4E            .BYTE   'S'+80H,"IN"
0328   6219 D4 41 4E            .BYTE   'T'+80H,"AN"
0329   621C C1 54 4E            .BYTE   'A'+80H,"TN"
0330   621F D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0331   6223 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0332   6227 D04F494E54          .BYTE   'P'+80H,"OINT"
0333   622C CC 45 4E            .BYTE   'L'+80H,"EN"
0334   622F D3 54 52 24         .BYTE   'S'+80H,"TR$"
0335   6233 D6 41 4C            .BYTE   'V'+80H,"AL"
0336   6236 C1 53 43            .BYTE   'A'+80H,"SC"
0337   6239 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0338   623D C8 45 58 24         .BYTE   'H'+80H,"EX$"
0339   6241 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0340   6245 CC45465424          .BYTE   'L'+80H,"EFT$"
0341   624A D24947485424        .BYTE   'R'+80H,"IGHT$"
0342   6250 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0343   6254 80                  .BYTE   80H             ; End of list marker
0344   6255             
0345   6255             ; KEYWORD ADDRESS TABLE
0346   6255             
0347   6255 4F 68       WORDTB: .WORD   PEND
0348   6257 4C 67               .WORD   FOR
0349   6259 27 6C               .WORD   NEXT
0350   625B 9C 69               .WORD   DATA
0351   625D 2E 6B               .WORD   INPUT
0352   625F 63 6E               .WORD   DIM
0353   6261 5D 6B               .WORD   READ
0354   6263 B3 69               .WORD   LET
0355   6265 59 69               .WORD   GOTO
0356   6267 3C 69               .WORD   RUN
0357   6269 2B 6A               .WORD   IF
0358   626B 15 68               .WORD   RESTOR
0359   626D 48 69               .WORD   GOSUB
0360   626F 77 69               .WORD   RETURN
0361   6271 9E 69               .WORD   REM
0362   6273 4D 68               .WORD   STOP
0363   6275 9C 73               .WORD   POUT
0364   6277 0D 6A               .WORD   ON
0365   6279 8E 68               .WORD   NULL
0366   627B A2 73               .WORD   WAIT
0367   627D 41 70               .WORD   DEF
0368   627F EB 73               .WORD   POKE
0369   6281 33 7B               .WORD   DOKE
0370   6283 9E 69               .WORD   REM
0371   6285 19 7B               .WORD   LINES
0372   6287 0C 7B               .WORD   CLS
0373   6289 11 7B               .WORD   WIDTH
0374   628B 49 7C               .WORD   MONITR
0375   628D 54 90               .WORD   PSET
0376   628F 57 90               .WORD   RESET
0377   6291 4F 6A               .WORD   PRINT
0378   6293 7B 68               .WORD   CONT
0379   6295 C1 66               .WORD   LIST
0380   6297 F6 68               .WORD   CLEAR
0381   6299 9E 69               .WORD   REM
0382   629B 9E 69               .WORD   REM
0383   629D B9 64               .WORD   NEW
0384   629F             
0385   629F             ; RESERVED WORD TOKEN VALUES
0386   629F             
0387   629F             ZEND    .EQU    080H            ; END
0388   629F             ZFOR    .EQU    081H            ; FOR
0389   629F             ZDATA   .EQU    083H            ; DATA
0390   629F             ZGOTO   .EQU    088H            ; GOTO
0391   629F             ZGOSUB  .EQU    08CH            ; GOSUB
0392   629F             ZREM    .EQU    08EH            ; REM
0393   629F             ZPRINT  .EQU    09EH            ; PRINT
0394   629F             ZNEW    .EQU    0A4H            ; NEW
0395   629F             
0396   629F             ZTAB    .EQU    0A5H            ; TAB
0397   629F             ZTO     .EQU    0A6H            ; TO
0398   629F             ZFN     .EQU    0A7H            ; FN
0399   629F             ZSPC    .EQU    0A8H            ; SPC
0400   629F             ZTHEN   .EQU    0A9H            ; THEN
0401   629F             ZNOT    .EQU    0AAH            ; NOT
0402   629F             ZSTEP   .EQU    0ABH            ; STEP
0403   629F             
0404   629F             ZPLUS   .EQU    0ACH            ; +
0405   629F             ZMINUS  .EQU    0ADH            ; -
0406   629F             ZTIMES  .EQU    0AEH            ; *
0407   629F             ZDIV    .EQU    0AFH            ; /
0408   629F             ZOR     .EQU    0B2H            ; OR
0409   629F             ZGTR    .EQU    0B3H            ; >
0410   629F             ZEQUAL  .EQU    0B4H            ; M
0411   629F             ZLTH    .EQU    0B5H            ; <
0412   629F             ZSGN    .EQU    0B6H            ; SGN
0413   629F             ZPOINT  .EQU    0C7H            ; POINT
0414   629F             ZLEFT   .EQU    0CDH +2         ; LEFT$
0415   629F             
0416   629F             ; ARITHMETIC PRECEDENCE TABLE
0417   629F             
0418   629F 79          PRITAB: .BYTE   79H             ; Precedence value
0419   62A0 D5 77               .WORD   PADD            ; FPREG = <last> + FPREG
0420   62A2             
0421   62A2 79                  .BYTE   79H             ; Precedence value
0422   62A3 09 74               .WORD   PSUB            ; FPREG = <last> - FPREG
0423   62A5             
0424   62A5 7C                  .BYTE   7CH             ; Precedence value
0425   62A6 47 75               .WORD   MULT            ; PPREG = <last> * FPREG
0426   62A8             
0427   62A8 7C                  .BYTE   7CH             ; Precedence value
0428   62A9 A8 75               .WORD   DIV             ; FPREG = <last> / FPREG
0429   62AB             
0430   62AB 7F                  .BYTE   7FH             ; Precedence value
0431   62AC F6 78               .WORD   POWER           ; FPREG = <last> ^ FPREG
0432   62AE             
0433   62AE 50                  .BYTE   50H             ; Precedence value
0434   62AF BC 6D               .WORD   PAND            ; FPREG = <last> AND FPREG
0435   62B1             
0436   62B1 46                  .BYTE   46H             ; Precedence value
0437   62B2 BB 6D               .WORD   POR             ; FPREG = <last> OR FPREG
0438   62B4             
0439   62B4             ; BASIC ERROR CODE LIST
0440   62B4             
0441   62B4 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0442   62B6 53 4E               .BYTE   "SN"            ; Syntax error
0443   62B8 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0444   62BA 4F 44               .BYTE   "OD"            ; Out of DATA
0445   62BC 46 43               .BYTE   "FC"            ; Illegal function call
0446   62BE 4F 56               .BYTE   "OV"            ; Overflow error
0447   62C0 4F 4D               .BYTE   "OM"            ; Out of memory
0448   62C2 55 4C               .BYTE   "UL"            ; Undefined line
0449   62C4 42 53               .BYTE   "BS"            ; Bad subscript
0450   62C6 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0451   62C8 2F 30               .BYTE   "/0"            ; Division by zero
0452   62CA 49 44               .BYTE   "ID"            ; Illegal direct
0453   62CC 54 4D               .BYTE   "TM"            ; Type mis-match
0454   62CE 4F 53               .BYTE   "OS"            ; Out of string space
0455   62D0 4C 53               .BYTE   "LS"            ; String too long
0456   62D2 53 54               .BYTE   "ST"            ; String formula too complex
0457   62D4 43 4E               .BYTE   "CN"            ; Can't CONTinue
0458   62D6 55 46               .BYTE   "UF"            ; Undefined FN function
0459   62D8 4D 4F               .BYTE   "MO"            ; Missing operand
0460   62DA 48 58               .BYTE   "HX"            ; HEX error
0461   62DC 42 4E               .BYTE   "BN"            ; BIN error
0462   62DE             
0463   62DE             ; INITIALISATION TABLE -------------------------------------------------------
0464   62DE             
0465   62DE C3 A4 60    INITAB: JP      WARMST          ; Warm start jump
0466   62E1 C3 CC 68            JP      FCERR           ; "USR (X)" jump (Set to Error)
0467   62E4 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0468   62E6 C9                  RET
0469   62E7 D6 00               SUB     0               ; Division support routine
0470   62E9 6F                  LD      L,A
0471   62EA 7C                  LD      A,H
0472   62EB DE 00               SBC     A,0
0473   62ED 67                  LD      H,A
0474   62EE 78                  LD      A,B
0475   62EF DE 00               SBC     A,0
0476   62F1 47                  LD      B,A
0477   62F2 3E 00               LD      A,0
0478   62F4 C9                  RET
0479   62F5 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0480   62F8 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0481   62FC 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0482   6300 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0483   6304 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0484   6308 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0485   630C 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0486   6310 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0487   6314 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0488   6318 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0489   631C DB 00               IN      A,(0)           ; INP (x) skeleton
0490   631E C9                  RET
0491   631F 01                  .BYTE   1               ; POS (x) number (1)
0492   6320 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0493   6321 1C                  .BYTE   28              ; Width for commas (3 columns)
0494   6322 00                  .BYTE   0               ; No nulls after input bytes
0495   6323 00                  .BYTE   0               ; Output enabled (^O off)
0496   6324 14 00               .WORD   20              ; Initial lines counter
0497   6326 14 00               .WORD   20              ; Initial lines number
0498   6328 00 00               .WORD   0               ; Array load/save check sum
0499   632A 00                  .BYTE   0               ; Break not by NMI
0500   632B 00                  .BYTE   0               ; Break flag
0501   632C C3 F2 65            JP      TTYLIN          ; Input reflection (set to TTY)
0502   632F C3 00 00            JP      $0000           ; POINT reflection unused
0503   6332 C3 00 00            JP      $0000           ; SET reflection
0504   6335 C3 00 00            JP      $0000          	; RESET reflection
0505   6338 5D 91               .WORD   STLOOK          ; Temp string space
0506   633A FE FF               .WORD   -2              ; Current line number (cold)
0507   633C FA 90               .WORD   PROGST+1        ; Start of program text
0508   633E             INITBE:                         
0509   633E             
0510   633E             ; END OF INITIALISATION TABLE ---------------------------------------------------
0511   633E             
0512   633E 204572726F72ERRMSG: .BYTE   " Error",0
0512   6344 00
0513   6345 20696E2000  INMSG:  .BYTE   " in ",0
0514   634A             ZERBYT  .EQU    $-1             ; A zero byte
0515   634A 4F6B0D0A0000OKMSG:  .BYTE   "Ok",CR,LF,0,0
0516   6350 427265616B00BRKMSG: .BYTE   "Break",0
0517   6356             
0518   6356 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0519   6359 39                  ADD     HL,SP           ; same index as specified
0520   635A 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0521   635B 23                  INC     HL              ; Point to index address
0522   635C FE 81               CP      ZFOR            ; Is it a "FOR" token
0523   635E C0                  RET     NZ              ; No - exit
0524   635F 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0525   6360 23                  INC     HL
0526   6361 46                  LD      B,(HL)
0527   6362 23                  INC     HL              ; Point to sign of STEP
0528   6363 E5                  PUSH    HL              ; Save pointer to sign
0529   6364 69                  LD      L,C             ; HL = address of "FOR" index
0530   6365 60                  LD      H,B
0531   6366 7A                  LD      A,D             ; See if an index was specified
0532   6367 B3                  OR      E               ; DE = 0 if no index specified
0533   6368 EB                  EX      DE,HL           ; Specified index into HL
0534   6369 CA 70 63            JP      Z,INDFND        ; Skip if no index given
0535   636C EB                  EX      DE,HL           ; Index back into DE
0536   636D CD 75 66            CALL    CPDEHL          ; Compare index with one given
0537   6370 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0538   6373 E1                  POP     HL              ; Restore pointer to sign
0539   6374 C8                  RET     Z               ; Return if block found
0540   6375 09                  ADD     HL,BC           ; Point to next block
0541   6376 C3 5A 63            JP      LOKFOR          ; Keep on looking
0542   6379             
0543   6379 CD 93 63    MOVUP:  CALL    ENFMEM          ; See if enough memory
0544   637C C5          MOVSTR: PUSH    BC              ; Save end of source
0545   637D E3                  EX      (SP),HL         ; Swap source and dest" end
0546   637E C1                  POP     BC              ; Get end of destination
0547   637F CD 75 66    MOVLP:  CALL    CPDEHL          ; See if list moved
0548   6382 7E                  LD      A,(HL)          ; Get byte
0549   6383 02                  LD      (BC),A          ; Move it
0550   6384 C8                  RET     Z               ; Exit if all done
0551   6385 0B                  DEC     BC              ; Next byte to move to
0552   6386 2B                  DEC     HL              ; Next byte to move
0553   6387 C3 7F 63            JP      MOVLP           ; Loop until all bytes moved
0554   638A             
0555   638A E5          CHKSTK: PUSH    HL              ; Save code string address
0556   638B 2A DA 90            LD      HL,(ARREND)     ; Lowest free memory
0557   638E 06 00               LD      B,0             ; BC = Number of levels to test
0558   6390 09                  ADD     HL,BC           ; 2 Bytes for each level
0559   6391 09                  ADD     HL,BC
0560   6392 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0561   6393 E5          ENFMEM: PUSH    HL              ; Save code string address
0562   6394 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0563   6396 95                  SUB     L
0564   6397 6F                  LD      L,A
0565   6398 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0566   639A 9C                  SBC     A,H
0567   639B DA A2 63            JP      C,OMERR         ; Not enough - ?OM Error
0568   639E 67                  LD      H,A
0569   639F 39                  ADD     HL,SP           ; Test if stack is overflowed
0570   63A0 E1                  POP     HL              ; Restore code string address
0571   63A1 D8                  RET     C               ; Return if enough mmory
0572   63A2 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0573   63A4 C3 C1 63            JP      ERROR
0574   63A7             
0575   63A7 2A C9 90    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0576   63AA 22 5C 90            LD      (LINEAT),HL     ; Save as current line
0577   63AD 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0578   63AF 01                  .BYTE   01H             ; Skip "LD E,DZ"
0579   63B0 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0580   63B2 01                  .BYTE   01H             ; Skip "LD E,NF"
0581   63B3 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0582   63B5 01                  .BYTE   01H             ; Skip "LD E,DD"
0583   63B6 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0584   63B8 01                  .BYTE   01H             ; Skip "LD E,UF"
0585   63B9 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0586   63BB 01                  .BYTE   01H             ; Skip "LD E,OV
0587   63BC 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0588   63BE 01                  .BYTE   01H             ; Skip "LD E,TM"
0589   63BF 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0590   63C1             
0591   63C1             ERROR:  
0592   63C1 CD DF 64            CALL    CLREG           ; Clear registers and stack
0593   63C4 32 45 90            LD      (CTLOFG),A      ; Enable output (A is 0)
0594   63C7 CD A0 6A            CALL    STTLIN          ; Start new line
0595   63CA 21 B4 62            LD      HL,ERRORS       ; Point to error codes
0596   63CD 57                  LD      D,A             ; D = 0 (A is 0)
0597   63CE 3E 3F               LD      A,'?'
0598   63D0 CD 86 66            CALL    OUTC            ; Output '?'
0599   63D3 19                  ADD     HL,DE           ; Offset to correct error code
0600   63D4 7E                  LD      A,(HL)          ; First character
0601   63D5 CD 86 66            CALL    OUTC            ; Output it
0602   63D8 CD 05 68            CALL    GETCHR          ; Get next character
0603   63DB CD 86 66            CALL    OUTC            ; Output it
0604   63DE 21 3E 63            LD      HL,ERRMSG       ; "Error" message
0605   63E1 CD 4B 71    ERRIN:  CALL    PRS             ; Output message
0606   63E4 2A 5C 90            LD      HL,(LINEAT)     ; Get line of error
0607   63E7 11 FE FF            LD      DE,-2           ; Cold start error if -2
0608   63EA CD 75 66            CALL    CPDEHL          ; See if cold start error
0609   63ED CA 11 60            JP      Z,CSTART        ; Cold start error - Restart
0610   63F0 7C                  LD      A,H             ; Was it a direct error?
0611   63F1 A5                  AND     L               ; Line = -1 if direct error
0612   63F2 3C                  INC     A
0613   63F3 C4 E6 77            CALL    NZ,LINEIN       ; No - output line of error
0614   63F6 3E                  .BYTE   3EH             ; Skip "POP BC"
0615   63F7 C1          POPNOK: POP     BC              ; Drop address in input buffer
0616   63F8             
0617   63F8             PRNTOK: 
0618   63F8 AF                  XOR     A               ; Output "Ok" and get command
0619   63F9 32 45 90            LD      (CTLOFG),A      ; Enable output
0620   63FC CD A0 6A            CALL    STTLIN          ; Start new line
0621   63FF 21 4A 63            LD      HL,OKMSG        ; "Ok" message
0622   6402 CD 4B 71            CALL    PRS             ; Output "Ok"
0623   6405 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0624   6408 22 5C 90            LD      (LINEAT),HL     ; Save as current line
0625   640B CD F2 65            CALL    GETLIN          ; Get an input line
0626   640E DA 05 64            JP      C,GETCMD        ; Get line again if break
0627   6411 CD 05 68            CALL    GETCHR          ; Get first character
0628   6414 3C                  INC     A               ; Test if end of line
0629   6415 3D                  DEC     A               ; Without affecting Carry
0630   6416 CA 05 64            JP      Z,GETCMD        ; Nothing entered - Get another
0631   6419 F5                  PUSH    AF              ; Save Carry status
0632   641A CD D1 68            CALL    ATOH            ; Get line number into DE
0633   641D D5                  PUSH    DE              ; Save line number
0634   641E CD 09 65            CALL    CRUNCH          ; Tokenise rest of line
0635   6421 47                  LD      B,A             ; Length of tokenised line
0636   6422 D1                  POP     DE              ; Restore line number
0637   6423 F1                  POP     AF              ; Restore Carry
0638   6424 D2 E5 67            JP      NC,EXCUTE       ; No line number - Direct mode
0639   6427 D5                  PUSH    DE              ; Save line number
0640   6428 C5                  PUSH    BC              ; Save length of tokenised line
0641   6429 AF                  XOR     A
0642   642A 32 CC 90            LD      (LSTBIN),A      ; Clear last byte input
0643   642D CD 05 68            CALL    GETCHR          ; Get next character
0644   6430 B7                  OR      A               ; Set flags
0645   6431 F5                  PUSH    AF              ; And save them
0646   6432 CD 99 64            CALL    SRCHLN          ; Search for line number in DE
0647   6435 DA 3E 64            JP      C,LINFND        ; Jump if line found
0648   6438 F1                  POP     AF              ; Get status
0649   6439 F5                  PUSH    AF              ; And re-save
0650   643A CA 72 69            JP      Z,ULERR         ; Nothing after number - Error
0651   643D B7                  OR      A               ; Clear Carry
0652   643E C5          LINFND: PUSH    BC              ; Save address of line in prog
0653   643F D2 55 64            JP      NC,INEWLN       ; Line not found - Insert new
0654   6442 EB                  EX      DE,HL           ; Next line address in DE
0655   6443 2A D6 90            LD      HL,(PROGND)     ; End of program
0656   6446 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0657   6447 02                  LD      (BC),A
0658   6448 03                  INC     BC              ; Next destination
0659   6449 13                  INC     DE              ; Next source
0660   644A CD 75 66            CALL    CPDEHL          ; All done?
0661   644D C2 46 64            JP      NZ,SFTPRG       ; More to do
0662   6450 60                  LD      H,B             ; HL - New end of program
0663   6451 69                  LD      L,C
0664   6452 22 D6 90            LD      (PROGND),HL     ; Update end of program
0665   6455             
0666   6455 D1          INEWLN: POP     DE              ; Get address of line,
0667   6456 F1                  POP     AF              ; Get status
0668   6457 CA 7C 64            JP      Z,SETPTR        ; No text - Set up pointers
0669   645A 2A D6 90            LD      HL,(PROGND)     ; Get end of program
0670   645D E3                  EX      (SP),HL         ; Get length of input line
0671   645E C1                  POP     BC              ; End of program to BC
0672   645F 09                  ADD     HL,BC           ; Find new end
0673   6460 E5                  PUSH    HL              ; Save new end
0674   6461 CD 79 63            CALL    MOVUP           ; Make space for line
0675   6464 E1                  POP     HL              ; Restore new end
0676   6465 22 D6 90            LD      (PROGND),HL     ; Update end of program pointer
0677   6468 EB                  EX      DE,HL           ; Get line to move up in HL
0678   6469 74                  LD      (HL),H          ; Save MSB
0679   646A D1                  POP     DE              ; Get new line number
0680   646B 23                  INC     HL              ; Skip pointer
0681   646C 23                  INC     HL
0682   646D 73                  LD      (HL),E          ; Save LSB of line number
0683   646E 23                  INC     HL
0684   646F 72                  LD      (HL),D          ; Save MSB of line number
0685   6470 23                  INC     HL              ; To first byte in line
0686   6471 11 61 90            LD      DE,BUFFER       ; Copy buffer to program
0687   6474 1A          MOVBUF: LD      A,(DE)          ; Get source
0688   6475 77                  LD      (HL),A          ; Save destinations
0689   6476 23                  INC     HL              ; Next source
0690   6477 13                  INC     DE              ; Next destination
0691   6478 B7                  OR      A               ; Done?
0692   6479 C2 74 64            JP      NZ,MOVBUF       ; No - Repeat
0693   647C CD C5 64    SETPTR: CALL    RUNFST          ; Set line pointers
0694   647F 23                  INC     HL              ; To LSB of pointer
0695   6480 EB                  EX      DE,HL           ; Address to DE
0696   6481 62          PTRLP:  LD      H,D             ; Address to HL
0697   6482 6B                  LD      L,E
0698   6483 7E                  LD      A,(HL)          ; Get LSB of pointer
0699   6484 23                  INC     HL              ; To MSB of pointer
0700   6485 B6                  OR      (HL)            ; Compare with MSB pointer
0701   6486 CA 05 64            JP      Z,GETCMD        ; Get command line if end
0702   6489 23                  INC     HL              ; To LSB of line number
0703   648A 23                  INC     HL              ; Skip line number
0704   648B 23                  INC     HL              ; Point to first byte in line
0705   648C AF                  XOR     A               ; Looking for 00 byte
0706   648D BE          FNDEND: CP      (HL)            ; Found end of line?
0707   648E 23                  INC     HL              ; Move to next byte
0708   648F C2 8D 64            JP      NZ,FNDEND       ; No - Keep looking
0709   6492 EB                  EX      DE,HL           ; Next line address to HL
0710   6493 73                  LD      (HL),E          ; Save LSB of pointer
0711   6494 23                  INC     HL
0712   6495 72                  LD      (HL),D          ; Save MSB of pointer
0713   6496 C3 81 64            JP      PTRLP           ; Do next line
0714   6499             
0715   6499 2A 5E 90    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0716   649C 44          SRCHLP: LD      B,H             ; BC = Address to look at
0717   649D 4D                  LD      C,L
0718   649E 7E                  LD      A,(HL)          ; Get address of next line
0719   649F 23                  INC     HL
0720   64A0 B6                  OR      (HL)            ; End of program found?
0721   64A1 2B                  DEC     HL
0722   64A2 C8                  RET     Z               ; Yes - Line not found
0723   64A3 23                  INC     HL
0724   64A4 23                  INC     HL
0725   64A5 7E                  LD      A,(HL)          ; Get LSB of line number
0726   64A6 23                  INC     HL
0727   64A7 66                  LD      H,(HL)          ; Get MSB of line number
0728   64A8 6F                  LD      L,A
0729   64A9 CD 75 66            CALL    CPDEHL          ; Compare with line in DE
0730   64AC 60                  LD      H,B             ; HL = Start of this line
0731   64AD 69                  LD      L,C
0732   64AE 7E                  LD      A,(HL)          ; Get LSB of next line address
0733   64AF 23                  INC     HL
0734   64B0 66                  LD      H,(HL)          ; Get MSB of next line address
0735   64B1 6F                  LD      L,A             ; Next line to HL
0736   64B2 3F                  CCF
0737   64B3 C8                  RET     Z               ; Lines found - Exit
0738   64B4 3F                  CCF
0739   64B5 D0                  RET     NC              ; Line not found,at line after
0740   64B6 C3 9C 64            JP      SRCHLP          ; Keep looking
0741   64B9             
0742   64B9 C0          NEW:    RET     NZ              ; Return if any more on line
0743   64BA 2A 5E 90    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0744   64BD AF                  XOR     A               ; Set program area to empty
0745   64BE 77                  LD      (HL),A          ; Save LSB = 00
0746   64BF 23                  INC     HL
0747   64C0 77                  LD      (HL),A          ; Save MSB = 00
0748   64C1 23                  INC     HL
0749   64C2 22 D6 90            LD      (PROGND),HL     ; Set program end
0750   64C5             
0751   64C5 2A 5E 90    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0752   64C8 2B                  DEC     HL
0753   64C9             
0754   64C9 22 CE 90    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0755   64CC 2A AF 90            LD      HL,(LSTRAM)     ; Get end of RAM
0756   64CF 22 C3 90            LD      (STRBOT),HL     ; Clear string space
0757   64D2 AF                  XOR     A
0758   64D3 CD 15 68            CALL    RESTOR          ; Reset DATA pointers
0759   64D6 2A D6 90            LD      HL,(PROGND)     ; Get end of program
0760   64D9 22 D8 90            LD      (VAREND),HL     ; Clear variables
0761   64DC 22 DA 90            LD      (ARREND),HL     ; Clear arrays
0762   64DF             
0763   64DF C1          CLREG:  POP     BC              ; Save return address
0764   64E0 2A 5A 90            LD      HL,(STRSPC)     ; Get end of working RAN
0765   64E3 F9                  LD      SP,HL           ; Set stack
0766   64E4 21 B3 90            LD      HL,TMSTPL       ; Temporary string pool
0767   64E7 22 B1 90            LD      (TMSTPT),HL     ; Reset temporary string ptr
0768   64EA AF                  XOR     A               ; A = 00
0769   64EB 6F                  LD      L,A             ; HL = 0000
0770   64EC 67                  LD      H,A
0771   64ED 22 D4 90            LD      (CONTAD),HL     ; No CONTinue
0772   64F0 32 CB 90            LD      (FORFLG),A      ; Clear FOR flag
0773   64F3 22 DE 90            LD      (FNRGNM),HL     ; Clear FN argument
0774   64F6 E5                  PUSH    HL              ; HL = 0000
0775   64F7 C5                  PUSH    BC              ; Put back return
0776   64F8 2A CE 90    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0777   64FB C9                  RET                     ; Return to execution driver
0778   64FC             
0779   64FC 3E 3F       PROMPT: LD      A,'?'           ; '?'
0780   64FE CD 86 66            CALL    OUTC            ; Output character
0781   6501 3E 20               LD      A,' '           ; Space
0782   6503 CD 86 66            CALL    OUTC            ; Output character
0783   6506 C3 4E 90            JP      RINPUT          ; Get input line
0784   6509             
0785   6509 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0786   650A 32 AE 90            LD      (DATFLG),A      ; Reset literal flag
0787   650D 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0788   650F 11 61 90            LD      DE,BUFFER       ; Start of input buffer
0789   6512 7E          CRNCLP: LD      A,(HL)          ; Get byte
0790   6513 FE 20               CP      ' '             ; Is it a space?
0791   6515 CA 91 65            JP      Z,MOVDIR        ; Yes - Copy direct
0792   6518 47                  LD      B,A             ; Save character
0793   6519 FE 22               CP      '"'             ; Is it a quote?
0794   651B CA B1 65            JP      Z,CPYLIT        ; Yes - Copy literal string
0795   651E B7                  OR      A               ; Is it end of buffer?
0796   651F CA B8 65            JP      Z,ENDBUF        ; Yes - End buffer
0797   6522 3A AE 90            LD      A,(DATFLG)      ; Get data type
0798   6525 B7                  OR      A               ; Literal?
0799   6526 7E                  LD      A,(HL)          ; Get byte to copy
0800   6527 C2 91 65            JP      NZ,MOVDIR       ; Literal - Copy direct
0801   652A FE 3F               CP      '?'             ; Is it '?' short for PRINT
0802   652C 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0803   652E CA 91 65            JP      Z,MOVDIR        ; Yes - replace it
0804   6531 7E                  LD      A,(HL)          ; Get byte again
0805   6532 FE 30               CP      '0'             ; Is it less than '0'
0806   6534 DA 3C 65            JP      C,FNDWRD        ; Yes - Look for reserved words
0807   6537 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0808   6539 DA 91 65            JP      C,MOVDIR        ; Yes - copy it direct
0809   653C D5          FNDWRD: PUSH    DE              ; Look for reserved words
0810   653D 11 35 61            LD      DE,WORDS-1      ; Point to table
0811   6540 C5                  PUSH    BC              ; Save count
0812   6541 01 8D 65            LD      BC,RETNAD       ; Where to return to
0813   6544 C5                  PUSH    BC              ; Save return address
0814   6545 06 7F               LD      B,ZEND-1        ; First token value -1
0815   6547 7E                  LD      A,(HL)          ; Get byte
0816   6548 FE 61               CP      'a'             ; Less than 'a' ?
0817   654A DA 55 65            JP      C,SEARCH        ; Yes - search for words
0818   654D FE 7B               CP      'z'+1           ; Greater than 'z' ?
0819   654F D2 55 65            JP      NC,SEARCH       ; Yes - search for words
0820   6552 E6 5F               AND     01011111B       ; Force upper case
0821   6554 77                  LD      (HL),A          ; Replace byte
0822   6555 4E          SEARCH: LD      C,(HL)          ; Search for a word
0823   6556 EB                  EX      DE,HL
0824   6557 23          GETNXT: INC     HL              ; Get next reserved word
0825   6558 B6                  OR      (HL)            ; Start of word?
0826   6559 F2 57 65            JP      P,GETNXT        ; No - move on
0827   655C 04                  INC     B               ; Increment token value
0828   655D 7E                  LD      A, (HL)         ; Get byte from table
0829   655E E6 7F               AND     01111111B       ; Strip bit 7
0830   6560 C8                  RET     Z               ; Return if end of list
0831   6561 B9                  CP      C               ; Same character as in buffer?
0832   6562 C2 57 65            JP      NZ,GETNXT       ; No - get next word
0833   6565 EB                  EX      DE,HL
0834   6566 E5                  PUSH    HL              ; Save start of word
0835   6567             
0836   6567 13          NXTBYT: INC     DE              ; Look through rest of word
0837   6568 1A                  LD      A,(DE)          ; Get byte from table
0838   6569 B7                  OR      A               ; End of word ?
0839   656A FA 89 65            JP      M,MATCH         ; Yes - Match found
0840   656D 4F                  LD      C,A             ; Save it
0841   656E 78                  LD      A,B             ; Get token value
0842   656F FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0843   6571 C2 78 65            JP      NZ,NOSPC        ; No - Don't allow spaces
0844   6574 CD 05 68            CALL    GETCHR          ; Get next character
0845   6577 2B                  DEC     HL              ; Cancel increment from GETCHR
0846   6578 23          NOSPC:  INC     HL              ; Next byte
0847   6579 7E                  LD      A,(HL)          ; Get byte
0848   657A FE 61               CP      'a'             ; Less than 'a' ?
0849   657C DA 81 65            JP      C,NOCHNG        ; Yes - don't change
0850   657F E6 5F               AND     01011111B       ; Make upper case
0851   6581 B9          NOCHNG: CP      C               ; Same as in buffer ?
0852   6582 CA 67 65            JP      Z,NXTBYT        ; Yes - keep testing
0853   6585 E1                  POP     HL              ; Get back start of word
0854   6586 C3 55 65            JP      SEARCH          ; Look at next word
0855   6589             
0856   6589 48          MATCH:  LD      C,B             ; Word found - Save token value
0857   658A F1                  POP     AF              ; Throw away return
0858   658B EB                  EX      DE,HL
0859   658C C9                  RET                     ; Return to "RETNAD"
0860   658D EB          RETNAD: EX      DE,HL           ; Get address in string
0861   658E 79                  LD      A,C             ; Get token value
0862   658F C1                  POP     BC              ; Restore buffer length
0863   6590 D1                  POP     DE              ; Get destination address
0864   6591 23          MOVDIR: INC     HL              ; Next source in buffer
0865   6592 12                  LD      (DE),A          ; Put byte in buffer
0866   6593 13                  INC     DE              ; Move up buffer
0867   6594 0C                  INC     C               ; Increment length of buffer
0868   6595 D6 3A               SUB     ':'             ; End of statement?
0869   6597 CA 9F 65            JP      Z,SETLIT        ; Jump if multi-statement line
0870   659A FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0871   659C C2 A2 65            JP      NZ,TSTREM       ; No - see if REM
0872   659F 32 AE 90    SETLIT: LD      (DATFLG),A      ; Set literal flag
0873   65A2 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0874   65A4 C2 12 65            JP      NZ,CRNCLP       ; No - Leave flag
0875   65A7 47                  LD      B,A             ; Copy rest of buffer
0876   65A8 7E          NXTCHR: LD      A,(HL)          ; Get byte
0877   65A9 B7                  OR      A               ; End of line ?
0878   65AA CA B8 65            JP      Z,ENDBUF        ; Yes - Terminate buffer
0879   65AD B8                  CP      B               ; End of statement ?
0880   65AE CA 91 65            JP      Z,MOVDIR        ; Yes - Get next one
0881   65B1 23          CPYLIT: INC     HL              ; Move up source string
0882   65B2 12                  LD      (DE),A          ; Save in destination
0883   65B3 0C                  INC     C               ; Increment length
0884   65B4 13                  INC     DE              ; Move up destination
0885   65B5 C3 A8 65            JP      NXTCHR          ; Repeat
0886   65B8             
0887   65B8 21 60 90    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0888   65BB 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0889   65BC 13                  INC     DE
0890   65BD 12                  LD      (DE),A          ; A = 00
0891   65BE 13                  INC     DE
0892   65BF 12                  LD      (DE),A          ; A = 00
0893   65C0 C9                  RET
0894   65C1             
0895   65C1 3A 44 90    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0896   65C4 B7                  OR      A               ; Is it zero?
0897   65C5 3E 00               LD      A,0             ; Zero A - Leave flags
0898   65C7 32 44 90            LD      (NULFLG),A      ; Zero null flag
0899   65CA C2 D5 65            JP      NZ,ECHDEL       ; Set - Echo it
0900   65CD 05                  DEC     B               ; Decrement length
0901   65CE CA F2 65            JP      Z,GETLIN        ; Get line again if empty
0902   65D1 CD 86 66            CALL    OUTC            ; Output null character
0903   65D4 3E                  .BYTE   3EH             ; Skip "DEC B"
0904   65D5 05          ECHDEL: DEC     B               ; Count bytes in buffer
0905   65D6 2B                  DEC     HL              ; Back space buffer
0906   65D7 CA E9 65            JP      Z,OTKLN         ; No buffer - Try again
0907   65DA 7E                  LD      A,(HL)          ; Get deleted byte
0908   65DB CD 86 66            CALL    OUTC            ; Echo it
0909   65DE C3 FB 65            JP      MORINP          ; Get more input
0910   65E1             
0911   65E1 05          DELCHR: DEC     B               ; Count bytes in buffer
0912   65E2 2B                  DEC     HL              ; Back space buffer
0913   65E3 CD 86 66            CALL    OUTC            ; Output character in A
0914   65E6 C2 FB 65            JP      NZ,MORINP       ; Not end - Get more
0915   65E9 CD 86 66    OTKLN:  CALL    OUTC            ; Output character in A
0916   65EC CD AD 6A    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0917   65EF C3 F2 65            JP      TTYLIN          ; Get line again
0918   65F2             
0919   65F2             GETLIN:
0920   65F2 21 61 90    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0921   65F5 06 01               LD      B,1             ; Set buffer as empty
0922   65F7 AF                  XOR     A
0923   65F8 32 44 90            LD      (NULFLG),A      ; Clear null flag
0924   65FB CD B0 66    MORINP: CALL    CLOTST          ; Get character and test ^O
0925   65FE 4F                  LD      C,A             ; Save character in C
0926   65FF FE 7F               CP      DEL             ; Delete character?
0927   6601 CA C1 65            JP      Z,DODEL         ; Yes - Process it
0928   6604 3A 44 90            LD      A,(NULFLG)      ; Get null flag
0929   6607 B7                  OR      A               ; Test null flag status
0930   6608 CA 14 66            JP      Z,PROCES        ; Reset - Process character
0931   660B 3E 00               LD      A,0             ; Set a null
0932   660D CD 86 66            CALL    OUTC            ; Output null
0933   6610 AF                  XOR     A               ; Clear A
0934   6611 32 44 90            LD      (NULFLG),A      ; Reset null flag
0935   6614 79          PROCES: LD      A,C             ; Get character
0936   6615 FE 07               CP      CTRLG           ; Bell?
0937   6617 CA 58 66            JP      Z,PUTCTL        ; Yes - Save it
0938   661A FE 03               CP      CTRLC           ; Is it control "C"?
0939   661C CC AD 6A            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0940   661F 37                  SCF                     ; Flag break
0941   6620 C8                  RET     Z               ; Return if control "C"
0942   6621 FE 0D               CP      CR              ; Is it enter?
0943   6623 CA A8 6A            JP      Z,ENDINP        ; Yes - Terminate input
0944   6626 FE 15               CP      CTRLU           ; Is it control "U"?
0945   6628 CA EC 65            JP      Z,KILIN         ; Yes - Get another line
0946   662B FE 40               CP      '@'             ; Is it "kill line"?
0947   662D CA E9 65            JP      Z,OTKLN         ; Yes - Kill line
0948   6630 FE 5F               CP      '_'             ; Is it delete?
0949   6632 CA E1 65            JP      Z,DELCHR        ; Yes - Delete character
0950   6635 FE 08               CP      BKSP            ; Is it backspace?
0951   6637 CA E1 65            JP      Z,DELCHR        ; Yes - Delete character
0952   663A FE 12               CP      CTRLR           ; Is it control "R"?
0953   663C C2 53 66            JP      NZ,PUTBUF       ; No - Put in buffer
0954   663F C5                  PUSH    BC              ; Save buffer length
0955   6640 D5                  PUSH    DE              ; Save DE
0956   6641 E5                  PUSH    HL              ; Save buffer address
0957   6642 36 00               LD      (HL),0          ; Mark end of buffer
0958   6644 CD 5D 7C            CALL    OUTNCR          ; Output and do CRLF
0959   6647 21 61 90            LD      HL,BUFFER       ; Point to buffer start
0960   664A CD 4B 71            CALL    PRS             ; Output buffer
0961   664D E1                  POP     HL              ; Restore buffer address
0962   664E D1                  POP     DE              ; Restore DE
0963   664F C1                  POP     BC              ; Restore buffer length
0964   6650 C3 FB 65            JP      MORINP          ; Get another character
0965   6653             
0966   6653 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0967   6655 DA FB 65            JP      C,MORINP        ; Yes - Ignore
0968   6658 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0969   6659 FE 49               CP      72+1            ; Test for line overflow
0970   665B 3E 07               LD      A,CTRLG         ; Set a bell
0971   665D D2 6D 66            JP      NC,OUTNBS       ; Ring bell if buffer full
0972   6660 79                  LD      A,C             ; Get character
0973   6661 71                  LD      (HL),C          ; Save in buffer
0974   6662 32 CC 90            LD      (LSTBIN),A      ; Save last input byte
0975   6665 23                  INC     HL              ; Move up buffer
0976   6666 04                  INC     B               ; Increment length
0977   6667 CD 86 66    OUTIT:  CALL    OUTC            ; Output the character entered
0978   666A C3 FB 65            JP      MORINP          ; Get another character
0979   666D             
0980   666D CD 86 66    OUTNBS: CALL    OUTC            ; Output bell and back over it
0981   6670 3E 08               LD      A,BKSP          ; Set back space
0982   6672 C3 67 66            JP      OUTIT           ; Output it and get more
0983   6675             
0984   6675 7C          CPDEHL: LD      A,H             ; Get H
0985   6676 92                  SUB     D               ; Compare with D
0986   6677 C0                  RET     NZ              ; Different - Exit
0987   6678 7D                  LD      A,L             ; Get L
0988   6679 93                  SUB     E               ; Compare with E
0989   667A C9                  RET                     ; Return status
0990   667B             
0991   667B 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0992   667C E3                  EX      (SP),HL         ; Address of test byte
0993   667D BE                  CP      (HL)            ; Same as in code string?
0994   667E 23                  INC     HL              ; Return address
0995   667F E3                  EX      (SP),HL         ; Put it back
0996   6680 CA 05 68            JP      Z,GETCHR        ; Yes - Get next character
0997   6683 C3 AD 63            JP      SNERR           ; Different - ?SN Error
0998   6686             
0999   6686 F5          OUTC:   PUSH    AF              ; Save character
1000   6687 3A 45 90            LD      A,(CTLOFG)      ; Get control "O" flag
1001   668A B7                  OR      A               ; Is it set?
1002   668B C2 80 71            JP      NZ,POPAF        ; Yes - don't output
1003   668E F1                  POP     AF              ; Restore character
1004   668F C5                  PUSH    BC              ; Save buffer length
1005   6690 F5                  PUSH    AF              ; Save character
1006   6691 FE 20               CP      ' '             ; Is it a control code?
1007   6693 DA AA 66            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1008   6696 3A 42 90            LD      A,(LWIDTH)      ; Get line width
1009   6699 47                  LD      B,A             ; To B
1010   669A 3A AB 90            LD      A,(CURPOS)      ; Get cursor position
1011   669D 04                  INC     B               ; Width 255?
1012   669E CA A6 66            JP      Z,INCLEN        ; Yes - No width limit
1013   66A1 05                  DEC     B               ; Restore width
1014   66A2 B8                  CP      B               ; At end of line?
1015   66A3 CC AD 6A            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1016   66A6 3C          INCLEN: INC     A               ; Move on one character
1017   66A7 32 AB 90            LD      (CURPOS),A      ; Save new position
1018   66AA F1          DINPOS: POP     AF              ; Restore character
1019   66AB C1                  POP     BC              ; Restore buffer length
1020   66AC CD 46 7C            CALL    MONOUT          ; Send it
1021   66AF C9                  RET
1022   66B0             
1023   66B0 CD 0A 7B    CLOTST: CALL    GETINP          ; Get input character
1024   66B3 E6 7F               AND     01111111B       ; Strip bit 7
1025   66B5 FE 0F               CP      CTRLO           ; Is it control "O"?
1026   66B7 C0                  RET     NZ              ; No don't flip flag
1027   66B8 3A 45 90            LD      A,(CTLOFG)      ; Get flag
1028   66BB 2F                  CPL                     ; Flip it
1029   66BC 32 45 90            LD      (CTLOFG),A      ; Put it back
1030   66BF AF                  XOR     A               ; Null character
1031   66C0 C9                  RET
1032   66C1             
1033   66C1 CD D1 68    LIST:   CALL    ATOH            ; ASCII number to DE
1034   66C4 C0                  RET     NZ              ; Return if anything extra
1035   66C5 C1                  POP     BC              ; Rubbish - Not needed
1036   66C6 CD 99 64            CALL    SRCHLN          ; Search for line number in DE
1037   66C9 C5                  PUSH    BC              ; Save address of line
1038   66CA CD 17 67            CALL    SETLIN          ; Set up lines counter
1039   66CD E1          LISTLP: POP     HL              ; Restore address of line
1040   66CE 4E                  LD      C,(HL)          ; Get LSB of next line
1041   66CF 23                  INC     HL
1042   66D0 46                  LD      B,(HL)          ; Get MSB of next line
1043   66D1 23                  INC     HL
1044   66D2 78                  LD      A,B             ; BC = 0 (End of program)?
1045   66D3 B1                  OR      C
1046   66D4 CA F8 63            JP      Z,PRNTOK        ; Yes - Go to command mode
1047   66D7 CD 20 67            CALL    COUNT           ; Count lines
1048   66DA CD 30 68            CALL    TSTBRK          ; Test for break key
1049   66DD C5                  PUSH    BC              ; Save address of next line
1050   66DE CD AD 6A            CALL    PRNTCRLF        ; Output CRLF
1051   66E1 5E                  LD      E,(HL)          ; Get LSB of line number
1052   66E2 23                  INC     HL
1053   66E3 56                  LD      D,(HL)          ; Get MSB of line number
1054   66E4 23                  INC     HL
1055   66E5 E5                  PUSH    HL              ; Save address of line start
1056   66E6 EB                  EX      DE,HL           ; Line number to HL
1057   66E7 CD EE 77            CALL    PRNTHL          ; Output line number in decimal
1058   66EA 3E 20               LD      A,' '           ; Space after line number
1059   66EC E1                  POP     HL              ; Restore start of line address
1060   66ED CD 86 66    LSTLP2: CALL    OUTC            ; Output character in A
1061   66F0 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1062   66F1 B7                  OR      A               ; End of line?
1063   66F2 23                  INC     HL              ; To next byte in line
1064   66F3 CA CD 66            JP      Z,LISTLP        ; Yes - get next line
1065   66F6 F2 ED 66            JP      P,LSTLP2        ; No token - output it
1066   66F9 D6 7F               SUB     ZEND-1          ; Find and output word
1067   66FB 4F                  LD      C,A             ; Token offset+1 to C
1068   66FC 11 36 61            LD      DE,WORDS        ; Reserved word list
1069   66FF 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1070   6700 13                  INC     DE              ; Move on to next
1071   6701 B7                  OR      A               ; Is it start of word?
1072   6702 F2 FF 66            JP      P,FNDTOK        ; No - Keep looking for word
1073   6705 0D                  DEC     C               ; Count words
1074   6706 C2 FF 66            JP      NZ,FNDTOK       ; Not there - keep looking
1075   6709 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1076   670B CD 86 66            CALL    OUTC            ; Output first character
1077   670E 1A                  LD      A,(DE)          ; Get next character
1078   670F 13                  INC     DE              ; Move on to next
1079   6710 B7                  OR      A               ; Is it end of word?
1080   6711 F2 09 67            JP      P,OUTWRD        ; No - output the rest
1081   6714 C3 F0 66            JP      LSTLP3          ; Next byte in line
1082   6717             
1083   6717 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1084   6718 2A 48 90            LD      HL,(LINESN)     ; Get LINES number
1085   671B 22 46 90            LD      (LINESC),HL     ; Save in LINES counter
1086   671E E1                  POP     HL
1087   671F C9                  RET
1088   6720             
1089   6720 E5          COUNT:  PUSH    HL              ; Save code string address
1090   6721 D5                  PUSH    DE
1091   6722 2A 46 90            LD      HL,(LINESC)     ; Get LINES counter
1092   6725 11 FF FF            LD      DE,-1
1093   6728 ED 5A               ADC     HL,DE           ; Decrement
1094   672A 22 46 90            LD      (LINESC),HL     ; Put it back
1095   672D D1                  POP     DE
1096   672E E1                  POP     HL              ; Restore code string address
1097   672F F0                  RET     P               ; Return if more lines to go
1098   6730 E5                  PUSH    HL              ; Save code string address
1099   6731 2A 48 90            LD      HL,(LINESN)     ; Get LINES number
1100   6734 22 46 90            LD      (LINESC),HL     ; Reset LINES counter
1101   6737 CD 0A 7B            CALL    GETINP          ; Get input character
1102   673A FE 03               CP      CTRLC           ; Is it control "C"?
1103   673C CA 43 67            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1104   673F E1                  POP     HL              ; Restore code string address
1105   6740 C3 20 67            JP      COUNT           ; Keep on counting
1106   6743             
1107   6743 2A 48 90    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1108   6746 22 46 90            LD      (LINESC),HL     ; Reset LINES counter
1109   6749 C3 A7 60            JP      BRKRET          ; Go and output "Break"
1110   674C             
1111   674C 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1112   674E 32 CB 90            LD      (FORFLG),A      ; Save "FOR" flag
1113   6751 CD B3 69            CALL    LET             ; Set up initial index
1114   6754 C1                  POP     BC              ; Drop RETurn address
1115   6755 E5                  PUSH    HL              ; Save code string address
1116   6756 CD 9C 69            CALL    DATA            ; Get next statement address
1117   6759 22 C7 90            LD      (LOOPST),HL     ; Save it for start of loop
1118   675C 21 02 00            LD      HL,2            ; Offset for "FOR" block
1119   675F 39                  ADD     HL,SP           ; Point to it
1120   6760 CD 5A 63    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1121   6763 D1                  POP     DE              ; Get code string address
1122   6764 C2 7C 67            JP      NZ,FORFND       ; No nesting found
1123   6767 09                  ADD     HL,BC           ; Move into "FOR" block
1124   6768 D5                  PUSH    DE              ; Save code string address
1125   6769 2B                  DEC     HL
1126   676A 56                  LD      D,(HL)          ; Get MSB of loop statement
1127   676B 2B                  DEC     HL
1128   676C 5E                  LD      E,(HL)          ; Get LSB of loop statement
1129   676D 23                  INC     HL
1130   676E 23                  INC     HL
1131   676F E5                  PUSH    HL              ; Save block address
1132   6770 2A C7 90            LD      HL,(LOOPST)     ; Get address of loop statement
1133   6773 CD 75 66            CALL    CPDEHL          ; Compare the FOR loops
1134   6776 E1                  POP     HL              ; Restore block address
1135   6777 C2 60 67            JP      NZ,FORSLP       ; Different FORs - Find another
1136   677A D1                  POP     DE              ; Restore code string address
1137   677B F9                  LD      SP,HL           ; Remove all nested loops
1138   677C             
1139   677C EB          FORFND: EX      DE,HL           ; Code string address to HL
1140   677D 0E 08               LD      C,8
1141   677F CD 8A 63            CALL    CHKSTK          ; Check for 8 levels of stack
1142   6782 E5                  PUSH    HL              ; Save code string address
1143   6783 2A C7 90            LD      HL,(LOOPST)     ; Get first statement of loop
1144   6786 E3                  EX      (SP),HL         ; Save and restore code string
1145   6787 E5                  PUSH    HL              ; Re-save code string address
1146   6788 2A 5C 90            LD      HL,(LINEAT)     ; Get current line number
1147   678B E3                  EX      (SP),HL         ; Save and restore code string
1148   678C CD 75 6C            CALL    TSTNUM          ; Make sure it's a number
1149   678F CD 7B 66            CALL    CHKSYN          ; Make sure "TO" is next
1150   6792 A6                  .BYTE   ZTO          ; "TO" token
1151   6793 CD 72 6C            CALL    GETNUM          ; Get "TO" expression value
1152   6796 E5                  PUSH    HL              ; Save code string address
1153   6797 CD A0 76            CALL    BCDEFP          ; Move "TO" value to BCDE
1154   679A E1                  POP     HL              ; Restore code string address
1155   679B C5                  PUSH    BC              ; Save "TO" value in block
1156   679C D5                  PUSH    DE
1157   679D 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1158   67A0 51                  LD      D,C             ; C=0
1159   67A1 5A                  LD      E,D             ; D=0
1160   67A2 7E                  LD      A,(HL)          ; Get next byte in code string
1161   67A3 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1162   67A5 3E 01               LD      A,1             ; Sign of step = 1
1163   67A7 C2 B8 67            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1164   67AA CD 05 68            CALL    GETCHR          ; Jump over "STEP" token
1165   67AD CD 72 6C            CALL    GETNUM          ; Get step value
1166   67B0 E5                  PUSH    HL              ; Save code string address
1167   67B1 CD A0 76            CALL    BCDEFP          ; Move STEP to BCDE
1168   67B4 CD 54 76            CALL    TSTSGN          ; Test sign of FPREG
1169   67B7 E1                  POP     HL              ; Restore code string address
1170   67B8 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1171   67B9 D5                  PUSH    DE
1172   67BA F5                  PUSH    AF              ; Save sign of STEP
1173   67BB 33                  INC     SP              ; Don't save flags
1174   67BC E5                  PUSH    HL              ; Save code string address
1175   67BD 2A CE 90            LD      HL,(BRKLIN)     ; Get address of index variable
1176   67C0 E3                  EX      (SP),HL         ; Save and restore code string
1177   67C1 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1178   67C3 C5                  PUSH    BC              ; Save it
1179   67C4 33                  INC     SP              ; Don't save C
1180   67C5             
1181   67C5 CD 30 68    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1182   67C8 22 CE 90            LD      (BRKLIN),HL     ; Save code address for break
1183   67CB 7E                  LD      A,(HL)          ; Get next byte in code string
1184   67CC FE 3A               CP      ':'             ; Multi statement line?
1185   67CE CA E5 67            JP      Z,EXCUTE        ; Yes - Execute it
1186   67D1 B7                  OR      A               ; End of line?
1187   67D2 C2 AD 63            JP      NZ,SNERR        ; No - Syntax error
1188   67D5 23                  INC     HL              ; Point to address of next line
1189   67D6 7E                  LD      A,(HL)          ; Get LSB of line pointer
1190   67D7 23                  INC     HL
1191   67D8 B6                  OR      (HL)            ; Is it zero (End of prog)?
1192   67D9 CA 57 68            JP      Z,ENDPRG        ; Yes - Terminate execution
1193   67DC 23                  INC     HL              ; Point to line number
1194   67DD 5E                  LD      E,(HL)          ; Get LSB of line number
1195   67DE 23                  INC     HL
1196   67DF 56                  LD      D,(HL)          ; Get MSB of line number
1197   67E0 EB                  EX      DE,HL           ; Line number to HL
1198   67E1 22 5C 90            LD      (LINEAT),HL     ; Save as current line number
1199   67E4 EB                  EX      DE,HL           ; Line number back to DE
1200   67E5 CD 05 68    EXCUTE: CALL    GETCHR          ; Get key word
1201   67E8 11 C5 67            LD      DE,RUNCNT       ; Where to RETurn to
1202   67EB D5                  PUSH    DE              ; Save for RETurn
1203   67EC C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1204   67ED D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1205   67EF DA B3 69            JP      C,LET           ; No - try to assign it
1206   67F2 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1207   67F4 D2 AD 63            JP      NC,SNERR        ; Not a key word - ?SN Error
1208   67F7 07                  RLCA                    ; Double it
1209   67F8 4F                  LD      C,A             ; BC = Offset into table
1210   67F9 06 00               LD      B,0
1211   67FB EB                  EX      DE,HL           ; Save code string address
1212   67FC 21 55 62            LD      HL,WORDTB       ; Keyword address table
1213   67FF 09                  ADD     HL,BC           ; Point to routine address
1214   6800 4E                  LD      C,(HL)          ; Get LSB of routine address
1215   6801 23                  INC     HL
1216   6802 46                  LD      B,(HL)          ; Get MSB of routine address
1217   6803 C5                  PUSH    BC              ; Save routine address
1218   6804 EB                  EX      DE,HL           ; Restore code string address
1219   6805             
1220   6805 23          GETCHR: INC     HL              ; Point to next character
1221   6806 7E                  LD      A,(HL)          ; Get next code string byte
1222   6807 FE 3A               CP      ':'             ; Z if ':'
1223   6809 D0                  RET     NC              ; NC if > "9"
1224   680A FE 20               CP      ' '
1225   680C CA 05 68            JP      Z,GETCHR        ; Skip over spaces
1226   680F FE 30               CP      '0'
1227   6811 3F                  CCF                     ; NC if < '0'
1228   6812 3C                  INC     A               ; Test for zero - Leave carry
1229   6813 3D                  DEC     A               ; Z if Null
1230   6814 C9                  RET
1231   6815             
1232   6815 EB          RESTOR: EX      DE,HL           ; Save code string address
1233   6816 2A 5E 90            LD      HL,(BASTXT)     ; Point to start of program
1234   6819 CA 2A 68            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1235   681C EB                  EX      DE,HL           ; Restore code string address
1236   681D CD D1 68            CALL    ATOH            ; Get line number to DE
1237   6820 E5                  PUSH    HL              ; Save code string address
1238   6821 CD 99 64            CALL    SRCHLN          ; Search for line number in DE
1239   6824 60                  LD      H,B             ; HL = Address of line
1240   6825 69                  LD      L,C
1241   6826 D1                  POP     DE              ; Restore code string address
1242   6827 D2 72 69            JP      NC,ULERR        ; ?UL Error if not found
1243   682A 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1244   682B 22 DC 90    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1245   682E EB                  EX      DE,HL           ; Restore code string address
1246   682F C9                  RET
1247   6830             
1248   6830             
1249   6830 DF          TSTBRK: RST     18H             ; Check input status
1250   6831 C8                  RET     Z               ; No key, go back
1251   6832 D7                  RST     10H             ; Get the key into A
1252   6833 FE 1B               CP      ESC             ; Escape key?
1253   6835 28 11               JR      Z,BRK           ; Yes, break
1254   6837 FE 03               CP      CTRLC           ; <Ctrl-C>
1255   6839 28 0D               JR      Z,BRK           ; Yes, break
1256   683B FE 13               CP      CTRLS           ; Stop scrolling?
1257   683D C0                  RET     NZ              ; Other key, ignore
1258   683E             
1259   683E             
1260   683E D7          STALL:  RST     10H             ; Wait for key
1261   683F FE 11               CP      CTRLQ           ; Resume scrolling?
1262   6841 C8                  RET      Z              ; Release the chokehold
1263   6842 FE 03               CP      CTRLC           ; Second break?
1264   6844 28 07               JR      Z,STOP          ; Break during hold exits prog
1265   6846 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1266   6848             
1267   6848 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1268   684A 32 4D 90            LD      (BRKFLG),A      ; Store it
1269   684D             
1270   684D             
1271   684D C0          STOP:   RET     NZ              ; Exit if anything else
1272   684E F6                  .BYTE   0F6H            ; Flag "STOP"
1273   684F C0          PEND:   RET     NZ              ; Exit if anything else
1274   6850 22 CE 90            LD      (BRKLIN),HL     ; Save point of break
1275   6853 21                  .BYTE   21H             ; Skip "OR 11111111B"
1276   6854 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1277   6856 C1                  POP     BC              ; Return not needed and more
1278   6857 2A 5C 90    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1279   685A F5                  PUSH    AF              ; Save STOP / END status
1280   685B 7D                  LD      A,L             ; Is it direct break?
1281   685C A4                  AND     H
1282   685D 3C                  INC     A               ; Line is -1 if direct break
1283   685E CA 6A 68            JP      Z,NOLIN         ; Yes - No line number
1284   6861 22 D2 90            LD      (ERRLIN),HL     ; Save line of break
1285   6864 2A CE 90            LD      HL,(BRKLIN)     ; Get point of break
1286   6867 22 D4 90            LD      (CONTAD),HL     ; Save point to CONTinue
1287   686A AF          NOLIN:  XOR     A
1288   686B 32 45 90            LD      (CTLOFG),A      ; Enable output
1289   686E CD A0 6A            CALL    STTLIN          ; Start a new line
1290   6871 F1                  POP     AF              ; Restore STOP / END status
1291   6872 21 50 63            LD      HL,BRKMSG       ; "Break" message
1292   6875 C2 E1 63            JP      NZ,ERRIN        ; "in line" wanted?
1293   6878 C3 F8 63            JP      PRNTOK          ; Go to command mode
1294   687B             
1295   687B 2A D4 90    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1296   687E 7C                  LD      A,H             ; Is it zero?
1297   687F B5                  OR      L
1298   6880 1E 20               LD      E,CN            ; ?CN Error
1299   6882 CA C1 63            JP      Z,ERROR         ; Yes - output "?CN Error"
1300   6885 EB                  EX      DE,HL           ; Save code string address
1301   6886 2A D2 90            LD      HL,(ERRLIN)     ; Get line of last break
1302   6889 22 5C 90            LD      (LINEAT),HL     ; Set up current line number
1303   688C EB                  EX      DE,HL           ; Restore code string address
1304   688D C9                  RET                     ; CONTinue where left off
1305   688E             
1306   688E CD D3 73    NULL:   CALL    GETINT          ; Get integer 0-255
1307   6891 C0                  RET     NZ              ; Return if bad value
1308   6892 32 41 90            LD      (NULLS),A       ; Set nulls number
1309   6895 C9                  RET
1310   6896             
1311   6896             
1312   6896 E5          ACCSUM: PUSH    HL              ; Save address in array
1313   6897 2A 4A 90            LD      HL,(CHKSUM)     ; Get check sum
1314   689A 06 00               LD      B,0             ; BC - Value of byte
1315   689C 4F                  LD      C,A
1316   689D 09                  ADD     HL,BC           ; Add byte to check sum
1317   689E 22 4A 90            LD      (CHKSUM),HL     ; Re-save check sum
1318   68A1 E1                  POP     HL              ; Restore address in array
1319   68A2 C9                  RET
1320   68A3             
1321   68A3 7E          CHKLTR: LD      A,(HL)          ; Get byte
1322   68A4 FE 41               CP      'A'             ; < 'a' ?
1323   68A6 D8                  RET     C               ; Carry set if not letter
1324   68A7 FE 5B               CP      'Z'+1           ; > 'z' ?
1325   68A9 3F                  CCF
1326   68AA C9                  RET                     ; Carry set if not letter
1327   68AB             
1328   68AB CD 05 68    FPSINT: CALL    GETCHR          ; Get next character
1329   68AE CD 72 6C    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1330   68B1 CD 54 76    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1331   68B4 FA CC 68            JP      M,FCERR         ; Negative - ?FC Error
1332   68B7 3A E7 90    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1333   68BA FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1334   68BC DA FC 76            JP      C,FPINT         ; Yes - convert it
1335   68BF 01 80 90            LD      BC,9080H        ; BCDE = -32768
1336   68C2 11 00 00            LD      DE,0000
1337   68C5 E5                  PUSH    HL              ; Save code string address
1338   68C6 CD CF 76            CALL    CMPNUM          ; Compare FPREG with BCDE
1339   68C9 E1                  POP     HL              ; Restore code string address
1340   68CA 51                  LD      D,C             ; MSB to D
1341   68CB C8                  RET     Z               ; Return if in range
1342   68CC 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1343   68CE C3 C1 63            JP      ERROR           ; Output error-
1344   68D1             
1345   68D1 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1346   68D2 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1347   68D5 CD 05 68    GTLNLP: CALL    GETCHR          ; Get next character
1348   68D8 D0                  RET     NC              ; Exit if not a digit
1349   68D9 E5                  PUSH    HL              ; Save code string address
1350   68DA F5                  PUSH    AF              ; Save digit
1351   68DB 21 98 19            LD      HL,65529/10     ; Largest number 65529
1352   68DE CD 75 66            CALL    CPDEHL          ; Number in range?
1353   68E1 DA AD 63            JP      C,SNERR         ; No - ?SN Error
1354   68E4 62                  LD      H,D             ; HL = Number
1355   68E5 6B                  LD      L,E
1356   68E6 19                  ADD     HL,DE           ; Times 2
1357   68E7 29                  ADD     HL,HL           ; Times 4
1358   68E8 19                  ADD     HL,DE           ; Times 5
1359   68E9 29                  ADD     HL,HL           ; Times 10
1360   68EA F1                  POP     AF              ; Restore digit
1361   68EB D6 30               SUB     '0'             ; Make it 0 to 9
1362   68ED 5F                  LD      E,A             ; DE = Value of digit
1363   68EE 16 00               LD      D,0
1364   68F0 19                  ADD     HL,DE           ; Add to number
1365   68F1 EB                  EX      DE,HL           ; Number to DE
1366   68F2 E1                  POP     HL              ; Restore code string address
1367   68F3 C3 D5 68            JP      GTLNLP          ; Go to next character
1368   68F6             
1369   68F6 CA C9 64    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1370   68F9 CD AE 68            CALL    POSINT          ; Get integer 0 to 32767 to DE
1371   68FC 2B                  DEC     HL              ; Cancel increment
1372   68FD CD 05 68            CALL    GETCHR          ; Get next character
1373   6900 E5                  PUSH    HL              ; Save code string address
1374   6901 2A AF 90            LD      HL,(LSTRAM)     ; Get end of RAM
1375   6904 CA 19 69            JP      Z,STORED        ; No value given - Use stored
1376   6907 E1                  POP     HL              ; Restore code string address
1377   6908 CD 7B 66            CALL    CHKSYN          ; Check for comma
1378   690B 2C                  .BYTE      ','
1379   690C D5                  PUSH    DE              ; Save number
1380   690D CD AE 68            CALL    POSINT          ; Get integer 0 to 32767
1381   6910 2B                  DEC     HL              ; Cancel increment
1382   6911 CD 05 68            CALL    GETCHR          ; Get next character
1383   6914 C2 AD 63            JP      NZ,SNERR        ; ?SN Error if more on line
1384   6917 E3                  EX      (SP),HL         ; Save code string address
1385   6918 EB                  EX      DE,HL           ; Number to DE
1386   6919 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1387   691A 93                  SUB     E               ; Subtract LSB of string space
1388   691B 5F                  LD      E,A             ; Save LSB
1389   691C 7C                  LD      A,H             ; Get MSB of new RAM top
1390   691D 9A                  SBC     A,D             ; Subtract MSB of string space
1391   691E 57                  LD      D,A             ; Save MSB
1392   691F DA A2 63            JP      C,OMERR         ; ?OM Error if not enough mem
1393   6922 E5                  PUSH    HL              ; Save RAM top
1394   6923 2A D6 90            LD      HL,(PROGND)     ; Get program end
1395   6926 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1396   6929 09                  ADD     HL,BC           ; Get lowest address
1397   692A CD 75 66            CALL    CPDEHL          ; Enough memory?
1398   692D D2 A2 63            JP      NC,OMERR        ; No - ?OM Error
1399   6930 EB                  EX      DE,HL           ; RAM top to HL
1400   6931 22 5A 90            LD      (STRSPC),HL     ; Set new string space
1401   6934 E1                  POP     HL              ; End of memory to use
1402   6935 22 AF 90            LD      (LSTRAM),HL     ; Set new top of RAM
1403   6938 E1                  POP     HL              ; Restore code string address
1404   6939 C3 C9 64            JP      INTVAR          ; Initialise variables
1405   693C             
1406   693C CA C5 64    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1407   693F CD C9 64            CALL    INTVAR          ; Initialise variables
1408   6942 01 C5 67            LD      BC,RUNCNT       ; Execution driver loop
1409   6945 C3 58 69            JP      RUNLIN          ; RUN from line number
1410   6948             
1411   6948 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1412   694A CD 8A 63            CALL    CHKSTK          ; Check for 3 levels of stack
1413   694D C1                  POP     BC              ; Get return address
1414   694E E5                  PUSH    HL              ; Save code string for RETURN
1415   694F E5                  PUSH    HL              ; And for GOSUB routine
1416   6950 2A 5C 90            LD      HL,(LINEAT)     ; Get current line
1417   6953 E3                  EX      (SP),HL         ; Into stack - Code string out
1418   6954 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1419   6956 F5                  PUSH    AF              ; Save token
1420   6957 33                  INC     SP              ; Don't save flags
1421   6958             
1422   6958 C5          RUNLIN: PUSH    BC              ; Save return address
1423   6959 CD D1 68    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1424   695C CD 9E 69            CALL    REM             ; Get end of line
1425   695F E5                  PUSH    HL              ; Save end of line
1426   6960 2A 5C 90            LD      HL,(LINEAT)     ; Get current line
1427   6963 CD 75 66            CALL    CPDEHL          ; Line after current?
1428   6966 E1                  POP     HL              ; Restore end of line
1429   6967 23                  INC     HL              ; Start of next line
1430   6968 DC 9C 64            CALL    C,SRCHLP        ; Line is after current line
1431   696B D4 99 64            CALL    NC,SRCHLN       ; Line is before current line
1432   696E 60                  LD      H,B             ; Set up code string address
1433   696F 69                  LD      L,C
1434   6970 2B                  DEC     HL              ; Incremented after
1435   6971 D8                  RET     C               ; Line found
1436   6972 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1437   6974 C3 C1 63            JP      ERROR           ; Output error message
1438   6977             
1439   6977 C0          RETURN: RET     NZ              ; Return if not just RETURN
1440   6978 16 FF               LD      D,-1            ; Flag "GOSUB" search
1441   697A CD 56 63            CALL    BAKSTK          ; Look "GOSUB" block
1442   697D F9                  LD      SP,HL           ; Kill all FORs in subroutine
1443   697E FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1444   6980 1E 04               LD      E,RG            ; ?RG Error
1445   6982 C2 C1 63            JP      NZ,ERROR        ; Error if no "GOSUB" found
1446   6985 E1                  POP     HL              ; Get RETURN line number
1447   6986 22 5C 90            LD      (LINEAT),HL     ; Save as current
1448   6989 23                  INC     HL              ; Was it from direct statement?
1449   698A 7C                  LD      A,H
1450   698B B5                  OR      L               ; Return to line
1451   698C C2 96 69            JP      NZ,RETLIN       ; No - Return to line
1452   698F 3A CC 90            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1453   6992 B7                  OR      A               ; If so buffer is corrupted
1454   6993 C2 F7 63            JP      NZ,POPNOK       ; Yes - Go to command mode
1455   6996 21 C5 67    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1456   6999 E3                  EX      (SP),HL         ; Into stack - Code string out
1457   699A 3E                  .BYTE      3EH             ; Skip "POP HL"
1458   699B E1          NXTDTA: POP     HL              ; Restore code string address
1459   699C             
1460   699C 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1461   699E 0E 00       REM:    LD      C,0             ; 00  End of statement
1462   69A0 06 00               LD      B,0
1463   69A2 79          NXTSTL: LD      A,C             ; Statement and byte
1464   69A3 48                  LD      C,B
1465   69A4 47                  LD      B,A             ; Statement end byte
1466   69A5 7E          NXTSTT: LD      A,(HL)          ; Get byte
1467   69A6 B7                  OR      A               ; End of line?
1468   69A7 C8                  RET     Z               ; Yes - Exit
1469   69A8 B8                  CP      B               ; End of statement?
1470   69A9 C8                  RET     Z               ; Yes - Exit
1471   69AA 23                  INC     HL              ; Next byte
1472   69AB FE 22               CP      '"'             ; Literal string?
1473   69AD CA A2 69            JP      Z,NXTSTL        ; Yes - Look for another '"'
1474   69B0 C3 A5 69            JP      NXTSTT          ; Keep looking
1475   69B3             
1476   69B3 CD 68 6E    LET:    CALL    GETVAR          ; Get variable name
1477   69B6 CD 7B 66            CALL    CHKSYN          ; Make sure "=" follows
1478   69B9 B4                  .BYTE      ZEQUAL          ; "=" token
1479   69BA D5                  PUSH    DE              ; Save address of variable
1480   69BB 3A AD 90            LD      A,(TYPE)        ; Get data type
1481   69BE F5                  PUSH    AF              ; Save type
1482   69BF CD 84 6C            CALL    EVAL            ; Evaluate expression
1483   69C2 F1                  POP     AF              ; Restore type
1484   69C3 E3                  EX      (SP),HL         ; Save code - Get var addr
1485   69C4 22 CE 90            LD      (BRKLIN),HL     ; Save address of variable
1486   69C7 1F                  RRA                     ; Adjust type
1487   69C8 CD 77 6C            CALL    CHKTYP          ; Check types are the same
1488   69CB CA 06 6A            JP      Z,LETNUM        ; Numeric - Move value
1489   69CE E5          LETSTR: PUSH    HL              ; Save address of string var
1490   69CF 2A E4 90            LD      HL,(FPREG)      ; Pointer to string entry
1491   69D2 E5                  PUSH    HL              ; Save it on stack
1492   69D3 23                  INC     HL              ; Skip over length
1493   69D4 23                  INC     HL
1494   69D5 5E                  LD      E,(HL)          ; LSB of string address
1495   69D6 23                  INC     HL
1496   69D7 56                  LD      D,(HL)          ; MSB of string address
1497   69D8 2A 5E 90            LD      HL,(BASTXT)     ; Point to start of program
1498   69DB CD 75 66            CALL    CPDEHL          ; Is string before program?
1499   69DE D2 F5 69            JP      NC,CRESTR       ; Yes - Create string entry
1500   69E1 2A 5A 90            LD      HL,(STRSPC)     ; Point to string space
1501   69E4 CD 75 66            CALL    CPDEHL          ; Is string literal in program?
1502   69E7 D1                  POP     DE              ; Restore address of string
1503   69E8 D2 FD 69            JP      NC,MVSTPT       ; Yes - Set up pointer
1504   69EB 21 BF 90            LD      HL,TMPSTR       ; Temporary string pool
1505   69EE CD 75 66            CALL    CPDEHL          ; Is string in temporary pool?
1506   69F1 D2 FD 69            JP      NC,MVSTPT       ; No - Set up pointer
1507   69F4 3E                  .BYTE   3EH             ; Skip "POP DE"
1508   69F5 D1          CRESTR: POP     DE              ; Restore address of string
1509   69F6 CD AC 72            CALL    BAKTMP          ; Back to last tmp-str entry
1510   69F9 EB                  EX      DE,HL           ; Address of string entry
1511   69FA CD E5 70            CALL    SAVSTR          ; Save string in string area
1512   69FD CD AC 72    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1513   6A00 E1                  POP     HL              ; Get string pointer
1514   6A01 CD AF 76            CALL    DETHL4          ; Move string pointer to var
1515   6A04 E1                  POP     HL              ; Restore code string address
1516   6A05 C9                  RET
1517   6A06             
1518   6A06 E5          LETNUM: PUSH    HL              ; Save address of variable
1519   6A07 CD AC 76            CALL    FPTHL           ; Move value to variable
1520   6A0A D1                  POP     DE              ; Restore address of variable
1521   6A0B E1                  POP     HL              ; Restore code string address
1522   6A0C C9                  RET
1523   6A0D             
1524   6A0D CD D3 73    ON:     CALL    GETINT          ; Get integer 0-255
1525   6A10 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1526   6A11 47                  LD      B,A             ; Save in B
1527   6A12 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1528   6A14 CA 1C 6A            JP      Z,ONGO          ; Yes - Find line number
1529   6A17 CD 7B 66            CALL    CHKSYN          ; Make sure it's "GOTO"
1530   6A1A 88                  .BYTE   ZGOTO           ; "GOTO" token
1531   6A1B 2B                  DEC     HL              ; Cancel increment
1532   6A1C 4B          ONGO:   LD      C,E             ; Integer of branch value
1533   6A1D 0D          ONGOLP: DEC     C               ; Count branches
1534   6A1E 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1535   6A1F CA ED 67            JP      Z,ONJMP         ; Go to that line if right one
1536   6A22 CD D2 68            CALL    GETLN           ; Get line number to DE
1537   6A25 FE 2C               CP      ','             ; Another line number?
1538   6A27 C0                  RET     NZ              ; No - Drop through
1539   6A28 C3 1D 6A            JP      ONGOLP          ; Yes - loop
1540   6A2B             
1541   6A2B CD 84 6C    IF:     CALL    EVAL            ; Evaluate expression
1542   6A2E 7E                  LD      A,(HL)          ; Get token
1543   6A2F FE 88               CP      ZGOTO           ; "GOTO" token?
1544   6A31 CA 39 6A            JP      Z,IFGO          ; Yes - Get line
1545   6A34 CD 7B 66            CALL    CHKSYN          ; Make sure it's "THEN"
1546   6A37 A9                  .BYTE      ZTHEN           ; "THEN" token
1547   6A38 2B                  DEC     HL              ; Cancel increment
1548   6A39 CD 75 6C    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1549   6A3C CD 54 76            CALL    TSTSGN          ; Test state of expression
1550   6A3F CA 9E 69            JP      Z,REM           ; False - Drop through
1551   6A42 CD 05 68            CALL    GETCHR          ; Get next character
1552   6A45 DA 59 69            JP      C,GOTO          ; Number - GOTO that line
1553   6A48 C3 EC 67            JP      IFJMP           ; Otherwise do statement
1554   6A4B             
1555   6A4B 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1556   6A4C CD 05 68            CALL    GETCHR          ; Get next character
1557   6A4F CA AD 6A    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1558   6A52 C8          PRNTLP: RET     Z               ; End of list - Exit
1559   6A53 FE A5               CP      ZTAB            ; "TAB(" token?
1560   6A55 CA E0 6A            JP      Z,DOTAB         ; Yes - Do TAB routine
1561   6A58 FE A8               CP      ZSPC            ; "SPC(" token?
1562   6A5A CA E0 6A            JP      Z,DOTAB         ; Yes - Do SPC routine
1563   6A5D E5                  PUSH    HL              ; Save code string address
1564   6A5E FE 2C               CP      ','             ; Comma?
1565   6A60 CA C9 6A            JP      Z,DOCOM         ; Yes - Move to next zone
1566   6A63 FE 3B               CP      59 ;";"         ; Semi-colon?
1567   6A65 CA 03 6B            JP      Z,NEXITM        ; Do semi-colon routine
1568   6A68 C1                  POP     BC              ; Code string address to BC
1569   6A69 CD 84 6C            CALL    EVAL            ; Evaluate expression
1570   6A6C E5                  PUSH    HL              ; Save code string address
1571   6A6D 3A AD 90            LD      A,(TYPE)        ; Get variable type
1572   6A70 B7                  OR      A               ; Is it a string variable?
1573   6A71 C2 99 6A            JP      NZ,PRNTST       ; Yes - Output string contents
1574   6A74 CD F9 77            CALL    NUMASC          ; Convert number to text
1575   6A77 CD 09 71            CALL    CRTST           ; Create temporary string
1576   6A7A 36 20               LD      (HL),' '        ; Followed by a space
1577   6A7C 2A E4 90            LD      HL,(FPREG)      ; Get length of output
1578   6A7F 34                  INC     (HL)            ; Plus 1 for the space
1579   6A80 2A E4 90            LD      HL,(FPREG)      ; < Not needed >
1580   6A83 3A 42 90            LD      A,(LWIDTH)      ; Get width of line
1581   6A86 47                  LD      B,A             ; To B
1582   6A87 04                  INC     B               ; Width 255 (No limit)?
1583   6A88 CA 95 6A            JP      Z,PRNTNB        ; Yes - Output number string
1584   6A8B 04                  INC     B               ; Adjust it
1585   6A8C 3A AB 90            LD      A,(CURPOS)      ; Get cursor position
1586   6A8F 86                  ADD     A,(HL)          ; Add length of string
1587   6A90 3D                  DEC     A               ; Adjust it
1588   6A91 B8                  CP      B               ; Will output fit on this line?
1589   6A92 D4 AD 6A            CALL    NC,PRNTCRLF     ; No - CRLF first
1590   6A95 CD 4E 71    PRNTNB: CALL    PRS1            ; Output string at (HL)
1591   6A98 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1592   6A99 C4 4E 71    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1593   6A9C E1                  POP     HL              ; Restore code string address
1594   6A9D C3 4B 6A            JP      MRPRNT          ; See if more to PRINT
1595   6AA0             
1596   6AA0 3A AB 90    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1597   6AA3 B7                  OR      A               ; Already at start?
1598   6AA4 C8                  RET     Z               ; Yes - Do nothing
1599   6AA5 C3 AD 6A            JP      PRNTCRLF        ; Start a new line
1600   6AA8             
1601   6AA8 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1602   6AAA 21 60 90            LD      HL,BUFFER-1     ; Point to buffer
1603   6AAD 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1604   6AAF CD 86 66            CALL    OUTC            ; Output character
1605   6AB2 3E 0A               LD      A,LF            ; Load a LF
1606   6AB4 CD 86 66            CALL    OUTC            ; Output character
1607   6AB7 AF          DONULL: XOR     A               ; Set to position 0
1608   6AB8 32 AB 90            LD      (CURPOS),A      ; Store it
1609   6ABB 3A 41 90            LD      A,(NULLS)       ; Get number of nulls
1610   6ABE 3D          NULLP:  DEC     A               ; Count them
1611   6ABF C8                  RET     Z               ; Return if done
1612   6AC0 F5                  PUSH    AF              ; Save count
1613   6AC1 AF                  XOR     A               ; Load a null
1614   6AC2 CD 86 66            CALL    OUTC            ; Output it
1615   6AC5 F1                  POP     AF              ; Restore count
1616   6AC6 C3 BE 6A            JP      NULLP           ; Keep counting
1617   6AC9             
1618   6AC9 3A 43 90    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1619   6ACC 47                  LD      B,A             ; Save in B
1620   6ACD 3A AB 90            LD      A,(CURPOS)      ; Get current position
1621   6AD0 B8                  CP      B               ; Within the limit?
1622   6AD1 D4 AD 6A            CALL    NC,PRNTCRLF     ; No - output CRLF
1623   6AD4 D2 03 6B            JP      NC,NEXITM       ; Get next item
1624   6AD7 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1625   6AD9 D2 D7 6A            JP      NC,ZONELP       ; Repeat if more zones
1626   6ADC 2F                  CPL                     ; Number of spaces to output
1627   6ADD C3 F8 6A            JP      ASPCS           ; Output them
1628   6AE0             
1629   6AE0 F5          DOTAB:  PUSH    AF              ; Save token
1630   6AE1 CD D0 73            CALL    FNDNUM          ; Evaluate expression
1631   6AE4 CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
1632   6AE7 29                  .BYTE   ")"
1633   6AE8 2B                  DEC     HL              ; Back space on to ")"
1634   6AE9 F1                  POP     AF              ; Restore token
1635   6AEA D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1636   6AEC E5                  PUSH    HL              ; Save code string address
1637   6AED CA F3 6A            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1638   6AF0 3A AB 90            LD      A,(CURPOS)      ; Get current position
1639   6AF3 2F          DOSPC:  CPL                     ; Number of spaces to print to
1640   6AF4 83                  ADD     A,E             ; Total number to print
1641   6AF5 D2 03 6B            JP      NC,NEXITM       ; TAB < Current POS(X)
1642   6AF8 3C          ASPCS:  INC     A               ; Output A spaces
1643   6AF9 47                  LD      B,A             ; Save number to print
1644   6AFA 3E 20               LD      A,' '           ; Space
1645   6AFC CD 86 66    SPCLP:  CALL    OUTC            ; Output character in A
1646   6AFF 05                  DEC     B               ; Count them
1647   6B00 C2 FC 6A            JP      NZ,SPCLP        ; Repeat if more
1648   6B03 E1          NEXITM: POP     HL              ; Restore code string address
1649   6B04 CD 05 68            CALL    GETCHR          ; Get next character
1650   6B07 C3 52 6A            JP      PRNTLP          ; More to print
1651   6B0A             
1652   6B0A 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
1652   6B10 66726F6D2073746172740D0A00
1653   6B1D             
1654   6B1D 3A CD 90    BADINP: LD      A,(READFG)      ; READ or INPUT?
1655   6B20 B7                  OR      A
1656   6B21 C2 A7 63            JP      NZ,DATSNR       ; READ - ?SN Error
1657   6B24 C1                  POP     BC              ; Throw away code string addr
1658   6B25 21 0A 6B            LD      HL,REDO         ; "Redo from start" message
1659   6B28 CD 4B 71            CALL    PRS             ; Output string
1660   6B2B C3 F8 64            JP      DOAGN           ; Do last INPUT again
1661   6B2E             
1662   6B2E CD B6 70    INPUT:  CALL    IDTEST          ; Test for illegal direct
1663   6B31 7E                  LD      A,(HL)          ; Get character after "INPUT"
1664   6B32 FE 22               CP      '"'             ; Is there a prompt string?
1665   6B34 3E 00               LD      A,0             ; Clear A and leave flags
1666   6B36 32 45 90            LD      (CTLOFG),A      ; Enable output
1667   6B39 C2 48 6B            JP      NZ,NOPMPT       ; No prompt - get input
1668   6B3C CD 0A 71            CALL    QTSTR           ; Get string terminated by '"'
1669   6B3F CD 7B 66            CALL    CHKSYN          ; Check for ';' after prompt
1670   6B42 3B                  .BYTE   ';'
1671   6B43 E5                  PUSH    HL              ; Save code string address
1672   6B44 CD 4E 71            CALL    PRS1            ; Output prompt string
1673   6B47 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1674   6B48 E5          NOPMPT: PUSH    HL              ; Save code string address
1675   6B49 CD FC 64            CALL    PROMPT          ; Get input with "? " prompt
1676   6B4C C1                  POP     BC              ; Restore code string address
1677   6B4D DA 54 68            JP      C,INPBRK        ; Break pressed - Exit
1678   6B50 23                  INC     HL              ; Next byte
1679   6B51 7E                  LD      A,(HL)          ; Get it
1680   6B52 B7                  OR      A               ; End of line?
1681   6B53 2B                  DEC     HL              ; Back again
1682   6B54 C5                  PUSH    BC              ; Re-save code string address
1683   6B55 CA 9B 69            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1684   6B58 36 2C               LD      (HL),','        ; Store comma as separator
1685   6B5A C3 62 6B            JP      NXTITM          ; Get next item
1686   6B5D             
1687   6B5D E5          READ:   PUSH    HL              ; Save code string address
1688   6B5E 2A DC 90            LD      HL,(NXTDAT)     ; Next DATA statement
1689   6B61 F6                  .BYTE   0F6H            ; Flag "READ"
1690   6B62 AF          NXTITM: XOR     A               ; Flag "INPUT"
1691   6B63 32 CD 90            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1692   6B66 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1693   6B67 C3 6E 6B            JP      GTVLUS          ; Get values
1694   6B6A             
1695   6B6A CD 7B 66    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1696   6B6D 2C                  .BYTE      ','
1697   6B6E CD 68 6E    GTVLUS: CALL    GETVAR          ; Get variable name
1698   6B71 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1699   6B72 D5                  PUSH    DE              ; Save variable address
1700   6B73 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1701   6B74 FE 2C               CP      ','             ; Comma?
1702   6B76 CA 96 6B            JP      Z,ANTVLU        ; Yes - Get another value
1703   6B79 3A CD 90            LD      A,(READFG)      ; Is it READ?
1704   6B7C B7                  OR      A
1705   6B7D C2 03 6C            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1706   6B80 3E 3F               LD      A,'?'           ; More INPUT needed
1707   6B82 CD 86 66            CALL    OUTC            ; Output character
1708   6B85 CD FC 64            CALL    PROMPT          ; Get INPUT with prompt
1709   6B88 D1                  POP     DE              ; Variable address
1710   6B89 C1                  POP     BC              ; Code string address
1711   6B8A DA 54 68            JP      C,INPBRK        ; Break pressed
1712   6B8D 23                  INC     HL              ; Point to next DATA byte
1713   6B8E 7E                  LD      A,(HL)          ; Get byte
1714   6B8F B7                  OR      A               ; Is it zero (No input) ?
1715   6B90 2B                  DEC     HL              ; Back space INPUT pointer
1716   6B91 C5                  PUSH    BC              ; Save code string address
1717   6B92 CA 9B 69            JP      Z,NXTDTA        ; Find end of buffer
1718   6B95 D5                  PUSH    DE              ; Save variable address
1719   6B96 3A AD 90    ANTVLU: LD      A,(TYPE)        ; Check data type
1720   6B99 B7                  OR      A               ; Is it numeric?
1721   6B9A CA C0 6B            JP      Z,INPBIN        ; Yes - Convert to binary
1722   6B9D CD 05 68            CALL    GETCHR          ; Get next character
1723   6BA0 57                  LD      D,A             ; Save input character
1724   6BA1 47                  LD      B,A             ; Again
1725   6BA2 FE 22               CP      '"'             ; Start of literal sting?
1726   6BA4 CA B4 6B            JP      Z,STRENT        ; Yes - Create string entry
1727   6BA7 3A CD 90            LD      A,(READFG)      ; "READ" or "INPUT" ?
1728   6BAA B7                  OR      A
1729   6BAB 57                  LD      D,A             ; Save 00 if "INPUT"
1730   6BAC CA B1 6B            JP      Z,ITMSEP        ; "INPUT" - End with 00
1731   6BAF 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1732   6BB1 06 2C       ITMSEP: LD      B,','           ; Item separator
1733   6BB3 2B                  DEC     HL              ; Back space for DTSTR
1734   6BB4 CD 0D 71    STRENT: CALL    DTSTR           ; Get string terminated by D
1735   6BB7 EB                  EX      DE,HL           ; String address to DE
1736   6BB8 21 CB 6B            LD      HL,LTSTND       ; Where to go after LETSTR
1737   6BBB E3                  EX      (SP),HL         ; Save HL , get input pointer
1738   6BBC D5                  PUSH    DE              ; Save address of string
1739   6BBD C3 CE 69            JP      LETSTR          ; Assign string to variable
1740   6BC0             
1741   6BC0 CD 05 68    INPBIN: CALL    GETCHR          ; Get next character
1742   6BC3 CD 5B 77            CALL    ASCTFP          ; Convert ASCII to FP number
1743   6BC6 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1744   6BC7 CD AC 76            CALL    FPTHL           ; Move FPREG to variable
1745   6BCA E1                  POP     HL              ; Restore input pointer
1746   6BCB 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1747   6BCC CD 05 68            CALL    GETCHR          ; Get next character
1748   6BCF CA D7 6B            JP      Z,MORDT         ; End of line - More needed?
1749   6BD2 FE 2C               CP      ','             ; Another value?
1750   6BD4 C2 1D 6B            JP      NZ,BADINP       ; No - Bad input
1751   6BD7 E3          MORDT:  EX      (SP),HL         ; Get code string address
1752   6BD8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1753   6BD9 CD 05 68            CALL    GETCHR          ; Get next character
1754   6BDC C2 6A 6B            JP      NZ,NEDMOR       ; More needed - Get it
1755   6BDF D1                  POP     DE              ; Restore DATA pointer
1756   6BE0 3A CD 90            LD      A,(READFG)      ; "READ" or "INPUT" ?
1757   6BE3 B7                  OR      A
1758   6BE4 EB                  EX      DE,HL           ; DATA pointer to HL
1759   6BE5 C2 2B 68            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1760   6BE8 D5                  PUSH    DE              ; Save code string address
1761   6BE9 B6                  OR      (HL)            ; More input given?
1762   6BEA 21 F2 6B            LD      HL,EXTIG        ; "?Extra ignored" message
1763   6BED C4 4B 71            CALL    NZ,PRS          ; Output string if extra given
1764   6BF0 E1                  POP     HL              ; Restore code string address
1765   6BF1 C9                  RET
1766   6BF2             
1767   6BF2 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1767   6BF8 2069676E6F7265640D0A00
1768   6C03             
1769   6C03 CD 9C 69    FDTLP:  CALL    DATA            ; Get next statement
1770   6C06 B7                  OR      A               ; End of line?
1771   6C07 C2 1C 6C            JP      NZ,FANDT        ; No - See if DATA statement
1772   6C0A 23                  INC     HL
1773   6C0B 7E                  LD      A,(HL)          ; End of program?
1774   6C0C 23                  INC     HL
1775   6C0D B6                  OR      (HL)            ; 00 00 Ends program
1776   6C0E 1E 06               LD      E,OD            ; ?OD Error
1777   6C10 CA C1 63            JP      Z,ERROR         ; Yes - Out of DATA
1778   6C13 23                  INC     HL
1779   6C14 5E                  LD      E,(HL)          ; LSB of line number
1780   6C15 23                  INC     HL
1781   6C16 56                  LD      D,(HL)          ; MSB of line number
1782   6C17 EB                  EX      DE,HL
1783   6C18 22 C9 90            LD      (DATLIN),HL     ; Set line of current DATA item
1784   6C1B EB                  EX      DE,HL
1785   6C1C CD 05 68    FANDT:  CALL    GETCHR          ; Get next character
1786   6C1F FE 83               CP      ZDATA           ; "DATA" token
1787   6C21 C2 03 6C            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1788   6C24 C3 96 6B            JP      ANTVLU          ; Found - Convert input
1789   6C27             
1790   6C27 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1791   6C2A C4 68 6E    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1792   6C2D 22 CE 90            LD      (BRKLIN),HL     ; Save code string address
1793   6C30 CD 56 63            CALL    BAKSTK          ; Look for "FOR" block
1794   6C33 C2 B3 63            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1795   6C36 F9                  LD      SP,HL           ; Clear nested loops
1796   6C37 D5                  PUSH    DE              ; Save index address
1797   6C38 7E                  LD      A,(HL)          ; Get sign of STEP
1798   6C39 23                  INC     HL
1799   6C3A F5                  PUSH    AF              ; Save sign of STEP
1800   6C3B D5                  PUSH    DE              ; Save index address
1801   6C3C CD 92 76            CALL    PHLTFP          ; Move index value to FPREG
1802   6C3F E3                  EX      (SP),HL         ; Save address of TO value
1803   6C40 E5                  PUSH    HL              ; Save address of index
1804   6C41 CD FF 73            CALL    ADDPHL          ; Add STEP to index value
1805   6C44 E1                  POP     HL              ; Restore address of index
1806   6C45 CD AC 76            CALL    FPTHL           ; Move value to index variable
1807   6C48 E1                  POP     HL              ; Restore address of TO value
1808   6C49 CD A3 76            CALL    LOADFP          ; Move TO value to BCDE
1809   6C4C E5                  PUSH    HL              ; Save address of line of FOR
1810   6C4D CD CF 76            CALL    CMPNUM          ; Compare index with TO value
1811   6C50 E1                  POP     HL              ; Restore address of line num
1812   6C51 C1                  POP     BC              ; Address of sign of STEP
1813   6C52 90                  SUB     B               ; Compare with expected sign
1814   6C53 CD A3 76            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1815   6C56 CA 62 6C            JP      Z,KILFOR        ; Loop finished - Terminate it
1816   6C59 EB                  EX      DE,HL           ; Loop statement line number
1817   6C5A 22 5C 90            LD      (LINEAT),HL     ; Set loop line number
1818   6C5D 69                  LD      L,C             ; Set code string to loop
1819   6C5E 60                  LD      H,B
1820   6C5F C3 C1 67            JP      PUTFID          ; Put back "FOR" and continue
1821   6C62             
1822   6C62 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1823   6C63 2A CE 90            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1824   6C66 7E                  LD      A,(HL)          ; Get next byte in code string
1825   6C67 FE 2C               CP      ','             ; More NEXTs ?
1826   6C69 C2 C5 67            JP      NZ,RUNCNT       ; No - Do next statement
1827   6C6C CD 05 68            CALL    GETCHR          ; Position to index name
1828   6C6F CD 2A 6C            CALL    NEXT1           ; Re-enter NEXT routine
1829   6C72             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1830   6C72             
1831   6C72 CD 84 6C    GETNUM: CALL    EVAL            ; Get a numeric expression
1832   6C75 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1833   6C76 37          TSTSTR: SCF                     ; Set carry (string)
1834   6C77 3A AD 90    CHKTYP: LD      A,(TYPE)        ; Check types match
1835   6C7A 8F                  ADC     A,A             ; Expected + actual
1836   6C7B B7                  OR      A               ; Clear carry , set parity
1837   6C7C E8                  RET     PE              ; Even parity - Types match
1838   6C7D C3 BF 63            JP      TMERR           ; Different types - Error
1839   6C80             
1840   6C80 CD 7B 66    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1841   6C83 28                  .BYTE   "("
1842   6C84 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1843   6C85 16 00               LD      D,0             ; Precedence value
1844   6C87 D5          EVAL1:  PUSH    DE              ; Save precedence
1845   6C88 0E 01               LD      C,1
1846   6C8A CD 8A 63            CALL    CHKSTK          ; Check for 1 level of stack
1847   6C8D CD FB 6C            CALL    OPRND           ; Get next expression value
1848   6C90 22 D0 90    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1849   6C93 2A D0 90    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1850   6C96 C1                  POP     BC              ; Precedence value and operator
1851   6C97 78                  LD      A,B             ; Get precedence value
1852   6C98 FE 78               CP      78H             ; "AND" or "OR" ?
1853   6C9A D4 75 6C            CALL    NC,TSTNUM       ; No - Make sure it's a number
1854   6C9D 7E                  LD      A,(HL)          ; Get next operator / function
1855   6C9E 16 00               LD      D,0             ; Clear Last relation
1856   6CA0 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1857   6CA2 DA BC 6C            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1858   6CA5 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1859   6CA7 D2 BC 6C            JP      NC,FOPRND       ; Function - Call it
1860   6CAA FE 01               CP      ZEQUAL-ZGTR     ; "="
1861   6CAC 17                  RLA                     ; <- Test for legal
1862   6CAD AA                  XOR     D               ; <- combinations of < = >
1863   6CAE BA                  CP      D               ; <- by combining last token
1864   6CAF 57                  LD      D,A             ; <- with current one
1865   6CB0 DA AD 63            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1866   6CB3 22 C5 90            LD      (CUROPR),HL     ; Save address of current token
1867   6CB6 CD 05 68            CALL    GETCHR          ; Get next character
1868   6CB9 C3 A0 6C            JP      RLTLP           ; Treat the two as one
1869   6CBC             
1870   6CBC 7A          FOPRND: LD      A,D             ; < = > found ?
1871   6CBD B7                  OR      A
1872   6CBE C2 E3 6D            JP      NZ,TSTRED       ; Yes - Test for reduction
1873   6CC1 7E                  LD      A,(HL)          ; Get operator token
1874   6CC2 22 C5 90            LD      (CUROPR),HL     ; Save operator address
1875   6CC5 D6 AC               SUB     ZPLUS           ; Operator or function?
1876   6CC7 D8                  RET     C               ; Neither - Exit
1877   6CC8 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1878   6CCA D0                  RET     NC              ; No - Exit
1879   6CCB 5F                  LD      E,A             ; Coded operator
1880   6CCC 3A AD 90            LD      A,(TYPE)        ; Get data type
1881   6CCF 3D                  DEC     A               ; FF = numeric , 00 = string
1882   6CD0 B3                  OR      E               ; Combine with coded operator
1883   6CD1 7B                  LD      A,E             ; Get coded operator
1884   6CD2 CA 41 72            JP      Z,CONCAT        ; String concatenation
1885   6CD5 07                  RLCA                    ; Times 2
1886   6CD6 83                  ADD     A,E             ; Times 3
1887   6CD7 5F                  LD      E,A             ; To DE (D is 0)
1888   6CD8 21 9F 62            LD      HL,PRITAB       ; Precedence table
1889   6CDB 19                  ADD     HL,DE           ; To the operator concerned
1890   6CDC 78                  LD      A,B             ; Last operator precedence
1891   6CDD 56                  LD      D,(HL)          ; Get evaluation precedence
1892   6CDE BA                  CP      D               ; Compare with eval precedence
1893   6CDF D0                  RET     NC              ; Exit if higher precedence
1894   6CE0 23                  INC     HL              ; Point to routine address
1895   6CE1 CD 75 6C            CALL    TSTNUM          ; Make sure it's a number
1896   6CE4             
1897   6CE4 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1898   6CE5 01 93 6C            LD      BC,EVAL3        ; Where to go on prec' break
1899   6CE8 C5                  PUSH    BC              ; Save on stack for return
1900   6CE9 43                  LD      B,E             ; Save operator
1901   6CEA 4A                  LD      C,D             ; Save precedence
1902   6CEB CD 85 76            CALL    STAKFP          ; Move value to stack
1903   6CEE 58                  LD      E,B             ; Restore operator
1904   6CEF 51                  LD      D,C             ; Restore precedence
1905   6CF0 4E                  LD      C,(HL)          ; Get LSB of routine address
1906   6CF1 23                  INC     HL
1907   6CF2 46                  LD      B,(HL)          ; Get MSB of routine address
1908   6CF3 23                  INC     HL
1909   6CF4 C5                  PUSH    BC              ; Save routine address
1910   6CF5 2A C5 90            LD      HL,(CUROPR)     ; Address of current operator
1911   6CF8 C3 87 6C            JP      EVAL1           ; Loop until prec' break
1912   6CFB             
1913   6CFB AF          OPRND:  XOR     A               ; Get operand routine
1914   6CFC 32 AD 90            LD      (TYPE),A        ; Set numeric expected
1915   6CFF CD 05 68            CALL    GETCHR          ; Get next character
1916   6D02 1E 24               LD      E,MO            ; ?MO Error
1917   6D04 CA C1 63            JP      Z,ERROR         ; No operand - Error
1918   6D07 DA 5B 77            JP      C,ASCTFP        ; Number - Get value
1919   6D0A CD A3 68            CALL    CHKLTR          ; See if a letter
1920   6D0D D2 62 6D            JP      NC,CONVAR       ; Letter - Find variable
1921   6D10 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1922   6D12 20 12               JR		NZ, NOTAMP
1923   6D14 CD 05 68            CALL    GETCHR          ; Get next character
1924   6D17 FE 48               CP      'H'             ; Hex number indicated? [function added]
1925   6D19 CA 9F 7B            JP      Z,HEXTFP        ; Convert Hex to FPREG
1926   6D1C FE 42               CP      'B'             ; Binary number indicated? [function added]
1927   6D1E CA 0F 7C            JP      Z,BINTFP        ; Convert Bin to FPREG
1928   6D21 1E 02               LD      E,SN            ; If neither then a ?SN Error
1929   6D23 CA C1 63            JP      Z,ERROR         ; 
1930   6D26 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1931   6D28 CA FB 6C            JP      Z,OPRND         ; Yes - Look for operand
1932   6D2B FE 2E               CP      '.'             ; '.' ?
1933   6D2D CA 5B 77            JP      Z,ASCTFP        ; Yes - Create FP number
1934   6D30 FE AD               CP      ZMINUS          ; '-' Token ?
1935   6D32 CA 51 6D            JP      Z,MINUS         ; Yes - Do minus
1936   6D35 FE 22               CP      '"'             ; Literal string ?
1937   6D37 CA 0A 71            JP      Z,QTSTR         ; Get string terminated by '"'
1938   6D3A FE AA               CP      ZNOT            ; "NOT" Token ?
1939   6D3C CA 43 6E            JP      Z,EVNOT         ; Yes - Eval NOT expression
1940   6D3F FE A7               CP      ZFN             ; "FN" Token ?
1941   6D41 CA 6E 70            JP      Z,DOFN          ; Yes - Do FN routine
1942   6D44 D6 B6               SUB     ZSGN            ; Is it a function?
1943   6D46 D2 73 6D            JP      NC,FNOFST       ; Yes - Evaluate function
1944   6D49 CD 80 6C    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1945   6D4C CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
1946   6D4F 29                  .BYTE   ")"
1947   6D50 C9                  RET
1948   6D51             
1949   6D51 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1950   6D53 CD 87 6C            CALL    EVAL1           ; Evaluate until prec' break
1951   6D56 2A D0 90            LD      HL,(NXTOPR)     ; Get next operator address
1952   6D59 E5                  PUSH    HL              ; Save next operator address
1953   6D5A CD 7D 76            CALL    INVSGN          ; Negate value
1954   6D5D CD 75 6C    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1955   6D60 E1                  POP     HL              ; Restore next operator address
1956   6D61 C9                  RET
1957   6D62             
1958   6D62 CD 68 6E    CONVAR: CALL    GETVAR          ; Get variable address to DE
1959   6D65 E5          FRMEVL: PUSH    HL              ; Save code string address
1960   6D66 EB                  EX      DE,HL           ; Variable address to HL
1961   6D67 22 E4 90            LD      (FPREG),HL      ; Save address of variable
1962   6D6A 3A AD 90            LD      A,(TYPE)        ; Get type
1963   6D6D B7                  OR      A               ; Numeric?
1964   6D6E CC 92 76            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1965   6D71 E1                  POP     HL              ; Restore code string address
1966   6D72 C9                  RET
1967   6D73             
1968   6D73 06 00       FNOFST: LD      B,0             ; Get address of function
1969   6D75 07                  RLCA                    ; Double function offset
1970   6D76 4F                  LD      C,A             ; BC = Offset in function table
1971   6D77 C5                  PUSH    BC              ; Save adjusted token value
1972   6D78 CD 05 68            CALL    GETCHR          ; Get next character
1973   6D7B 79                  LD      A,C             ; Get adjusted token value
1974   6D7C FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1975   6D7E DA 9A 6D            JP      C,FNVAL         ; No - Do function
1976   6D81 CD 80 6C            CALL    OPNPAR          ; Evaluate expression  (X,...
1977   6D84 CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
1978   6D87 2C                  .BYTE      ','
1979   6D88 CD 76 6C            CALL    TSTSTR          ; Make sure it's a string
1980   6D8B EB                  EX      DE,HL           ; Save code string address
1981   6D8C 2A E4 90            LD      HL,(FPREG)      ; Get address of string
1982   6D8F E3                  EX      (SP),HL         ; Save address of string
1983   6D90 E5                  PUSH    HL              ; Save adjusted token value
1984   6D91 EB                  EX      DE,HL           ; Restore code string address
1985   6D92 CD D3 73            CALL    GETINT          ; Get integer 0-255
1986   6D95 EB                  EX      DE,HL           ; Save code string address
1987   6D96 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1988   6D97 C3 A2 6D            JP      GOFUNC          ; Jump to string function
1989   6D9A             
1990   6D9A CD 49 6D    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1991   6D9D E3                  EX      (SP),HL         ; HL = Adjusted token value
1992   6D9E 11 5D 6D            LD      DE,RETNUM       ; Return number from function
1993   6DA1 D5                  PUSH    DE              ; Save on stack
1994   6DA2 01 FE 60    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1995   6DA5 09                  ADD     HL,BC           ; Point to right address
1996   6DA6 4E                  LD      C,(HL)          ; Get LSB of address
1997   6DA7 23                  INC     HL              ;
1998   6DA8 66                  LD      H,(HL)          ; Get MSB of address
1999   6DA9 69                  LD      L,C             ; Address to HL
2000   6DAA E9                  JP      (HL)            ; Jump to function
2001   6DAB             
2002   6DAB 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2003   6DAC FE AD               CP      ZMINUS          ; '-' token ?
2004   6DAE C8                  RET     Z               ; Yes - Return
2005   6DAF FE 2D               CP      '-'             ; '-' ASCII ?
2006   6DB1 C8                  RET     Z               ; Yes - Return
2007   6DB2 14                  INC     D               ; Inc to flag positive exponent
2008   6DB3 FE 2B               CP      '+'             ; '+' ASCII ?
2009   6DB5 C8                  RET     Z               ; Yes - Return
2010   6DB6 FE AC               CP      ZPLUS           ; '+' token ?
2011   6DB8 C8                  RET     Z               ; Yes - Return
2012   6DB9 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2013   6DBA C9                  RET                     ; Return "NZ"
2014   6DBB             
2015   6DBB F6          POR:    .BYTE      0F6H            ; Flag "OR"
2016   6DBC AF          PAND:   XOR     A               ; Flag "AND"
2017   6DBD F5                  PUSH    AF              ; Save "AND" / "OR" flag
2018   6DBE CD 75 6C            CALL    TSTNUM          ; Make sure it's a number
2019   6DC1 CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
2020   6DC4 F1                  POP     AF              ; Restore "AND" / "OR" flag
2021   6DC5 EB                  EX      DE,HL           ; <- Get last
2022   6DC6 C1                  POP     BC              ; <-  value
2023   6DC7 E3                  EX      (SP),HL         ; <-  from
2024   6DC8 EB                  EX      DE,HL           ; <-  stack
2025   6DC9 CD 95 76            CALL    FPBCDE          ; Move last value to FPREG
2026   6DCC F5                  PUSH    AF              ; Save "AND" / "OR" flag
2027   6DCD CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
2028   6DD0 F1                  POP     AF              ; Restore "AND" / "OR" flag
2029   6DD1 C1                  POP     BC              ; Get value
2030   6DD2 79                  LD      A,C             ; Get LSB
2031   6DD3 21 2C 70            LD      HL,ACPASS       ; Address of save AC as current
2032   6DD6 C2 DE 6D            JP      NZ,POR1         ; Jump if OR
2033   6DD9 A3                  AND     E               ; "AND" LSBs
2034   6DDA 4F                  LD      C,A             ; Save LSB
2035   6DDB 78                  LD      A,B             ; Get MBS
2036   6DDC A2                  AND     D               ; "AND" MSBs
2037   6DDD E9                  JP      (HL)            ; Save AC as current (ACPASS)
2038   6DDE             
2039   6DDE B3          POR1:   OR      E               ; "OR" LSBs
2040   6DDF 4F                  LD      C,A             ; Save LSB
2041   6DE0 78                  LD      A,B             ; Get MSB
2042   6DE1 B2                  OR      D               ; "OR" MSBs
2043   6DE2 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2044   6DE3             
2045   6DE3 21 F5 6D    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2046   6DE6 3A AD 90            LD      A,(TYPE)        ; Get data type
2047   6DE9 1F                  RRA                     ; Carry set = string
2048   6DEA 7A                  LD      A,D             ; Get last precedence value
2049   6DEB 17                  RLA                     ; Times 2 plus carry
2050   6DEC 5F                  LD      E,A             ; To E
2051   6DED 16 64               LD      D,64H           ; Relational precedence
2052   6DEF 78                  LD      A,B             ; Get current precedence
2053   6DF0 BA                  CP      D               ; Compare with last
2054   6DF1 D0                  RET     NC              ; Eval if last was rel' or log'
2055   6DF2 C3 E4 6C            JP      STKTHS          ; Stack this one and get next
2056   6DF5             
2057   6DF5 F7 6D       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2058   6DF7 79          CMPLG1: LD      A,C             ; Get data type
2059   6DF8 B7                  OR      A
2060   6DF9 1F                  RRA
2061   6DFA C1                  POP     BC              ; Get last expression to BCDE
2062   6DFB D1                  POP     DE
2063   6DFC F5                  PUSH    AF              ; Save status
2064   6DFD CD 77 6C            CALL    CHKTYP          ; Check that types match
2065   6E00 21 39 6E            LD      HL,CMPRES       ; Result to comparison
2066   6E03 E5                  PUSH    HL              ; Save for RETurn
2067   6E04 CA CF 76            JP      Z,CMPNUM        ; Compare values if numeric
2068   6E07 AF                  XOR     A               ; Compare two strings
2069   6E08 32 AD 90            LD      (TYPE),A        ; Set type to numeric
2070   6E0B D5                  PUSH    DE              ; Save string name
2071   6E0C CD 8E 72            CALL    GSTRCU          ; Get current string
2072   6E0F 7E                  LD      A,(HL)          ; Get length of string
2073   6E10 23                  INC     HL
2074   6E11 23                  INC     HL
2075   6E12 4E                  LD      C,(HL)          ; Get LSB of address
2076   6E13 23                  INC     HL
2077   6E14 46                  LD      B,(HL)          ; Get MSB of address
2078   6E15 D1                  POP     DE              ; Restore string name
2079   6E16 C5                  PUSH    BC              ; Save address of string
2080   6E17 F5                  PUSH    AF              ; Save length of string
2081   6E18 CD 92 72            CALL    GSTRDE          ; Get second string
2082   6E1B CD A3 76            CALL    LOADFP          ; Get address of second string
2083   6E1E F1                  POP     AF              ; Restore length of string 1
2084   6E1F 57                  LD      D,A             ; Length to D
2085   6E20 E1                  POP     HL              ; Restore address of string 1
2086   6E21 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2087   6E22 B2                  OR      D               ; Bytes of string 1 to do
2088   6E23 C8                  RET     Z               ; Exit if all bytes compared
2089   6E24 7A                  LD      A,D             ; Get bytes of string 1 to do
2090   6E25 D6 01               SUB     1
2091   6E27 D8                  RET     C               ; Exit if end of string 1
2092   6E28 AF                  XOR     A
2093   6E29 BB                  CP      E               ; Bytes of string 2 to do
2094   6E2A 3C                  INC     A
2095   6E2B D0                  RET     NC              ; Exit if end of string 2
2096   6E2C 15                  DEC     D               ; Count bytes in string 1
2097   6E2D 1D                  DEC     E               ; Count bytes in string 2
2098   6E2E 0A                  LD      A,(BC)          ; Byte in string 2
2099   6E2F BE                  CP      (HL)            ; Compare to byte in string 1
2100   6E30 23                  INC     HL              ; Move up string 1
2101   6E31 03                  INC     BC              ; Move up string 2
2102   6E32 CA 21 6E            JP      Z,CMPSTR        ; Same - Try next bytes
2103   6E35 3F                  CCF                     ; Flag difference (">" or "<")
2104   6E36 C3 5F 76            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2105   6E39             
2106   6E39 3C          CMPRES: INC     A               ; Increment current value
2107   6E3A 8F                  ADC     A,A             ; Double plus carry
2108   6E3B C1                  POP     BC              ; Get other value
2109   6E3C A0                  AND     B               ; Combine them
2110   6E3D C6 FF               ADD     A,-1            ; Carry set if different
2111   6E3F 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2112   6E40 C3 66 76            JP      FLGREL          ; Set current value & continue
2113   6E43             
2114   6E43 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2115   6E45 CD 87 6C            CALL    EVAL1           ; Eval until precedence break
2116   6E48 CD 75 6C            CALL    TSTNUM          ; Make sure it's a number
2117   6E4B CD B7 68            CALL    DEINT           ; Get integer -32768 - 32767
2118   6E4E 7B                  LD      A,E             ; Get LSB
2119   6E4F 2F                  CPL                     ; Invert LSB
2120   6E50 4F                  LD      C,A             ; Save "NOT" of LSB
2121   6E51 7A                  LD      A,D             ; Get MSB
2122   6E52 2F                  CPL                     ; Invert MSB
2123   6E53 CD 2C 70            CALL    ACPASS          ; Save AC as current
2124   6E56 C1                  POP     BC              ; Clean up stack
2125   6E57 C3 93 6C            JP      EVAL3           ; Continue evaluation
2126   6E5A             
2127   6E5A 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2128   6E5B CD 05 68            CALL    GETCHR          ; Get next character
2129   6E5E C8                  RET     Z               ; End of DIM statement
2130   6E5F CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
2131   6E62 2C                  .BYTE      ','
2132   6E63 01 5A 6E    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2133   6E66 C5                  PUSH    BC              ; Save on stack
2134   6E67 F6                  .BYTE      0F6H            ; Flag "Create" variable
2135   6E68 AF          GETVAR: XOR     A               ; Find variable address,to DE
2136   6E69 32 AC 90            LD      (LCRFLG),A      ; Set locate / create flag
2137   6E6C 46                  LD      B,(HL)          ; Get First byte of name
2138   6E6D CD A3 68    GTFNAM: CALL    CHKLTR          ; See if a letter
2139   6E70 DA AD 63            JP      C,SNERR         ; ?SN Error if not a letter
2140   6E73 AF                  XOR     A
2141   6E74 4F                  LD      C,A             ; Clear second byte of name
2142   6E75 32 AD 90            LD      (TYPE),A        ; Set type to numeric
2143   6E78 CD 05 68            CALL    GETCHR          ; Get next character
2144   6E7B DA 84 6E            JP      C,SVNAM2        ; Numeric - Save in name
2145   6E7E CD A3 68            CALL    CHKLTR          ; See if a letter
2146   6E81 DA 91 6E            JP      C,CHARTY        ; Not a letter - Check type
2147   6E84 4F          SVNAM2: LD      C,A             ; Save second byte of name
2148   6E85 CD 05 68    ENDNAM: CALL    GETCHR          ; Get next character
2149   6E88 DA 85 6E            JP      C,ENDNAM        ; Numeric - Get another
2150   6E8B CD A3 68            CALL    CHKLTR          ; See if a letter
2151   6E8E D2 85 6E            JP      NC,ENDNAM       ; Letter - Get another
2152   6E91 D6 24       CHARTY: SUB     '$'             ; String variable?
2153   6E93 C2 A0 6E            JP      NZ,NOTSTR       ; No - Numeric variable
2154   6E96 3C                  INC     A               ; A = 1 (string type)
2155   6E97 32 AD 90            LD      (TYPE),A        ; Set type to string
2156   6E9A 0F                  RRCA                    ; A = 80H , Flag for string
2157   6E9B 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2158   6E9C 4F                  LD      C,A             ; Resave second byte on name
2159   6E9D CD 05 68            CALL    GETCHR          ; Get next character
2160   6EA0 3A CB 90    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2161   6EA3 3D                  DEC     A
2162   6EA4 CA 4D 6F            JP      Z,ARLDSV        ; Yes - Get array name
2163   6EA7 F2 B0 6E            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2164   6EAA 7E                  LD      A,(HL)          ; Get byte again
2165   6EAB D6 28               SUB     '('             ; Subscripted variable?
2166   6EAD CA 25 6F            JP      Z,SBSCPT        ; Yes - Sort out subscript
2167   6EB0             
2168   6EB0 AF          NSCFOR: XOR     A               ; Simple variable
2169   6EB1 32 CB 90            LD      (FORFLG),A      ; Clear "FOR" flag
2170   6EB4 E5                  PUSH    HL              ; Save code string address
2171   6EB5 50                  LD      D,B             ; DE = Variable name to find
2172   6EB6 59                  LD      E,C
2173   6EB7 2A DE 90            LD      HL,(FNRGNM)     ; FN argument name
2174   6EBA CD 75 66            CALL    CPDEHL          ; Is it the FN argument?
2175   6EBD 11 E0 90            LD      DE,FNARG        ; Point to argument value
2176   6EC0 CA 95 75            JP      Z,POPHRT        ; Yes - Return FN argument value
2177   6EC3 2A D8 90            LD      HL,(VAREND)     ; End of variables
2178   6EC6 EB                  EX      DE,HL           ; Address of end of search
2179   6EC7 2A D6 90            LD      HL,(PROGND)     ; Start of variables address
2180   6ECA CD 75 66    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2181   6ECD CA E3 6E            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2182   6ED0 79                  LD      A,C             ; Get second byte of name
2183   6ED1 96                  SUB     (HL)            ; Compare with name in list
2184   6ED2 23                  INC     HL              ; Move on to first byte
2185   6ED3 C2 D8 6E            JP      NZ,FNTHR        ; Different - Find another
2186   6ED6 78                  LD      A,B             ; Get first byte of name
2187   6ED7 96                  SUB     (HL)            ; Compare with name in list
2188   6ED8 23          FNTHR:  INC     HL              ; Move on to LSB of value
2189   6ED9 CA 17 6F            JP      Z,RETADR        ; Found - Return address
2190   6EDC 23                  INC     HL              ; <- Skip
2191   6EDD 23                  INC     HL              ; <- over
2192   6EDE 23                  INC     HL              ; <- F.P.
2193   6EDF 23                  INC     HL              ; <- value
2194   6EE0 C3 CA 6E            JP      FNDVAR          ; Keep looking
2195   6EE3             
2196   6EE3 E1          CFEVAL: POP     HL              ; Restore code string address
2197   6EE4 E3                  EX      (SP),HL         ; Get return address
2198   6EE5 D5                  PUSH    DE              ; Save address of variable
2199   6EE6 11 65 6D            LD      DE,FRMEVL       ; Return address in EVAL
2200   6EE9 CD 75 66            CALL    CPDEHL          ; Called from EVAL ?
2201   6EEC D1                  POP     DE              ; Restore address of variable
2202   6EED CA 1A 6F            JP      Z,RETNUL        ; Yes - Return null variable
2203   6EF0 E3                  EX      (SP),HL         ; Put back return
2204   6EF1 E5                  PUSH    HL              ; Save code string address
2205   6EF2 C5                  PUSH    BC              ; Save variable name
2206   6EF3 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2207   6EF6 2A DA 90            LD      HL,(ARREND)     ; End of arrays
2208   6EF9 E5                  PUSH    HL              ; Save end of arrays
2209   6EFA 09                  ADD     HL,BC           ; Move up 6 bytes
2210   6EFB C1                  POP     BC              ; Source address in BC
2211   6EFC E5                  PUSH    HL              ; Save new end address
2212   6EFD CD 79 63            CALL    MOVUP           ; Move arrays up
2213   6F00 E1                  POP     HL              ; Restore new end address
2214   6F01 22 DA 90            LD      (ARREND),HL     ; Set new end address
2215   6F04 60                  LD      H,B             ; End of variables to HL
2216   6F05 69                  LD      L,C
2217   6F06 22 D8 90            LD      (VAREND),HL     ; Set new end address
2218   6F09             
2219   6F09 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2220   6F0A 36 00               LD      (HL),0          ; Zero byte in variable
2221   6F0C CD 75 66            CALL    CPDEHL          ; Done them all?
2222   6F0F C2 09 6F            JP      NZ,ZEROLP       ; No - Keep on going
2223   6F12 D1                  POP     DE              ; Get variable name
2224   6F13 73                  LD      (HL),E          ; Store second character
2225   6F14 23                  INC     HL
2226   6F15 72                  LD      (HL),D          ; Store first character
2227   6F16 23                  INC     HL
2228   6F17 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2229   6F18 E1                  POP     HL              ; Restore code string address
2230   6F19 C9                  RET
2231   6F1A             
2232   6F1A 32 E7 90    RETNUL: LD      (FPEXP),A       ; Set result to zero
2233   6F1D 21 49 63            LD      HL,ZERBYT       ; Also set a null string
2234   6F20 22 E4 90            LD      (FPREG),HL      ; Save for EVAL
2235   6F23 E1                  POP     HL              ; Restore code string address
2236   6F24 C9                  RET
2237   6F25             
2238   6F25 E5          SBSCPT: PUSH    HL              ; Save code string address
2239   6F26 2A AC 90            LD      HL,(LCRFLG)     ; Locate/Create and Type
2240   6F29 E3                  EX      (SP),HL         ; Save and get code string
2241   6F2A 57                  LD      D,A             ; Zero number of dimensions
2242   6F2B D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2243   6F2C C5                  PUSH    BC              ; Save array name
2244   6F2D CD AB 68            CALL    FPSINT          ; Get subscript (0-32767)
2245   6F30 C1                  POP     BC              ; Restore array name
2246   6F31 F1                  POP     AF              ; Get number of dimensions
2247   6F32 EB                  EX      DE,HL
2248   6F33 E3                  EX      (SP),HL         ; Save subscript value
2249   6F34 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2250   6F35 EB                  EX      DE,HL
2251   6F36 3C                  INC     A               ; Count dimensions
2252   6F37 57                  LD      D,A             ; Save in D
2253   6F38 7E                  LD      A,(HL)          ; Get next byte in code string
2254   6F39 FE 2C               CP      ','             ; Comma (more to come)?
2255   6F3B CA 2B 6F            JP      Z,SCPTLP        ; Yes - More subscripts
2256   6F3E CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
2257   6F41 29                  .BYTE      ")"
2258   6F42 22 D0 90            LD      (NXTOPR),HL     ; Save code string address
2259   6F45 E1                  POP     HL              ; Get LCRFLG and TYPE
2260   6F46 22 AC 90            LD      (LCRFLG),HL     ; Restore Locate/create & type
2261   6F49 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2262   6F4B D5                  PUSH    DE              ; Save number of dimensions (D)
2263   6F4C 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2264   6F4D             
2265   6F4D E5          ARLDSV: PUSH    HL              ; Save code string address
2266   6F4E F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2267   6F4F 2A D8 90            LD      HL,(VAREND)     ; Start of arrays
2268   6F52 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2269   6F53 19          FNDARY: ADD     HL,DE           ; Move to next array start
2270   6F54 EB                  EX      DE,HL
2271   6F55 2A DA 90            LD      HL,(ARREND)     ; End of arrays
2272   6F58 EB                  EX      DE,HL           ; Current array pointer
2273   6F59 CD 75 66            CALL    CPDEHL          ; End of arrays found?
2274   6F5C CA 85 6F            JP      Z,CREARY        ; Yes - Create array
2275   6F5F 7E                  LD      A,(HL)          ; Get second byte of name
2276   6F60 B9                  CP      C               ; Compare with name given
2277   6F61 23                  INC     HL              ; Move on
2278   6F62 C2 67 6F            JP      NZ,NXTARY       ; Different - Find next array
2279   6F65 7E                  LD      A,(HL)          ; Get first byte of name
2280   6F66 B8                  CP      B               ; Compare with name given
2281   6F67 23          NXTARY: INC     HL              ; Move on
2282   6F68 5E                  LD      E,(HL)          ; Get LSB of next array address
2283   6F69 23                  INC     HL
2284   6F6A 56                  LD      D,(HL)          ; Get MSB of next array address
2285   6F6B 23                  INC     HL
2286   6F6C C2 53 6F            JP      NZ,FNDARY       ; Not found - Keep looking
2287   6F6F 3A AC 90            LD      A,(LCRFLG)      ; Found Locate or Create it?
2288   6F72 B7                  OR      A
2289   6F73 C2 B6 63            JP      NZ,DDERR        ; Create - ?DD Error
2290   6F76 F1                  POP     AF              ; Locate - Get number of dim'ns
2291   6F77 44                  LD      B,H             ; BC Points to array dim'ns
2292   6F78 4D                  LD      C,L
2293   6F79 CA 95 75            JP      Z,POPHRT        ; Jump if array load/save
2294   6F7C 96                  SUB     (HL)            ; Same number of dimensions?
2295   6F7D CA E3 6F            JP      Z,FINDEL        ; Yes - Find element
2296   6F80 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2297   6F82 C3 C1 63            JP      ERROR           ; Output error
2298   6F85             
2299   6F85 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2300   6F88 F1                  POP     AF              ; Array to save or 0 dim'ns?
2301   6F89 CA CC 68            JP      Z,FCERR         ; Yes - ?FC Error
2302   6F8C 71                  LD      (HL),C          ; Save second byte of name
2303   6F8D 23                  INC     HL
2304   6F8E 70                  LD      (HL),B          ; Save first byte of name
2305   6F8F 23                  INC     HL
2306   6F90 4F                  LD      C,A             ; Number of dimensions to C
2307   6F91 CD 8A 63            CALL    CHKSTK          ; Check if enough memory
2308   6F94 23                  INC     HL              ; Point to number of dimensions
2309   6F95 23                  INC     HL
2310   6F96 22 C5 90            LD      (CUROPR),HL     ; Save address of pointer
2311   6F99 71                  LD      (HL),C          ; Set number of dimensions
2312   6F9A 23                  INC     HL
2313   6F9B 3A AC 90            LD      A,(LCRFLG)      ; Locate of Create?
2314   6F9E 17                  RLA                     ; Carry set = Create
2315   6F9F 79                  LD      A,C             ; Get number of dimensions
2316   6FA0 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2317   6FA3 D2 A8 6F            JP      NC,DEFSIZ       ; Locate - Set default size
2318   6FA6 C1                  POP     BC              ; Get specified dimension size
2319   6FA7 03                  INC     BC              ; Include zero element
2320   6FA8 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2321   6FA9 23                  INC     HL
2322   6FAA 70                  LD      (HL),B          ; Save MSB of dimension size
2323   6FAB 23                  INC     HL
2324   6FAC F5                  PUSH    AF              ; Save num' of dim'ns an status
2325   6FAD E5                  PUSH    HL              ; Save address of dim'n size
2326   6FAE CD 40 77            CALL    MLDEBC          ; Multiply DE by BC to find
2327   6FB1 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2328   6FB2 E1                  POP     HL              ; Restore address of dimension
2329   6FB3 F1                  POP     AF              ; Restore number of dimensions
2330   6FB4 3D                  DEC     A               ; Count them
2331   6FB5 C2 A0 6F            JP      NZ,CRARLP       ; Do next dimension if more
2332   6FB8 F5                  PUSH    AF              ; Save locate/create flag
2333   6FB9 42                  LD      B,D             ; MSB of memory needed
2334   6FBA 4B                  LD      C,E             ; LSB of memory needed
2335   6FBB EB                  EX      DE,HL
2336   6FBC 19                  ADD     HL,DE           ; Add bytes to array start
2337   6FBD DA A2 63            JP      C,OMERR         ; Too big - Error
2338   6FC0 CD 93 63            CALL    ENFMEM          ; See if enough memory
2339   6FC3 22 DA 90            LD      (ARREND),HL     ; Save new end of array
2340   6FC6             
2341   6FC6 2B          ZERARY: DEC     HL              ; Back through array data
2342   6FC7 36 00               LD      (HL),0          ; Set array element to zero
2343   6FC9 CD 75 66            CALL    CPDEHL          ; All elements zeroed?
2344   6FCC C2 C6 6F            JP      NZ,ZERARY       ; No - Keep on going
2345   6FCF 03                  INC     BC              ; Number of bytes + 1
2346   6FD0 57                  LD      D,A             ; A=0
2347   6FD1 2A C5 90            LD      HL,(CUROPR)     ; Get address of array
2348   6FD4 5E                  LD      E,(HL)          ; Number of dimensions
2349   6FD5 EB                  EX      DE,HL           ; To HL
2350   6FD6 29                  ADD     HL,HL           ; Two bytes per dimension size
2351   6FD7 09                  ADD     HL,BC           ; Add number of bytes
2352   6FD8 EB                  EX      DE,HL           ; Bytes needed to DE
2353   6FD9 2B                  DEC     HL
2354   6FDA 2B                  DEC     HL
2355   6FDB 73                  LD      (HL),E          ; Save LSB of bytes needed
2356   6FDC 23                  INC     HL
2357   6FDD 72                  LD      (HL),D          ; Save MSB of bytes needed
2358   6FDE 23                  INC     HL
2359   6FDF F1                  POP     AF              ; Locate / Create?
2360   6FE0 DA 07 70            JP      C,ENDDIM        ; A is 0 , End if create
2361   6FE3 47          FINDEL: LD      B,A             ; Find array element
2362   6FE4 4F                  LD      C,A
2363   6FE5 7E                  LD      A,(HL)          ; Number of dimensions
2364   6FE6 23                  INC     HL
2365   6FE7 16                  .BYTE      16H             ; Skip "POP HL"
2366   6FE8 E1          FNDELP: POP     HL              ; Address of next dim' size
2367   6FE9 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2368   6FEA 23                  INC     HL
2369   6FEB 56                  LD      D,(HL)          ; Get MSB of dim'n size
2370   6FEC 23                  INC     HL
2371   6FED E3                  EX      (SP),HL         ; Save address - Get index
2372   6FEE F5                  PUSH    AF              ; Save number of dim'ns
2373   6FEF CD 75 66            CALL    CPDEHL          ; Dimension too large?
2374   6FF2 D2 80 6F            JP      NC,BSERR        ; Yes - ?BS Error
2375   6FF5 E5                  PUSH    HL              ; Save index
2376   6FF6 CD 40 77            CALL    MLDEBC          ; Multiply previous by size
2377   6FF9 D1                  POP     DE              ; Index supplied to DE
2378   6FFA 19                  ADD     HL,DE           ; Add index to pointer
2379   6FFB F1                  POP     AF              ; Number of dimensions
2380   6FFC 3D                  DEC     A               ; Count them
2381   6FFD 44                  LD      B,H             ; MSB of pointer
2382   6FFE 4D                  LD      C,L             ; LSB of pointer
2383   6FFF C2 E8 6F            JP      NZ,FNDELP       ; More - Keep going
2384   7002 29                  ADD     HL,HL           ; 4 Bytes per element
2385   7003 29                  ADD     HL,HL
2386   7004 C1                  POP     BC              ; Start of array
2387   7005 09                  ADD     HL,BC           ; Point to element
2388   7006 EB                  EX      DE,HL           ; Address of element to DE
2389   7007 2A D0 90    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2390   700A C9                  RET
2391   700B             
2392   700B 2A DA 90    FRE:    LD      HL,(ARREND)     ; Start of free memory
2393   700E EB                  EX      DE,HL           ; To DE
2394   700F 21 00 00            LD      HL,0            ; End of free memory
2395   7012 39                  ADD     HL,SP           ; Current stack value
2396   7013 3A AD 90            LD      A,(TYPE)        ; Dummy argument type
2397   7016 B7                  OR      A
2398   7017 CA 27 70            JP      Z,FRENUM        ; Numeric - Free variable space
2399   701A CD 8E 72            CALL    GSTRCU          ; Current string to pool
2400   701D CD 8E 71            CALL    GARBGE          ; Garbage collection
2401   7020 2A 5A 90            LD      HL,(STRSPC)     ; Bottom of string space in use
2402   7023 EB                  EX      DE,HL           ; To DE
2403   7024 2A C3 90            LD      HL,(STRBOT)     ; Bottom of string space
2404   7027 7D          FRENUM: LD      A,L             ; Get LSB of end
2405   7028 93                  SUB     E               ; Subtract LSB of beginning
2406   7029 4F                  LD      C,A             ; Save difference if C
2407   702A 7C                  LD      A,H             ; Get MSB of end
2408   702B 9A                  SBC     A,D             ; Subtract MSB of beginning
2409   702C 41          ACPASS: LD      B,C             ; Return integer AC
2410   702D 50          ABPASS: LD      D,B             ; Return integer AB
2411   702E 1E 00               LD      E,0
2412   7030 21 AD 90            LD      HL,TYPE         ; Point to type
2413   7033 73                  LD      (HL),E          ; Set type to numeric
2414   7034 06 90               LD      B,80H+16        ; 16 bit integer
2415   7036 C3 6B 76            JP      RETINT          ; Return the integr
2416   7039             
2417   7039 3A AB 90    POS:    LD      A,(CURPOS)      ; Get cursor position
2418   703C 47          PASSA:  LD      B,A             ; Put A into AB
2419   703D AF                  XOR     A               ; Zero A
2420   703E C3 2D 70            JP      ABPASS          ; Return integer AB
2421   7041             
2422   7041 CD C4 70    DEF:    CALL    CHEKFN          ; Get "FN" and name
2423   7044 CD B6 70            CALL    IDTEST          ; Test for illegal direct
2424   7047 01 9C 69            LD      BC,DATA         ; To get next statement
2425   704A C5                  PUSH    BC              ; Save address for RETurn
2426   704B D5                  PUSH    DE              ; Save address of function ptr
2427   704C CD 7B 66            CALL    CHKSYN          ; Make sure "(" follows
2428   704F 28                  .BYTE      "("
2429   7050 CD 68 6E            CALL    GETVAR          ; Get argument variable name
2430   7053 E5                  PUSH    HL              ; Save code string address
2431   7054 EB                  EX      DE,HL           ; Argument address to HL
2432   7055 2B                  DEC     HL
2433   7056 56                  LD      D,(HL)          ; Get first byte of arg name
2434   7057 2B                  DEC     HL
2435   7058 5E                  LD      E,(HL)          ; Get second byte of arg name
2436   7059 E1                  POP     HL              ; Restore code string address
2437   705A CD 75 6C            CALL    TSTNUM          ; Make sure numeric argument
2438   705D CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
2439   7060 29                  .BYTE      ")"
2440   7061 CD 7B 66            CALL    CHKSYN          ; Make sure "=" follows
2441   7064 B4                  .BYTE      ZEQUAL          ; "=" token
2442   7065 44                  LD      B,H             ; Code string address to BC
2443   7066 4D                  LD      C,L
2444   7067 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2445   7068 71                  LD      (HL),C          ; Save LSB of FN code string
2446   7069 23                  INC     HL
2447   706A 70                  LD      (HL),B          ; Save MSB of FN code string
2448   706B C3 03 71            JP      SVSTAD          ; Save address and do function
2449   706E             
2450   706E CD C4 70    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2451   7071 D5                  PUSH    DE              ; Save function pointer address
2452   7072 CD 49 6D            CALL    EVLPAR          ; Evaluate expression in "()"
2453   7075 CD 75 6C            CALL    TSTNUM          ; Make sure numeric result
2454   7078 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2455   7079 5E                  LD      E,(HL)          ; Get LSB of FN code string
2456   707A 23                  INC     HL
2457   707B 56                  LD      D,(HL)          ; Get MSB of FN code string
2458   707C 23                  INC     HL
2459   707D 7A                  LD      A,D             ; And function DEFined?
2460   707E B3                  OR      E
2461   707F CA B9 63            JP      Z,UFERR         ; No - ?UF Error
2462   7082 7E                  LD      A,(HL)          ; Get LSB of argument address
2463   7083 23                  INC     HL
2464   7084 66                  LD      H,(HL)          ; Get MSB of argument address
2465   7085 6F                  LD      L,A             ; HL = Arg variable address
2466   7086 E5                  PUSH    HL              ; Save it
2467   7087 2A DE 90            LD      HL,(FNRGNM)     ; Get old argument name
2468   708A E3                  EX      (SP),HL ;       ; Save old , Get new
2469   708B 22 DE 90            LD      (FNRGNM),HL     ; Set new argument name
2470   708E 2A E2 90            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2471   7091 E5                  PUSH    HL              ; Save it
2472   7092 2A E0 90            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2473   7095 E5                  PUSH    HL              ; Save it
2474   7096 21 E0 90            LD      HL,FNARG        ; HL = Value of argument
2475   7099 D5                  PUSH    DE              ; Save FN code string address
2476   709A CD AC 76            CALL    FPTHL           ; Move FPREG to argument
2477   709D E1                  POP     HL              ; Get FN code string address
2478   709E CD 72 6C            CALL    GETNUM          ; Get value from function
2479   70A1 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2480   70A2 CD 05 68            CALL    GETCHR          ; Get next character
2481   70A5 C2 AD 63            JP      NZ,SNERR        ; Bad character in FN - Error
2482   70A8 E1                  POP     HL              ; Get MSB,EXP of old arg
2483   70A9 22 E0 90            LD      (FNARG),HL      ; Restore it
2484   70AC E1                  POP     HL              ; Get LSB,NLSB of old arg
2485   70AD 22 E2 90            LD      (FNARG+2),HL    ; Restore it
2486   70B0 E1                  POP     HL              ; Get name of old arg
2487   70B1 22 DE 90            LD      (FNRGNM),HL     ; Restore it
2488   70B4 E1                  POP     HL              ; Restore code string address
2489   70B5 C9                  RET
2490   70B6             
2491   70B6 E5          IDTEST: PUSH    HL              ; Save code string address
2492   70B7 2A 5C 90            LD      HL,(LINEAT)     ; Get current line number
2493   70BA 23                  INC     HL              ; -1 means direct statement
2494   70BB 7C                  LD      A,H
2495   70BC B5                  OR      L
2496   70BD E1                  POP     HL              ; Restore code string address
2497   70BE C0                  RET     NZ              ; Return if in program
2498   70BF 1E 16               LD      E,ID            ; ?ID Error
2499   70C1 C3 C1 63            JP      ERROR
2500   70C4             
2501   70C4 CD 7B 66    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2502   70C7 A7                  .BYTE      ZFN             ; "FN" token
2503   70C8 3E 80               LD      A,80H
2504   70CA 32 CB 90            LD      (FORFLG),A      ; Flag FN name to find
2505   70CD B6                  OR      (HL)            ; FN name has bit 7 set
2506   70CE 47                  LD      B,A             ; in first byte of name
2507   70CF CD 6D 6E            CALL    GTFNAM          ; Get FN name
2508   70D2 C3 75 6C            JP      TSTNUM          ; Make sure numeric function
2509   70D5             
2510   70D5 CD 75 6C    STR:    CALL    TSTNUM          ; Make sure it's a number
2511   70D8 CD F9 77            CALL    NUMASC          ; Turn number into text
2512   70DB CD 09 71    STR1:   CALL    CRTST           ; Create string entry for it
2513   70DE CD 8E 72            CALL    GSTRCU          ; Current string to pool
2514   70E1 01 E9 72            LD      BC,TOPOOL       ; Save in string pool
2515   70E4 C5                  PUSH    BC              ; Save address on stack
2516   70E5             
2517   70E5 7E          SAVSTR: LD      A,(HL)          ; Get string length
2518   70E6 23                  INC     HL
2519   70E7 23                  INC     HL
2520   70E8 E5                  PUSH    HL              ; Save pointer to string
2521   70E9 CD 64 71            CALL    TESTR           ; See if enough string space
2522   70EC E1                  POP     HL              ; Restore pointer to string
2523   70ED 4E                  LD      C,(HL)          ; Get LSB of address
2524   70EE 23                  INC     HL
2525   70EF 46                  LD      B,(HL)          ; Get MSB of address
2526   70F0 CD FD 70            CALL    CRTMST          ; Create string entry
2527   70F3 E5                  PUSH    HL              ; Save pointer to MSB of addr
2528   70F4 6F                  LD      L,A             ; Length of string
2529   70F5 CD 81 72            CALL    TOSTRA          ; Move to string area
2530   70F8 D1                  POP     DE              ; Restore pointer to MSB
2531   70F9 C9                  RET
2532   70FA             
2533   70FA CD 64 71    MKTMST: CALL    TESTR           ; See if enough string space
2534   70FD 21 BF 90    CRTMST: LD      HL,TMPSTR       ; Temporary string
2535   7100 E5                  PUSH    HL              ; Save it
2536   7101 77                  LD      (HL),A          ; Save length of string
2537   7102 23                  INC     HL
2538   7103 23          SVSTAD: INC     HL
2539   7104 73                  LD      (HL),E          ; Save LSB of address
2540   7105 23                  INC     HL
2541   7106 72                  LD      (HL),D          ; Save MSB of address
2542   7107 E1                  POP     HL              ; Restore pointer
2543   7108 C9                  RET
2544   7109             
2545   7109 2B          CRTST:  DEC     HL              ; DEC - INCed after
2546   710A 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2547   710C 50                  LD      D,B             ; Quote to D
2548   710D E5          DTSTR:  PUSH    HL              ; Save start
2549   710E 0E FF               LD      C,-1            ; Set counter to -1
2550   7110 23          QTSTLP: INC     HL              ; Move on
2551   7111 7E                  LD      A,(HL)          ; Get byte
2552   7112 0C                  INC     C               ; Count bytes
2553   7113 B7                  OR      A               ; End of line?
2554   7114 CA 1F 71            JP      Z,CRTSTE        ; Yes - Create string entry
2555   7117 BA                  CP      D               ; Terminator D found?
2556   7118 CA 1F 71            JP      Z,CRTSTE        ; Yes - Create string entry
2557   711B B8                  CP      B               ; Terminator B found?
2558   711C C2 10 71            JP      NZ,QTSTLP       ; No - Keep looking
2559   711F FE 22       CRTSTE: CP      '"'             ; End with '"'?
2560   7121 CC 05 68            CALL    Z,GETCHR        ; Yes - Get next character
2561   7124 E3                  EX      (SP),HL         ; Starting quote
2562   7125 23                  INC     HL              ; First byte of string
2563   7126 EB                  EX      DE,HL           ; To DE
2564   7127 79                  LD      A,C             ; Get length
2565   7128 CD FD 70            CALL    CRTMST          ; Create string entry
2566   712B 11 BF 90    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2567   712E 2A B1 90            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2568   7131 22 E4 90            LD      (FPREG),HL      ; Save address of string ptr
2569   7134 3E 01               LD      A,1
2570   7136 32 AD 90            LD      (TYPE),A        ; Set type to string
2571   7139 CD AF 76            CALL    DETHL4          ; Move string to pool
2572   713C CD 75 66            CALL    CPDEHL          ; Out of string pool?
2573   713F 22 B1 90            LD      (TMSTPT),HL     ; Save new pointer
2574   7142 E1                  POP     HL              ; Restore code string address
2575   7143 7E                  LD      A,(HL)          ; Get next code byte
2576   7144 C0                  RET     NZ              ; Return if pool OK
2577   7145 1E 1E               LD      E,ST            ; ?ST Error
2578   7147 C3 C1 63            JP      ERROR           ; String pool overflow
2579   714A             
2580   714A 23          PRNUMS: INC     HL              ; Skip leading space
2581   714B CD 09 71    PRS:    CALL    CRTST           ; Create string entry for it
2582   714E CD 8E 72    PRS1:   CALL    GSTRCU          ; Current string to pool
2583   7151 CD A3 76            CALL    LOADFP          ; Move string block to BCDE
2584   7154 1C                  INC     E               ; Length + 1
2585   7155 1D          PRSLP:  DEC     E               ; Count characters
2586   7156 C8                  RET     Z               ; End of string
2587   7157 0A                  LD      A,(BC)          ; Get byte to output
2588   7158 CD 86 66            CALL    OUTC            ; Output character in A
2589   715B FE 0D               CP      CR              ; Return?
2590   715D CC B7 6A            CALL    Z,DONULL        ; Yes - Do nulls
2591   7160 03                  INC     BC              ; Next byte in string
2592   7161 C3 55 71            JP      PRSLP           ; More characters to output
2593   7164             
2594   7164 B7          TESTR:  OR      A               ; Test if enough room
2595   7165 0E                  .BYTE      0EH             ; No garbage collection done
2596   7166 F1          GRBDON: POP     AF              ; Garbage collection done
2597   7167 F5                  PUSH    AF              ; Save status
2598   7168 2A 5A 90            LD      HL,(STRSPC)     ; Bottom of string space in use
2599   716B EB                  EX      DE,HL           ; To DE
2600   716C 2A C3 90            LD      HL,(STRBOT)     ; Bottom of string area
2601   716F 2F                  CPL                     ; Negate length (Top down)
2602   7170 4F                  LD      C,A             ; -Length to BC
2603   7171 06 FF               LD      B,-1            ; BC = -ve length of string
2604   7173 09                  ADD     HL,BC           ; Add to bottom of space in use
2605   7174 23                  INC     HL              ; Plus one for 2's complement
2606   7175 CD 75 66            CALL    CPDEHL          ; Below string RAM area?
2607   7178 DA 82 71            JP      C,TESTOS        ; Tidy up if not done else err
2608   717B 22 C3 90            LD      (STRBOT),HL     ; Save new bottom of area
2609   717E 23                  INC     HL              ; Point to first byte of string
2610   717F EB                  EX      DE,HL           ; Address to DE
2611   7180 F1          POPAF:  POP     AF              ; Throw away status push
2612   7181 C9                  RET
2613   7182             
2614   7182 F1          TESTOS: POP     AF              ; Garbage collect been done?
2615   7183 1E 1A               LD      E,OS            ; ?OS Error
2616   7185 CA C1 63            JP      Z,ERROR         ; Yes - Not enough string apace
2617   7188 BF                  CP      A               ; Flag garbage collect done
2618   7189 F5                  PUSH    AF              ; Save status
2619   718A 01 66 71            LD      BC,GRBDON       ; Garbage collection done
2620   718D C5                  PUSH    BC              ; Save for RETurn
2621   718E 2A AF 90    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2622   7191 22 C3 90    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2623   7194 21 00 00            LD      HL,0
2624   7197 E5                  PUSH    HL              ; Flag no string found
2625   7198 2A 5A 90            LD      HL,(STRSPC)     ; Get bottom of string space
2626   719B E5                  PUSH    HL              ; Save bottom of string space
2627   719C 21 B3 90            LD      HL,TMSTPL       ; Temporary string pool
2628   719F EB          GRBLP:  EX      DE,HL
2629   71A0 2A B1 90            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2630   71A3 EB                  EX      DE,HL
2631   71A4 CD 75 66            CALL    CPDEHL          ; Temporary string pool done?
2632   71A7 01 9F 71            LD      BC,GRBLP        ; Loop until string pool done
2633   71AA C2 F3 71            JP      NZ,STPOOL       ; No - See if in string area
2634   71AD 2A D6 90            LD      HL,(PROGND)     ; Start of simple variables
2635   71B0 EB          SMPVAR: EX      DE,HL
2636   71B1 2A D8 90            LD      HL,(VAREND)     ; End of simple variables
2637   71B4 EB                  EX      DE,HL
2638   71B5 CD 75 66            CALL    CPDEHL          ; All simple strings done?
2639   71B8 CA C6 71            JP      Z,ARRLP         ; Yes - Do string arrays
2640   71BB 7E                  LD      A,(HL)          ; Get type of variable
2641   71BC 23                  INC     HL
2642   71BD 23                  INC     HL
2643   71BE B7                  OR      A               ; "S" flag set if string
2644   71BF CD F6 71            CALL    STRADD          ; See if string in string area
2645   71C2 C3 B0 71            JP      SMPVAR          ; Loop until simple ones done
2646   71C5             
2647   71C5 C1          GNXARY: POP     BC              ; Scrap address of this array
2648   71C6 EB          ARRLP:  EX      DE,HL
2649   71C7 2A DA 90            LD      HL,(ARREND)     ; End of string arrays
2650   71CA EB                  EX      DE,HL
2651   71CB CD 75 66            CALL    CPDEHL          ; All string arrays done?
2652   71CE CA 1C 72            JP      Z,SCNEND        ; Yes - Move string if found
2653   71D1 CD A3 76            CALL    LOADFP          ; Get array name to BCDE
2654   71D4 7B                  LD      A,E             ; Get type of array     
2655   71D5 E5                  PUSH    HL              ; Save address of num of dim'ns
2656   71D6 09                  ADD     HL,BC           ; Start of next array
2657   71D7 B7                  OR      A               ; Test type of array
2658   71D8 F2 C5 71            JP      P,GNXARY        ; Numeric array - Ignore it
2659   71DB 22 C5 90            LD      (CUROPR),HL     ; Save address of next array
2660   71DE E1                  POP     HL              ; Get address of num of dim'ns
2661   71DF 4E                  LD      C,(HL)          ; BC = Number of dimensions
2662   71E0 06 00               LD      B,0
2663   71E2 09                  ADD     HL,BC           ; Two bytes per dimension size
2664   71E3 09                  ADD     HL,BC
2665   71E4 23                  INC     HL              ; Plus one for number of dim'ns
2666   71E5 EB          GRBARY: EX      DE,HL
2667   71E6 2A C5 90            LD      HL,(CUROPR)     ; Get address of next array
2668   71E9 EB                  EX      DE,HL
2669   71EA CD 75 66            CALL    CPDEHL          ; Is this array finished?
2670   71ED CA C6 71            JP      Z,ARRLP         ; Yes - Get next one
2671   71F0 01 E5 71            LD      BC,GRBARY       ; Loop until array all done
2672   71F3 C5          STPOOL: PUSH    BC              ; Save return address
2673   71F4 F6 80               OR      80H             ; Flag string type
2674   71F6 7E          STRADD: LD      A,(HL)          ; Get string length
2675   71F7 23                  INC     HL
2676   71F8 23                  INC     HL
2677   71F9 5E                  LD      E,(HL)          ; Get LSB of string address
2678   71FA 23                  INC     HL
2679   71FB 56                  LD      D,(HL)          ; Get MSB of string address
2680   71FC 23                  INC     HL
2681   71FD F0                  RET     P               ; Not a string - Return
2682   71FE B7                  OR      A               ; Set flags on string length
2683   71FF C8                  RET     Z               ; Null string - Return
2684   7200 44                  LD      B,H             ; Save variable pointer
2685   7201 4D                  LD      C,L
2686   7202 2A C3 90            LD      HL,(STRBOT)     ; Bottom of new area
2687   7205 CD 75 66            CALL    CPDEHL          ; String been done?
2688   7208 60                  LD      H,B             ; Restore variable pointer
2689   7209 69                  LD      L,C
2690   720A D8                  RET     C               ; String done - Ignore
2691   720B E1                  POP     HL              ; Return address
2692   720C E3                  EX      (SP),HL         ; Lowest available string area
2693   720D CD 75 66            CALL    CPDEHL          ; String within string area?
2694   7210 E3                  EX      (SP),HL         ; Lowest available string area
2695   7211 E5                  PUSH    HL              ; Re-save return address
2696   7212 60                  LD      H,B             ; Restore variable pointer
2697   7213 69                  LD      L,C
2698   7214 D0                  RET     NC              ; Outside string area - Ignore
2699   7215 C1                  POP     BC              ; Get return , Throw 2 away
2700   7216 F1                  POP     AF              ; 
2701   7217 F1                  POP     AF              ; 
2702   7218 E5                  PUSH    HL              ; Save variable pointer
2703   7219 D5                  PUSH    DE              ; Save address of current
2704   721A C5                  PUSH    BC              ; Put back return address
2705   721B C9                  RET                     ; Go to it
2706   721C             
2707   721C D1          SCNEND: POP     DE              ; Addresses of strings
2708   721D E1                  POP     HL              ; 
2709   721E 7D                  LD      A,L             ; HL = 0 if no more to do
2710   721F B4                  OR      H
2711   7220 C8                  RET     Z               ; No more to do - Return
2712   7221 2B                  DEC     HL
2713   7222 46                  LD      B,(HL)          ; MSB of address of string
2714   7223 2B                  DEC     HL
2715   7224 4E                  LD      C,(HL)          ; LSB of address of string
2716   7225 E5                  PUSH    HL              ; Save variable address
2717   7226 2B                  DEC     HL
2718   7227 2B                  DEC     HL
2719   7228 6E                  LD      L,(HL)          ; HL = Length of string
2720   7229 26 00               LD      H,0
2721   722B 09                  ADD     HL,BC           ; Address of end of string+1
2722   722C 50                  LD      D,B             ; String address to DE
2723   722D 59                  LD      E,C
2724   722E 2B                  DEC     HL              ; Last byte in string
2725   722F 44                  LD      B,H             ; Address to BC
2726   7230 4D                  LD      C,L
2727   7231 2A C3 90            LD      HL,(STRBOT)     ; Current bottom of string area
2728   7234 CD 7C 63            CALL    MOVSTR          ; Move string to new address
2729   7237 E1                  POP     HL              ; Restore variable address
2730   7238 71                  LD      (HL),C          ; Save new LSB of address
2731   7239 23                  INC     HL
2732   723A 70                  LD      (HL),B          ; Save new MSB of address
2733   723B 69                  LD      L,C             ; Next string area+1 to HL
2734   723C 60                  LD      H,B
2735   723D 2B                  DEC     HL              ; Next string area address
2736   723E C3 91 71            JP      GARBLP          ; Look for more strings
2737   7241             
2738   7241 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2739   7242 E5                  PUSH    HL              ; 
2740   7243 2A E4 90            LD      HL,(FPREG)      ; Get first string
2741   7246 E3                  EX      (SP),HL         ; Save first string
2742   7247 CD FB 6C            CALL    OPRND           ; Get second string
2743   724A E3                  EX      (SP),HL         ; Restore first string
2744   724B CD 76 6C            CALL    TSTSTR          ; Make sure it's a string
2745   724E 7E                  LD      A,(HL)          ; Get length of second string
2746   724F E5                  PUSH    HL              ; Save first string
2747   7250 2A E4 90            LD      HL,(FPREG)      ; Get second string
2748   7253 E5                  PUSH    HL              ; Save second string
2749   7254 86                  ADD     A,(HL)          ; Add length of second string
2750   7255 1E 1C               LD      E,LS            ; ?LS Error
2751   7257 DA C1 63            JP      C,ERROR         ; String too long - Error
2752   725A CD FA 70            CALL    MKTMST          ; Make temporary string
2753   725D D1                  POP     DE              ; Get second string to DE
2754   725E CD 92 72            CALL    GSTRDE          ; Move to string pool if needed
2755   7261 E3                  EX      (SP),HL         ; Get first string
2756   7262 CD 91 72            CALL    GSTRHL          ; Move to string pool if needed
2757   7265 E5                  PUSH    HL              ; Save first string
2758   7266 2A C1 90            LD      HL,(TMPSTR+2)   ; Temporary string address
2759   7269 EB                  EX      DE,HL           ; To DE
2760   726A CD 78 72            CALL    SSTSA           ; First string to string area
2761   726D CD 78 72            CALL    SSTSA           ; Second string to string area
2762   7270 21 90 6C            LD      HL,EVAL2        ; Return to evaluation loop
2763   7273 E3                  EX      (SP),HL         ; Save return,get code string
2764   7274 E5                  PUSH    HL              ; Save code string address
2765   7275 C3 2B 71            JP      TSTOPL          ; To temporary string to pool
2766   7278             
2767   7278 E1          SSTSA:  POP     HL              ; Return address
2768   7279 E3                  EX      (SP),HL         ; Get string block,save return
2769   727A 7E                  LD      A,(HL)          ; Get length of string
2770   727B 23                  INC     HL
2771   727C 23                  INC     HL
2772   727D 4E                  LD      C,(HL)          ; Get LSB of string address
2773   727E 23                  INC     HL
2774   727F 46                  LD      B,(HL)          ; Get MSB of string address
2775   7280 6F                  LD      L,A             ; Length to L
2776   7281 2C          TOSTRA: INC     L               ; INC - DECed after
2777   7282 2D          TSALP:  DEC     L               ; Count bytes moved
2778   7283 C8                  RET     Z               ; End of string - Return
2779   7284 0A                  LD      A,(BC)          ; Get source
2780   7285 12                  LD      (DE),A          ; Save destination
2781   7286 03                  INC     BC              ; Next source
2782   7287 13                  INC     DE              ; Next destination
2783   7288 C3 82 72            JP      TSALP           ; Loop until string moved
2784   728B             
2785   728B CD 76 6C    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2786   728E 2A E4 90    GSTRCU: LD      HL,(FPREG)      ; Get current string
2787   7291 EB          GSTRHL: EX      DE,HL           ; Save DE
2788   7292 CD AC 72    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2789   7295 EB                  EX      DE,HL           ; Restore DE
2790   7296 C0                  RET     NZ              ; No - Return
2791   7297 D5                  PUSH    DE              ; Save string
2792   7298 50                  LD      D,B             ; String block address to DE
2793   7299 59                  LD      E,C
2794   729A 1B                  DEC     DE              ; Point to length
2795   729B 4E                  LD      C,(HL)          ; Get string length
2796   729C 2A C3 90            LD      HL,(STRBOT)     ; Current bottom of string area
2797   729F CD 75 66            CALL    CPDEHL          ; Last one in string area?
2798   72A2 C2 AA 72            JP      NZ,POPHL        ; No - Return
2799   72A5 47                  LD      B,A             ; Clear B (A=0)
2800   72A6 09                  ADD     HL,BC           ; Remove string from str' area
2801   72A7 22 C3 90            LD      (STRBOT),HL     ; Save new bottom of str' area
2802   72AA E1          POPHL:  POP     HL              ; Restore string
2803   72AB C9                  RET
2804   72AC             
2805   72AC 2A B1 90    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2806   72AF 2B                  DEC     HL              ; Back
2807   72B0 46                  LD      B,(HL)          ; Get MSB of address
2808   72B1 2B                  DEC     HL              ; Back
2809   72B2 4E                  LD      C,(HL)          ; Get LSB of address
2810   72B3 2B                  DEC     HL              ; Back
2811   72B4 2B                  DEC     HL              ; Back
2812   72B5 CD 75 66            CALL    CPDEHL          ; String last in string pool?
2813   72B8 C0                  RET     NZ              ; Yes - Leave it
2814   72B9 22 B1 90            LD      (TMSTPT),HL     ; Save new string pool top
2815   72BC C9                  RET
2816   72BD             
2817   72BD 01 3C 70    LEN:    LD      BC,PASSA        ; To return integer A
2818   72C0 C5                  PUSH    BC              ; Save address
2819   72C1 CD 8B 72    GETLEN: CALL    GETSTR          ; Get string and its length
2820   72C4 AF                  XOR     A
2821   72C5 57                  LD      D,A             ; Clear D
2822   72C6 32 AD 90            LD      (TYPE),A        ; Set type to numeric
2823   72C9 7E                  LD      A,(HL)          ; Get length of string
2824   72CA B7                  OR      A               ; Set status flags
2825   72CB C9                  RET
2826   72CC             
2827   72CC 01 3C 70    ASC:    LD      BC,PASSA        ; To return integer A
2828   72CF C5                  PUSH    BC              ; Save address
2829   72D0 CD C1 72    GTFLNM: CALL    GETLEN          ; Get length of string
2830   72D3 CA CC 68            JP      Z,FCERR         ; Null string - Error
2831   72D6 23                  INC     HL
2832   72D7 23                  INC     HL
2833   72D8 5E                  LD      E,(HL)          ; Get LSB of address
2834   72D9 23                  INC     HL
2835   72DA 56                  LD      D,(HL)          ; Get MSB of address
2836   72DB 1A                  LD      A,(DE)          ; Get first byte of string
2837   72DC C9                  RET
2838   72DD             
2839   72DD 3E 01       CHR:    LD      A,1             ; One character string
2840   72DF CD FA 70            CALL    MKTMST          ; Make a temporary string
2841   72E2 CD D6 73            CALL    MAKINT          ; Make it integer A
2842   72E5 2A C1 90            LD      HL,(TMPSTR+2)   ; Get address of string
2843   72E8 73                  LD      (HL),E          ; Save character
2844   72E9 C1          TOPOOL: POP     BC              ; Clean up stack
2845   72EA C3 2B 71            JP      TSTOPL          ; Temporary string to pool
2846   72ED             
2847   72ED CD 86 73    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2848   72F0 AF                  XOR     A               ; Start at first byte in string
2849   72F1 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2850   72F2 4F                  LD      C,A             ; Starting position in string
2851   72F3 E5          MID1:   PUSH    HL              ; Save string block address
2852   72F4 7E                  LD      A,(HL)          ; Get length of string
2853   72F5 B8                  CP      B               ; Compare with number given
2854   72F6 DA FB 72            JP      C,ALLFOL        ; All following bytes required
2855   72F9 78                  LD      A,B             ; Get new length
2856   72FA 11                  .BYTE      11H             ; Skip "LD C,0"
2857   72FB 0E 00       ALLFOL: LD      C,0             ; First byte of string
2858   72FD C5                  PUSH    BC              ; Save position in string
2859   72FE CD 64 71            CALL    TESTR           ; See if enough string space
2860   7301 C1                  POP     BC              ; Get position in string
2861   7302 E1                  POP     HL              ; Restore string block address
2862   7303 E5                  PUSH    HL              ; And re-save it
2863   7304 23                  INC     HL
2864   7305 23                  INC     HL
2865   7306 46                  LD      B,(HL)          ; Get LSB of address
2866   7307 23                  INC     HL
2867   7308 66                  LD      H,(HL)          ; Get MSB of address
2868   7309 68                  LD      L,B             ; HL = address of string
2869   730A 06 00               LD      B,0             ; BC = starting address
2870   730C 09                  ADD     HL,BC           ; Point to that byte
2871   730D 44                  LD      B,H             ; BC = source string
2872   730E 4D                  LD      C,L
2873   730F CD FD 70            CALL    CRTMST          ; Create a string entry
2874   7312 6F                  LD      L,A             ; Length of new string
2875   7313 CD 81 72            CALL    TOSTRA          ; Move string to string area
2876   7316 D1                  POP     DE              ; Clear stack
2877   7317 CD 92 72            CALL    GSTRDE          ; Move to string pool if needed
2878   731A C3 2B 71            JP      TSTOPL          ; Temporary string to pool
2879   731D             
2880   731D CD 86 73    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2881   7320 D1                  POP     DE              ; Get string length
2882   7321 D5                  PUSH    DE              ; And re-save
2883   7322 1A                  LD      A,(DE)          ; Get length
2884   7323 90                  SUB     B               ; Move back N bytes
2885   7324 C3 F1 72            JP      RIGHT1          ; Go and get sub-string
2886   7327             
2887   7327 EB          MID:    EX      DE,HL           ; Get code string address
2888   7328 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2889   7329 CD 8B 73            CALL    MIDNUM          ; Get number supplied
2890   732C 04                  INC     B               ; Is it character zero?
2891   732D 05                  DEC     B
2892   732E CA CC 68            JP      Z,FCERR         ; Yes - Error
2893   7331 C5                  PUSH    BC              ; Save starting position
2894   7332 1E FF               LD      E,255           ; All of string
2895   7334 FE 29               CP      ')'             ; Any length given?
2896   7336 CA 40 73            JP      Z,RSTSTR        ; No - Rest of string
2897   7339 CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
2898   733C 2C                  .BYTE      ','
2899   733D CD D3 73            CALL    GETINT          ; Get integer 0-255
2900   7340 CD 7B 66    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2901   7343 29                  .BYTE      ")"
2902   7344 F1                  POP     AF              ; Restore starting position
2903   7345 E3                  EX      (SP),HL         ; Get string,8ave code string
2904   7346 01 F3 72            LD      BC,MID1         ; Continuation of MID$ routine
2905   7349 C5                  PUSH    BC              ; Save for return
2906   734A 3D                  DEC     A               ; Starting position-1
2907   734B BE                  CP      (HL)            ; Compare with length
2908   734C 06 00               LD      B,0             ; Zero bytes length
2909   734E D0                  RET     NC              ; Null string if start past end
2910   734F 4F                  LD      C,A             ; Save starting position-1
2911   7350 7E                  LD      A,(HL)          ; Get length of string
2912   7351 91                  SUB     C               ; Subtract start
2913   7352 BB                  CP      E               ; Enough string for it?
2914   7353 47                  LD      B,A             ; Save maximum length available
2915   7354 D8                  RET     C               ; Truncate string if needed
2916   7355 43                  LD      B,E             ; Set specified length
2917   7356 C9                  RET                     ; Go and create string
2918   7357             
2919   7357 CD C1 72    VAL:    CALL    GETLEN          ; Get length of string
2920   735A CA 74 74            JP      Z,RESZER        ; Result zero
2921   735D 5F                  LD      E,A             ; Save length
2922   735E 23                  INC     HL
2923   735F 23                  INC     HL
2924   7360 7E                  LD      A,(HL)          ; Get LSB of address
2925   7361 23                  INC     HL
2926   7362 66                  LD      H,(HL)          ; Get MSB of address
2927   7363 6F                  LD      L,A             ; HL = String address
2928   7364 E5                  PUSH    HL              ; Save string address
2929   7365 19                  ADD     HL,DE
2930   7366 46                  LD      B,(HL)          ; Get end of string+1 byte
2931   7367 72                  LD      (HL),D          ; Zero it to terminate
2932   7368 E3                  EX      (SP),HL         ; Save string end,get start
2933   7369 C5                  PUSH    BC              ; Save end+1 byte
2934   736A 7E                  LD      A,(HL)          ; Get starting byte
2935   736B FE 24           CP	'$'		; Hex number indicated? [function added]
2936   736D C2 75 73        JP	NZ,VAL1
2937   7370 CD 9F 7B        CALL	HEXTFP		; Convert Hex to FPREG
2938   7373 18 0D           JR	VAL3
2939   7375 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2940   7377 C2 7F 73        JP	NZ,VAL2
2941   737A CD 0F 7C        CALL	BINTFP		; Convert Bin to FPREG
2942   737D 18 03           JR	VAL3
2943   737F CD 5B 77    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2944   7382 C1          VAL3:   POP     BC              ; Restore end+1 byte
2945   7383 E1                  POP     HL              ; Restore end+1 address
2946   7384 70                  LD      (HL),B          ; Put back original byte
2947   7385 C9                  RET
2948   7386             
2949   7386 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2950   7387 CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
2951   738A 29                  .BYTE      ")"
2952   738B C1          MIDNUM: POP     BC              ; Get return address
2953   738C D1                  POP     DE              ; Get number supplied
2954   738D C5                  PUSH    BC              ; Re-save return address
2955   738E 43                  LD      B,E             ; Number to B
2956   738F C9                  RET
2957   7390             
2958   7390 CD D6 73    INP:    CALL    MAKINT          ; Make it integer A
2959   7393 32 3F 90            LD      (INPORT),A      ; Set input port
2960   7396 CD 3E 90            CALL    INPSUB          ; Get input from port
2961   7399 C3 3C 70            JP      PASSA           ; Return integer A
2962   739C             
2963   739C CD C0 73    POUT:   CALL    SETIO           ; Set up port number
2964   739F C3 06 90            JP      OUTSUB          ; Output data and return
2965   73A2             
2966   73A2 CD C0 73    WAIT:   CALL    SETIO           ; Set up port number
2967   73A5 F5                  PUSH    AF              ; Save AND mask
2968   73A6 1E 00               LD      E,0             ; Assume zero if none given
2969   73A8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2970   73A9 CD 05 68            CALL    GETCHR          ; Get next character
2971   73AC CA B6 73            JP      Z,NOXOR         ; No XOR byte given
2972   73AF CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
2973   73B2 2C                  .BYTE      ','
2974   73B3 CD D3 73            CALL    GETINT          ; Get integer 0-255 to XOR with
2975   73B6 C1          NOXOR:  POP     BC              ; Restore AND mask
2976   73B7 CD 3E 90    WAITLP: CALL    INPSUB          ; Get input
2977   73BA AB                  XOR     E               ; Flip selected bits
2978   73BB A0                  AND     B               ; Result non-zero?
2979   73BC CA B7 73            JP      Z,WAITLP        ; No = keep waiting
2980   73BF C9                  RET
2981   73C0             
2982   73C0 CD D3 73    SETIO:  CALL    GETINT          ; Get integer 0-255
2983   73C3 32 3F 90            LD      (INPORT),A      ; Set input port
2984   73C6 32 07 90            LD      (OTPORT),A      ; Set output port
2985   73C9 CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
2986   73CC 2C                  .BYTE      ','
2987   73CD C3 D3 73            JP      GETINT          ; Get integer 0-255 and return
2988   73D0             
2989   73D0 CD 05 68    FNDNUM: CALL    GETCHR          ; Get next character
2990   73D3 CD 72 6C    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2991   73D6 CD B1 68    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2992   73D9 7A                  LD      A,D             ; Get MSB of number
2993   73DA B7                  OR      A               ; Zero?
2994   73DB C2 CC 68            JP      NZ,FCERR        ; No - Error
2995   73DE 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2996   73DF CD 05 68            CALL    GETCHR          ; Get next character
2997   73E2 7B                  LD      A,E             ; Get number to A
2998   73E3 C9                  RET
2999   73E4             
3000   73E4 CD B7 68    PEEK:   CALL    DEINT           ; Get memory address
3001   73E7 1A                  LD      A,(DE)          ; Get byte in memory
3002   73E8 C3 3C 70            JP      PASSA           ; Return integer A
3003   73EB             
3004   73EB CD 72 6C    POKE:   CALL    GETNUM          ; Get memory address
3005   73EE CD B7 68            CALL    DEINT           ; Get integer -32768 to 3276
3006   73F1 D5                  PUSH    DE              ; Save memory address
3007   73F2 CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
3008   73F5 2C                  .BYTE      ','
3009   73F6 CD D3 73            CALL    GETINT          ; Get integer 0-255
3010   73F9 D1                  POP     DE              ; Restore memory address
3011   73FA 12                  LD      (DE),A          ; Load it into memory
3012   73FB C9                  RET
3013   73FC             
3014   73FC 21 D2 78    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3015   73FF CD A3 76    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3016   7402 C3 0E 74            JP      FPADD           ; Add BCDE to FPREG
3017   7405             
3018   7405 CD A3 76    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3019   7408 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3020   7409 C1          PSUB:   POP     BC              ; Get FP number from stack
3021   740A D1                  POP     DE
3022   740B CD 7D 76    SUBCDE: CALL    INVSGN          ; Negate FPREG
3023   740E 78          FPADD:  LD      A,B             ; Get FP exponent
3024   740F B7                  OR      A               ; Is number zero?
3025   7410 C8                  RET     Z               ; Yes - Nothing to add
3026   7411 3A E7 90            LD      A,(FPEXP)       ; Get FPREG exponent
3027   7414 B7                  OR      A               ; Is this number zero?
3028   7415 CA 95 76            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3029   7418 90                  SUB     B               ; BCDE number larger?
3030   7419 D2 28 74            JP      NC,NOSWAP       ; No - Don't swap them
3031   741C 2F                  CPL                     ; Two's complement
3032   741D 3C                  INC     A               ;  FP exponent
3033   741E EB                  EX      DE,HL
3034   741F CD 85 76            CALL    STAKFP          ; Put FPREG on stack
3035   7422 EB                  EX      DE,HL
3036   7423 CD 95 76            CALL    FPBCDE          ; Move BCDE to FPREG
3037   7426 C1                  POP     BC              ; Restore number from stack
3038   7427 D1                  POP     DE
3039   7428 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3040   742A D0                  RET     NC              ; Yes - First number is result
3041   742B F5                  PUSH    AF              ; Save number of bits to scale
3042   742C CD BA 76            CALL    SIGNS           ; Set MSBs & sign of result
3043   742F 67                  LD      H,A             ; Save sign of result
3044   7430 F1                  POP     AF              ; Restore scaling factor
3045   7431 CD D3 74            CALL    SCALE           ; Scale BCDE to same exponent
3046   7434 B4                  OR      H               ; Result to be positive?
3047   7435 21 E4 90            LD      HL,FPREG        ; Point to FPREG
3048   7438 F2 4E 74            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3049   743B CD B3 74            CALL    PLUCDE          ; Add FPREG to CDE
3050   743E D2 94 74            JP      NC,RONDUP       ; No overflow - Round it up
3051   7441 23                  INC     HL              ; Point to exponent
3052   7442 34                  INC     (HL)            ; Increment it
3053   7443 CA BC 63            JP      Z,OVERR         ; Number overflowed - Error
3054   7446 2E 01               LD      L,1             ; 1 bit to shift right
3055   7448 CD E9 74            CALL    SHRT1           ; Shift result right
3056   744B C3 94 74            JP      RONDUP          ; Round it up
3057   744E             
3058   744E AF          MINCDE: XOR     A               ; Clear A and carry
3059   744F 90                  SUB     B               ; Negate exponent
3060   7450 47                  LD      B,A             ; Re-save exponent
3061   7451 7E                  LD      A,(HL)          ; Get LSB of FPREG
3062   7452 9B                  SBC     A, E            ; Subtract LSB of BCDE
3063   7453 5F                  LD      E,A             ; Save LSB of BCDE
3064   7454 23                  INC     HL
3065   7455 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3066   7456 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3067   7457 57                  LD      D,A             ; Save NMSB of BCDE
3068   7458 23                  INC     HL
3069   7459 7E                  LD      A,(HL)          ; Get MSB of FPREG
3070   745A 99                  SBC     A,C             ; Subtract MSB of BCDE
3071   745B 4F                  LD      C,A             ; Save MSB of BCDE
3072   745C DC BF 74    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3073   745F             
3074   745F 68          BNORM:  LD      L,B             ; L = Exponent
3075   7460 63                  LD      H,E             ; H = LSB
3076   7461 AF                  XOR     A
3077   7462 47          BNRMLP: LD      B,A             ; Save bit count
3078   7463 79                  LD      A,C             ; Get MSB
3079   7464 B7                  OR      A               ; Is it zero?
3080   7465 C2 81 74            JP      NZ,PNORM        ; No - Do it bit at a time
3081   7468 4A                  LD      C,D             ; MSB = NMSB
3082   7469 54                  LD      D,H             ; NMSB= LSB
3083   746A 65                  LD      H,L             ; LSB = VLSB
3084   746B 6F                  LD      L,A             ; VLSB= 0
3085   746C 78                  LD      A,B             ; Get exponent
3086   746D D6 08               SUB     8               ; Count 8 bits
3087   746F FE E0               CP      -24-8           ; Was number zero?
3088   7471 C2 62 74            JP      NZ,BNRMLP       ; No - Keep normalising
3089   7474 AF          RESZER: XOR     A               ; Result is zero
3090   7475 32 E7 90    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3091   7478 C9                  RET
3092   7479             
3093   7479 05          NORMAL: DEC     B               ; Count bits
3094   747A 29                  ADD     HL,HL           ; Shift HL left
3095   747B 7A                  LD      A,D             ; Get NMSB
3096   747C 17                  RLA                     ; Shift left with last bit
3097   747D 57                  LD      D,A             ; Save NMSB
3098   747E 79                  LD      A,C             ; Get MSB
3099   747F 8F                  ADC     A,A             ; Shift left with last bit
3100   7480 4F                  LD      C,A             ; Save MSB
3101   7481 F2 79 74    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3102   7484 78                  LD      A,B             ; Number of bits shifted
3103   7485 5C                  LD      E,H             ; Save HL in EB
3104   7486 45                  LD      B,L
3105   7487 B7                  OR      A               ; Any shifting done?
3106   7488 CA 94 74            JP      Z,RONDUP        ; No - Round it up
3107   748B 21 E7 90            LD      HL,FPEXP        ; Point to exponent
3108   748E 86                  ADD     A,(HL)          ; Add shifted bits
3109   748F 77                  LD      (HL),A          ; Re-save exponent
3110   7490 D2 74 74            JP      NC,RESZER       ; Underflow - Result is zero
3111   7493 C8                  RET     Z               ; Result is zero
3112   7494 78          RONDUP: LD      A,B             ; Get VLSB of number
3113   7495 21 E7 90    RONDB:  LD      HL,FPEXP        ; Point to exponent
3114   7498 B7                  OR      A               ; Any rounding?
3115   7499 FC A6 74            CALL    M,FPROND        ; Yes - Round number up
3116   749C 46                  LD      B,(HL)          ; B = Exponent
3117   749D 23                  INC     HL
3118   749E 7E                  LD      A,(HL)          ; Get sign of result
3119   749F E6 80               AND     10000000B       ; Only bit 7 needed
3120   74A1 A9                  XOR     C               ; Set correct sign
3121   74A2 4F                  LD      C,A             ; Save correct sign in number
3122   74A3 C3 95 76            JP      FPBCDE          ; Move BCDE to FPREG
3123   74A6             
3124   74A6 1C          FPROND: INC     E               ; Round LSB
3125   74A7 C0                  RET     NZ              ; Return if ok
3126   74A8 14                  INC     D               ; Round NMSB
3127   74A9 C0                  RET     NZ              ; Return if ok
3128   74AA 0C                  INC     C               ; Round MSB
3129   74AB C0                  RET     NZ              ; Return if ok
3130   74AC 0E 80               LD      C,80H           ; Set normal value
3131   74AE 34                  INC     (HL)            ; Increment exponent
3132   74AF C0                  RET     NZ              ; Return if ok
3133   74B0 C3 BC 63            JP      OVERR           ; Overflow error
3134   74B3             
3135   74B3 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3136   74B4 83                  ADD     A,E             ; Add LSB of BCDE
3137   74B5 5F                  LD      E,A             ; Save LSB of BCDE
3138   74B6 23                  INC     HL
3139   74B7 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3140   74B8 8A                  ADC     A,D             ; Add NMSB of BCDE
3141   74B9 57                  LD      D,A             ; Save NMSB of BCDE
3142   74BA 23                  INC     HL
3143   74BB 7E                  LD      A,(HL)          ; Get MSB of FPREG
3144   74BC 89                  ADC     A,C             ; Add MSB of BCDE
3145   74BD 4F                  LD      C,A             ; Save MSB of BCDE
3146   74BE C9                  RET
3147   74BF             
3148   74BF 21 E8 90    COMPL:  LD      HL,SGNRES       ; Sign of result
3149   74C2 7E                  LD      A,(HL)          ; Get sign of result
3150   74C3 2F                  CPL                     ; Negate it
3151   74C4 77                  LD      (HL),A          ; Put it back
3152   74C5 AF                  XOR     A
3153   74C6 6F                  LD      L,A             ; Set L to zero
3154   74C7 90                  SUB     B               ; Negate exponent,set carry
3155   74C8 47                  LD      B,A             ; Re-save exponent
3156   74C9 7D                  LD      A,L             ; Load zero
3157   74CA 9B                  SBC     A,E             ; Negate LSB
3158   74CB 5F                  LD      E,A             ; Re-save LSB
3159   74CC 7D                  LD      A,L             ; Load zero
3160   74CD 9A                  SBC     A,D             ; Negate NMSB
3161   74CE 57                  LD      D,A             ; Re-save NMSB
3162   74CF 7D                  LD      A,L             ; Load zero
3163   74D0 99                  SBC     A,C             ; Negate MSB
3164   74D1 4F                  LD      C,A             ; Re-save MSB
3165   74D2 C9                  RET
3166   74D3             
3167   74D3 06 00       SCALE:  LD      B,0             ; Clear underflow
3168   74D5 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3169   74D7 DA E2 74            JP      C,SHRITE        ; No - Shift right A bits
3170   74DA 43                  LD      B,E             ; <- Shift
3171   74DB 5A                  LD      E,D             ; <- right
3172   74DC 51                  LD      D,C             ; <- eight
3173   74DD 0E 00               LD      C,0             ; <- bits
3174   74DF C3 D5 74            JP      SCALLP          ; More bits to shift
3175   74E2             
3176   74E2 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3177   74E4 6F                  LD      L,A             ; Save bits to shift
3178   74E5 AF          SHRLP:  XOR     A               ; Flag for all done
3179   74E6 2D                  DEC     L               ; All shifting done?
3180   74E7 C8                  RET     Z               ; Yes - Return
3181   74E8 79                  LD      A,C             ; Get MSB
3182   74E9 1F          SHRT1:  RRA                     ; Shift it right
3183   74EA 4F                  LD      C,A             ; Re-save
3184   74EB 7A                  LD      A,D             ; Get NMSB
3185   74EC 1F                  RRA                     ; Shift right with last bit
3186   74ED 57                  LD      D,A             ; Re-save it
3187   74EE 7B                  LD      A,E             ; Get LSB
3188   74EF 1F                  RRA                     ; Shift right with last bit
3189   74F0 5F                  LD      E,A             ; Re-save it
3190   74F1 78                  LD      A,B             ; Get underflow
3191   74F2 1F                  RRA                     ; Shift right with last bit
3192   74F3 47                  LD      B,A             ; Re-save underflow
3193   74F4 C3 E5 74            JP      SHRLP           ; More bits to do
3194   74F7             
3195   74F7 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3196   74FB             
3197   74FB 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3198   74FC AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3199   7500 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3200   7504 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3201   7508             
3202   7508 CD 54 76    LOG:    CALL    TSTSGN          ; Test sign of value
3203   750B B7                  OR      A
3204   750C EA CC 68            JP      PE,FCERR        ; ?FC Error if <= zero
3205   750F 21 E7 90            LD      HL,FPEXP        ; Point to exponent
3206   7512 7E                  LD      A,(HL)          ; Get exponent
3207   7513 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3208   7516 11 F3 04            LD      DE,04F3H
3209   7519 90                  SUB     B               ; Scale value to be < 1
3210   751A F5                  PUSH    AF              ; Save scale factor
3211   751B 70                  LD      (HL),B          ; Save new exponent
3212   751C D5                  PUSH    DE              ; Save SQR(1/2)
3213   751D C5                  PUSH    BC
3214   751E CD 0E 74            CALL    FPADD           ; Add SQR(1/2) to value
3215   7521 C1                  POP     BC              ; Restore SQR(1/2)
3216   7522 D1                  POP     DE
3217   7523 04                  INC     B               ; Make it SQR(2)
3218   7524 CD AA 75            CALL    DVBCDE          ; Divide by SQR(2)
3219   7527 21 F7 74            LD      HL,UNITY        ; Point to 1.
3220   752A CD 05 74            CALL    SUBPHL          ; Subtract FPREG from 1
3221   752D 21 FB 74            LD      HL,LOGTAB       ; Coefficient table
3222   7530 CD 9C 79            CALL    SUMSER          ; Evaluate sum of series
3223   7533 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3224   7536 11 00 00            LD      DE,0000H
3225   7539 CD 0E 74            CALL    FPADD           ; Subtract 0.5 from FPREG
3226   753C F1                  POP     AF              ; Restore scale factor
3227   753D CD CF 77            CALL    RSCALE          ; Re-scale number
3228   7540 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3229   7543 11 18 72            LD      DE,7218H
3230   7546 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3231   7547             
3232   7547 C1          MULT:   POP     BC              ; Get number from stack
3233   7548 D1                  POP     DE
3234   7549 CD 54 76    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3235   754C C8                  RET     Z               ; Return zero if zero
3236   754D 2E 00               LD      L,0             ; Flag add exponents
3237   754F CD 12 76            CALL    ADDEXP          ; Add exponents
3238   7552 79                  LD      A,C             ; Get MSB of multiplier
3239   7553 32 F6 90            LD      (MULVAL),A      ; Save MSB of multiplier
3240   7556 EB                  EX      DE,HL
3241   7557 22 F7 90            LD      (MULVAL+1),HL   ; Save rest of multiplier
3242   755A 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3243   755D 50                  LD      D,B
3244   755E 58                  LD      E,B
3245   755F 21 5F 74            LD      HL,BNORM        ; Address of normalise
3246   7562 E5                  PUSH    HL              ; Save for return
3247   7563 21 6B 75            LD      HL,MULT8        ; Address of 8 bit multiply
3248   7566 E5                  PUSH    HL              ; Save for NMSB,MSB
3249   7567 E5                  PUSH    HL              ; 
3250   7568 21 E4 90            LD      HL,FPREG        ; Point to number
3251   756B 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3252   756C 23                  INC     HL              ; Point to NMSB
3253   756D B7                  OR      A               ; Test LSB
3254   756E CA 97 75            JP      Z,BYTSFT        ; Zero - shift to next byte
3255   7571 E5                  PUSH    HL              ; Save address of number
3256   7572 2E 08               LD      L,8             ; 8 bits to multiply by
3257   7574 1F          MUL8LP: RRA                     ; Shift LSB right
3258   7575 67                  LD      H,A             ; Save LSB
3259   7576 79                  LD      A,C             ; Get MSB
3260   7577 D2 85 75            JP      NC,NOMADD       ; Bit was zero - Don't add
3261   757A E5                  PUSH    HL              ; Save LSB and count
3262   757B 2A F7 90            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3263   757E 19                  ADD     HL,DE           ; Add NMSB and LSB
3264   757F EB                  EX      DE,HL           ; Leave sum in DE
3265   7580 E1                  POP     HL              ; Restore MSB and count
3266   7581 3A F6 90            LD      A,(MULVAL)      ; Get MSB of multiplier
3267   7584 89                  ADC     A,C             ; Add MSB
3268   7585 1F          NOMADD: RRA                     ; Shift MSB right
3269   7586 4F                  LD      C,A             ; Re-save MSB
3270   7587 7A                  LD      A,D             ; Get NMSB
3271   7588 1F                  RRA                     ; Shift NMSB right
3272   7589 57                  LD      D,A             ; Re-save NMSB
3273   758A 7B                  LD      A,E             ; Get LSB
3274   758B 1F                  RRA                     ; Shift LSB right
3275   758C 5F                  LD      E,A             ; Re-save LSB
3276   758D 78                  LD      A,B             ; Get VLSB
3277   758E 1F                  RRA                     ; Shift VLSB right
3278   758F 47                  LD      B,A             ; Re-save VLSB
3279   7590 2D                  DEC     L               ; Count bits multiplied
3280   7591 7C                  LD      A,H             ; Get LSB of multiplier
3281   7592 C2 74 75            JP      NZ,MUL8LP       ; More - Do it
3282   7595 E1          POPHRT: POP     HL              ; Restore address of number
3283   7596 C9                  RET
3284   7597             
3285   7597 43          BYTSFT: LD      B,E             ; Shift partial product left
3286   7598 5A                  LD      E,D
3287   7599 51                  LD      D,C
3288   759A 4F                  LD      C,A
3289   759B C9                  RET
3290   759C             
3291   759C CD 85 76    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3292   759F 01 20 84            LD      BC,8420H        ; BCDE = 10.
3293   75A2 11 00 00            LD      DE,0000H
3294   75A5 CD 95 76            CALL    FPBCDE          ; Move 10 to FPREG
3295   75A8             
3296   75A8 C1          DIV:    POP     BC              ; Get number from stack
3297   75A9 D1                  POP     DE
3298   75AA CD 54 76    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3299   75AD CA B0 63            JP      Z,DZERR         ; Error if division by zero
3300   75B0 2E FF               LD      L,-1            ; Flag subtract exponents
3301   75B2 CD 12 76            CALL    ADDEXP          ; Subtract exponents
3302   75B5 34                  INC     (HL)            ; Add 2 to exponent to adjust
3303   75B6 34                  INC     (HL)
3304   75B7 2B                  DEC     HL              ; Point to MSB
3305   75B8 7E                  LD      A,(HL)          ; Get MSB of dividend
3306   75B9 32 12 90            LD      (DIV3),A        ; Save for subtraction
3307   75BC 2B                  DEC     HL
3308   75BD 7E                  LD      A,(HL)          ; Get NMSB of dividend
3309   75BE 32 0E 90            LD      (DIV2),A        ; Save for subtraction
3310   75C1 2B                  DEC     HL
3311   75C2 7E                  LD      A,(HL)          ; Get MSB of dividend
3312   75C3 32 0A 90            LD      (DIV1),A        ; Save for subtraction
3313   75C6 41                  LD      B,C             ; Get MSB
3314   75C7 EB                  EX      DE,HL           ; NMSB,LSB to HL
3315   75C8 AF                  XOR     A
3316   75C9 4F                  LD      C,A             ; Clear MSB of quotient
3317   75CA 57                  LD      D,A             ; Clear NMSB of quotient
3318   75CB 5F                  LD      E,A             ; Clear LSB of quotient
3319   75CC 32 15 90            LD      (DIV4),A        ; Clear overflow count
3320   75CF E5          DIVLP:  PUSH    HL              ; Save divisor
3321   75D0 C5                  PUSH    BC
3322   75D1 7D                  LD      A,L             ; Get LSB of number
3323   75D2 CD 09 90            CALL    DIVSUP          ; Subt' divisor from dividend
3324   75D5 DE 00               SBC     A,0             ; Count for overflows
3325   75D7 3F                  CCF
3326   75D8 D2 E2 75            JP      NC,RESDIV       ; Restore divisor if borrow
3327   75DB 32 15 90            LD      (DIV4),A        ; Re-save overflow count
3328   75DE F1                  POP     AF              ; Scrap divisor
3329   75DF F1                  POP     AF
3330   75E0 37                  SCF                     ; Set carry to
3331   75E1 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3332   75E2             
3333   75E2 C1          RESDIV: POP     BC              ; Restore divisor
3334   75E3 E1                  POP     HL
3335   75E4 79                  LD      A,C             ; Get MSB of quotient
3336   75E5 3C                  INC     A
3337   75E6 3D                  DEC     A
3338   75E7 1F                  RRA                     ; Bit 0 to bit 7
3339   75E8 FA 95 74            JP      M,RONDB         ; Done - Normalise result
3340   75EB 17                  RLA                     ; Restore carry
3341   75EC 7B                  LD      A,E             ; Get LSB of quotient
3342   75ED 17                  RLA                     ; Double it
3343   75EE 5F                  LD      E,A             ; Put it back
3344   75EF 7A                  LD      A,D             ; Get NMSB of quotient
3345   75F0 17                  RLA                     ; Double it
3346   75F1 57                  LD      D,A             ; Put it back
3347   75F2 79                  LD      A,C             ; Get MSB of quotient
3348   75F3 17                  RLA                     ; Double it
3349   75F4 4F                  LD      C,A             ; Put it back
3350   75F5 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3351   75F6 78                  LD      A,B             ; Get MSB of divisor
3352   75F7 17                  RLA                     ; Double it
3353   75F8 47                  LD      B,A             ; Put it back
3354   75F9 3A 15 90            LD      A,(DIV4)        ; Get VLSB of quotient
3355   75FC 17                  RLA                     ; Double it
3356   75FD 32 15 90            LD      (DIV4),A        ; Put it back
3357   7600 79                  LD      A,C             ; Get MSB of quotient
3358   7601 B2                  OR      D               ; Merge NMSB
3359   7602 B3                  OR      E               ; Merge LSB
3360   7603 C2 CF 75            JP      NZ,DIVLP        ; Not done - Keep dividing
3361   7606 E5                  PUSH    HL              ; Save divisor
3362   7607 21 E7 90            LD      HL,FPEXP        ; Point to exponent
3363   760A 35                  DEC     (HL)            ; Divide by 2
3364   760B E1                  POP     HL              ; Restore divisor
3365   760C C2 CF 75            JP      NZ,DIVLP        ; Ok - Keep going
3366   760F C3 BC 63            JP      OVERR           ; Overflow error
3367   7612             
3368   7612 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3369   7613 B7                  OR      A               ; Test it
3370   7614 CA 36 76            JP      Z,OVTST3        ; Zero - Result zero
3371   7617 7D                  LD      A,L             ; Get add/subtract flag
3372   7618 21 E7 90            LD      HL,FPEXP        ; Point to exponent
3373   761B AE                  XOR     (HL)            ; Add or subtract it
3374   761C 80                  ADD     A,B             ; Add the other exponent
3375   761D 47                  LD      B,A             ; Save new exponent
3376   761E 1F                  RRA                     ; Test exponent for overflow
3377   761F A8                  XOR     B
3378   7620 78                  LD      A,B             ; Get exponent
3379   7621 F2 35 76            JP      P,OVTST2        ; Positive - Test for overflow
3380   7624 C6 80               ADD     A,80H           ; Add excess 128
3381   7626 77                  LD      (HL),A          ; Save new exponent
3382   7627 CA 95 75            JP      Z,POPHRT        ; Zero - Result zero
3383   762A CD BA 76            CALL    SIGNS           ; Set MSBs and sign of result
3384   762D 77                  LD      (HL),A          ; Save new exponent
3385   762E 2B                  DEC     HL              ; Point to MSB
3386   762F C9                  RET
3387   7630             
3388   7630 CD 54 76    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3389   7633 2F                  CPL                     ; Invert sign
3390   7634 E1                  POP     HL              ; Clean up stack
3391   7635 B7          OVTST2: OR      A               ; Test if new exponent zero
3392   7636 E1          OVTST3: POP     HL              ; Clear off return address
3393   7637 F2 74 74            JP      P,RESZER        ; Result zero
3394   763A C3 BC 63            JP      OVERR           ; Overflow error
3395   763D             
3396   763D CD A0 76    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3397   7640 78                  LD      A,B             ; Get exponent
3398   7641 B7                  OR      A               ; Is it zero?
3399   7642 C8                  RET     Z               ; Yes - Result is zero
3400   7643 C6 02               ADD     A,2             ; Multiply by 4
3401   7645 DA BC 63            JP      C,OVERR         ; Overflow - ?OV Error
3402   7648 47                  LD      B,A             ; Re-save exponent
3403   7649 CD 0E 74            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3404   764C 21 E7 90            LD      HL,FPEXP        ; Point to exponent
3405   764F 34                  INC     (HL)            ; Double number (Times 10)
3406   7650 C0                  RET     NZ              ; Ok - Return
3407   7651 C3 BC 63            JP      OVERR           ; Overflow error
3408   7654             
3409   7654 3A E7 90    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3410   7657 B7                  OR      A
3411   7658 C8                  RET     Z               ; RETurn if number is zero
3412   7659 3A E6 90            LD      A,(FPREG+2)     ; Get MSB of FPREG
3413   765C FE                  .BYTE      0FEH            ; Test sign
3414   765D 2F          RETREL: CPL                     ; Invert sign
3415   765E 17                  RLA                     ; Sign bit to carry
3416   765F 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3417   7660 C0                  RET     NZ              ; Return -1 if negative
3418   7661 3C                  INC     A               ; Bump to +1
3419   7662 C9                  RET                     ; Positive - Return +1
3420   7663             
3421   7663 CD 54 76    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3422   7666 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3423   7668 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3424   766B 21 E7 90    RETINT: LD      HL,FPEXP        ; Point to exponent
3425   766E 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3426   766F 70                  LD      (HL),B          ; Save exponent
3427   7670 06 00               LD      B,0             ; CDE = integer to normalise
3428   7672 23                  INC     HL              ; Point to sign of result
3429   7673 36 80               LD      (HL),80H        ; Set sign of result
3430   7675 17                  RLA                     ; Carry = sign of integer
3431   7676 C3 5C 74            JP      CONPOS          ; Set sign of result
3432   7679             
3433   7679 CD 54 76    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3434   767C F0                  RET     P               ; Return if positive
3435   767D 21 E6 90    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3436   7680 7E                  LD      A,(HL)          ; Get sign of mantissa
3437   7681 EE 80               XOR     80H             ; Invert sign of mantissa
3438   7683 77                  LD      (HL),A          ; Re-save sign of mantissa
3439   7684 C9                  RET
3440   7685             
3441   7685 EB          STAKFP: EX      DE,HL           ; Save code string address
3442   7686 2A E4 90            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3443   7689 E3                  EX      (SP),HL         ; Stack them,get return
3444   768A E5                  PUSH    HL              ; Re-save return
3445   768B 2A E6 90            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3446   768E E3                  EX      (SP),HL         ; Stack them,get return
3447   768F E5                  PUSH    HL              ; Re-save return
3448   7690 EB                  EX      DE,HL           ; Restore code string address
3449   7691 C9                  RET
3450   7692             
3451   7692 CD A3 76    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3452   7695 EB          FPBCDE: EX      DE,HL           ; Save code string address
3453   7696 22 E4 90            LD      (FPREG),HL      ; Save LSB,NLSB of number
3454   7699 60                  LD      H,B             ; Exponent of number
3455   769A 69                  LD      L,C             ; MSB of number
3456   769B 22 E6 90            LD      (FPREG+2),HL    ; Save MSB and exponent
3457   769E EB                  EX      DE,HL           ; Restore code string address
3458   769F C9                  RET
3459   76A0             
3460   76A0 21 E4 90    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3461   76A3 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3462   76A4 23                  INC     HL
3463   76A5 56                  LD      D,(HL)          ; Get NMSB of number
3464   76A6 23                  INC     HL
3465   76A7 4E                  LD      C,(HL)          ; Get MSB of number
3466   76A8 23                  INC     HL
3467   76A9 46                  LD      B,(HL)          ; Get exponent of number
3468   76AA 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3469   76AB C9                  RET
3470   76AC             
3471   76AC 11 E4 90    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3472   76AF 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3473   76B1 1A          DETHLB: LD      A,(DE)          ; Get source
3474   76B2 77                  LD      (HL),A          ; Save destination
3475   76B3 13                  INC     DE              ; Next source
3476   76B4 23                  INC     HL              ; Next destination
3477   76B5 05                  DEC     B               ; Count bytes
3478   76B6 C2 B1 76            JP      NZ,DETHLB       ; Loop if more
3479   76B9 C9                  RET
3480   76BA             
3481   76BA 21 E6 90    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3482   76BD 7E                  LD      A,(HL)          ; Get MSB
3483   76BE 07                  RLCA                    ; Old sign to carry
3484   76BF 37                  SCF                     ; Set MSBit
3485   76C0 1F                  RRA                     ; Set MSBit of MSB
3486   76C1 77                  LD      (HL),A          ; Save new MSB
3487   76C2 3F                  CCF                     ; Complement sign
3488   76C3 1F                  RRA                     ; Old sign to carry
3489   76C4 23                  INC     HL
3490   76C5 23                  INC     HL
3491   76C6 77                  LD      (HL),A          ; Set sign of result
3492   76C7 79                  LD      A,C             ; Get MSB
3493   76C8 07                  RLCA                    ; Old sign to carry
3494   76C9 37                  SCF                     ; Set MSBit
3495   76CA 1F                  RRA                     ; Set MSBit of MSB
3496   76CB 4F                  LD      C,A             ; Save MSB
3497   76CC 1F                  RRA
3498   76CD AE                  XOR     (HL)            ; New sign of result
3499   76CE C9                  RET
3500   76CF             
3501   76CF 78          CMPNUM: LD      A,B             ; Get exponent of number
3502   76D0 B7                  OR      A
3503   76D1 CA 54 76            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3504   76D4 21 5D 76            LD      HL,RETREL       ; Return relation routine
3505   76D7 E5                  PUSH    HL              ; Save for return
3506   76D8 CD 54 76            CALL    TSTSGN          ; Test sign of FPREG
3507   76DB 79                  LD      A,C             ; Get MSB of number
3508   76DC C8                  RET     Z               ; FPREG zero - Number's MSB
3509   76DD 21 E6 90            LD      HL,FPREG+2      ; MSB of FPREG
3510   76E0 AE                  XOR     (HL)            ; Combine signs
3511   76E1 79                  LD      A,C             ; Get MSB of number
3512   76E2 F8                  RET     M               ; Exit if signs different
3513   76E3 CD E9 76            CALL    CMPFP           ; Compare FP numbers
3514   76E6 1F                  RRA                     ; Get carry to sign
3515   76E7 A9                  XOR     C               ; Combine with MSB of number
3516   76E8 C9                  RET
3517   76E9             
3518   76E9 23          CMPFP:  INC     HL              ; Point to exponent
3519   76EA 78                  LD      A,B             ; Get exponent
3520   76EB BE                  CP      (HL)            ; Compare exponents
3521   76EC C0                  RET     NZ              ; Different
3522   76ED 2B                  DEC     HL              ; Point to MBS
3523   76EE 79                  LD      A,C             ; Get MSB
3524   76EF BE                  CP      (HL)            ; Compare MSBs
3525   76F0 C0                  RET     NZ              ; Different
3526   76F1 2B                  DEC     HL              ; Point to NMSB
3527   76F2 7A                  LD      A,D             ; Get NMSB
3528   76F3 BE                  CP      (HL)            ; Compare NMSBs
3529   76F4 C0                  RET     NZ              ; Different
3530   76F5 2B                  DEC     HL              ; Point to LSB
3531   76F6 7B                  LD      A,E             ; Get LSB
3532   76F7 96                  SUB     (HL)            ; Compare LSBs
3533   76F8 C0                  RET     NZ              ; Different
3534   76F9 E1                  POP     HL              ; Drop RETurn
3535   76FA E1                  POP     HL              ; Drop another RETurn
3536   76FB C9                  RET
3537   76FC             
3538   76FC 47          FPINT:  LD      B,A             ; <- Move
3539   76FD 4F                  LD      C,A             ; <- exponent
3540   76FE 57                  LD      D,A             ; <- to all
3541   76FF 5F                  LD      E,A             ; <- bits
3542   7700 B7                  OR      A               ; Test exponent
3543   7701 C8                  RET     Z               ; Zero - Return zero
3544   7702 E5                  PUSH    HL              ; Save pointer to number
3545   7703 CD A0 76            CALL    BCDEFP          ; Move FPREG to BCDE
3546   7706 CD BA 76            CALL    SIGNS           ; Set MSBs & sign of result
3547   7709 AE                  XOR     (HL)            ; Combine with sign of FPREG
3548   770A 67                  LD      H,A             ; Save combined signs
3549   770B FC 20 77            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3550   770E 3E 98               LD      A,80H+24        ; 24 bits
3551   7710 90                  SUB     B               ; Bits to shift
3552   7711 CD D3 74            CALL    SCALE           ; Shift BCDE
3553   7714 7C                  LD      A,H             ; Get combined sign
3554   7715 17                  RLA                     ; Sign to carry
3555   7716 DC A6 74            CALL    C,FPROND        ; Negative - Round number up
3556   7719 06 00               LD      B,0             ; Zero exponent
3557   771B DC BF 74            CALL    C,COMPL         ; If negative make positive
3558   771E E1                  POP     HL              ; Restore pointer to number
3559   771F C9                  RET
3560   7720             
3561   7720 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3562   7721 7A                  LD      A,D             ; Test LSBs
3563   7722 A3                  AND     E
3564   7723 3C                  INC     A
3565   7724 C0                  RET     NZ              ; Exit if LSBs not FFFF
3566   7725 0B                  DEC     BC              ; Decrement MSBs
3567   7726 C9                  RET
3568   7727             
3569   7727 21 E7 90    INT:    LD      HL,FPEXP        ; Point to exponent
3570   772A 7E                  LD      A,(HL)          ; Get exponent
3571   772B FE 98               CP      80H+24          ; Integer accuracy only?
3572   772D 3A E4 90            LD      A,(FPREG)       ; Get LSB
3573   7730 D0                  RET     NC              ; Yes - Already integer
3574   7731 7E                  LD      A,(HL)          ; Get exponent
3575   7732 CD FC 76            CALL    FPINT           ; F.P to integer
3576   7735 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3577   7737 7B                  LD      A,E             ; Get LSB of number
3578   7738 F5                  PUSH    AF              ; Save LSB
3579   7739 79                  LD      A,C             ; Get MSB of number
3580   773A 17                  RLA                     ; Sign to carry
3581   773B CD 5C 74            CALL    CONPOS          ; Set sign of result
3582   773E F1                  POP     AF              ; Restore LSB of number
3583   773F C9                  RET
3584   7740             
3585   7740 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3586   7743 78                  LD      A,B             ; Test multiplier
3587   7744 B1                  OR      C
3588   7745 C8                  RET     Z               ; Return zero if zero
3589   7746 3E 10               LD      A,16            ; 16 bits
3590   7748 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3591   7749 DA 80 6F            JP      C,BSERR         ; ?BS Error if overflow
3592   774C EB                  EX      DE,HL
3593   774D 29                  ADD     HL,HL           ; Shift multiplier left
3594   774E EB                  EX      DE,HL
3595   774F D2 56 77            JP      NC,NOMLAD       ; Bit was zero - No add
3596   7752 09                  ADD     HL,BC           ; Add multiplicand
3597   7753 DA 80 6F            JP      C,BSERR         ; ?BS Error if overflow
3598   7756 3D          NOMLAD: DEC     A               ; Count bits
3599   7757 C2 48 77            JP      NZ,MLDBLP       ; More
3600   775A C9                  RET
3601   775B             
3602   775B FE 2D       ASCTFP: CP      '-'             ; Negative?
3603   775D F5                  PUSH    AF              ; Save it and flags
3604   775E CA 67 77            JP      Z,CNVNUM        ; Yes - Convert number
3605   7761 FE 2B               CP      '+'             ; Positive?
3606   7763 CA 67 77            JP      Z,CNVNUM        ; Yes - Convert number
3607   7766 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3608   7767 CD 74 74    CNVNUM: CALL    RESZER          ; Set result to zero
3609   776A 47                  LD      B,A             ; Digits after point counter
3610   776B 57                  LD      D,A             ; Sign of exponent
3611   776C 5F                  LD      E,A             ; Exponent of ten
3612   776D 2F                  CPL
3613   776E 4F                  LD      C,A             ; Before or after point flag
3614   776F CD 05 68    MANLP:  CALL    GETCHR          ; Get next character
3615   7772 DA B8 77            JP      C,ADDIG         ; Digit - Add to number
3616   7775 FE 2E               CP      '.'
3617   7777 CA 93 77            JP      Z,DPOINT        ; '.' - Flag point
3618   777A FE 45               CP      'E'
3619   777C C2 97 77            JP      NZ,CONEXP       ; Not 'E' - Scale number
3620   777F CD 05 68            CALL    GETCHR          ; Get next character
3621   7782 CD AB 6D            CALL    SGNEXP          ; Get sign of exponent
3622   7785 CD 05 68    EXPLP:  CALL    GETCHR          ; Get next character
3623   7788 DA DA 77            JP      C,EDIGIT        ; Digit - Add to exponent
3624   778B 14                  INC     D               ; Is sign negative?
3625   778C C2 97 77            JP      NZ,CONEXP       ; No - Scale number
3626   778F AF                  XOR     A
3627   7790 93                  SUB     E               ; Negate exponent
3628   7791 5F                  LD      E,A             ; And re-save it
3629   7792 0C                  INC     C               ; Flag end of number
3630   7793 0C          DPOINT: INC     C               ; Flag point passed
3631   7794 CA 6F 77            JP      Z,MANLP         ; Zero - Get another digit
3632   7797 E5          CONEXP: PUSH    HL              ; Save code string address
3633   7798 7B                  LD      A,E             ; Get exponent
3634   7799 90                  SUB     B               ; Subtract digits after point
3635   779A F4 B0 77    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3636   779D F2 A6 77            JP      P,ENDCON        ; Positive - All done
3637   77A0 F5                  PUSH    AF              ; Save number of times to /10
3638   77A1 CD 9C 75            CALL    DIV10           ; Divide by 10
3639   77A4 F1                  POP     AF              ; Restore count
3640   77A5 3C                  INC     A               ; Count divides
3641   77A6             
3642   77A6 C2 9A 77    ENDCON: JP      NZ,SCALMI       ; More to do
3643   77A9 D1                  POP     DE              ; Restore code string address
3644   77AA F1                  POP     AF              ; Restore sign of number
3645   77AB CC 7D 76            CALL    Z,INVSGN        ; Negative - Negate number
3646   77AE EB                  EX      DE,HL           ; Code string address to HL
3647   77AF C9                  RET
3648   77B0             
3649   77B0 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3650   77B1 F5          MULTEN: PUSH    AF              ; Save count
3651   77B2 CD 3D 76            CALL    MLSP10          ; Multiply number by 10
3652   77B5 F1                  POP     AF              ; Restore count
3653   77B6 3D                  DEC     A               ; Count multiplies
3654   77B7 C9                  RET
3655   77B8             
3656   77B8 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3657   77B9 57                  LD      D,A             ; Save digit
3658   77BA 78                  LD      A,B             ; Get digits after point
3659   77BB 89                  ADC     A,C             ; Add one if after point
3660   77BC 47                  LD      B,A             ; Re-save counter
3661   77BD C5                  PUSH    BC              ; Save point flags
3662   77BE E5                  PUSH    HL              ; Save code string address
3663   77BF D5                  PUSH    DE              ; Save digit
3664   77C0 CD 3D 76            CALL    MLSP10          ; Multiply number by 10
3665   77C3 F1                  POP     AF              ; Restore digit
3666   77C4 D6 30               SUB     '0'             ; Make it absolute
3667   77C6 CD CF 77            CALL    RSCALE          ; Re-scale number
3668   77C9 E1                  POP     HL              ; Restore code string address
3669   77CA C1                  POP     BC              ; Restore point flags
3670   77CB D1                  POP     DE              ; Restore sign of exponent
3671   77CC C3 6F 77            JP      MANLP           ; Get another digit
3672   77CF             
3673   77CF CD 85 76    RSCALE: CALL    STAKFP          ; Put number on stack
3674   77D2 CD 66 76            CALL    FLGREL          ; Digit to add to FPREG
3675   77D5 C1          PADD:   POP     BC              ; Restore number
3676   77D6 D1                  POP     DE
3677   77D7 C3 0E 74            JP      FPADD           ; Add BCDE to FPREG and return
3678   77DA             
3679   77DA 7B          EDIGIT: LD      A,E             ; Get digit
3680   77DB 07                  RLCA                    ; Times 2
3681   77DC 07                  RLCA                    ; Times 4
3682   77DD 83                  ADD     A,E             ; Times 5
3683   77DE 07                  RLCA                    ; Times 10
3684   77DF 86                  ADD     A,(HL)          ; Add next digit
3685   77E0 D6 30               SUB     '0'             ; Make it absolute
3686   77E2 5F                  LD      E,A             ; Save new digit
3687   77E3 C3 85 77            JP      EXPLP           ; Look for another digit
3688   77E6             
3689   77E6 E5          LINEIN: PUSH    HL              ; Save code string address
3690   77E7 21 45 63            LD      HL,INMSG        ; Output " in "
3691   77EA CD 4B 71            CALL    PRS             ; Output string at HL
3692   77ED E1                  POP     HL              ; Restore code string address
3693   77EE EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3694   77EF AF                  XOR     A
3695   77F0 06 98               LD      B,80H+24        ; 24 bits
3696   77F2 CD 6B 76            CALL    RETINT          ; Return the integer
3697   77F5 21 4A 71            LD      HL,PRNUMS       ; Print number string
3698   77F8 E5                  PUSH    HL              ; Save for return
3699   77F9 21 E9 90    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3700   77FC E5                  PUSH    HL              ; Save for return
3701   77FD CD 54 76            CALL    TSTSGN          ; Test sign of FPREG
3702   7800 36 20               LD      (HL),' '        ; Space at start
3703   7802 F2 07 78            JP      P,SPCFST        ; Positive - Space to start
3704   7805 36 2D               LD      (HL),'-'        ; '-' sign at start
3705   7807 23          SPCFST: INC     HL              ; First byte of number
3706   7808 36 30               LD      (HL),'0'        ; '0' if zero
3707   780A CA BD 78            JP      Z,JSTZER        ; Return '0' if zero
3708   780D E5                  PUSH    HL              ; Save buffer address
3709   780E FC 7D 76            CALL    M,INVSGN        ; Negate FPREG if negative
3710   7811 AF                  XOR     A               ; Zero A
3711   7812 F5                  PUSH    AF              ; Save it
3712   7813 CD C3 78            CALL    RNGTST          ; Test number is in range
3713   7816 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3714   7819 11 F8 4F            LD      DE,4FF8H
3715   781C CD CF 76            CALL    CMPNUM          ; Compare numbers
3716   781F B7                  OR      A
3717   7820 E2 34 78            JP      PO,INRNG        ; > 99999.9 - Sort it out
3718   7823 F1                  POP     AF              ; Restore count
3719   7824 CD B1 77            CALL    MULTEN          ; Multiply by ten
3720   7827 F5                  PUSH    AF              ; Re-save count
3721   7828 C3 16 78            JP      SIXDIG          ; Test it again
3722   782B             
3723   782B CD 9C 75    GTSIXD: CALL    DIV10           ; Divide by 10
3724   782E F1                  POP     AF              ; Get count
3725   782F 3C                  INC     A               ; Count divides
3726   7830 F5                  PUSH    AF              ; Re-save count
3727   7831 CD C3 78            CALL    RNGTST          ; Test number is in range
3728   7834 CD FC 73    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3729   7837 3C                  INC     A
3730   7838 CD FC 76            CALL    FPINT           ; F.P to integer
3731   783B CD 95 76            CALL    FPBCDE          ; Move BCDE to FPREG
3732   783E 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3733   7841 F1                  POP     AF              ; Restore count
3734   7842 81                  ADD     A,C             ; 6 digits before point
3735   7843 3C                  INC     A               ; Add one
3736   7844 FA 50 78            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3737   7847 FE 08               CP      6+1+1           ; More than 999999 ?
3738   7849 D2 50 78            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3739   784C 3C                  INC     A               ; Adjust for exponent
3740   784D 47                  LD      B,A             ; Exponent of number
3741   784E 3E 02               LD      A,2             ; Make it zero after
3742   7850             
3743   7850 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3744   7851 3D                  DEC     A
3745   7852 E1                  POP     HL              ; Restore buffer address
3746   7853 F5                  PUSH    AF              ; Save count
3747   7854 11 D6 78            LD      DE,POWERS       ; Powers of ten
3748   7857 05                  DEC     B               ; Count digits before point
3749   7858 C2 61 78            JP      NZ,DIGTXT       ; Not zero - Do number
3750   785B 36 2E               LD      (HL),'.'        ; Save point
3751   785D 23                  INC     HL              ; Move on
3752   785E 36 30               LD      (HL),'0'        ; Save zero
3753   7860 23                  INC     HL              ; Move on
3754   7861 05          DIGTXT: DEC     B               ; Count digits before point
3755   7862 36 2E               LD      (HL),'.'        ; Save point in case
3756   7864 CC AA 76            CALL    Z,INCHL         ; Last digit - move on
3757   7867 C5                  PUSH    BC              ; Save digits before point
3758   7868 E5                  PUSH    HL              ; Save buffer address
3759   7869 D5                  PUSH    DE              ; Save powers of ten
3760   786A CD A0 76            CALL    BCDEFP          ; Move FPREG to BCDE
3761   786D E1                  POP     HL              ; Powers of ten table
3762   786E 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3763   7870 04          TRYAGN: INC     B               ; Count subtractions
3764   7871 7B                  LD      A,E             ; Get LSB
3765   7872 96                  SUB     (HL)            ; Subtract LSB
3766   7873 5F                  LD      E,A             ; Save LSB
3767   7874 23                  INC     HL
3768   7875 7A                  LD      A,D             ; Get NMSB
3769   7876 9E                  SBC     A,(HL)          ; Subtract NMSB
3770   7877 57                  LD      D,A             ; Save NMSB
3771   7878 23                  INC     HL
3772   7879 79                  LD      A,C             ; Get MSB
3773   787A 9E                  SBC     A,(HL)          ; Subtract MSB
3774   787B 4F                  LD      C,A             ; Save MSB
3775   787C 2B                  DEC     HL              ; Point back to start
3776   787D 2B                  DEC     HL
3777   787E D2 70 78            JP      NC,TRYAGN       ; No overflow - Try again
3778   7881 CD B3 74            CALL    PLUCDE          ; Restore number
3779   7884 23                  INC     HL              ; Start of next number
3780   7885 CD 95 76            CALL    FPBCDE          ; Move BCDE to FPREG
3781   7888 EB                  EX      DE,HL           ; Save point in table
3782   7889 E1                  POP     HL              ; Restore buffer address
3783   788A 70                  LD      (HL),B          ; Save digit in buffer
3784   788B 23                  INC     HL              ; And move on
3785   788C C1                  POP     BC              ; Restore digit count
3786   788D 0D                  DEC     C               ; Count digits
3787   788E C2 61 78            JP      NZ,DIGTXT       ; More - Do them
3788   7891 05                  DEC     B               ; Any decimal part?
3789   7892 CA A1 78            JP      Z,DOEBIT        ; No - Do 'E' bit
3790   7895 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3791   7896 7E                  LD      A,(HL)          ; Get character
3792   7897 FE 30               CP      '0'             ; '0' character?
3793   7899 CA 95 78            JP      Z,SUPTLZ        ; Yes - Look back for more
3794   789C FE 2E               CP      '.'             ; A decimal point?
3795   789E C4 AA 76            CALL    NZ,INCHL        ; Move back over digit
3796   78A1             
3797   78A1 F1          DOEBIT: POP     AF              ; Get 'E' flag
3798   78A2 CA C0 78            JP      Z,NOENED        ; No 'E' needed - End buffer
3799   78A5 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3800   78A7 23                  INC     HL              ; And move on
3801   78A8 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3802   78AA F2 B1 78            JP      P,OUTEXP        ; Positive - Output exponent
3803   78AD 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3804   78AF 2F                  CPL                     ; Negate exponent
3805   78B0 3C                  INC     A
3806   78B1 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3807   78B3 04          EXPTEN: INC     B               ; Count subtractions
3808   78B4 D6 0A               SUB     10              ; Tens digit
3809   78B6 D2 B3 78            JP      NC,EXPTEN       ; More to do
3810   78B9 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3811   78BB 23                  INC     HL              ; Move on
3812   78BC 70                  LD      (HL),B          ; Save MSB of exponent
3813   78BD 23          JSTZER: INC     HL              ;
3814   78BE 77                  LD      (HL),A          ; Save LSB of exponent
3815   78BF 23                  INC     HL
3816   78C0 71          NOENED: LD      (HL),C          ; Mark end of buffer
3817   78C1 E1                  POP     HL              ; Restore code string address
3818   78C2 C9                  RET
3819   78C3             
3820   78C3 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3821   78C6 11 F7 23            LD      DE,23F7H
3822   78C9 CD CF 76            CALL    CMPNUM          ; Compare numbers
3823   78CC B7                  OR      A
3824   78CD E1                  POP     HL              ; Return address to HL
3825   78CE E2 2B 78            JP      PO,GTSIXD       ; Too big - Divide by ten
3826   78D1 E9                  JP      (HL)            ; Otherwise return to caller
3827   78D2             
3828   78D2 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3829   78D6             
3830   78D6 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3831   78D9 10 27 00            .BYTE      010H,027H,000H  ;  10000
3832   78DC E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3833   78DF 64 00 00            .BYTE      064H,000H,000H  ;    100
3834   78E2 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3835   78E5 01 00 00            .BYTE      001H,000H,000H  ;      1
3836   78E8             
3837   78E8 21 7D 76    NEGAFT: LD  HL,INVSGN           ; Negate result
3838   78EB E3                  EX      (SP),HL         ; To be done after caller
3839   78EC E9                  JP      (HL)            ; Return to caller
3840   78ED             
3841   78ED CD 85 76    SQR:    CALL    STAKFP          ; Put value on stack
3842   78F0 21 D2 78            LD      HL,HALF         ; Set power to 1/2
3843   78F3 CD 92 76            CALL    PHLTFP          ; Move 1/2 to FPREG
3844   78F6             
3845   78F6 C1          POWER:  POP     BC              ; Get base
3846   78F7 D1                  POP     DE
3847   78F8 CD 54 76            CALL    TSTSGN          ; Test sign of power
3848   78FB 78                  LD      A,B             ; Get exponent of base
3849   78FC CA 3B 79            JP      Z,EXP           ; Make result 1 if zero
3850   78FF F2 06 79            JP      P,POWER1        ; Positive base - Ok
3851   7902 B7                  OR      A               ; Zero to negative power?
3852   7903 CA B0 63            JP      Z,DZERR         ; Yes - ?/0 Error
3853   7906 B7          POWER1: OR      A               ; Base zero?
3854   7907 CA 75 74            JP      Z,SAVEXP        ; Yes - Return zero
3855   790A D5                  PUSH    DE              ; Save base
3856   790B C5                  PUSH    BC
3857   790C 79                  LD      A,C             ; Get MSB of base
3858   790D F6 7F               OR      01111111B       ; Get sign status
3859   790F CD A0 76            CALL    BCDEFP          ; Move power to BCDE
3860   7912 F2 23 79            JP      P,POWER2        ; Positive base - Ok
3861   7915 D5                  PUSH    DE              ; Save power
3862   7916 C5                  PUSH    BC
3863   7917 CD 27 77            CALL    INT             ; Get integer of power
3864   791A C1                  POP     BC              ; Restore power
3865   791B D1                  POP     DE
3866   791C F5                  PUSH    AF              ; MSB of base
3867   791D CD CF 76            CALL    CMPNUM          ; Power an integer?
3868   7920 E1                  POP     HL              ; Restore MSB of base
3869   7921 7C                  LD      A,H             ; but don't affect flags
3870   7922 1F                  RRA                     ; Exponent odd or even?
3871   7923 E1          POWER2: POP     HL              ; Restore MSB and exponent
3872   7924 22 E6 90            LD      (FPREG+2),HL    ; Save base in FPREG
3873   7927 E1                  POP     HL              ; LSBs of base
3874   7928 22 E4 90            LD      (FPREG),HL      ; Save in FPREG
3875   792B DC E8 78            CALL    C,NEGAFT        ; Odd power - Negate result
3876   792E CC 7D 76            CALL    Z,INVSGN        ; Negative base - Negate it
3877   7931 D5                  PUSH    DE              ; Save power
3878   7932 C5                  PUSH    BC
3879   7933 CD 08 75            CALL    LOG             ; Get LOG of base
3880   7936 C1                  POP     BC              ; Restore power
3881   7937 D1                  POP     DE
3882   7938 CD 49 75            CALL    FPMULT          ; Multiply LOG by power
3883   793B             
3884   793B CD 85 76    EXP:    CALL    STAKFP          ; Put value on stack
3885   793E 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3886   7941 11 3B AA            LD      DE,0AA3BH
3887   7944 CD 49 75            CALL    FPMULT          ; Multiply value by 1/LN(2)
3888   7947 3A E7 90            LD      A,(FPEXP)       ; Get exponent
3889   794A FE 88               CP      80H+8           ; Is it in range?
3890   794C D2 30 76            JP      NC,OVTST1       ; No - Test for overflow
3891   794F CD 27 77            CALL    INT             ; Get INT of FPREG
3892   7952 C6 80               ADD     A,80H           ; For excess 128
3893   7954 C6 02               ADD     A,2             ; Exponent > 126?
3894   7956 DA 30 76            JP      C,OVTST1        ; Yes - Test for overflow
3895   7959 F5                  PUSH    AF              ; Save scaling factor
3896   795A 21 F7 74            LD      HL,UNITY        ; Point to 1.
3897   795D CD FF 73            CALL    ADDPHL          ; Add 1 to FPREG
3898   7960 CD 40 75            CALL    MULLN2          ; Multiply by LN(2)
3899   7963 F1                  POP     AF              ; Restore scaling factor
3900   7964 C1                  POP     BC              ; Restore exponent
3901   7965 D1                  POP     DE
3902   7966 F5                  PUSH    AF              ; Save scaling factor
3903   7967 CD 0B 74            CALL    SUBCDE          ; Subtract exponent from FPREG
3904   796A CD 7D 76            CALL    INVSGN          ; Negate result
3905   796D 21 7B 79            LD      HL,EXPTAB       ; Coefficient table
3906   7970 CD AB 79            CALL    SMSER1          ; Sum the series
3907   7973 11 00 00            LD      DE,0            ; Zero LSBs
3908   7976 C1                  POP     BC              ; Scaling factor
3909   7977 4A                  LD      C,D             ; Zero MSB
3910   7978 C3 49 75            JP      FPMULT          ; Scale result to correct value
3911   797B             
3912   797B 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3913   797C 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3914   7980 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3915   7984 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3916   7988 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3917   798C 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3918   7990 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3919   7994 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3920   7998 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3921   799C             
3922   799C CD 85 76    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3923   799F 11 47 75            LD      DE,MULT         ; Multiply by "X"
3924   79A2 D5                  PUSH    DE              ; To be done after
3925   79A3 E5                  PUSH    HL              ; Save address of table
3926   79A4 CD A0 76            CALL    BCDEFP          ; Move FPREG to BCDE
3927   79A7 CD 49 75            CALL    FPMULT          ; Square the value
3928   79AA E1                  POP     HL              ; Restore address of table
3929   79AB CD 85 76    SMSER1: CALL    STAKFP          ; Put value on stack
3930   79AE 7E                  LD      A,(HL)          ; Get number of coefficients
3931   79AF 23                  INC     HL              ; Point to start of table
3932   79B0 CD 92 76            CALL    PHLTFP          ; Move coefficient to FPREG
3933   79B3 06                  .BYTE      06H             ; Skip "POP AF"
3934   79B4 F1          SUMLP:  POP     AF              ; Restore count
3935   79B5 C1                  POP     BC              ; Restore number
3936   79B6 D1                  POP     DE
3937   79B7 3D                  DEC     A               ; Cont coefficients
3938   79B8 C8                  RET     Z               ; All done
3939   79B9 D5                  PUSH    DE              ; Save number
3940   79BA C5                  PUSH    BC
3941   79BB F5                  PUSH    AF              ; Save count
3942   79BC E5                  PUSH    HL              ; Save address in table
3943   79BD CD 49 75            CALL    FPMULT          ; Multiply FPREG by BCDE
3944   79C0 E1                  POP     HL              ; Restore address in table
3945   79C1 CD A3 76            CALL    LOADFP          ; Number at HL to BCDE
3946   79C4 E5                  PUSH    HL              ; Save address in table
3947   79C5 CD 0E 74            CALL    FPADD           ; Add coefficient to FPREG
3948   79C8 E1                  POP     HL              ; Restore address in table
3949   79C9 C3 B4 79            JP      SUMLP           ; More coefficients
3950   79CC             
3951   79CC CD 54 76    RND:    CALL    TSTSGN          ; Test sign of FPREG
3952   79CF 21 19 90            LD      HL,SEED+2       ; Random number seed
3953   79D2 FA 2D 7A            JP      M,RESEED        ; Negative - Re-seed
3954   79D5 21 3A 90            LD      HL,LSTRND       ; Last random number
3955   79D8 CD 92 76            CALL    PHLTFP          ; Move last RND to FPREG
3956   79DB 21 19 90            LD      HL,SEED+2       ; Random number seed
3957   79DE C8                  RET     Z               ; Return if RND(0)
3958   79DF 86                  ADD     A,(HL)          ; Add (SEED)+2)
3959   79E0 E6 07               AND     00000111B       ; 0 to 7
3960   79E2 06 00               LD      B,0
3961   79E4 77                  LD      (HL),A          ; Re-save seed
3962   79E5 23                  INC     HL              ; Move to coefficient table
3963   79E6 87                  ADD     A,A             ; 4 bytes
3964   79E7 87                  ADD     A,A             ; per entry
3965   79E8 4F                  LD      C,A             ; BC = Offset into table
3966   79E9 09                  ADD     HL,BC           ; Point to coefficient
3967   79EA CD A3 76            CALL    LOADFP          ; Coefficient to BCDE
3968   79ED CD 49 75            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3969   79F0 3A 18 90            LD      A,(SEED+1)      ; Get (SEED+1)
3970   79F3 3C                  INC     A               ; Add 1
3971   79F4 E6 03               AND     00000011B       ; 0 to 3
3972   79F6 06 00               LD      B,0
3973   79F8 FE 01               CP      1               ; Is it zero?
3974   79FA 88                  ADC     A,B             ; Yes - Make it 1
3975   79FB 32 18 90            LD      (SEED+1),A      ; Re-save seed
3976   79FE 21 31 7A            LD      HL,RNDTAB-4     ; Addition table
3977   7A01 87                  ADD     A,A             ; 4 bytes
3978   7A02 87                  ADD     A,A             ; per entry
3979   7A03 4F                  LD      C,A             ; BC = Offset into table
3980   7A04 09                  ADD     HL,BC           ; Point to value
3981   7A05 CD FF 73            CALL    ADDPHL          ; Add value to FPREG
3982   7A08 CD A0 76    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3983   7A0B 7B                  LD      A,E             ; Get LSB
3984   7A0C 59                  LD      E,C             ; LSB = MSB
3985   7A0D EE 4F               XOR     01001111B       ; Fiddle around
3986   7A0F 4F                  LD      C,A             ; New MSB
3987   7A10 36 80               LD      (HL),80H        ; Set exponent
3988   7A12 2B                  DEC     HL              ; Point to MSB
3989   7A13 46                  LD      B,(HL)          ; Get MSB
3990   7A14 36 80               LD      (HL),80H        ; Make value -0.5
3991   7A16 21 17 90            LD      HL,SEED         ; Random number seed
3992   7A19 34                  INC     (HL)            ; Count seed
3993   7A1A 7E                  LD      A,(HL)          ; Get seed
3994   7A1B D6 AB               SUB     171             ; Do it modulo 171
3995   7A1D C2 24 7A            JP      NZ,RND2         ; Non-zero - Ok
3996   7A20 77                  LD      (HL),A          ; Zero seed
3997   7A21 0C                  INC     C               ; Fillde about
3998   7A22 15                  DEC     D               ; with the
3999   7A23 1C                  INC     E               ; number
4000   7A24 CD 5F 74    RND2:   CALL    BNORM           ; Normalise number
4001   7A27 21 3A 90            LD      HL,LSTRND       ; Save random number
4002   7A2A C3 AC 76            JP      FPTHL           ; Move FPREG to last and return
4003   7A2D             
4004   7A2D 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4005   7A2E 2B                  DEC     HL
4006   7A2F 77                  LD      (HL),A
4007   7A30 2B                  DEC     HL
4008   7A31 77                  LD      (HL),A
4009   7A32 C3 08 7A            JP      RND1            ; Return RND seed
4010   7A35             
4011   7A35 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4012   7A39 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4013   7A3D 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4014   7A41             
4015   7A41 21 8B 7A    COS:    LD      HL,HALFPI       ; Point to PI/2
4016   7A44 CD FF 73            CALL    ADDPHL          ; Add it to PPREG
4017   7A47 CD 85 76    SIN:    CALL    STAKFP          ; Put angle on stack
4018   7A4A 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4019   7A4D 11 DB 0F            LD      DE,0FDBH
4020   7A50 CD 95 76            CALL    FPBCDE          ; Move 2 PI to FPREG
4021   7A53 C1                  POP     BC              ; Restore angle
4022   7A54 D1                  POP     DE
4023   7A55 CD AA 75            CALL    DVBCDE          ; Divide angle by 2 PI
4024   7A58 CD 85 76            CALL    STAKFP          ; Put it on stack
4025   7A5B CD 27 77            CALL    INT             ; Get INT of result
4026   7A5E C1                  POP     BC              ; Restore number
4027   7A5F D1                  POP     DE
4028   7A60 CD 0B 74            CALL    SUBCDE          ; Make it 0 <= value < 1
4029   7A63 21 8F 7A            LD      HL,QUARTR       ; Point to 0.25
4030   7A66 CD 05 74            CALL    SUBPHL          ; Subtract value from 0.25
4031   7A69 CD 54 76            CALL    TSTSGN          ; Test sign of value
4032   7A6C 37                  SCF                     ; Flag positive
4033   7A6D F2 77 7A            JP      P,SIN1          ; Positive - Ok
4034   7A70 CD FC 73            CALL    ROUND           ; Add 0.5 to value
4035   7A73 CD 54 76            CALL    TSTSGN          ; Test sign of value
4036   7A76 B7                  OR      A               ; Flag negative
4037   7A77 F5          SIN1:   PUSH    AF              ; Save sign
4038   7A78 F4 7D 76            CALL    P,INVSGN        ; Negate value if positive
4039   7A7B 21 8F 7A            LD      HL,QUARTR       ; Point to 0.25
4040   7A7E CD FF 73            CALL    ADDPHL          ; Add 0.25 to value
4041   7A81 F1                  POP     AF              ; Restore sign
4042   7A82 D4 7D 76            CALL    NC,INVSGN       ; Negative - Make positive
4043   7A85 21 93 7A            LD      HL,SINTAB       ; Coefficient table
4044   7A88 C3 9C 79            JP      SUMSER          ; Evaluate sum of series
4045   7A8B             
4046   7A8B DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4047   7A8F             
4048   7A8F 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4049   7A93             
4050   7A93 05          SINTAB: .BYTE   5                       ; Table used by SIN
4051   7A94 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4052   7A98 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4053   7A9C 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4054   7AA0 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4055   7AA4 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4056   7AA8             
4057   7AA8 CD 85 76    TAN:    CALL    STAKFP          ; Put angle on stack
4058   7AAB CD 47 7A            CALL    SIN             ; Get SIN of angle
4059   7AAE C1                  POP     BC              ; Restore angle
4060   7AAF E1                  POP     HL
4061   7AB0 CD 85 76            CALL    STAKFP          ; Save SIN of angle
4062   7AB3 EB                  EX      DE,HL           ; BCDE = Angle
4063   7AB4 CD 95 76            CALL    FPBCDE          ; Angle to FPREG
4064   7AB7 CD 41 7A            CALL    COS             ; Get COS of angle
4065   7ABA C3 A8 75            JP      DIV             ; TAN = SIN / COS
4066   7ABD             
4067   7ABD CD 54 76    ATN:    CALL    TSTSGN          ; Test sign of value
4068   7AC0 FC E8 78            CALL    M,NEGAFT        ; Negate result after if -ve
4069   7AC3 FC 7D 76            CALL    M,INVSGN        ; Negate value if -ve
4070   7AC6 3A E7 90            LD      A,(FPEXP)       ; Get exponent
4071   7AC9 FE 81               CP      81H             ; Number less than 1?
4072   7ACB DA DA 7A            JP      C,ATN1          ; Yes - Get arc tangnt
4073   7ACE 01 00 81            LD      BC,8100H        ; BCDE = 1
4074   7AD1 51                  LD      D,C
4075   7AD2 59                  LD      E,C
4076   7AD3 CD AA 75            CALL    DVBCDE          ; Get reciprocal of number
4077   7AD6 21 05 74            LD      HL,SUBPHL       ; Sub angle from PI/2
4078   7AD9 E5                  PUSH    HL              ; Save for angle > 1
4079   7ADA 21 E4 7A    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4080   7ADD CD 9C 79            CALL    SUMSER          ; Evaluate sum of series
4081   7AE0 21 8B 7A            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4082   7AE3 C9                  RET                     ; Number > 1 - Sub from PI/2
4083   7AE4             
4084   7AE4 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4085   7AE5 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4086   7AE9 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4087   7AED FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4088   7AF1 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4089   7AF5 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4090   7AF9 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4091   7AFD E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4092   7B01 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4093   7B05 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4094   7B09             
4095   7B09             
4096   7B09 C9          ARET:   RET                     ; A RETurn instruction
4097   7B0A             
4098   7B0A D7          GETINP: RST	    10H             ;input a character
4099   7B0B C9                  RET
4100   7B0C             
4101   7B0C             CLS: 
4102   7B0C 3E 0C               LD      A,CS            ; ASCII Clear screen
4103   7B0E C3 46 7C            JP      MONOUT          ; Output character
4104   7B11             
4105   7B11 CD D3 73    WIDTH:  CALL    GETINT          ; Get integer 0-255
4106   7B14 7B                  LD      A,E             ; Width to A
4107   7B15 32 42 90            LD      (LWIDTH),A      ; Set width
4108   7B18 C9                  RET
4109   7B19             
4110   7B19 CD 72 6C    LINES:  CALL    GETNUM          ; Get a number
4111   7B1C CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
4112   7B1F ED 53 46 90         LD      (LINESC),DE     ; Set lines counter
4113   7B23 ED 53 48 90         LD      (LINESN),DE     ; Set lines number
4114   7B27 C9                  RET
4115   7B28             
4116   7B28 CD B7 68    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4117   7B2B D5                  PUSH    DE              ; Save number
4118   7B2C E1                  POP     HL              ; Number to HL
4119   7B2D 46                  LD      B,(HL)          ; Get LSB of contents
4120   7B2E 23                  INC     HL
4121   7B2F 7E                  LD      A,(HL)          ; Get MSB of contents
4122   7B30 C3 2D 70            JP      ABPASS          ; Return integer AB
4123   7B33             
4124   7B33 CD 72 6C    DOKE:   CALL    GETNUM          ; Get a number
4125   7B36 CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
4126   7B39 D5                  PUSH    DE              ; Save address
4127   7B3A CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
4128   7B3D 2C                  .BYTE      ','
4129   7B3E CD 72 6C            CALL    GETNUM          ; Get a number
4130   7B41 CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
4131   7B44 E3                  EX      (SP),HL         ; Save value,get address
4132   7B45 73                  LD      (HL),E          ; Save LSB of value
4133   7B46 23                  INC     HL
4134   7B47 72                  LD      (HL),D          ; Save MSB of value
4135   7B48 E1                  POP     HL              ; Restore code string address
4136   7B49 C9                  RET
4137   7B4A             
4138   7B4A             
4139   7B4A             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4140   7B4A             
4141   7B4A CD 75 6C    HEX: 	CALL	TSTNUM          ; Verify it's a number
4142   7B4D CD B7 68            CALL	DEINT           ; Get integer -32768 to 32767
4143   7B50 C5                  PUSH	BC              ; Save contents of BC
4144   7B51 21 E9 90            LD	    HL,PBUFF
4145   7B54 7A                  LD	    A,D             ; Get high order into A
4146   7B55 FE 00               CP      $0
4147   7B57 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4148   7B59 CD 82 7B            CALL    BYT2ASC         ; Convert D to ASCII
4149   7B5C 78          		LD      A,B
4150   7B5D FE 30       		CP      '0'
4151   7B5F 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4152   7B61 70                  LD	    (HL),B          ; Store it to PBUFF
4153   7B62 23                  INC	    HL              ; Next location
4154   7B63 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4155   7B64 23                  INC     HL              ; Next location
4156   7B65 7B          HEX2:   LD	    A,E             ; Get lower byte
4157   7B66 CD 82 7B            CALL    BYT2ASC         ; Convert E to ASCII
4158   7B69 7A          		LD      A,D
4159   7B6A FE 00               CP      $0
4160   7B6C 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4161   7B6E 78          		LD      A,B
4162   7B6F FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4163   7B71 28 02       		JR      Z,HEX4
4164   7B73 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4165   7B74 23                  INC     HL              ; Next location
4166   7B75 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4167   7B76 23                  INC     HL              ; PBUFF+4 to zero
4168   7B77 AF                  XOR     A               ; Terminating character
4169   7B78 77                  LD      (HL),A          ; Store zero to terminate
4170   7B79 23                  INC     HL              ; Make sure PBUFF is terminated
4171   7B7A 77                  LD      (HL),A          ; Store the double zero there
4172   7B7B C1                  POP     BC              ; Get BC back
4173   7B7C 21 E9 90            LD      HL,PBUFF        ; Reset to start of PBUFF
4174   7B7F C3 DB 70            JP      STR1            ; Convert the PBUFF to a string and return it
4175   7B82             
4176   7B82 47          BYT2ASC	LD      B,A             ; Save original value
4177   7B83 E6 0F               AND     $0F             ; Strip off upper nybble
4178   7B85 FE 0A               CP      $0A             ; 0-9?
4179   7B87 38 02               JR      C,ADD30         ; If A-F, add 7 more
4180   7B89 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4181   7B8B C6 30       ADD30	ADD     A,$30           ; And make ASCII
4182   7B8D 4F                  LD      C,A             ; Save converted char to C
4183   7B8E 78                  LD      A,B             ; Retrieve original value
4184   7B8F 0F                  RRCA                    ; and Rotate it right
4185   7B90 0F                  RRCA
4186   7B91 0F                  RRCA
4187   7B92 0F                  RRCA
4188   7B93 E6 0F               AND     $0F             ; Mask off upper nybble
4189   7B95 FE 0A               CP      $0A             ; 0-9? < A hex?
4190   7B97 38 02               JR      C,ADD301        ; Skip Add 7
4191   7B99 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4192   7B9B C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4193   7B9D 47                  LD      B,A             ; Store high order byte
4194   7B9E C9                  RET	
4195   7B9F             
4196   7B9F             ; Convert "&Hnnnn" to FPREG
4197   7B9F             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4198   7B9F             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4199   7B9F EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4200   7BA0 21 00 00            LD      HL,$0000        ; Zero out the value
4201   7BA3 CD B8 7B            CALL    GETHEX          ; Check the number for valid hex
4202   7BA6 DA D8 7B            JP      C,HXERR         ; First value wasn't hex, HX error
4203   7BA9 18 05               JR      HEXLP1          ; Convert first character
4204   7BAB CD B8 7B    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4205   7BAE 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4206   7BB0 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4207   7BB1 29                  ADD     HL,HL
4208   7BB2 29                  ADD     HL,HL
4209   7BB3 29                  ADD     HL,HL
4210   7BB4 B5                  OR      L               ; Add in D0-D3 into L
4211   7BB5 6F                  LD      L,A             ; Save new value
4212   7BB6 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4213   7BB8             
4214   7BB8 13          GETHEX  INC     DE              ; Next location
4215   7BB9 1A                  LD      A,(DE)          ; Load character at pointer
4216   7BBA FE 20               CP      ' '
4217   7BBC CA B8 7B            JP      Z,GETHEX        ; Skip spaces
4218   7BBF D6 30               SUB     $30             ; Get absolute value
4219   7BC1 D8                  RET     C               ; < "0", error
4220   7BC2 FE 0A               CP      $0A
4221   7BC4 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4222   7BC6 D6 07               SUB     $07             ; Reduce to A-F
4223   7BC8 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4224   7BCA D8                  RET     C               ; CY set if was :            ; < = > ? @
4225   7BCB FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4226   7BCD 3F                  CCF
4227   7BCE C9                  RET                     ; CY set if it wasn't valid hex
4228   7BCF                 
4229   7BCF EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4230   7BD0 7A                  LD      A,D             ; Load DE into AC
4231   7BD1 4B                  LD      C,E             ; For prep to 
4232   7BD2 E5                  PUSH    HL
4233   7BD3 CD 2C 70            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4234   7BD6 E1                  POP     HL
4235   7BD7 C9                  RET
4236   7BD8             
4237   7BD8 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4238   7BDA C3 C1 63            JP      ERROR
4239   7BDD             
4240   7BDD             ; BIN$(NN) Convert integer to a 1-16 char binary string
4241   7BDD CD 75 6C    BIN:    CALL    TSTNUM          ; Verify it's a number
4242   7BE0 CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
4243   7BE3 C5          BIN2:   PUSH    BC              ; Save contents of BC
4244   7BE4 21 E9 90            LD      HL,PBUFF
4245   7BE7 06 11               LD      B,17            ; One higher than max char count
4246   7BE9             ZEROSUP:                        ; Suppress leading zeros
4247   7BE9 05                  DEC     B               ; Max 16 chars
4248   7BEA 78                  LD      A,B
4249   7BEB FE 01               CP      $01
4250   7BED 28 08               JR      Z,BITOUT        ; Always output at least one character
4251   7BEF CB 13               RL      E
4252   7BF1 CB 12               RL      D
4253   7BF3 30 F4               JR      NC,ZEROSUP
4254   7BF5 18 04               JR      BITOUT2
4255   7BF7             BITOUT:      
4256   7BF7 CB 13               RL      E
4257   7BF9 CB 12               RL      D               ; Top bit now in carry
4258   7BFB             BITOUT2:
4259   7BFB 3E 30               LD      A,'0'           ; Char for '0'
4260   7BFD CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4261   7BFF 77                  LD      (HL),A
4262   7C00 23                  INC     HL
4263   7C01 05                  DEC     B
4264   7C02 20 F3               JR      NZ,BITOUT
4265   7C04 AF                  XOR     A               ; Terminating character
4266   7C05 77                  LD      (HL),A          ; Store zero to terminate
4267   7C06 23                  INC     HL              ; Make sure PBUFF is terminated
4268   7C07 77                  LD      (HL),A          ; Store the double zero there
4269   7C08 C1                  POP     BC
4270   7C09 21 E9 90            LD      HL,PBUFF
4271   7C0C C3 DB 70            JP      STR1
4272   7C0F             
4273   7C0F             ; Convert "&Bnnnn" to FPREG
4274   7C0F             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4275   7C0F EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4276   7C10 21 00 00            LD      HL,$0000        ; Zero out the value
4277   7C13 CD 2C 7C            CALL    CHKBIN          ; Check the number for valid bin
4278   7C16 DA 3A 7C            JP      C,BINERR        ; First value wasn't bin, HX error
4279   7C19 D6 30       BINIT:  SUB     '0'
4280   7C1B 29                  ADD     HL,HL           ; Rotate HL left
4281   7C1C B5                  OR      L
4282   7C1D 6F                  LD      L,A
4283   7C1E CD 2C 7C            CALL    CHKBIN          ; Get second and addtional characters
4284   7C21 30 F6               JR      NC,BINIT        ; Process if a bin character
4285   7C23 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4286   7C24 7A                  LD      A,D             ; Load DE into AC
4287   7C25 4B                  LD      C,E             ; For prep to 
4288   7C26 E5                  PUSH    HL
4289   7C27 CD 2C 70            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4290   7C2A E1                  POP     HL
4291   7C2B C9                  RET
4292   7C2C             
4293   7C2C             ; Char is in A, NC if char is 0 or 1
4294   7C2C 13          CHKBIN: INC     DE
4295   7C2D 1A                  LD      A,(DE)
4296   7C2E FE 20               CP      ' '
4297   7C30 CA 2C 7C            JP      Z,CHKBIN        ; Skip spaces
4298   7C33 FE 30               CP      '0'             ; Set C if < '0'
4299   7C35 D8                  RET     C
4300   7C36 FE 32               CP      '2'
4301   7C38 3F                  CCF                     ; Set C if > '1'
4302   7C39 C9                  RET
4303   7C3A             
4304   7C3A 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4305   7C3C C3 C1 63            JP      ERROR
4306   7C3F             
4307   7C3F             
4308   7C3F             JJUMP1: 
4309   7C3F DD 21 FF FF         LD      IX,-1           ; Flag cold start
4310   7C43 C3 11 60            JP      CSTART          ; Go and initialise
4311   7C46             
4312   7C46             MONOUT: 
4313   7C46 C3 08 00            JP      $0008           ; output a char
4314   7C49             
4315   7C49             
4316   7C49             MONITR: 
4317   7C49 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4318   7C4C             
4319   7C4C             
4320   7C4C 3E 00       INITST: LD      A,0             ; Clear break flag
4321   7C4E 32 4D 90            LD      (BRKFLG),A
4322   7C51 C3 18 60            JP      INIT
4323   7C54             
4324   7C54 ED 45       ARETN:  RETN                    ; Return from NMI
4325   7C56             
4326   7C56             
4327   7C56 F5          TSTBIT: PUSH    AF              ; Save bit mask
4328   7C57 A0                  AND     B               ; Get common bits
4329   7C58 C1                  POP     BC              ; Restore bit mask
4330   7C59 B8                  CP      B               ; Same bit set?
4331   7C5A 3E 00               LD      A,0             ; Return 0 in A
4332   7C5C C9                  RET
4333   7C5D             
4334   7C5D CD 86 66    OUTNCR: CALL    OUTC            ; Output character in A
4335   7C60 C3 AD 6A            JP      PRNTCRLF        ; Output CRLF
4336   7C63             
4337   7C63             .end
4338   7C63             
tasm: Number of errors = 0
