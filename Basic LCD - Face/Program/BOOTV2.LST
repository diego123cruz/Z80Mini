0001   0000             ; Diego Cruz - Nov 2022
0002   0000             ; 
0003   0000             ; bootV2: 
0004   0000             ;         - CPU Z80@4Mhz
0005   0000             ;         - Lcd Grafico 128x64
0006   0000             ;         - Keyboard 40 keys + Shift
0007   0000             ;         - Rom 32k 0000h - 7FFFh
0008   0000             ;         - Ram 32k 8000h - FFFFh
0009   0000             ;         
0010   0000             ;
0011   0000             ;         - Ports:
0012   0000             ;               - Keyboard: 40H
0013   0000             ;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
0014   0000             ;               - User IN/OUT: C0H
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------
0017   0000             LCDCTRL	    .EQU    70H
0018   0000             LCDDATA     .EQU    71H
0019   0000             KEY_IN      .EQU    40H
0020   0000             KEY_OUT     .EQU    40H
0021   0000             
0022   0000             CTRLC       .EQU    03H             ; Control "C"
0023   0000             CTRLG       .EQU    07H             ; Control "G"
0024   0000             BKSP        .EQU    08H             ; Back space
0025   0000             LF          .EQU    0AH             ; Line feed
0026   0000             VT          .equ    0BH             ; 
0027   0000             CS          .EQU    0CH             ; Clear screen
0028   0000             CR          .EQU    0DH             ; Carriage return [Enter]
0029   0000             CTRLO       .EQU    0FH             ; Control "O"
0030   0000             CTRLQ	    .EQU	11H		        ; Control "Q"
0031   0000             CTRLR       .EQU    12H             ; Control "R"
0032   0000             CTRLS       .EQU    13H             ; Control "S"
0033   0000             CTRLU       .EQU    15H             ; Control "U"
0034   0000             ESC         .EQU    1BH             ; Escape
0035   0000             DEL         .EQU    7FH             ; Delete
0036   0000             
0037   0000             KLEFT       .EQU    $B4             ; Key Left
0038   0000             KRIGHT      .EQU    $B7             ; Key Right
0039   0000             KUP         .EQU    $B5             ; Key Up
0040   0000             KDOWN       .EQU    $B6             ; Key Down
0041   0000             KF1         .EQU    $80             ; Key F1
0042   0000             KF2         .EQU    $81             ; Key F2
0043   0000             KF3         .EQU    $82             ; Key F3
0044   0000             KF4         .EQU    $83             ; Key F4
0045   0000             KF5         .EQU    $84             ; Key F5 (SHIFT)
0046   0000             KF6         .EQU    $85             ; Key F6 (SHIFT)
0047   0000             KF7         .EQU    $86             ; Key F7 (SHIFT)
0048   0000             KF8         .EQU    $87             ; Key F8 (SHIFT)
0049   0000             
0050   0000             kCPUClock:  .EQU 4000000       ;CPU clock speed in Hz
0051   0000             kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
0052   0000             kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
0053   0000             kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
0054   0000             kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
0055   0000             kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop
0056   0000             
0057   0000             BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
0058   0000             ;
0059   0000             ; BAUD RATE CONSTANTS
0060   0000             ;
0061   0000             B300:	.EQU	0220H	;300 BAUD
0062   0000             B1200:	.EQU	0080H	;1200 BAUD
0063   0000             B2400:	.EQU	003FH	;2400 BAUD
0064   0000             B4800:	.EQU	001BH	;4800 BAUD
0065   0000             B9600:	.EQU	000BH	;9600 BAUD
0066   0000             
0067   0000             SYSTEM:	.EQU 	0F000H	;INITIAL STACK POINTER
0068   0000             I2CDATA .EQU    0D000H 
0069   0000             
0070   0000             I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
0071   0000             TIMEOUT:    .EQU 10000          ;Timeout loop counter
0072   0000             
0073   0000             ADDR:       .EQU 0FEB0H   ;THE ADDRESS  2 bytes
0074   0000             ADDR_FROM   .EQU 0FEB2H   ;THE ADDRESS FROM  2 bytes
0075   0000             ADDR_TO     .EQU 0FEB4H   ;THE ADDRESS TO 2 bytes
0076   0000             ADDR_SIZE   .EQU 0FEB6H   ;THE ADDRESS SIZE 2 bytes
0077   0000             DATA:       .EQU 0FEB8H   ;THE DATA
0078   0000             MSGBUF:     .EQU 0FE00H   ;STRING HANDLING AREA
0079   0000             
0080   0000             PORT_SET        .EQU 0FFB0H ; 1 byte - Define port (input/output) Default 0xC0(onboard)
0081   0000             PORT_OUT_VAL    .EQU 0FFB1H ; 1 byte - save value out port
0082   0000             LCD_DATA        .EQU 0FFB2H ; 1byte
0083   0000             
0084   0000             I2C_ADDR        .EQU $FFC0 ; 1 byte - device address
0085   0000             I2C_RR          .EQU $FFC1 ; 1 byte - register
0086   0000             I2C_DD          .EQU $FFC2 ; 1 byte - data
0087   0000             
0088   0000             
0089   0000             BAUD:	 .EQU	0FFC0H	 ;BAUD RATE
0090   0000             PUTCH:   .EQU   0FFAAH   ;OUTPUT A CHARACTER TO SERIAL
0091   0000             GETCH:   .EQU   0FFACH   ;WAIT FOR A CHARACTER FROM SERIAL
0092   0000             
0093   0000             SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
0094   0000             SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
0095   0000             
0096   0000             
0097   0000             ; LCD TEXT MODE
0098   0000             LCD_LINE1   .EQU    80H
0099   0000             LCD_LINE2   .EQU    90H
0100   0000             LCD_LINE3   .EQU    88H
0101   0000             LCD_LINE4   .EQU    98H
0102   0000             
0103   0000             
0104   0000             ; RAM MAP
0105   0000             
0106   0000             
0107   0000             
0108   0000             LCD_CHAR            .EQU    $E000   ; 1 byte char ex: 'A'
0109   0000             LCD_CHAR_POINT      .EQU    $E001   ; 2 bytes ponteiro para o mapa de caracteres
0110   0000             LCD_TXT_X           .EQU    $E003   ; 1 byte  0-20 (21 col)
0111   0000             LCD_TXT_Y           .EQU    $E004   ; 1 byte  0-7  (8 row)
0112   0000             LCD_BYTE_INDEX      .EQU    $E005   ; 2 bytes pointer pixel(8)
0113   0000             LCD_BIT_INDEX       .EQU    $E007   ; 1 byte pointer pixel(1)
0114   0000             LCD_TXT_X_TMP       .EQU    $E008   ; 2 bytes = LCD_TXT_X * 6
0115   0000             LCD_TXT_Y_TMP       .EQU    $E00A   ; 2 bytes = LCD_TXT_Y * 128
0116   0000             LCD_CHAR_H          .EQU    $E00C   ; 1 byte altura do char
0117   0000             LCD_CHAR_W          .EQU    $E00D   ; 1 byte largura do char
0118   0000             LCD_TMP_POINT       .EQU    $E00E   ; 2 bytes ponteiro do pixel altural do print
0119   0000             LCD_DELETE_CHAR     .EQU    $E00F   ; 1 byte, 0 não, ff delete proximo char
0120   0000             LCD_AUTO_X          .EQU    $E010   ; 1 byte, 0 sim, ff nao
0121   0000             
0122   0000             DISPLAY             .EQU    $E500
0123   0000             
0124   0000             LCD_TEMP        .EQU    $E110
0125   0000             LCD_COOX        .EQU    $E102 ; 1 byte, local onde vai printar
0126   0000             LCD_COOY        .EQU    $E103 ; 1 byte
0127   0000             LCD_PRINT_H     .EQU    $E104 ; 1 byte, tamanho do que vai printar
0128   0000             LCD_PRINT_W     .EQU    $E105 ; 1 byte
0129   0000             LCD_PRINT_IMAGE .EQU    $E106 ; 2 bytes
0130   0000             
0131   0000             
0132   0000                     .ORG 0
0133   0000 F3          RST00	DI
0134   0001 C3 93 04            JP  INICIO
0135   0004             						
0136   0008                     .ORG     0008H
0137   0008 C3 43 0A    RST08   JP  PRINTCHAR
0138   000B             
0139   0010                     .ORG 0010H
0140   0010 C3 74 0D    RST10   JP KEYREADINIT
0141   0013             
0142   0018                     .ORG 0018H ; check break
0143   0018 C3 5F 0D    RST18   JP CHKKEY
0144   001B             
0145   0030                     .ORG 0030H
0146   0030 C3 48 05    RST30   JP APIHandler
0147   0033             
0148   0033             
0149   0033             KEYMAP:
0150   0033 313233343580.BYTE   "12345",KF1,"67890"
0150   0039 3637383930
0151   003E 815157455254.BYTE   KF2,"QWERT",KF3,"YUIOP"
0151   0044 825955494F50
0152   004A 834153444647.BYTE   KF4,"ASDFG",KLEFT,"HJKL", CR
0152   0050 B4484A4B4C0D
0153   0056 B6035A584356.BYTE   KDOWN,CTRLC, "ZXCV",KRIGHT,"BNM ", DEL, KUP
0153   005C B7424E4D207FB5
0154   0063             
0155   0063             SHIFTKEYMAP:
0156   0063 214023242584.BYTE   "!@#$%",KF5,"^&*()"
0156   0069 5E262A2829
0157   006E 85607E2D5F3D.BYTE   KF6,"`~-_=",KF7,"+;:'" 
0157   0074 862B3B3A27
0158   0079 22          .BYTE 22h,
0159   007A 877B7D5B5D7C.BYTE   KF8,"{}[]|",KLEFT,$5C,"<>?", CR
0159   0080 B45C3C3E3F0D
0160   0086 B61B2F2C2E20.BYTE   KDOWN,ESC,"/,. ",KRIGHT,"    ", DEL, KUP
0160   008C B7202020207FB5
0161   0093             
0162   0093             
0163   0093             
0164   0093             
0165   0093             TABLE:
0166   0093 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
0166   0099 0000
0167   009B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
0167   00A1 0000
0168   00A3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
0168   00A9 0000
0169   00AB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
0169   00B1 0000
0170   00B3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
0170   00B9 0000
0171   00BB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
0171   00C1 0000
0172   00C3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
0172   00C9 0000
0173   00CB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
0173   00D1 0000
0174   00D3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
0174   00D9 0000
0175   00DB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
0175   00E1 0000
0176   00E3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0176   00E9 0000
0177   00EB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
0177   00F1 0000
0178   00F3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0178   00F9 0000
0179   00FB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
0179   0101 0000
0180   0103 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0180   0109 0000
0181   010B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
0181   0111 0000
0182   0113 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0182   0119 0000
0183   011B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
0183   0121 0000
0184   0123 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0184   0129 0000
0185   012B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
0185   0131 0000
0186   0133 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0186   0139 0000
0187   013B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
0187   0141 0000
0188   0143 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0188   0149 0000
0189   014B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
0189   0151 0000
0190   0153 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0190   0159 0000
0191   015B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
0191   0161 0000
0192   0163 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0192   0169 0000
0193   016B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
0193   0171 0000
0194   0173 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0194   0179 0000
0195   017B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
0195   0181 0000
0196   0183 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
0196   0189 0000
0197   018B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
0197   0191 0000
0198   0193             
0199   0193             ; DEC 32
0200   0193 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
0200   0199 0000
0201   019B 202020202000.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
0201   01A1 2000
0202   01A3 505050000000.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
0202   01A9 0000
0203   01AB 5050F850F850.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
0203   01B1 5000
0204   01B3 2078A07028F0.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
0204   01B9 2000
0205   01BB C0C810204098.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
0205   01C1 1800
0206   01C3 6090A040A890.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
0206   01C9 6800
0207   01CB 202020000000.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
0207   01D1 0000
0208   01D3 102040404020.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
0208   01D9 1000
0209   01DB 402010101020.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
0209   01E1 4000
0210   01E3 0020A870A820.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0210   01E9 0000
0211   01EB 002020F82020.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
0211   01F1 0000
0212   01F3 000000006020.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0212   01F9 4000
0213   01FB 000000F80000.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
0213   0201 0000
0214   0203 000000000060.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0214   0209 6000
0215   020B 000008102040.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
0215   0211 8000
0216   0213 708898A8C888.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0216   0219 7000
0217   021B 206020202020.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
0217   0221 7000
0218   0223 708808102040.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0218   0229 F800
0219   022B F81020100888.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
0219   0231 7000
0220   0233 10305090F810.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0220   0239 1000
0221   023B F880F0080888.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
0221   0241 7000
0222   0243 304080F08888.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0222   0249 7000
0223   024B F80810204040.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
0223   0251 4000
0224   0253 708888708888.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0224   0259 7000
0225   025B 708888780810.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
0225   0261 6000
0226   0263 000030300030.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0226   0269 3000
0227   026B 003030003010.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
0227   0271 2000
0228   0273 102040804020.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0228   0279 1000
0229   027B 0000F800F800.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
0229   0281 0000
0230   0283 402010081020.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
0230   0289 4000
0231   028B 304808102000.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
0231   0291 2000
0232   0293 70880868A8A8.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
0232   0299 7000
0233   029B             
0234   029B             ; DEC 65 Maiusculas
0235   029B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0235   02A1 8800
0236   02A3 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0236   02A9 F000
0237   02AB 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0237   02B1 7000
0238   02B3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0238   02B9 E000
0239   02BB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0239   02C1 F800
0240   02C3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0240   02C9 8000
0241   02CB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0241   02D1 7000
0242   02D3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0242   02D9 8800
0243   02DB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0243   02E1 7000
0244   02E3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0244   02E9 7000
0245   02EB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0245   02F1 8800
0246   02F3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0246   02F9 F800
0247   02FB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0247   0301 8800
0248   0303 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0248   0309 8800
0249   030B 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0249   0311 7000
0250   0313 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0250   0319 8000
0251   031B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0251   0321 7000
0252   0323 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0252   0329 8800
0253   032B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0253   0331 7000
0254   0333 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0254   0339 2000
0255   033B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0255   0341 7000
0256   0343 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0256   0349 2000
0257   034B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0257   0351 8800
0258   0353 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0258   0359 8800
0259   035B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0259   0361 2000
0260   0363 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0260   0369 F800
0261   036B             
0262   036B             ; DEC 91
0263   036B 302020202020.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
0263   0371 3000
0264   0373 008040201008.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0264   0379 0000
0265   037B 602020202020.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
0265   0381 6000
0266   0383 205088000000.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
0266   0389 0000
0267   038B 000000000000.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
0267   0391 F800
0268   0393 402010000000.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
0268   0399 0000
0269   039B             
0270   039B             ; DEC 97 "Minusculas"
0271   039B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0271   03A1 8800
0272   03A3 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0272   03A9 F000
0273   03AB 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0273   03B1 7000
0274   03B3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0274   03B9 E000
0275   03BB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0275   03C1 F800
0276   03C3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0276   03C9 8000
0277   03CB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0277   03D1 7000
0278   03D3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0278   03D9 8800
0279   03DB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0279   03E1 7000
0280   03E3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0280   03E9 7000
0281   03EB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0281   03F1 8800
0282   03F3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0282   03F9 F800
0283   03FB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0283   0401 8800
0284   0403 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0284   0409 8800
0285   040B 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0285   0411 7000
0286   0413 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0286   0419 8000
0287   041B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0287   0421 7000
0288   0423 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0288   0429 8800
0289   042B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0289   0431 7000
0290   0433 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0290   0439 2000
0291   043B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0291   0441 7000
0292   0443 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0292   0449 2000
0293   044B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0293   0451 8800
0294   0453 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0294   0459 8800
0295   045B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0295   0461 2000
0296   0463 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0296   0469 F800
0297   046B             
0298   046B             ; DEC 123
0299   046B 102020402020.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0299   0471 1000
0300   0473 202020202020.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0300   0479 2000
0301   047B 402020102020.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0301   0481 4000
0302   0483 000050A00000.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0302   0489 0000
0303   048B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0303   0491 0000
0304   0493             
0305   0493             
0306   0493             
0307   0493             
0308   0493             
0309   0493             ; -----------------------------------------------------------------------------
0310   0493             ;   INICIO
0311   0493             ; -----------------------------------------------------------------------------
0312   0493             INICIO:
0313   0493 31 00 F0        LD  SP, SYSTEM
0314   0496             
0315   0496 3E 00           LD A, 0
0316   0498 32 B1 FF        LD (PORT_OUT_VAL), A
0317   049B             
0318   049B 3E C0           LD A, $c0
0319   049D 32 B0 FF        LD (PORT_SET), A
0320   04A0             
0321   04A0                 ; init serial
0322   04A0 CD 0D 0F        CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0323   04A3 21 A8 0E        LD    HL,TXDATA
0324   04A6 22 AA FF        LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0325   04A9 21 D3 0E        LD    HL,RXDATA
0326   04AC 22 AC FF        LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
0327   04AF                 
0328   04AF 21 1B 00        LD	HL,B4800
0329   04B2 22 C0 FF    	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
0330   04B5             
0331   04B5 3E FF           LD A, $FF
0332   04B7 D3 C0           OUT (SERIAL_TX_PORT), A
0333   04B9             
0334   04B9 21 F6 10        LD HL, WELLCOME
0335   04BC CD 8E 0E        CALL SNDMSG
0336   04BF             
0337   04BF                 ; CALL INCH
0338   04BF                 ; CALL OUTCH
0339   04BF             
0340   04BF                 ; Init LCD hardware
0341   04BF CD C1 0B        CALL INIT_LCD
0342   04C2 CD 50 0D        call delay
0343   04C5             
0344   04C5 CD D9 0C        call cls_TXT
0345   04C8 CD 50 0D        call delay
0346   04CB             
0347   04CB CD 63 0C        CALL enable_grafic
0348   04CE CD 50 0D        call delay
0349   04D1             
0350   04D1 CD DF 0C        call cls_GRAPHIC
0351   04D4 CD 50 0D        call delay
0352   04D7             
0353   04D7                 ;call lcd_clear
0354   04D7             
0355   04D7                 ;ld hl, DISPLAY
0356   04D7                 ;call print_image
0357   04D7             
0358   04D7                 ;call delay
0359   04D7             RESET_WARM:
0360   04D7 CD 55 0C        call lcd_clear
0361   04DA             
0362   04DA                 ; Init LCD logical
0363   04DA CD B4 09        call INIT_TXT_LCD ; set cursor X Y to 0
0364   04DD             
0365   04DD 21 0E 11        LD HL, MSG_MONITOR
0366   04E0 CD 7B 0E        CALL SNDLCDMSG
0367   04E3             
0368   04E3 3E 3E           LD A, '>'
0369   04E5 CD 43 0A        CALL PRINTCHAR
0370   04E8             
0371   04E8             KEY:
0372   04E8 CD 74 0D        CALL KEYREADINIT
0373   04EB             
0374   04EB FE 48           CP 'H'
0375   04ED CC 44 08        CALL Z, SHOWHELP
0376   04F0             
0377   04F0 FE 80           CP KF1
0378   04F2 CA 00 80        JP Z, $8000
0379   04F5             
0380   04F5 FE 81           CP KF2
0381   04F7 CA 38 08        JP Z, INTEL_HEX
0382   04FA             
0383   04FA FE 42           CP 'B'
0384   04FC CA 00 60        JP Z, BASIC
0385   04FF             
0386   04FF FE 47           CP 'G'
0387   0501 CC 06 09        CALL Z, GOJUMP
0388   0504             
0389   0504 FE 4D           CP 'M'
0390   0506 CC A4 08        CALL Z, MODIFY
0391   0509             
0392   0509 FE 44           CP 'D'
0393   050B CC 28 06        CALL Z, DSPLAY
0394   050E             
0395   050E FE 4F           CP 'O'
0396   0510 CC CB 05        CALL Z, OUTPORT
0397   0513             
0398   0513 FE 49           CP 'I'
0399   0515 CC E2 05        CALL Z, INPORT
0400   0518             
0401   0518 FE 31           CP '1'
0402   051A CC 23 0F        CALL Z, I2CLIST
0403   051D             
0404   051D FE 32           CP '2'
0405   051F CC AD 07        CALL Z, I2CCPUTOMEM
0406   0522             
0407   0522 FE 33           CP '3'
0408   0524 CC 85 07        CALL Z, I2CMEMTOCPU
0409   0527             
0410   0527 FE 34           CP '4'
0411   0529 CC A6 06        CALL Z, I2C_WR_DD
0412   052C             
0413   052C FE 35           CP '5'
0414   052E CC C9 06        CALL Z, I2C_WR_RR_DD
0415   0531             
0416   0531 FE 36           CP '6'
0417   0533 CC F5 06        CALL Z, I2C_RD
0418   0536             
0419   0536 FE 37           CP '7'
0420   0538 CC 26 07        CALL Z, I2C_RD_RR
0421   053B             
0422   053B                 
0423   053B             
0424   053B             
0425   053B             
0426   053B             
0427   053B             
0428   053B             
0429   053B             
0430   053B 3E 0D           LD A, CR 
0431   053D CD 43 0A        CALL PRINTCHAR
0432   0540 3E 3E           LD A, '>' 
0433   0542 CD 43 0A        CALL PRINTCHAR
0434   0545             
0435   0545 C3 E8 04        JP  KEY
0436   0548             
0437   0548             
0438   0548             ; **********************************************************************
0439   0548             ; **  Public functions                                                **
0440   0548             ; **********************************************************************
0441   0548             ; API: Main entry point
0442   0548             ;   On entry: C = Function number
0443   0548             ;             A, DE = Parameters (as specified by function)
0444   0548             ;   On exit:  AF,BC,DE,HL = Return values (as specified by function)
0445   0548             ;             IX IY I AF' BC' DE' HL' preserved
0446   0548             ; This handler modifies: F, B, HL but preserves A, C, DE
0447   0548             ; Other registers depend on API function called
0448   0548 21 5A 05    APIHandler: LD   HL,APITable    ;Start of function address table
0449   054B 47                      LD   B,A            ;Preserve A
0450   054C 79                      LD   A,C            ;Get function number
0451   054D FE 14                   CP   kAPILast+1     ;Supported function?
0452   054F D0                      RET  NC             ;No, so abort
0453   0550 78                      LD   A,B            ;Restore A
0454   0551 06 00                   LD   B,0
0455   0553 09                      ADD  HL,BC          ;Calculate table pointer..
0456   0554 09                      ADD  HL,BC
0457   0555 46                      LD   B,(HL)         ;Read function address from table..
0458   0556 23                      INC  HL
0459   0557 66                      LD   H,(HL)
0460   0558 68                      LD   L,B
0461   0559 E9                      JP   (HL)           ;Jump to function address
0462   055A             
0463   055A             
0464   055A             ; API: Function address table
0465   055A             ; This table contains a list of addresses, one for each API function. 
0466   055A             ; Each is the address of the subroutine for the relevant function.
0467   055A 82 05       APITable:   .DW  SysReset           ; 0x00 = System reset
0468   055C 85 05                   .DW  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
0469   055E 88 05                   .DW  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
0470   0560 8B 05                   .DW  OutLcdNewLine      ; 0x03 = Output new line LCD
0471   0562 13 06                   .DW  H_Delay            ; 0x04 = Delay in milliseconds
0472   0564 90 05                   .DW  PrtSet             ; 0x05 = Set Port (Default C0)
0473   0566 94 05                   .DW  PrtOWr             ; 0x06 = Write to output port
0474   0568 A0 05                   .DW  PrtORd             ; 0x07 = Read from output port
0475   056A A4 05                   .DW  PrtIRd             ; 0x08 = Read from input port
0476   056C 55 0A                   .DW  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
0477   056E AB 05                   .DW  DisplayImage128x64 ; 0x0A = Print image (Pointer in DE), 128x64, 1024 bytes
0478   0570 B0 05                   .DW  ClearDisplayBuffer ; 0x0B = Clear display buffer and show to lcd
0479   0572 B9 05                   .DW  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
0480   0574 82 05                   .DW  SysReset           ; 0x0D = Reserved
0481   0576 82 05                   .DW  SysReset           ; 0x0E = Reserved
0482   0578 82 05                   .DW  SysReset           ; 0x0F = Reserved
0483   057A BF 05                   .DW  I2COpen            ; 0x10 = Start i2c (Device address in A)
0484   057C C2 05                   .DW  I2CClose           ; 0x11 = Close i2c 
0485   057E C5 05                   .DW  I2CRead            ; 0x12 = I2C Read
0486   0580 C8 05                   .DW  I2CWrite           ; 0x13 = I2C Write
0487   0582             kAPILast:   .EQU $13                ;Last API function number
0488   0582             
0489   0582             
0490   0582             
0491   0582             
0492   0582             
0493   0582             
0494   0582             
0495   0582             SysReset:
0496   0582 C3 93 04        JP INICIO
0497   0585             
0498   0585             InputCharKey:
0499   0585 C3 74 0D        JP KEYREADINIT
0500   0588             
0501   0588             OutLcdChar:
0502   0588 C3 43 0A        JP PRINTCHAR
0503   058B             
0504   058B             OutLcdNewLine:
0505   058B 3E 0D           LD A, CR
0506   058D C3 43 0A        JP PRINTCHAR
0507   0590             
0508   0590             PrtSet:
0509   0590 32 B0 FF        LD (PORT_SET), A ; define a porta padrão de entrada e saida
0510   0593 C9              RET
0511   0594             
0512   0594             PrtOWr:
0513   0594 47              LD B, A
0514   0595 3A B0 FF        LD A, (PORT_SET)
0515   0598 4F              LD C, A
0516   0599 78              LD A, B
0517   059A 32 B1 FF        LD (PORT_OUT_VAL), A
0518   059D ED 79           out (C), A
0519   059F C9              RET
0520   05A0             
0521   05A0             PrtORd: ; Return value from output port
0522   05A0 3A B1 FF        LD A, (PORT_OUT_VAL)
0523   05A3 C9              RET
0524   05A4             
0525   05A4             PrtIRd: ; Return value from input
0526   05A4 3A B0 FF        LD A, (PORT_SET)
0527   05A7 4F              LD C, A
0528   05A8 ED 78           in A, (C)
0529   05AA C9              RET
0530   05AB             
0531   05AB             DisplayImage128x64:
0532   05AB 62              LD H, D
0533   05AC 6B              LD L, E
0534   05AD C3 7C 0C        JP print_image
0535   05B0             
0536   05B0             ClearDisplayBuffer:
0537   05B0 CD 55 0C        CALL lcd_clear
0538   05B3 21 00 E5        LD HL, DISPLAY
0539   05B6 C3 7C 0C        JP print_image
0540   05B9             
0541   05B9             ShowBufferDisplay:
0542   05B9 21 00 E5        LD HL, DISPLAY
0543   05BC C3 7C 0C        JP print_image
0544   05BF             
0545   05BF             I2COpen:
0546   05BF C3 36 10        JP I2C_Open
0547   05C2             
0548   05C2             I2CClose:
0549   05C2 C3 3D 10        JP I2C_Close
0550   05C5             
0551   05C5             I2CRead:
0552   05C5 C3 7D 10        JP I2C_Read
0553   05C8             
0554   05C8             I2CWrite:
0555   05C8 C3 40 10        JP I2C_Write
0556   05CB             
0557   05CB             
0558   05CB             
0559   05CB             
0560   05CB             
0561   05CB             
0562   05CB             
0563   05CB             OUTPORT:
0564   05CB 3E 4F           LD A, 'O'
0565   05CD CD 55 0A        CALL PrintBufferChar
0566   05D0 CD 2E 09        CALL OUTSP ; space and show lcd
0567   05D3             
0568   05D3 CD 3A 09        CALL  GETCHR 
0569   05D6 D8              RET   C
0570   05D7 4F              LD C, A
0571   05D8             
0572   05D8 CD 2E 09        CALL OUTSP
0573   05DB             
0574   05DB CD 3A 09        CALL  GETCHR 
0575   05DE D8              RET   C
0576   05DF ED 79           OUT (C), A
0577   05E1 C9              RET
0578   05E2             
0579   05E2             
0580   05E2             INPORT:
0581   05E2 3E 49           LD A, 'I'
0582   05E4 CD 55 0A        CALL PrintBufferChar
0583   05E7 CD 2E 09        CALL OUTSP ; space and show lcd
0584   05EA             
0585   05EA CD 3A 09        CALL  GETCHR 
0586   05ED D8              RET   C
0587   05EE 4F              LD C, A
0588   05EF             
0589   05EF ED 78           IN A, (C)
0590   05F1             
0591   05F1 47              LD B, A
0592   05F2 C5              PUSH BC
0593   05F3 3E 0D           LD A, CR
0594   05F5 CD 43 0A        CALL PRINTCHAR
0595   05F8 C1              POP BC
0596   05F9 78              LD A, B
0597   05FA             
0598   05FA CD FE 05        CALL CONV_A_HEX
0599   05FD C9              RET
0600   05FE             
0601   05FE             
0602   05FE             
0603   05FE             
0604   05FE             
0605   05FE             
0606   05FE             ;----------------
0607   05FE             ;CONVERT A TO ASCII (HEX) AND SHOW LCD
0608   05FE             ;----------------
0609   05FE             ;
0610   05FE             ;CONVERT A BYTE TO ASCII 
0611   05FE             ;
0612   05FE F5          CONV_A_HEX: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
0613   05FF 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
0614   0600 0F                 RRCA
0615   0601 0F                 RRCA
0616   0602 0F                 RRCA
0617   0603 CD 07 06           CALL CONV_A_HEX_NYBASC       ;CALL NYBBLE CONVERTER 
0618   0606 F1                 POP AF            ;RESTORE LOW NYBBLE
0619   0607             ;           
0620   0607             ; CONVERT A NYBBLE TO ASCII
0621   0607             ;
0622   0607 E6 0F       CONV_A_HEX_NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
0623   0609 C6 90              ADD   A,90H       ;CONVERT TO
0624   060B 27                 DAA               ;ASCII
0625   060C CE 40              ADC   A,40H
0626   060E 27                 DAA
0627   060F             ;            
0628   060F             ; Print inlcd
0629   060F             ;
0630   060F CD 43 0A        CALL PRINTCHAR
0631   0612 C9              RET 
0632   0613             
0633   0613             
0634   0613             ; **********************************************************************
0635   0613             ; Delay by DE milliseconds
0636   0613             ;   On entry: DE = Delay time in milliseconds
0637   0613             ;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
0638   0613 F5          H_Delay:    PUSH AF
0639   0614 C5                      PUSH BC
0640   0615 D5                      PUSH DE
0641   0616             ; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
0642   0616 01 98 00    LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
0643   0619             ; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
0644   0619 0B          LoopBC:    DEC  BC             ;[6]     [4]
0645   061A 79                      LD   A,C            ;[4]     [4]
0646   061B B0                      OR   B              ;[4]     [4]
0647   061C C2 19 06                JP   NZ,LoopBC     ;[12/7]  [8/6] 
0648   061F             ; Have we looped once for each millisecond requested?
0649   061F 1B                      DEC  DE             ;[6]     [4]
0650   0620 7B                      LD   A,E            ;[4]     [4]
0651   0621 B2                      OR   D              ;[4]     [4]
0652   0622 20 F2                   JR   NZ, LoopDE     ;[12/7]  [8/6]
0653   0624 D1                      POP  DE
0654   0625 C1                      POP  BC
0655   0626 F1                      POP  AF
0656   0627 C9                      RET
0657   0628             
0658   0628             ;--------------------------
0659   0628             ; D DISPLAY MEMORY LOCATION
0660   0628             ;--------------------------
0661   0628 3E 44       DSPLAY: LD A, 'D'
0662   062A CD 43 0A            CALL PRINTCHAR
0663   062D CD 2E 09            CALL  OUTSP       ;A SPACE
0664   0630 CD 3A 09           CALL  GETCHR
0665   0633 D8                 RET   C         
0666   0634 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0667   0637 CD 3A 09           CALL  GETCHR
0668   063A D8                 RET   C
0669   063B 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0670   063E             ;
0671   063E             ; WAIT FOR CR OR ESC
0672   063E             ;
0673   063E CD 74 0D    DPLAY1: CALL  KEYREADINIT
0674   0641 FE 1B              CP    ESC
0675   0643 C8                 RET   Z
0676   0644 FE 0D              CP    CR
0677   0646 20 F6              JR    NZ,DPLAY1          
0678   0648 CD 34 09           CALL  TXCRLF      ;NEWLINE
0679   064B             ;
0680   064B             ; DISPLAY THE LINE
0681   064B             ;
0682   064B CD 60 06    DPLAY2: CALL  DPLINE
0683   064E ED 53 B0 FE        LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
0684   0652             ;
0685   0652             ; DISPLAY MORE LINES OR EXIT
0686   0652             ;       
0687   0652 CD 74 0D    DPLAY3: CALL  KEYREADINIT
0688   0655 38 FB              JR    C,DPLAY3   
0689   0657 FE 0D              CP    CR        ;ENTER DISPLAYS THE NEXT LINE
0690   0659 28 F0              JR    Z,DPLAY2
0691   065B FE 1B              CP    ESC         ;ESC EXITS (SHIFT + C)
0692   065D 20 F3              JR    NZ,DPLAY3     
0693   065F C9                 RET   
0694   0660             ;-------------------------
0695   0660             ; DISPLAY A LINE OF MEMORY
0696   0660             ;-------------------------      
0697   0660 ED 5B B0 FE DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
0698   0664 21 00 FE           LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
0699   0667             ;
0700   0667             ; DISPLAY THE ADDRESS
0701   0667             ;         
0702   0667 CD 9B 09           CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
0703   066A CD A0 06           CALL  SPCBUF        
0704   066D             ;
0705   066D             ; DISPLAY 4 BYTES
0706   066D             ;
0707   066D 06 04              LD    B,4 ;16
0708   066F 1A          DLINE1: LD    A,(DE)
0709   0670 CD A0 09           CALL  BYTASC
0710   0673 CD A0 06           CALL  SPCBUF
0711   0676 13                 INC   DE        
0712   0677 10 F6              DJNZ  DLINE1
0713   0679                    ;CALL  SPCBUF
0714   0679             ;
0715   0679             ; NOW DISPLAY THE ASCII CHARACTER
0716   0679             ; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
0717   0679             ; BE DIFFERENT BETWEEN THE TWO PASSES!
0718   0679             ;
0719   0679 ED 5B B0 FE        LD    DE,(ADDR)    
0720   067D 06 04              LD    B,4 ;16
0721   067F 1A          DLINE2: LD    A,(DE)   
0722   0680 FE 20              CP    20H
0723   0682 38 07              JR    C,DOT
0724   0684 FE 7F              CP    7FH
0725   0686 30 03              JR    NC,DOT
0726   0688 C3 8D 06           JP    NDOT
0727   068B 3E 2E       DOT:    LD    A,'.'
0728   068D CD A2 06    NDOT:   CALL  INBUF
0729   0690 13                 INC   DE       
0730   0691 10 EC              DJNZ  DLINE2
0731   0693             ;         
0732   0693             ;TERMINATE AND DISPLAY STRING
0733   0693             ;       
0734   0693 CD A5 06           CALL  BCRLF
0735   0696 3E 00              LD    A,00H
0736   0698 77                 LD    (HL),A
0737   0699 21 00 FE           LD    HL,MSGBUF
0738   069C CD 7B 0E           CALL  SNDLCDMSG
0739   069F C9                 RET
0740   06A0             
0741   06A0             
0742   06A0             ;
0743   06A0             ; PUT A SPACE IN THE BUFFER
0744   06A0             ;
0745   06A0 3E 08       SPCBUF: LD    A, 8 ;20H(32dec)
0746   06A2 77          INBUF:  LD    (HL),A
0747   06A3 23                 INC   HL
0748   06A4 C9                 RET
0749   06A5             ;
0750   06A5             ; PUT A CR LF IN THE BUFFER
0751   06A5             ;        
0752   06A5             BCRLF:  ;LD    A,CR  
0753   06A5                    ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
0754   06A5 C9                 RET
0755   06A6             
0756   06A6             
0757   06A6             
0758   06A6             ; --------------------------------------
0759   06A6             ; I2C - Write one byte
0760   06A6             ; --------------------------------------
0761   06A6             I2C_WR_DD:
0762   06A6 3E 0C           LD A, $0C ; limpar tela
0763   06A8 CD 43 0A        CALL PRINTCHAR
0764   06AB             
0765   06AB                 ; Show msg func
0766   06AB 21 5B 12        LD HL, MSG_I2C_WR_DD
0767   06AE CD 7B 0E        CALL SNDLCDMSG
0768   06B1             
0769   06B1                 ; Device Address
0770   06B1 CD 5B 07        CALL GET_DEV_ADDR ; get address
0771   06B4             
0772   06B4             I2C_WR_DD_LOOP:
0773   06B4                 ; Get Data
0774   06B4 CD 69 07        CALL GET_DEV_DD   ; get data
0775   06B7             
0776   06B7                 ; Send
0777   06B7 3A C0 FF        LD A, (I2C_ADDR) ; Open
0778   06BA CD 36 10        CALL I2C_Open
0779   06BD             
0780   06BD 3A C2 FF        LD A, (I2C_DD)  ; Data
0781   06C0 CD 40 10        CALL I2C_Write
0782   06C3              
0783   06C3 CD 3D 10        CALL I2C_Close  ; Close
0784   06C6             
0785   06C6 18 EC           JR I2C_WR_DD_LOOP
0786   06C8             
0787   06C8 C9              RET
0788   06C9             
0789   06C9             
0790   06C9             
0791   06C9             ; --------------------------------------
0792   06C9             ; I2C - Write register one byte
0793   06C9             ; --------------------------------------
0794   06C9             I2C_WR_RR_DD:
0795   06C9 3E 0C           LD A, $0C ; limpar tela
0796   06CB CD 43 0A        CALL PRINTCHAR
0797   06CE             
0798   06CE                 ; Show msg func
0799   06CE 21 6C 12        LD HL, MSG_I2C_WR_RR_DD
0800   06D1 CD 7B 0E        CALL SNDLCDMSG
0801   06D4             
0802   06D4                 ; Device Address
0803   06D4 CD 5B 07        CALL GET_DEV_ADDR ; get address
0804   06D7             
0805   06D7             I2C_WR_RR_DD_LOOP:
0806   06D7                 ; Get register
0807   06D7 CD 77 07        CALL GET_DEV_RR ; get address
0808   06DA             
0809   06DA                 ; Get Data
0810   06DA CD 69 07        CALL GET_DEV_DD   ; get data
0811   06DD             
0812   06DD                 ; Send
0813   06DD 3A C0 FF        LD A, (I2C_ADDR) ; Open
0814   06E0 CD 36 10        CALL I2C_Open
0815   06E3             
0816   06E3 3A C1 FF        LD A, (I2C_RR)  ; register
0817   06E6 CD 40 10        CALL I2C_Write
0818   06E9             
0819   06E9 3A C2 FF        LD A, (I2C_DD)  ; Data
0820   06EC CD 40 10        CALL I2C_Write
0821   06EF             
0822   06EF CD 3D 10        CALL I2C_Close  ; Close
0823   06F2             
0824   06F2 18 E3           JR I2C_WR_RR_DD_LOOP
0825   06F4             
0826   06F4 C9              RET
0827   06F5             
0828   06F5             
0829   06F5             ; --------------------------------------
0830   06F5             ; I2C - Read one byte
0831   06F5             ; --------------------------------------
0832   06F5             I2C_RD:
0833   06F5 3E 0C           LD A, $0C ; limpar tela
0834   06F7 CD 43 0A        CALL PRINTCHAR
0835   06FA             
0836   06FA                 ; Show msg func
0837   06FA 21 81 12        LD HL, MSG_I2C_RD
0838   06FD CD 7B 0E        CALL SNDLCDMSG
0839   0700             
0840   0700                 ; Device Address
0841   0700 CD 5B 07        CALL GET_DEV_ADDR ; get address
0842   0703 CD 34 09        CALL TXCRLF ; new line
0843   0706             
0844   0706             I2C_RD_LOOP:
0845   0706                 ; Send
0846   0706 3A C0 FF        LD A, (I2C_ADDR) ; Open
0847   0709 3C              INC A ; To read address + 1 (flag)
0848   070A CD 36 10        CALL I2C_Open
0849   070D             
0850   070D CD 7D 10        CALL I2C_Read      ; Read
0851   0710 F5              PUSH AF
0852   0711             
0853   0711 CD 3D 10        CALL I2C_Close     ; Close
0854   0714             
0855   0714                 ; Show
0856   0714 F1              POP AF
0857   0715 CD FE 05        CALL CONV_A_HEX ; Show A to (HEX) LCD
0858   0718 CD 34 09        CALL TXCRLF ; new line
0859   071B             
0860   071B CD 74 0D        CALL KEYREADINIT
0861   071E FE 03           CP CTRLC
0862   0720 CA D7 04        JP Z, RESET_WARM
0863   0723             
0864   0723 18 E1           JR I2C_RD_LOOP
0865   0725 C9              RET
0866   0726             
0867   0726             
0868   0726             ; --------------------------------------
0869   0726             ; I2C - Read register one byte
0870   0726             ; --------------------------------------
0871   0726             I2C_RD_RR:
0872   0726 3E 0C           LD A, $0C ; limpar tela
0873   0728 CD 43 0A        CALL PRINTCHAR
0874   072B             
0875   072B                 ; Show msg func
0876   072B 21 91 12        LD HL, MSG_I2C_RD_RR
0877   072E CD 7B 0E        CALL SNDLCDMSG
0878   0731             
0879   0731                 ; Device Address
0880   0731 CD 5B 07        CALL GET_DEV_ADDR ; get address
0881   0734             
0882   0734             I2C_RD_RR_LOOP:
0883   0734                 ; Get register
0884   0734 CD 77 07        CALL GET_DEV_RR ; get address
0885   0737 CD 34 09        CALL TXCRLF ; new line
0886   073A             
0887   073A                 ; Send
0888   073A 3A C0 FF        LD A, (I2C_ADDR) ; Open
0889   073D CD 36 10        CALL I2C_Open
0890   0740             
0891   0740 3A C1 FF        LD A, (I2C_RR)
0892   0743 CD 40 10        CALL I2C_Write ; Register to read
0893   0746             
0894   0746 3A C0 FF        LD A, (I2C_ADDR) ; Open
0895   0749 3C              INC A ; To read address + 1 (flag)
0896   074A CD 36 10        CALL I2C_Open
0897   074D             
0898   074D CD 7D 10        CALL I2C_Read ; Read register
0899   0750 F5              PUSH AF
0900   0751             
0901   0751 CD 3D 10        CALL I2C_Close ; Close
0902   0754             
0903   0754                 ; Show
0904   0754 F1              POP AF
0905   0755 CD FE 05        CALL CONV_A_HEX ; Show A to (HEX) LCD
0906   0758             
0907   0758 18 DA           JR I2C_RD_RR_LOOP
0908   075A C9              RET
0909   075B             
0910   075B             
0911   075B             GET_DEV_ADDR:
0912   075B 21 D5 12        LD HL, MSG_DEV_ADDR
0913   075E CD 7B 0E        CALL SNDLCDMSG
0914   0761 CD 3A 09        CALL  GETCHR 
0915   0764 D8              RET   C
0916   0765 32 C0 FF        LD (I2C_ADDR), A
0917   0768 C9              RET
0918   0769             
0919   0769             GET_DEV_DD:
0920   0769 21 F8 12        LD HL, MSG_DEV_DATA
0921   076C CD 7B 0E        CALL SNDLCDMSG
0922   076F             
0923   076F CD 3A 09        CALL  GETCHR 
0924   0772 D8              RET   C
0925   0773 32 C2 FF        LD (I2C_DD), A
0926   0776 C9              RET
0927   0777             
0928   0777             GET_DEV_RR:
0929   0777 21 E8 12        LD HL, MSG_DEV_REG
0930   077A CD 7B 0E        CALL SNDLCDMSG
0931   077D             
0932   077D CD 3A 09        CALL  GETCHR 
0933   0780 D8              RET   C
0934   0781 32 C1 FF        LD (I2C_RR), A
0935   0784 C9              RET
0936   0785             
0937   0785             
0938   0785             
0939   0785             
0940   0785             I2CMEMTOCPU:
0941   0785                 ; Get parameters to copy a block from I2C memory to CPU memory
0942   0785             ;   On entry: DE = First address in I2C memory
0943   0785             ;             HL = First address in CPU memory
0944   0785             ;             BC = Number of bytes to be copied
0945   0785             ;             SCL = unknown, SDA = unknown
0946   0785             ;   On exit:  If successfully A = 0 and Z flagged
0947   0785             ;             If unsuccessfully A = Error and NZ flagged
0948   0785             ;             IX IY preserved
0949   0785             
0950   0785 21 2F 12        LD HL, MSG_MEM2CPU
0951   0788 CD 7B 0E        CALL SNDLCDMSG
0952   078B             
0953   078B CD D5 07        CALL GET_FROM_TO_SIZE
0954   078E             
0955   078E             ;    DE = First address in I2C memory
0956   078E             ;    HL = First address in CPU memory
0957   078E             ;    BC = Number of bytes to be copied
0958   078E             
0959   078E ED 5B B2 FE     LD DE, (ADDR_FROM)
0960   0792 2A B4 FE        LD HL, (ADDR_TO)
0961   0795 ED 4B B6 FE     LD BC, (ADDR_SIZE)
0962   0799 CD 4D 0F        CALL I2C_MemRd  
0963   079C             
0964   079C CA A6 07        JP Z, I2CMEMTOCPU_OK
0965   079F 21 CA 12        LD HL, MSG_COPYFAIL
0966   07A2 CD 7B 0E        CALL SNDLCDMSG
0967   07A5 C9              RET
0968   07A6             I2CMEMTOCPU_OK:
0969   07A6 21 C1 12        LD HL, MSG_COPYOK
0970   07A9 CD 7B 0E        CALL SNDLCDMSG
0971   07AC C9              RET
0972   07AD             
0973   07AD             
0974   07AD             I2CCPUTOMEM:
0975   07AD             ; Get parameters to copy a block from CPU memory to I2C memory
0976   07AD             ;   On entry: DE = First address in I2C memory
0977   07AD             ;             HL = First address in CPU memory
0978   07AD             ;             BC = Number of bytes to be copied
0979   07AD             ;             SCL = unknown, SDA = unknown
0980   07AD             ;   On exit:  If successfully A = 0 and Z flagged
0981   07AD             ;             If unsuccessfully A = Error and NZ flagged
0982   07AD             ;             IX IY preserved
0983   07AD             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
0984   07AD             ; pages.
0985   07AD 21 45 12        LD HL, MSG_CPU2MEM
0986   07B0 CD 7B 0E        CALL SNDLCDMSG
0987   07B3             
0988   07B3 CD D5 07        CALL GET_FROM_TO_SIZE
0989   07B6             
0990   07B6             ;    DE = First address in I2C memory
0991   07B6             ;    HL = First address in CPU memory
0992   07B6             ;    BC = Number of bytes to be copied
0993   07B6             
0994   07B6 2A B2 FE        LD HL, (ADDR_FROM)
0995   07B9 ED 5B B4 FE     LD DE, (ADDR_TO)
0996   07BD ED 4B B6 FE     LD BC, (ADDR_SIZE)
0997   07C1 CD 82 0F        CALL I2C_MemWr
0998   07C4                 
0999   07C4 CA CE 07        JP Z, I2CCPUTOMEM_OK
1000   07C7 21 CA 12        LD HL, MSG_COPYFAIL
1001   07CA CD 7B 0E        CALL SNDLCDMSG
1002   07CD C9              RET
1003   07CE             I2CCPUTOMEM_OK:
1004   07CE 21 C1 12        LD HL, MSG_COPYOK
1005   07D1 CD 7B 0E        CALL SNDLCDMSG
1006   07D4 C9              RET
1007   07D5             
1008   07D5             
1009   07D5             
1010   07D5             
1011   07D5             
1012   07D5             
1013   07D5             GET_FROM_TO_SIZE:
1014   07D5                 ; FROM
1015   07D5 21 A5 12        LD HL, MSG_FROM
1016   07D8 CD 7B 0E        CALL SNDLCDMSG
1017   07DB                 ;
1018   07DB                 ;GET THE ADDRESS  FROM
1019   07DB                 ;
1020   07DB CD 3A 09        CALL  GETCHR 
1021   07DE D8              RET   C        
1022   07DF 32 B3 FE        LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
1023   07E2 CD 3A 09        CALL  GETCHR
1024   07E5 D8              RET   C
1025   07E6 32 B2 FE        LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW
1026   07E9             
1027   07E9 CD 74 0D        CALL  KEYREADINIT
1028   07EC FE 1B           CP    ESC         ;ESC KEY?
1029   07EE C8              RET   Z
1030   07EF FE 0D           CP    CR
1031   07F1 28 08           JR Z, GET_FROM_TO_SIZE_TO
1032   07F3 3E 0D           LD A, CR
1033   07F5 CD 43 0A        CALL PRINTCHAR
1034   07F8 C3 D5 07        JP GET_FROM_TO_SIZE
1035   07FB             
1036   07FB             GET_FROM_TO_SIZE_TO:
1037   07FB                 ; TO
1038   07FB 21 AC 12        LD HL, MSG_TO
1039   07FE CD 7B 0E        CALL SNDLCDMSG
1040   0801                 ;
1041   0801                 ;GET THE ADDRESS  TO
1042   0801                 ;
1043   0801 CD 3A 09        CALL  GETCHR 
1044   0804 D8              RET   C        
1045   0805 32 B5 FE        LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
1046   0808 CD 3A 09        CALL  GETCHR
1047   080B D8              RET   C
1048   080C 32 B4 FE        LD    (ADDR_TO),A    ;SAVE ADDRESS LOW
1049   080F             
1050   080F CD 74 0D        CALL  KEYREADINIT
1051   0812 FE 1B           CP    ESC         ;ESC KEY?
1052   0814 C8              RET   Z
1053   0815 FE 0D           CP    CR
1054   0817 20 E2           JR NZ, GET_FROM_TO_SIZE_TO
1055   0819             
1056   0819             GET_FROM_TO_SIZE_SIZE:
1057   0819                 ; SIZE
1058   0819 21 B2 12        LD HL, MSG_SIZE
1059   081C CD 7B 0E        CALL SNDLCDMSG
1060   081F                 ;
1061   081F                 ;GET THE SIZE
1062   081F                 ;
1063   081F CD 3A 09        CALL  GETCHR 
1064   0822 D8              RET   C        
1065   0823 32 B7 FE        LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
1066   0826 CD 3A 09        CALL  GETCHR
1067   0829 D8              RET   C
1068   082A 32 B6 FE        LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW
1069   082D             
1070   082D CD 74 0D        CALL  KEYREADINIT
1071   0830 FE 1B           CP    ESC         ;ESC KEY?
1072   0832 C8              RET   Z
1073   0833 FE 0D           CP    CR
1074   0835 20 E2           JR NZ, GET_FROM_TO_SIZE_SIZE
1075   0837 C9              RET
1076   0838             
1077   0838             
1078   0838             INTEL_HEX:
1079   0838 CD C8 0D        CALL INTHEX
1080   083B CD 50 0D        CALL delay
1081   083E CD 50 0D        CALL delay
1082   0841 C3 93 04        JP INICIO
1083   0844             
1084   0844             SHOWHELP:
1085   0844 3E 0C           LD A, $0C ; limpar tela
1086   0846 CD 43 0A        CALL PRINTCHAR
1087   0849             
1088   0849 21 23 11        LD HL, MSG_MENU0
1089   084C CD 7B 0E        CALL SNDLCDMSG
1090   084F             
1091   084F 21 36 11        LD HL, MSG_MENU1
1092   0852 CD 7B 0E        CALL SNDLCDMSG
1093   0855             
1094   0855 21 4B 11        LD HL, MSG_MENU2
1095   0858 CD 7B 0E        CALL SNDLCDMSG
1096   085B             
1097   085B 21 56 11        LD HL, MSG_MENU3
1098   085E CD 7B 0E        CALL SNDLCDMSG
1099   0861             
1100   0861 21 68 11        LD HL, MSG_MENU4
1101   0864 CD 7B 0E        CALL SNDLCDMSG
1102   0867             
1103   0867 21 79 11        LD HL, MSG_MENU5
1104   086A CD 7B 0E        CALL SNDLCDMSG
1105   086D             
1106   086D 21 89 11        LD HL, MSG_MENU6
1107   0870 CD 7B 0E        CALL SNDLCDMSG
1108   0873             
1109   0873 21 96 11        LD HL, MSG_MENU7
1110   0876 CD 7B 0E        CALL SNDLCDMSG
1111   0879             
1112   0879 21 9F 11        LD HL, MSG_MENU8
1113   087C CD 7B 0E        CALL SNDLCDMSG
1114   087F             
1115   087F 21 AB 11        LD HL, MSG_MENU9
1116   0882 CD 7B 0E        CALL SNDLCDMSG
1117   0885             
1118   0885 21 BC 11        LD HL, MSG_MENU10
1119   0888 CD 7B 0E        CALL SNDLCDMSG
1120   088B             
1121   088B 21 CD 11        LD HL, MSG_MENU11
1122   088E CD 7B 0E        CALL SNDLCDMSG
1123   0891             
1124   0891 21 DD 11        LD HL, MSG_MENU12
1125   0894 CD 7B 0E        CALL SNDLCDMSG
1126   0897             
1127   0897 21 F0 11        LD HL, MSG_MENU13
1128   089A CD 7B 0E        CALL SNDLCDMSG
1129   089D             
1130   089D 21 05 12        LD HL, MSG_MENU14
1131   08A0 CD 7B 0E        CALL SNDLCDMSG
1132   08A3             
1133   08A3 C9              RET
1134   08A4             
1135   08A4             
1136   08A4             ;----------------------------
1137   08A4             ; M DISPLAY AND MODIFY MEMORY
1138   08A4             ;----------------------------
1139   08A4 3E 4D       MODIFY: LD A, 'M'
1140   08A6 CD 43 0A            CALL PRINTCHAR
1141   08A9 CD 2E 09         CALL  OUTSP
1142   08AC             ;
1143   08AC             ;GET THE ADDRESS        
1144   08AC             ;
1145   08AC CD 3A 09           CALL  GETCHR 
1146   08AF D8                 RET   C        
1147   08B0 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
1148   08B3 CD 3A 09           CALL  GETCHR
1149   08B6 D8                 RET   C
1150   08B7 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
1151   08BA             ;
1152   08BA             ; DISPLAY ON A NEW LINE
1153   08BA             ;       
1154   08BA CD 34 09    MDIFY1: CALL  TXCRLF       
1155   08BD ED 5B B0 FE        LD    DE,(ADDR)    
1156   08C1 21 00 FE           LD    HL,MSGBUF   
1157   08C4 CD 9B 09           CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
1158   08C7 21 00 FE           LD    HL,MSGBUF
1159   08CA CD 8F 09           CALL  WRDOUT      ;OUTPUT THE ADDRESS
1160   08CD CD 2E 09           CALL  OUTSP    
1161   08D0             ;      
1162   08D0             ;GET THE DATA AT THE ADDRESS        
1163   08D0             ;
1164   08D0 2A B0 FE            LD   HL,(ADDR)       
1165   08D3 7E                  LD   A,(HL)
1166   08D4             ;
1167   08D4             ; DISPLAY THE DATA
1168   08D4             ;        
1169   08D4 21 00 FE           LD    HL,MSGBUF
1170   08D7 CD A0 09           CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
1171   08DA 21 00 FE           LD    HL,MSGBUF
1172   08DD CD 92 09           CALL  BYTOUT      ;OUTPUT THE BYTE
1173   08E0 CD 2E 09           CALL  OUTSP
1174   08E3             ;
1175   08E3             ; GET NEW DATA,EXIT OR CONTINUE
1176   08E3             ;
1177   08E3 CD 3A 09           CALL  GETCHR
1178   08E6 D8                 RET   C
1179   08E7 47                 LD    B,A         ;SAVE IT FOR LATER
1180   08E8 2A B0 FE           LD    HL,(ADDR)
1181   08EB 77                 LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
1182   08EC 78                 LD    A,B
1183   08ED BE                 CP    (HL)
1184   08EE 28 05              JR    Z,MDIFY2
1185   08F0 3E 3F              LD    A,'?'
1186   08F2 CD 43 0A           CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
1187   08F5             ;
1188   08F5             ; INCREMENT THE ADDRESS
1189   08F5             ;
1190   08F5 23          MDIFY2: INC   HL
1191   08F6 22 B0 FE           LD    (ADDR),HL
1192   08F9 C3 BA 08           JP    MDIFY1
1193   08FC             
1194   08FC             
1195   08FC             
1196   08FC             ;------------------------------
1197   08FC             ; GO <ADDR>
1198   08FC             ; TRANSFERS EXECUTION TO <ADDR>
1199   08FC             ;------------------------------
1200   08FC             GOJUMP_new:
1201   08FC 3E 0D           LD A, CR
1202   08FE CD 43 0A        CALL PRINTCHAR
1203   0901             
1204   0901 3E 3E           LD A, '>'
1205   0903 CD 43 0A        CALL PRINTCHAR
1206   0906             
1207   0906 3E 47       GOJUMP: LD A, 'G'
1208   0908 CD 43 0A            CALL PRINTCHAR
1209   090B CD 2E 09           CALL  OUTSP       
1210   090E CD 3A 09           CALL  GETCHR      ;GET ADDRESS HIGH BYTE
1211   0911 D8                 RET   C
1212   0912 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
1213   0915 CD 3A 09           CALL  GETCHR      ;GET ADDRESS LOW BYTE
1214   0918 D8                 RET   C
1215   0919 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
1216   091C             ;
1217   091C             ; WAIT FOR A CR OR ESC
1218   091C             ;       
1219   091C CD 74 0D    GOJMP1: CALL  KEYREADINIT
1220   091F FE 1B              CP    ESC         ;ESC KEY?
1221   0921 C8                 RET   Z
1222   0922 FE 0D              CP    CR
1223   0924                    ;JR    NZ,GOJMP1
1224   0924 20 D6              JR NZ, GOJUMP_new
1225   0926 CD 34 09           CALL  TXCRLF
1226   0929 E1                 POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
1227   092A 2A B0 FE           LD    HL,(ADDR)
1228   092D E9                 JP    (HL)        ;GOOD LUCK WITH THAT!
1229   092E             
1230   092E             
1231   092E             ;---------------
1232   092E             ; OUTPUT A SPACE
1233   092E             ;---------------
1234   092E 3E 20       OUTSP:  LD    A, ' '
1235   0930 CD 43 0A           CALL  PRINTCHAR
1236   0933 C9                 RET
1237   0934             
1238   0934             ;-------------      
1239   0934             ; OUTPUT CRLF (NEW LINE)
1240   0934             ;------------
1241   0934 3E 0D       TXCRLF: LD   A,CR
1242   0936 CD 43 0A           CALL PRINTCHAR   
1243   0939 C9                 RET
1244   093A             
1245   093A             ;-----------------------------
1246   093A             ; GET A BYTE FROM THE TERMINAL
1247   093A             ;-----------------------------
1248   093A CD 74 0D    GETCHR: CALL KEYREADINIT ; read key
1249   093D FE 1B              CP    ESC
1250   093F 28 31              JR    Z,GETOUT
1251   0941 FE 03              CP    CTRLC  ; key BK (reset)
1252   0943 CA D7 04           JP    Z, RESET_WARM
1253   0946 47                 LD    B,A                ;SAVE TO ECHO      
1254   0947 CD 74 09           CALL  ASC2HEX
1255   094A 30 EE              JR    NC,GETCHR          ;REJECT NON HEX CHARS    
1256   094C 21 B8 FE           LD    HL,DATA
1257   094F 77                 LD    (HL),A 
1258   0950 78                 LD    A,B         
1259   0951 CD 43 0A           CALL  PRINTCHAR             ;ECHO VALID HEX
1260   0954                    
1261   0954 CD 74 0D    GETNYB: CALL  KEYREADINIT
1262   0957 FE 1B              CP    ESC
1263   0959 28 17              JR    Z,GETOUT
1264   095B FE 03              CP    CTRLC  ; key BK (reset)
1265   095D CA D7 04           JP    Z, RESET_WARM
1266   0960 47                 LD    B,A               ;SAVE TO ECHO
1267   0961 CD 74 09           CALL  ASC2HEX
1268   0964 30 EE              JR    NC,GETNYB         ;REJECT NON HEX CHARS
1269   0966 ED 6F              RLD
1270   0968 78                 LD    A,B
1271   0969 CD 43 0A           CALL  PRINTCHAR             ;ECHO VALID HEX
1272   096C 7E                 LD    A,(HL)
1273   096D CD 72 09           CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
1274   0970 3F                 CCF                    ;AND THEN COMPLEMENTING IT
1275   0971 C9                 RET   
1276   0972 37          GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
1277   0973 C9                 RET
1278   0974             
1279   0974             
1280   0974             ;----------------------------------------
1281   0974             ; CONVERT ASCII CHARACTER INTO HEX NYBBLE
1282   0974             ;----------------------------------------
1283   0974             ; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
1284   0974             ; ENTRY OTHER THAN HEXADECIMAL KEYS
1285   0974             ;
1286   0974             ;CONVERTS ASCII 0-9,A-F INTO HEX LSN
1287   0974             ;ENTRY : A= ASCII 0-9,A-F
1288   0974             ;EXIT  : CARRY =  1
1289   0974             ;          A= HEX 0-F IN LSN    
1290   0974             ;      : CARRY = 0
1291   0974             ;          A= OUT OF RANGE CHARACTER & 7FH
1292   0974             ; A AND F REGISTERS MODIFIED
1293   0974             ;
1294   0974 E6 7F       ASC2HEX: AND   7FH        ;STRIP OUT PARITY
1295   0976 FE 30              CP    30H
1296   0978 38 12              JR    C,AC2HEX3    ;LESS THAN 0
1297   097A FE 3A              CP    3AH
1298   097C 30 02              JR    NC,AC2HEX2   ;MORE THAN 9
1299   097E 37          AC2HEX1: SCF               ;SET THE CARRY - IS HEX
1300   097F C9                 RET
1301   0980             ;     
1302   0980 FE 41       AC2HEX2: CP    41H
1303   0982 38 08              JR    C,AC2HEX3    ;LESS THAN A
1304   0984 FE 47              CP    47H
1305   0986 30 04              JR    NC,AC2HEX3   ;MORE THAN F
1306   0988 D6 07              SUB   07H        ;CONVERT TO NYBBLE
1307   098A 18 F2              JR    AC2HEX1  
1308   098C E6 FF       AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
1309   098E C9                 RET
1310   098F             
1311   098F             
1312   098F             ;----------------------     
1313   098F             ; SEND ASCII HEX VALUES        
1314   098F             ;----------------------
1315   098F             ;
1316   098F             ; OUTPUT THE 4 BYTE, WRDOUT
1317   098F             ; THE 2 BYTE, BYTOUT
1318   098F             ; OR THE SINGLE BYTE, NYBOUT
1319   098F             ; ASCII STRING AT HL TO THE SERIAL PORT
1320   098F             ;
1321   098F CD 92 09    WRDOUT: CALL  BYTOUT
1322   0992 CD 95 09    BYTOUT: CALL  NYBOUT
1323   0995 7E          NYBOUT: LD    A,(HL)
1324   0996 CD 43 0A           CALL  PRINTCHAR
1325   0999 23                 INC   HL
1326   099A C9                 RET       
1327   099B             ;----------------
1328   099B             ;CONVERT TO ASCII 
1329   099B             ;----------------
1330   099B             ;
1331   099B             ; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
1332   099B             ;
1333   099B             ;         ENTRY :  A = BINARY TO CONVERT
1334   099B             ;                  HL = CHARACTER BUFFER ADDRESS   
1335   099B             ;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
1336   099B             ;   
1337   099B             ;        MODIFIES : DE
1338   099B             
1339   099B 7A          WRDASC: LD    A,D         ;CONVERT AND
1340   099C CD A0 09           CALL  BYTASC      ;OUTPUT D
1341   099F 7B                 LD    A,E         ;THEN E
1342   09A0             ;
1343   09A0             ;CONVERT A BYTE TO ASCII 
1344   09A0             ;
1345   09A0 F5          BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
1346   09A1 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
1347   09A2 0F                 RRCA
1348   09A3 0F                 RRCA
1349   09A4 0F                 RRCA
1350   09A5 CD A9 09           CALL NYBASC       ;CALL NYBBLE CONVERTER 
1351   09A8 F1                 POP AF            ;RESTORE LOW NYBBLE
1352   09A9             
1353   09A9             ;           
1354   09A9             ; CONVERT A NYBBLE TO ASCII
1355   09A9             ;
1356   09A9 E6 0F       NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
1357   09AB C6 90              ADD   A,90H       ;CONVERT TO
1358   09AD 27                 DAA               ;ASCII
1359   09AE CE 40              ADC   A,40H
1360   09B0 27                 DAA
1361   09B1             ;            
1362   09B1             ; SAVE IN STRING
1363   09B1             ;
1364   09B1 77          INSBUF: LD    (HL),A
1365   09B2 23                 INC   HL 
1366   09B3 C9                 RET 
1367   09B4             
1368   09B4             
1369   09B4             
1370   09B4             INIT_TXT_LCD:
1371   09B4 3E 00           ld a, 0
1372   09B6 32 03 E0        ld (LCD_TXT_X), a
1373   09B9 32 04 E0        ld (LCD_TXT_Y), a
1374   09BC 32 0F E0        ld (LCD_DELETE_CHAR), a
1375   09BF 32 10 E0        ld (LCD_AUTO_X), a
1376   09C2 21 00 00        ld hl, 0
1377   09C5 22 08 E0        ld (LCD_TXT_X_TMP), hl
1378   09C8 23              inc hl
1379   09C9 22 0A E0        ld (LCD_TXT_Y_TMP), hl
1380   09CC C9              RET
1381   09CD             
1382   09CD             
1383   09CD             DISPLAY_SCROLL_UP:
1384   09CD                 ; cada linha tem 128 bytes
1385   09CD                 ; temos 8 linhas
1386   09CD                 ; total 1024 bytes
1387   09CD             
1388   09CD                 ; display lines 0 to 7
1389   09CD                 ; move line 1 to 0
1390   09CD 21 80 E5        ld hl, DISPLAY+128
1391   09D0 11 00 E5        ld de, DISPLAY
1392   09D3 01 7F 00        ld bc, 127
1393   09D6 ED B0           ldir
1394   09D8             
1395   09D8                 ; move line 2 to 1
1396   09D8 21 00 E6        ld hl, DISPLAY+256
1397   09DB 11 80 E5        ld de, DISPLAY+128
1398   09DE 01 7F 00        ld bc, 127
1399   09E1 ED B0           ldir
1400   09E3             
1401   09E3                 ; move line 3 to 2
1402   09E3 21 80 E6        ld hl, DISPLAY+384
1403   09E6 11 00 E6        ld de, DISPLAY+256
1404   09E9 01 7F 00        ld bc, 127
1405   09EC ED B0           ldir
1406   09EE             
1407   09EE                 ; move line 4 to 3
1408   09EE 21 00 E7        ld hl, DISPLAY+512
1409   09F1 11 80 E6        ld de, DISPLAY+384
1410   09F4 01 7F 00        ld bc, 127
1411   09F7 ED B0           ldir
1412   09F9             
1413   09F9                 ; move line 5 to 4
1414   09F9 21 80 E7        ld hl, DISPLAY+640
1415   09FC 11 00 E7        ld de, DISPLAY+512
1416   09FF 01 7F 00        ld bc, 127
1417   0A02 ED B0           ldir
1418   0A04             
1419   0A04                 ; move line 6 to 5
1420   0A04 21 00 E8        ld hl, DISPLAY+768
1421   0A07 11 80 E7        ld de, DISPLAY+640
1422   0A0A 01 7F 00        ld bc, 127
1423   0A0D ED B0           ldir
1424   0A0F             
1425   0A0F                 ; move line 7 to 6
1426   0A0F 21 80 E8        ld hl, DISPLAY+896
1427   0A12 11 00 E8        ld de, DISPLAY+768
1428   0A15 01 7F 00        ld bc, 127
1429   0A18 ED B0           ldir
1430   0A1A             
1431   0A1A                 ; clear line 7
1432   0A1A                 ; 896 to 1024
1433   0A1A 21 80 E8        ld hl, DISPLAY+896
1434   0A1D 5D              ld e,l
1435   0A1E 54              ld d,h
1436   0A1F 13              inc de
1437   0A20 36 00           ld (hl), 0
1438   0A22 01 7F 00        ld bc, 127
1439   0A25 ED B0           ldir
1440   0A27             
1441   0A27 C9              RET
1442   0A28             
1443   0A28             DELETE_CHAR:
1444   0A28 E1              POP HL ; retorno do call
1445   0A29 3E 00           LD A, 0
1446   0A2B 32 0F E0        LD (LCD_DELETE_CHAR), A
1447   0A2E 3A 03 E0        LD A, (LCD_TXT_X)
1448   0A31 3D              DEC A
1449   0A32 32 03 E0        LD (LCD_TXT_X), A
1450   0A35             
1451   0A35 3E FF           LD A, $FF
1452   0A37 32 10 E0        LD (LCD_AUTO_X), A
1453   0A3A             
1454   0A3A F1              POP AF
1455   0A3B 3E 20           LD A, ' '
1456   0A3D 32 00 E0        LD (LCD_CHAR), A
1457   0A40 F5              PUSH AF
1458   0A41 E5              PUSH HL ; call
1459   0A42 C9              RET
1460   0A43             
1461   0A43             
1462   0A43             ; Print char in buffer and show to lcd
1463   0A43             ; char in A
1464   0A43             PRINTCHAR:
1465   0A43 F5              PUSH AF
1466   0A44 C5              PUSH BC
1467   0A45 D5              PUSH DE
1468   0A46 E5              PUSH HL
1469   0A47 CD 55 0A        CALL PrintBufferChar
1470   0A4A 21 00 E5        LD HL, DISPLAY
1471   0A4D CD 7C 0C        CALL print_image
1472   0A50 E1              POP HL
1473   0A51 D1              POP DE
1474   0A52 C1              POP BC
1475   0A53 F1              POP AF
1476   0A54 C9              RET
1477   0A55             
1478   0A55             
1479   0A55             ; Print char in buffer lcd (without show to lcd)
1480   0A55             ; char in A
1481   0A55             PrintBufferChar:
1482   0A55 32 00 E0        LD (LCD_CHAR), A ; save char to print
1483   0A58             
1484   0A58 F5              PUSH AF
1485   0A59 C5              PUSH BC
1486   0A5A D5              PUSH DE
1487   0A5B E5              PUSH HL
1488   0A5C             
1489   0A5C F5              PUSH AF
1490   0A5D 3E 00           LD A, $0
1491   0A5F 32 10 E0        LD (LCD_AUTO_X), A
1492   0A62 F1              POP AF
1493   0A63             
1494   0A63             
1495   0A63             ver_delete:
1496   0A63 F5              PUSH AF
1497   0A64 3A 0F E0        LD A, (LCD_DELETE_CHAR)
1498   0A67 B7              or a
1499   0A68 FE FF           CP $FF
1500   0A6A CC 28 0A        call z, DELETE_CHAR
1501   0A6D F1              POP AF
1502   0A6E B7              or a
1503   0A6F FE 00           CP $0
1504   0A71 20 08           jr nz, ver_enter
1505   0A73 3E FF           LD A, $FF ; delete proximo char
1506   0A75 32 0F E0        LD (LCD_DELETE_CHAR), A
1507   0A78 C3 A0 0B        jp print_char_fim
1508   0A7B             
1509   0A7B                 ; Verificar Enter, clear, etc... SEM PERDER O reg. A
1510   0A7B             ver_enter:       
1511   0A7B             
1512   0A7B                             ; trata dados para o lcd
1513   0A7B FE 0D                       CP      CR                     ; compara com ENTER
1514   0A7D 20 1A                       jr      nz, ver_limpa
1515   0A7F             
1516   0A7F 3E 00                       LD A,0
1517   0A81 32 03 E0                    LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
1518   0A84             
1519   0A84 3A 04 E0                    LD A, (LCD_TXT_Y)
1520   0A87 3C                          inc a
1521   0A88 FE 08                       cp 8
1522   0A8A C2 93 0A                    jp nz, ver_enter_incYOK
1523   0A8D                             
1524   0A8D CD CD 09                    CALL DISPLAY_SCROLL_UP
1525   0A90                             ;ld hl, DISPLAY
1526   0A90                             ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1527   0A90                             
1528   0A90 C3 A0 0B                    jp print_char_fim
1529   0A93             
1530   0A93             ver_enter_incYOK:
1531   0A93 32 04 E0                    ld (LCD_TXT_Y), a
1532   0A96 C3 A0 0B                    jp print_char_fim
1533   0A99             
1534   0A99             
1535   0A99             ver_limpa:
1536   0A99 FE 0C                       CP      $0C                     ; compara com limpar tela
1537   0A9B 20 0E                       jr      NZ, ver_line
1538   0A9D                             
1539   0A9D                             ;call    clear_lcd_screen
1540   0A9D                             ;call    show_lcd_screen
1541   0A9D CD 55 0C                    call lcd_clear
1542   0AA0                             ;ld hl, DISPLAY
1543   0AA0                             ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1544   0AA0 3E 00                       LD A, 0
1545   0AA2 32 03 E0                    LD (LCD_TXT_X), A
1546   0AA5 32 04 E0                    LD (LCD_TXT_Y), A
1547   0AA8             
1548   0AA8 C3 A0 0B                    JP print_char_fim
1549   0AAB             
1550   0AAB             ver_line:
1551   0AAB FE 0A                       CP      LF                     ; retorna começo da linha
1552   0AAD 20 03                       jr      NZ, print_lcd      
1553   0AAF             
1554   0AAF                                 ;----- verificar se precisa add algo aqui
1555   0AAF                             ;call    shift_lcd_up
1556   0AAF                             ;call    show_lcd_screen
1557   0AAF C3 A0 0B                    JP print_char_fim
1558   0AB2             
1559   0AB2             print_lcd:
1560   0AB2                 ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
1561   0AB2 26 00           ld H, 0
1562   0AB4 6F              ld L, A
1563   0AB5 29              ADD HL, HL ; hl x 8
1564   0AB6 29              ADD HL, HL
1565   0AB7 29              ADD HL, HL
1566   0AB8             
1567   0AB8 54              LD D, H
1568   0AB9 5D              LD E, L
1569   0ABA 21 93 00        ld hl, TABLE
1570   0ABD 19              add hl, de
1571   0ABE 22 01 E0        ld (LCD_CHAR_POINT), HL ; table
1572   0AC1             
1573   0AC1             
1574   0AC1                 ; ajusta X
1575   0AC1 06 06           ld b, 6
1576   0AC3 3A 03 E0        ld a, (LCD_TXT_X)
1577   0AC6 B7              or A
1578   0AC7 CA D1 0A        jp z, ajustX
1579   0ACA 4F              ld c, a
1580   0ACB CD A5 0B        call multiplication
1581   0ACE C3 D4 0A        jp ajustXOK
1582   0AD1                 
1583   0AD1             ajustX:
1584   0AD1 21 00 00        ld hl, 0
1585   0AD4             ajustXOK:
1586   0AD4 22 08 E0        ld (LCD_TXT_X_TMP), HL 
1587   0AD7             
1588   0AD7             
1589   0AD7             
1590   0AD7                 ; ajuste Y
1591   0AD7 16 04           ld d, 4
1592   0AD9 1E 00           ld e, 0 ; = 128x8 proxima linha
1593   0ADB 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1594   0ADE 3A 04 E0        ld a, (LCD_TXT_Y)
1595   0AE1 B7              or a
1596   0AE2 CA F2 0A        JP Z, multYfim
1597   0AE5 21 00 00        ld hl, 0
1598   0AE8 47              ld b, a
1599   0AE9             multY:
1600   0AE9 19              add hl, de
1601   0AEA 10 FD           DJNZ multY
1602   0AEC             
1603   0AEC 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1604   0AEF C3 F8 0A        jp multYfimok
1605   0AF2             
1606   0AF2             multYfim:
1607   0AF2 21 00 00        ld hl, 0
1608   0AF5 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1609   0AF8             
1610   0AF8             multYfimok:
1611   0AF8             
1612   0AF8 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1613   0AFB ED 5B 08 E0     ld de, (LCD_TXT_X_TMP)
1614   0AFF             
1615   0AFF 19              add hl, de  ; hl tem pos do pix 0-8191
1616   0B00             
1617   0B00 22 0E E0        ld (LCD_TMP_POINT), hl
1618   0B03             
1619   0B03             
1620   0B03 3E 08           ld a, 8 ; altura do caracter
1621   0B05 32 0C E0        ld (LCD_CHAR_H), a
1622   0B08             printchar_loopH:
1623   0B08 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1624   0B0B 7E              ld a, (HL)
1625   0B0C 32 10 E1        ld (LCD_TEMP), a
1626   0B0F             
1627   0B0F 3E 06           ld a, 6 ; largura do caracter
1628   0B11 32 0D E0        ld (LCD_CHAR_W), a
1629   0B14             printchar_loopW:
1630   0B14 3A 10 E1        ld a, (LCD_TEMP)
1631   0B17 E6 80           and 128
1632   0B19 FE 00           cp 0
1633   0B1B CA 27 0B        jp z, printchar_loopWC
1634   0B1E 2A 0E E0        ld hl, (LCD_TMP_POINT)
1635   0B21 CD E0 0B        call lcd_setPixel
1636   0B24 C3 2D 0B        JP printchar_loopWE
1637   0B27             
1638   0B27             printchar_loopWC:
1639   0B27 2A 0E E0        ld hl, (LCD_TMP_POINT)
1640   0B2A CD 19 0C        call lcd_clearPixel
1641   0B2D             
1642   0B2D             printchar_loopWE:
1643   0B2D 3A 10 E1        ld a, (LCD_TEMP)
1644   0B30 CB 27           sla a
1645   0B32 32 10 E1        ld (LCD_TEMP), a
1646   0B35                 
1647   0B35 2A 0E E0        ld hl, (LCD_TMP_POINT)
1648   0B38 23              inc hl
1649   0B39 22 0E E0        ld (LCD_TMP_POINT), hl
1650   0B3C             
1651   0B3C 3A 0D E0        ld a, (LCD_CHAR_W)
1652   0B3F 3D              dec A
1653   0B40 32 0D E0        ld (LCD_CHAR_W), a
1654   0B43 FE 00           cp 0
1655   0B45 C2 14 0B        JP NZ, printchar_loopW
1656   0B48             
1657   0B48             
1658   0B48 2A 0E E0        ld hl, (LCD_TMP_POINT)
1659   0B4B 2B              dec hl
1660   0B4C 2B              dec hl
1661   0B4D 2B              dec hl
1662   0B4E 2B              dec hl
1663   0B4F 2B              dec hl
1664   0B50 2B              dec hl
1665   0B51             
1666   0B51 16 00           ld d, 0
1667   0B53 1E 80           ld e, 128
1668   0B55 19              add hl, de
1669   0B56 22 0E E0        ld (LCD_TMP_POINT), HL
1670   0B59             
1671   0B59 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1672   0B5C 23              inc hl
1673   0B5D 22 01 E0        ld (LCD_CHAR_POINT), hl
1674   0B60             
1675   0B60             
1676   0B60 3A 0C E0        ld a, (LCD_CHAR_H)
1677   0B63 3D              dec A
1678   0B64 32 0C E0        ld (LCD_CHAR_H), a
1679   0B67 FE 00           cp 0
1680   0B69 C2 08 0B        jp NZ, printchar_loopH
1681   0B6C             
1682   0B6C                 ;ld hl, DISPLAY
1683   0B6C                 ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1684   0B6C             
1685   0B6C             
1686   0B6C                 ; check auto x
1687   0B6C 3A 10 E0        LD A, (LCD_AUTO_X)
1688   0B6F B7              OR A
1689   0B70 FE FF           CP $FF
1690   0B72 CA A0 0B        JP Z, print_char_fim
1691   0B75             
1692   0B75                 ; increment X, Y
1693   0B75 3A 03 E0        ld a, (LCD_TXT_X)
1694   0B78 3C              inc a
1695   0B79 FE 15           cp 21
1696   0B7B C2 9D 0B        jp nz, incXOK
1697   0B7E 3E 00           ld a, 0
1698   0B80 32 03 E0        ld (LCD_TXT_X), a
1699   0B83 3A 04 E0        ld a, (LCD_TXT_Y)
1700   0B86 3C              inc a
1701   0B87 FE 08           cp 8
1702   0B89 C2 97 0B        jp nz, incYOK
1703   0B8C CD CD 09        CALL DISPLAY_SCROLL_UP
1704   0B8F                 ;ld hl, DISPLAY
1705   0B8F                 ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1706   0B8F 3E 00           ld a, 0
1707   0B91 32 03 E0        ld (LCD_TXT_X), a
1708   0B94 C3 A0 0B        jp print_char_fim
1709   0B97             
1710   0B97             incYOK:
1711   0B97 32 04 E0        ld (LCD_TXT_Y), a
1712   0B9A C3 A0 0B        jp print_char_fim
1713   0B9D             
1714   0B9D             incXOK:
1715   0B9D 32 03 E0        ld (LCD_TXT_X), a
1716   0BA0             
1717   0BA0             print_char_fim:
1718   0BA0                 ;ld hl, DISPLAY
1719   0BA0                 ;CALL print_image
1720   0BA0 E1              POP HL
1721   0BA1 D1              POP DE
1722   0BA2 C1              POP BC
1723   0BA3 F1              POP AF
1724   0BA4 C9              RET
1725   0BA5             ;-------- FIM PRINTCHAR ------------------
1726   0BA5             
1727   0BA5             
1728   0BA5             
1729   0BA5             ; ----------------------------------
1730   0BA5             
1731   0BA5             ; INPUT: THE VALUES IN REGISTER B EN C
1732   0BA5             ; OUTPUT: HL = B * C
1733   0BA5             ; CHANGES: AF,DE,HL,B
1734   0BA5             ;
1735   0BA5             multiplication:
1736   0BA5 21 00 00    	LD HL,0
1737   0BA8 78          	LD A,B
1738   0BA9 B7          	OR A
1739   0BAA C8          	RET Z
1740   0BAB 16 00       	LD D,0
1741   0BAD 59          	LD E,C
1742   0BAE 19          multiplicationLOOP:	ADD HL,DE
1743   0BAF 10 FD       	DJNZ multiplicationLOOP
1744   0BB1 C9          	RET 
1745   0BB2             
1746   0BB2             ;-----------------------------------
1747   0BB2             
1748   0BB2             Div_HL_D:
1749   0BB2             ;Inputs:
1750   0BB2             ;   HL and D
1751   0BB2             ;Outputs:
1752   0BB2             ;   HL is the quotient (HL/D)
1753   0BB2             ;   A is the remainder
1754   0BB2             ;   B is 0
1755   0BB2             ;   C,D,E are preserved
1756   0BB2 AF              xor a         ; Clear upper eight bits of AHL
1757   0BB3 06 10           ld b,16       ; Sixteen bits in dividend
1758   0BB5             _loop:
1759   0BB5 29              add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
1760   0BB6 17              rla           ; This moves the upper bits of the dividend into A
1761   0BB7 38 03           jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
1762   0BB9 BA              cp d          ; Check if we can subtract the divisor
1763   0BBA 38 02           jr c,_skip    ; Carry means A < D
1764   0BBC             _overflow:
1765   0BBC 92              sub d         ; Do subtraction for real this time
1766   0BBD 2C              inc l         ; Set the next bit of the quotient (currently bit 0)
1767   0BBE             _skip:
1768   0BBE 10 F5           djnz _loop
1769   0BC0 C9              ret
1770   0BC1             
1771   0BC1             
1772   0BC1             ; -----------------------------------------------------------------------------
1773   0BC1             ;   LCD DRIVER
1774   0BC1             ; -----------------------------------------------------------------------------
1775   0BC1             ; INIT_LCD - Inicia o lcd em mode texto
1776   0BC1             ; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
1777   0BC1             ; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
1778   0BC1             ; lcd_clear - Limpa buffer do lcd
1779   0BC1             ; enable_grafic - Coloca o LCD em modo grafico
1780   0BC1             ; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
1781   0BC1             ; cls_TXT - Limpa LCD mode text
1782   0BC1             ; cls_GRAPHIC - Limpa LCD modo grafico
1783   0BC1             
1784   0BC1             INIT_LCD:
1785   0BC1                 ;Initialisation
1786   0BC1 3E 30       	ld a, 30H
1787   0BC3 CD 05 0D    	call lcd_send_command
1788   0BC6             
1789   0BC6 3E A0       	ld a, 0b00100000
1790   0BC8 CD 05 0D    	call lcd_send_command
1791   0BCB             
1792   0BCB 3E 30       	ld a, 30H
1793   0BCD CD 05 0D    	call lcd_send_command
1794   0BD0             
1795   0BD0 3E 0C       	ld a, 0CH
1796   0BD2 CD 05 0D    	call lcd_send_command
1797   0BD5             
1798   0BD5 3E 01       	ld a, 01H
1799   0BD7 CD 0F 0D    	call lcd_send_command_clear ;; clear
1800   0BDA             
1801   0BDA 3E 02       	ld a, 02H
1802   0BDC CD 05 0D    	call lcd_send_command
1803   0BDF C9              RET
1804   0BE0             
1805   0BE0             
1806   0BE0             ; pixel index in HL
1807   0BE0             lcd_setPixel:
1808   0BE0 E5              push hl
1809   0BE1 C5              push bc
1810   0BE2 D5              push de
1811   0BE3 F5              push af
1812   0BE4 AF              xor A
1813   0BE5 32 07 E0        ld (LCD_BIT_INDEX), A
1814   0BE8 32 05 E0        ld (LCD_BYTE_INDEX), A
1815   0BEB             
1816   0BEB 16 08           ld d, 8
1817   0BED CD B2 0B        call Div_HL_D
1818   0BF0 32 07 E0        ld (LCD_BIT_INDEX), A
1819   0BF3 22 05 E0        ld (LCD_BYTE_INDEX), HL
1820   0BF6 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1821   0BFA 21 00 E5        ld hl, DISPLAY
1822   0BFD 09              add hl, bc
1823   0BFE                 
1824   0BFE 06 80           ld b, 128 ; 1000 0000
1825   0C00 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1826   0C03 FE 00           cp 0
1827   0C05 CA 11 0C        jp z, lcd_setPixel_fim
1828   0C08             lcd_setPixel_bit:
1829   0C08 CB 38           srl B
1830   0C0A 3D              dec A
1831   0C0B CA 11 0C        jp z, lcd_setPixel_fim
1832   0C0E                 
1833   0C0E C3 08 0C        jp lcd_setPixel_bit
1834   0C11             lcd_setPixel_fim
1835   0C11 7E              ld a, (hl)
1836   0C12 B0              or b
1837   0C13 77              ld (hl), a
1838   0C14             
1839   0C14 F1              pop af
1840   0C15 C1              pop bc
1841   0C16 D1              pop de
1842   0C17 E1              pop hl
1843   0C18 C9              ret
1844   0C19             
1845   0C19             ;===============================
1846   0C19             ; pixel index in HL
1847   0C19             lcd_clearPixel:
1848   0C19 E5              push hl
1849   0C1A C5              push bc
1850   0C1B D5              push de
1851   0C1C F5              push af
1852   0C1D AF              xor A
1853   0C1E 32 07 E0        ld (LCD_BIT_INDEX), A
1854   0C21 32 05 E0        ld (LCD_BYTE_INDEX), A
1855   0C24 16 08           ld d, 8
1856   0C26 CD B2 0B        call Div_HL_D
1857   0C29 32 07 E0        ld (LCD_BIT_INDEX), A
1858   0C2C 22 05 E0        ld (LCD_BYTE_INDEX), HL
1859   0C2F ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1860   0C33 21 00 E5        ld hl, DISPLAY
1861   0C36 09              add hl, bc
1862   0C37                 
1863   0C37 06 80           ld b, 128 ; 1000 0000
1864   0C39 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1865   0C3C FE 00           cp 0
1866   0C3E CA 4A 0C        jp z, lcd_clearPixel_fim
1867   0C41             lcd_clearPixel_bit:
1868   0C41 CB 38           srl B
1869   0C43 3D              dec A
1870   0C44 CA 4A 0C        jp z, lcd_clearPixel_fim
1871   0C47                 
1872   0C47 C3 41 0C        jp lcd_clearPixel_bit
1873   0C4A             lcd_clearPixel_fim
1874   0C4A 78              ld a, b
1875   0C4B 2F              cpl     ; NOT B
1876   0C4C 47              ld b, a
1877   0C4D             
1878   0C4D 7E              ld a, (hl)
1879   0C4E A0              and b
1880   0C4F 77              ld (hl), a
1881   0C50             
1882   0C50 F1              pop af
1883   0C51 C1              pop bc
1884   0C52 D1              pop de
1885   0C53 E1              pop hl
1886   0C54 C9              ret
1887   0C55             
1888   0C55             
1889   0C55             ;;--------------------------------------------------
1890   0C55             lcd_clear:
1891   0C55                 ;; HL = start address of block
1892   0C55 21 00 E5        ld hl, DISPLAY
1893   0C58             
1894   0C58                 ;; DE = HL + 1
1895   0C58 5D              ld e,l
1896   0C59 54              ld d,h
1897   0C5A 13              inc de
1898   0C5B             
1899   0C5B                 ;; initialise first byte of block
1900   0C5B                 ;; with data byte (&00)
1901   0C5B 36 00           ld (hl), 0
1902   0C5D                     
1903   0C5D                 ;; BC = length of block in bytes
1904   0C5D                 ;; HL+BC-1 = end address of block
1905   0C5D             
1906   0C5D 01 00 04        ld bc, 1024
1907   0C60             
1908   0C60                 ;; fill memory
1909   0C60 ED B0           ldir
1910   0C62 C9              ret
1911   0C63             
1912   0C63             
1913   0C63             ;===================
1914   0C63             
1915   0C63             ; grafic mode - enable
1916   0C63             enable_grafic:
1917   0C63 3E 30       	ld a, 30H
1918   0C65 CD 05 0D    	call lcd_send_command
1919   0C68 CD 38 0D    	call delayLCD
1920   0C6B             	
1921   0C6B 3E 34       	ld a, 34H
1922   0C6D CD 05 0D    	call lcd_send_command
1923   0C70 CD 38 0D    	call delayLCD
1924   0C73             	
1925   0C73 3E 36       	ld a, 36H
1926   0C75 CD 05 0D    	call lcd_send_command
1927   0C78 CD 38 0D    	call delayLCD
1928   0C7B C9              ret
1929   0C7C             
1930   0C7C             
1931   0C7C             ;==========================
1932   0C7C             
1933   0C7C             print_image:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
1934   0C7C             									; HL content the data address
1935   0C7C F5              push af
1936   0C7D D5          	push de
1937   0C7E C5          	push bc
1938   0C7F             
1939   0C7F             
1940   0C7F             ; premiere partie : X de 0 à 127 / Y de 0 à 32
1941   0C7F             
1942   0C7F 3E 20       	ld a,32
1943   0C81 57          	ld d,a							; boucle Y
1944   0C82 3E 00       	ld a,0
1945   0C84 5F          	ld e,a
1946   0C85             	
1947   0C85             boucle_colonne:
1948   0C85 3E 80       		ld a,$80					; coordonnée Y (0)
1949   0C87 83          		add a,e
1950   0C88 CD 05 0D    		call lcd_send_command
1951   0C8B             		
1952   0C8B 3E 80       		ld a,$80					; coordonnée X (0)		
1953   0C8D CD 05 0D    		call lcd_send_command
1954   0C90             		
1955   0C90 3E 08       		ld a,8
1956   0C92 47          		ld b,a						; boucle X
1957   0C93             		
1958   0C93             boucle_ligne:	
1959   0C93 7E          			ld a,(hl)
1960   0C94 CD 19 0D    			call lcd_send_data
1961   0C97 23          			inc hl
1962   0C98 7E          			ld a,(hl)
1963   0C99 CD 19 0D    			call lcd_send_data		; auto-increment on screen address
1964   0C9C 23          			inc hl
1965   0C9D 05          			dec b
1966   0C9E AF          			XOR a
1967   0C9F B0          			OR b
1968   0CA0 C2 93 0C    			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
1969   0CA3             		
1970   0CA3 15          		dec d
1971   0CA4 1C          		inc e
1972   0CA5 AF          		XOR a
1973   0CA6 B2          		OR d
1974   0CA7 C2 85 0C    		jp nz,boucle_colonne
1975   0CAA             		
1976   0CAA             
1977   0CAA             ; seconde partie : X de 128 à 255 / Y de 0 à 32
1978   0CAA             
1979   0CAA 3E 20       	ld a,32
1980   0CAC 57          	ld d,a							; boucle Y
1981   0CAD 3E 00       	ld a,0
1982   0CAF 5F          	ld e,a
1983   0CB0             	
1984   0CB0             boucle_colonne2:
1985   0CB0 3E 80       		ld a,$80					; coordonnée Y (0)
1986   0CB2 83          		add a, e
1987   0CB3 CD 05 0D    		call lcd_send_command
1988   0CB6             		
1989   0CB6 3E 88       		ld a,$88					; coordonnée X (8)		
1990   0CB8 CD 05 0D    		call lcd_send_command
1991   0CBB             		
1992   0CBB 3E 08       		ld a,8
1993   0CBD 47          		ld b,a						; boucle X
1994   0CBE             		
1995   0CBE             boucle_ligne2:	
1996   0CBE 7E          			ld a,(hl)
1997   0CBF CD 19 0D    			call lcd_send_data
1998   0CC2 23          			inc hl
1999   0CC3 7E          			ld a,(hl)
2000   0CC4 CD 19 0D    			call lcd_send_data		; auto-increment on screen address
2001   0CC7 23          			inc hl
2002   0CC8 05          			dec b
2003   0CC9 AF          			XOR a
2004   0CCA B0          			OR b
2005   0CCB C2 BE 0C    			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
2006   0CCE             		
2007   0CCE 15          		dec d
2008   0CCF 1C          		inc e
2009   0CD0 AF          		XOR a
2010   0CD1 B2          		OR d
2011   0CD2 C2 B0 0C    		jp nz,boucle_colonne2
2012   0CD5             
2013   0CD5 C1          	pop bc
2014   0CD6 D1          	pop de
2015   0CD7 F1              pop af
2016   0CD8             
2017   0CD8 C9              ret
2018   0CD9             
2019   0CD9             
2020   0CD9             
2021   0CD9             ; ======================
2022   0CD9             cls_TXT:
2023   0CD9             	; # CLEAR DISPLAY IN TEXT MODE # 
2024   0CD9 3E 01       	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
2025   0CDB CD 0F 0D    	call lcd_send_command_clear		; CLEAR DISPLAY	
2026   0CDE C9              ret
2027   0CDF             
2028   0CDF             ; ========================
2029   0CDF             
2030   0CDF             cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
2031   0CDF             					;	Graphic RAM (GDRAM) use :
2032   0CDF             					;	1. Set vertical address (Y) for GDRAM
2033   0CDF             					;	2. Set horizontal address (X) for GDRAM
2034   0CDF             					;	3. Write D15~D8 to GDRAM (first byte)
2035   0CDF             					;	4. Write D7~D0 to GDRAM (second byte)
2036   0CDF C5          	push bc
2037   0CE0 D5          	push de
2038   0CE1             
2039   0CE1 1E 20       	ld e,$20						; e = 32 
2040   0CE3 16 00       	ld d,$0							; d = 0
2041   0CE5             Boucle32X:
2042   0CE5 7A          		ld a,d
2043   0CE6 F6 80       		OR $80
2044   0CE8 CD 05 0D    		call lcd_send_command
2045   0CEB             		
2046   0CEB 3E 80       		ld a,$80					; Set horizontal address（X） for GDRAM = 0 ($80)
2047   0CED CD 05 0D    		call lcd_send_command
2048   0CF0             		
2049   0CF0 AF          		xor a							 	
2050   0CF1 06 10       		ld b,$10							; b = 17
2051   0CF3             		
2052   0CF3             Boucle16X:	 
2053   0CF3 CD 19 0D    			call lcd_send_data 			; Write D15〜D8 to GDRAM (first byte)
2054   0CF6 CD 19 0D    			call lcd_send_data 			; Write D7〜D0 to GDRAM (second byte)
2055   0CF9             											; Address counter will automatically increase by one for the next two-byte data												
2056   0CF9 10 F8       			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
2057   0CFB             		
2058   0CFB 1D          		dec e 
2059   0CFC 14          		inc d
2060   0CFD AF          		xor a							; a = 0
2061   0CFE B3          		or e
2062   0CFF C2 E5 0C    		jp nz,Boucle32X
2063   0D02             
2064   0D02 D1          	pop de
2065   0D03 C1          	pop bc
2066   0D04             	
2067   0D04 C9              ret
2068   0D05             
2069   0D05             
2070   0D05             
2071   0D05             ;******************
2072   0D05             ;Send a command byte to the LCD
2073   0D05             ;Entry: A= command byte
2074   0D05             ;Exit: All preserved
2075   0D05             ;******************
2076   0D05             lcd_send_command:
2077   0D05 C5          	push bc				;Preserve
2078   0D06 0E 70       	ld c, LCDCTRL   	;Command port
2079   0D08             	
2080   0D08 CD 38 0D    	call delayLCD
2081   0D0B             	
2082   0D0B ED 79       	out (c),a			;Send command
2083   0D0D C1          	pop bc				;Restore
2084   0D0E C9          	ret
2085   0D0F             
2086   0D0F             
2087   0D0F             ;******************
2088   0D0F             ;Send a command byte to the LCD
2089   0D0F             ;Entry: A= command byte
2090   0D0F             ;Exit: All preserved
2091   0D0F             ;******************
2092   0D0F             lcd_send_command_clear:
2093   0D0F C5          	push bc				;Preserve
2094   0D10             	
2095   0D10 CD 42 0D    	call delayLCDclear
2096   0D13             	
2097   0D13 0E 70           ld c, LCDCTRL   	;Command port
2098   0D15 ED 79       	out (c),a			;Send command
2099   0D17 C1          	pop bc				;Restore
2100   0D18 C9          	ret
2101   0D19             	
2102   0D19             ;******************
2103   0D19             ;Send a data byte to the LCD
2104   0D19             ;Entry: A= data byte
2105   0D19             ;Exit: All preserved
2106   0D19             ;******************
2107   0D19             lcd_send_data:
2108   0D19 C5          	push bc				;Preserve
2109   0D1A             	
2110   0D1A                 ;Busy wait
2111   0D1A CD 38 0D    	call delayLCD
2112   0D1D             
2113   0D1D 0E 71       	ld c, LCDDATA	;Data port $71
2114   0D1F ED 79       	out (c),a			;Send data
2115   0D21 C1          	pop bc				;Restore
2116   0D22 C9          	ret
2117   0D23             
2118   0D23             
2119   0D23             
2120   0D23             
2121   0D23             ;******************
2122   0D23             ;Send an asciiz string to the LCD
2123   0D23             ;Entry: HL=address of string
2124   0D23             ;Exit: HL=address of ending zero of the string. All others preserved
2125   0D23             ;******************
2126   0D23             lcd_send_asciiz:
2127   0D23 F5          	push af
2128   0D24 C5          	push bc				;Preserve
2129   0D25             lcd_asciiz_char_loop:
2130   0D25 0E 70       	ld c, LCDCTRL   	;Command port
2131   0D27             	
2132   0D27             lcd_asciiz_wait_loop:	;Busy wait
2133   0D27 CD 38 0D    	call delayLCD
2134   0D2A             	
2135   0D2A 7E          	ld a,(hl)			;Get character
2136   0D2B A7          	and a				;Is it zero?
2137   0D2C 28 07       	jr z,lcd_asciiz_done	;If so, we're done
2138   0D2E             	
2139   0D2E 0E 71       	ld c, LCDDATA	;Data port
2140   0D30 ED 79       	out (c),a			;Send data
2141   0D32 23          	inc hl				;Next char
2142   0D33 18 F0       	jr lcd_asciiz_char_loop
2143   0D35             	
2144   0D35             lcd_asciiz_done:
2145   0D35 C1          	pop bc				;Restore
2146   0D36 F1          	pop af
2147   0D37 C9          	ret
2148   0D38             
2149   0D38             ; =========================================================
2150   0D38             ; Delay LCD
2151   0D38             ; =========================================================
2152   0D38             delayLCD:
2153   0D38 00          	NOP
2154   0D39 00          	NOP
2155   0D3A 00          	NOP
2156   0D3B 00          	NOP
2157   0D3C 00          	NOP
2158   0D3D 00          	NOP
2159   0D3E 00          	NOP
2160   0D3F 00          	NOP
2161   0D40 00              NOP
2162   0D41 C9              ret
2163   0D42             
2164   0D42             delayLCDclear:
2165   0D42 00          	NOP
2166   0D43 00          	NOP
2167   0D44 00          	NOP
2168   0D45 00          	NOP
2169   0D46 00          	NOP
2170   0D47 00          	NOP
2171   0D48 00          	NOP
2172   0D49 00          	NOP
2173   0D4A 00          	NOP
2174   0D4B 00          	NOP
2175   0D4C 00          	NOP
2176   0D4D 00          	NOP
2177   0D4E 00              NOP
2178   0D4F C9              ret
2179   0D50             
2180   0D50             	
2181   0D50             ; =========================================================
2182   0D50             ; Delay
2183   0D50             ; =========================================================
2184   0D50             delay:
2185   0D50 C5          	push bc                       ; 2.75 us
2186   0D51 06 01           ld b, 1                     ; 1.75 us
2187   0D53             delay_loop_b:
2188   0D53 0E FF       	ld c, 255                     ; 1.75 us
2189   0D55             delay_loop:
2190   0D55 0D          	dec c                         ; 1 us
2191   0D56 C2 55 0D        jp nz, delay_loop             ; true = 3 us, false 1.75 us
2192   0D59 05              dec b                         ; 1 us
2193   0D5A C2 53 0D        jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
2194   0D5D C1              pop bc                        ; 2.50 us
2195   0D5E C9              ret   
2196   0D5F             
2197   0D5F             
2198   0D5F             ; Check break key
2199   0D5F 3E 40       CHKKEY: LD  A, $40
2200   0D61 D3 40       	OUT (KEY_OUT), A ; line 4
2201   0D63 DB 40       	IN  A, (KEY_IN)
2202   0D65 FE 01       	CP  1
2203   0D67 C2 6F 0D    	JP  NZ, GRET
2204   0D6A 3E 03       	LD  A, CTRLC
2205   0D6C FE 00       	CP	0
2206   0D6E C9          	RET
2207   0D6F             GRET:
2208   0D6F 3E 00       	LD  A, 0
2209   0D71 FE 00       	CP 0
2210   0D73 C9          	RET
2211   0D74             
2212   0D74             
2213   0D74             
2214   0D74             
2215   0D74             ; -----------------------------------------------------------------------------
2216   0D74             ;   KEYREAD - KEY In A
2217   0D74             ; -----------------------------------------------------------------------------
2218   0D74             KEYREADINIT:
2219   0D74 C5              PUSH    BC
2220   0D75 D5          	PUSH	DE
2221   0D76 E5          	PUSH    HL
2222   0D77 1E 00       	LD      E, 0                    ; E will be the last pressed key
2223   0D79             READKEY:        
2224   0D79 26 01           LD      H, 1                    ; H is the line register, start with second
2225   0D7B 06 00       	LD      B, 0                    ; Count lines for later multiplication	
2226   0D7D 16 00       	LD      D, 0                    ; DE will be the adress for mask
2227   0D7F             						
2228   0D7F             NEXTKEY:        
2229   0D7F 7C              LD      A, H						
2230   0D80 FE 00           CP      0                       ; All lines tried? 
2231   0D82 CA BD 0D        JP      Z, KEYOUT               ; Then check if there was a key pressed
2232   0D85 D3 40       	OUT     (KEY_OUT), A		    ; Put current line to register
2233   0D87 DB 40       	IN      A, (KEY_IN)		        ; Input Keys
2234   0D89 E6 3F       	AND     $3F                     ; only 6 bits
2235   0D8B CB 24       	SLA     H                       ; Next line
2236   0D8D 04              INC     B
2237   0D8E FE 00           CP      0                       ; Was key zero?
2238   0D90 CA 7F 0D        JP      Z, NEXTKEY              ; Then try again with next lines
2239   0D93 16 00           LD      D, 0                    ; In D will be the number of the key
2240   0D95             LOGARITHM:      
2241   0D95 14              INC     D	                    ; Add one per shift
2242   0D96 CB 3F           SRL     A                       ; Shift key right
2243   0D98 C2 95 0D        JP      NZ, LOGARITHM		    ; If not zero shift again
2244   0D9B 15              DEC     D                       ; Was too much
2245   0D9C DB 40       	IN      A, (KEY_IN)
2246   0D9E E6 80           AND     $80                     ; Check if first bit set (shift key pressed)
2247   0DA0 C2 A9 0D        JP      NZ, LOADSHIFT		    ; Then jump to read with shift
2248   0DA3 7A              LD      A, D                    ; Put read key into accu
2249   0DA4 C6 33           ADD     A, KEYMAP               ; Add base of key map array
2250   0DA6 C3 AC 0D        JP      ADDOFFSET               ; Jump to load key
2251   0DA9             LOADSHIFT:
2252   0DA9 7A              LD      A, D
2253   0DAA C6 63           ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
2254   0DAC             ADDOFFSET:
2255   0DAC C6 06           ADD     A, 6                    ; Add 6 for every line
2256   0DAE 10 FC           DJNZ    ADDOFFSET               ; Jump back (do while loop)
2257   0DB0 D6 06       	SUB     6                       ; Since do while is one too much
2258   0DB2             TRANSKEY:
2259   0DB2 A8              XOR     B                       ; Empty B
2260   0DB3 4F          	LD      C, A                    ; A will be address in BC
2261   0DB4 0A          	LD      A, (BC)	                ; Load key
2262   0DB5 BB          	CP      E                       ; Same key?
2263   0DB6 CA 79 0D    	JP      Z, READKEY              ; Then from beginning
2264   0DB9 5F          	LD      E, A                    ; Otherwise save new key
2265   0DBA C3 79 0D    	JP      READKEY	                ; And restart
2266   0DBD             KEYOUT:
2267   0DBD 7B              LD      A, E
2268   0DBE 1E 00           LD      E, 0                    ; empty it
2269   0DC0 B7              OR      A	                    ; Was a key read?
2270   0DC1 CA 79 0D        JP      Z, READKEY              ; If not restart
2271   0DC4 E1              POP     HL
2272   0DC5 D1              POP     DE
2273   0DC6 C1              POP     BC
2274   0DC7 C9              RET
2275   0DC8             
2276   0DC8             
2277   0DC8             ;-----------------------
2278   0DC8             ; RECEIVE INTEL HEX FILE
2279   0DC8             ;-----------------------       
2280   0DC8             INTHEX: 
2281   0DC8 21 04 13           LD HL, MSG_ILOAD
2282   0DCB CD 7B 0E           CALL  SNDLCDMSG
2283   0DCE             
2284   0DCE 21 04 13           LD HL, MSG_ILOAD
2285   0DD1 CD 8E 0E           CALL  SNDMSG
2286   0DD4                    
2287   0DD4             
2288   0DD4 CD F3 0D           CALL  INTELH
2289   0DD7 20 0D              JR    NZ,ITHEX1      
2290   0DD9             
2291   0DD9 21 1A 13           LD    HL,FILEOK
2292   0DDC CD 7B 0E           CALL  SNDLCDMSG   ;GOT FILE OK LCD
2293   0DDF 21 1A 13           LD    HL,FILEOK
2294   0DE2 CD 8E 0E           CALL  SNDMSG      ;GOT FILE OK Serial
2295   0DE5                    
2296   0DE5 C9                 RET
2297   0DE6 21 2C 13    ITHEX1: LD    HL,CSUMERR
2298   0DE9 CD 7B 0E           CALL  SNDLCDMSG
2299   0DEC             
2300   0DEC 21 2C 13           LD    HL,CSUMERR
2301   0DEF CD 8E 0E           CALL  SNDMSG      ;CHECKSUM ERROR
2302   0DF2                    
2303   0DF2 C9                 RET  
2304   0DF3             
2305   0DF3             
2306   0DF3             
2307   0DF3             
2308   0DF3             
2309   0DF3             ;-----------------------
2310   0DF3             ; RECEIVE INTEL HEX FILE
2311   0DF3             ;-----------------------
2312   0DF3 DD 21 00 F0 INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
2313   0DF7             ;
2314   0DF7             ; WAIT FOR RECORD MARK
2315   0DF7             ;
2316   0DF7 AF          INTEL1:	XOR	A
2317   0DF8 DD 77 03    	LD	(IX+3),A	;CLEAR CHECKSUM
2318   0DFB CD D3 0E    	CALL	RXDATA	;WAIT FOR THE RECORD MARK
2319   0DFE FE 3A       	CP	':'	;TO BE TRANSMITTED
2320   0E00 20 F5       	JR	NZ,INTEL1	;NOT RECORD MARK
2321   0E02             ;
2322   0E02             ; GET RECORD LENGTH
2323   0E02             ;
2324   0E02 CD 4F 0E    	CALL	GETBYT
2325   0E05 DD 77 00    	LD	(IX+0),A	;NUMBER OF DATA BYTES
2326   0E08             ;
2327   0E08             ; GET ADDRESS FIELD
2328   0E08             ;
2329   0E08 CD 4F 0E    	CALL	GETBYT
2330   0E0B DD 77 02    	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
2331   0E0E CD 4F 0E    	CALL	GETBYT
2332   0E11 DD 77 01    	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
2333   0E14             ;
2334   0E14             ; GET RECORD TYPE
2335   0E14             ;
2336   0E14 CD 4F 0E    	CALL	GETBYT
2337   0E17 20 24       	JR	NZ,INTEL4	;END OF FILE RECORD
2338   0E19             ;
2339   0E19             ; READ IN THE DATA
2340   0E19             ;
2341   0E19 DD 46 00    	LD	B,(IX+0)	;NUMBER OF DATA BYTES
2342   0E1C DD 66 02    	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
2343   0E1F DD 6E 01    	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
2344   0E22             
2345   0E22 CD 4F 0E    INTEL2:	CALL	GETBYT	;GET DATA BYTE
2346   0E25 77          	LD	(HL),A	;STORE DATA BYTE
2347   0E26 23          	INC	HL
2348   0E27 10 F9       	DJNZ	INTEL2	;LOAD MORE BYTES
2349   0E29             ;
2350   0E29             ; GET CHECKSUM AND COMPARE
2351   0E29             ;
2352   0E29 DD 7E 03    	LD	A,(IX+3)	;CONVERT CHECKSUM TO
2353   0E2C ED 44       	NEG		;TWO'S COMPLEMENT
2354   0E2E DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
2355   0E31 CD 4F 0E    	CALL	GETBYT
2356   0E34 DD 77 03    	LD	(IX+3),A	;SAVE RECORD CHECKSUM
2357   0E37 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
2358   0E3A 28 BB       	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
2359   0E3C C9              RET             ;NZ=CHECKSUM ERROR
2360   0E3D             ;
2361   0E3D             ; END OF FILE RECORD
2362   0E3D             ;
2363   0E3D DD 7E 03    INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
2364   0E40 ED 44       	NEG		;TWO'S COMPLEMENT
2365   0E42 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
2366   0E45 CD 4F 0E    	CALL	GETBYT
2367   0E48 DD 77 03    	LD	(IX+3),A	;SAVE EOF CHECKSUM
2368   0E4B DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
2369   0E4E C9          	RET  	    ;NZ=CHECKSUM ERROR
2370   0E4F             ;--------------------------
2371   0E4F             ; GET BYTE FROM SERIAL PORT
2372   0E4F             ;--------------------------
2373   0E4F C5          GETBYT:	PUSH	BC
2374   0E50 CD D3 0E    	CALL	RXDATA
2375   0E53 CB 77       	BIT	6,A
2376   0E55 28 02       	JR	Z,GETBT1
2377   0E57 C6 09       	ADD	A,09H
2378   0E59 E6 0F       GETBT1:	AND	0FH
2379   0E5B CB 27       	SLA 	A
2380   0E5D CB 27       	SLA	A
2381   0E5F CB 27       	SLA	A
2382   0E61 CB 27       	SLA	A
2383   0E63 4F          	LD	C,A
2384   0E64             ;
2385   0E64             ; GET LOW NYBBLE
2386   0E64             ;
2387   0E64 CD D3 0E    	CALL	RXDATA
2388   0E67 CB 77       	BIT	6,A
2389   0E69 28 02       	JR	Z,GETBT2
2390   0E6B C6 09       	ADD	A,09H
2391   0E6D E6 0F       GETBT2:	AND	0FH
2392   0E6F B1          	OR	C
2393   0E70 47          	LD	B,A
2394   0E71 DD 86 03    	ADD	A,(IX+3)
2395   0E74 DD 77 03    	LD	(IX+3),A	;ADD TO CHECKSUM
2396   0E77 78          	LD	A,B
2397   0E78 A7          	AND	A	;CLEAR CARRY
2398   0E79 C1              POP	BC
2399   0E7A C9          	RET
2400   0E7B             
2401   0E7B             ;-----------------------------------------
2402   0E7B             ; SEND AN ASCII STRING OUT LCD
2403   0E7B             ;-----------------------------------------
2404   0E7B             ; 
2405   0E7B             ; SENDS A ZERO TERMINATED STRING OR 
2406   0E7B             ; 128 CHARACTERS MAX. OUT LCD
2407   0E7B             ;
2408   0E7B             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2409   0E7B             ;      EXIT  : NONE
2410   0E7B             ;
2411   0E7B             ;       MODIFIES : A,B,C
2412   0E7B             ;          
2413   0E7B 06 80       SNDLCDMSG: LD    B,128         ;128 CHARS MAX
2414   0E7D 7E          SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
2415   0E7E FE 00              CP    00H          ;ZERO TERMINATOR?
2416   0E80 28 06              JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2417   0E82 CD 55 0A           CALL PrintBufferChar         ;TRANSMIT THE CHAR
2418   0E85 23                 INC   HL
2419   0E86 10 F5              DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
2420   0E88             SDLCDMSG2: 
2421   0E88 21 00 E5        LD HL, DISPLAY
2422   0E8B CD 7C 0C        CALL print_image
2423   0E8E             RET
2424   0E8E             
2425   0E8E             ;-----------------------------------------
2426   0E8E             ; SEND AN ASCII STRING OUT THE SERIAL PORT
2427   0E8E             ;-----------------------------------------
2428   0E8E             ; 
2429   0E8E             ; SENDS A ZERO TERMINATED STRING OR 
2430   0E8E             ; 128 CHARACTERS MAX. OUT THE SERIAL PORT
2431   0E8E             ;
2432   0E8E             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2433   0E8E             ;      EXIT  : NONE
2434   0E8E             ;
2435   0E8E             ;       MODIFIES : A,B,C
2436   0E8E             ;          
2437   0E8E 06 80       SNDMSG: LD    B,128         ;128 CHARS MAX
2438   0E90 7E          SDMSG1: LD    A,(HL)        ;GET THE CHAR
2439   0E91 FE 00              CP    00H          ;ZERO TERMINATOR?
2440   0E93 28 06              JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2441   0E95 CD 9C 0E           CALL  OUTCH         ;TRANSMIT THE CHAR
2442   0E98 23                 INC   HL
2443   0E99 10 F5              DJNZ  SDMSG1        ;128 CHARS MAX!    
2444   0E9B C9          SDMSG2: RET
2445   0E9C             
2446   0E9C             
2447   0E9C             
2448   0E9C             ;-----------------------------------
2449   0E9C             ; OUTPUT A CHARACTER TO THE TERMINAL
2450   0E9C             ;-----------------------------------       
2451   0E9C DD 2A AA FF OUTCH:  LD   IX,(PUTCH)
2452   0EA0 DD E9              JP   (IX)
2453   0EA2             ;------------------------------------
2454   0EA2             ; INPUT A CHARACTER FROM THE TERMINAL
2455   0EA2             ;------------------------------------
2456   0EA2 DD 2A AC FF INCH:  LD   IX,(GETCH)
2457   0EA6 DD E9             JP   (IX)
2458   0EA8             
2459   0EA8             
2460   0EA8             
2461   0EA8             ;------------------------
2462   0EA8             ; SERIAL TRANSMIT ROUTINE
2463   0EA8             ;------------------------
2464   0EA8             ;TRANSMIT BYTE SERIALLY ON DOUT
2465   0EA8             ;
2466   0EA8             ; ENTRY : A = BYTE TO TRANSMIT
2467   0EA8             ;  EXIT : NO REGISTERS MODIFIED
2468   0EA8             ;
2469   0EA8 F5          TXDATA:	PUSH	AF
2470   0EA9 C5          	PUSH	BC
2471   0EAA E5          	PUSH	HL
2472   0EAB 2A C0 FF    	LD	HL,(BAUD)
2473   0EAE 4F          	LD	C,A
2474   0EAF             ;
2475   0EAF             ; TRANSMIT START BIT
2476   0EAF             ;
2477   0EAF AF          	XOR	A
2478   0EB0 D3 C0       	OUT	(SERIAL_TX_PORT),A
2479   0EB2 CD 00 0F    	CALL	BITIME
2480   0EB5             ;
2481   0EB5             ; TRANSMIT DATA
2482   0EB5             ;
2483   0EB5 06 08       	LD	B,08H
2484   0EB7 CB 09       	RRC	C
2485   0EB9 CB 09       NXTBIT:	RRC	C	;SHIFT BITS TO D6,
2486   0EBB 79          	LD	A,C	;LSB FIRST AND OUTPUT
2487   0EBC E6 40       	AND	40H	;THEM FOR ONE BIT TIME.
2488   0EBE D3 C0       	OUT	(SERIAL_TX_PORT),A
2489   0EC0 CD 00 0F    	CALL	BITIME
2490   0EC3 10 F4       	DJNZ	NXTBIT
2491   0EC5             ;
2492   0EC5             ; SEND STOP BITS
2493   0EC5             ;
2494   0EC5 3E 40       	LD	A,40H
2495   0EC7 D3 C0       	OUT	(SERIAL_TX_PORT),A
2496   0EC9 CD 00 0F    	CALL	BITIME
2497   0ECC CD 00 0F    	CALL	BITIME
2498   0ECF E1          	POP	HL
2499   0ED0 C1          	POP	BC
2500   0ED1 F1          	POP	AF
2501   0ED2 C9          	RET
2502   0ED3             ;-----------------------
2503   0ED3             ; SERIAL RECEIVE ROUTINE
2504   0ED3             ;-----------------------
2505   0ED3             ;RECEIVE SERIAL BYTE FROM DIN
2506   0ED3             ;
2507   0ED3             ; ENTRY : NONE
2508   0ED3             ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
2509   0ED3             ;
2510   0ED3             ; REGISTERS MODIFIED A AND F
2511   0ED3             ;
2512   0ED3 C5          RXDATA:	PUSH	BC
2513   0ED4 E5          	PUSH	HL
2514   0ED5             ;
2515   0ED5             ; WAIT FOR START BIT 
2516   0ED5             ;
2517   0ED5 DB C0       RXDAT1: IN	A,(SERIAL_RX_PORT)
2518   0ED7 CB 7F       	    BIT	7,A
2519   0ED9 20 FA       	    JR	NZ,RXDAT1	;NO START BIT
2520   0EDB             ;
2521   0EDB             ; DETECTED START BIT
2522   0EDB             ;
2523   0EDB 2A C0 FF    	LD	HL,(BAUD)
2524   0EDE CB 3C       	SRL	H
2525   0EE0 CB 1D       	RR	L 	;DELAY FOR HALF BIT TIME
2526   0EE2 CD 00 0F    	CALL 	BITIME
2527   0EE5 DB C0       	IN	A,(SERIAL_RX_PORT)
2528   0EE7 CB 7F       	BIT	7,A
2529   0EE9 20 EA       	JR	NZ,RXDAT1	;START BIT NOT VALID
2530   0EEB             ;
2531   0EEB             ; DETECTED VALID START BIT,READ IN DATA
2532   0EEB             ;
2533   0EEB 06 08       	LD	B,08H
2534   0EED 2A C0 FF    RXDAT2:	LD	HL,(BAUD)
2535   0EF0 CD 00 0F    	CALL	BITIME	;DELAY ONE BIT TIME
2536   0EF3 DB C0       	IN	A,(SERIAL_RX_PORT)
2537   0EF5 CB 17       	RL	A
2538   0EF7 CB 19       	RR	C	;SHIFT BIT INTO DATA REG
2539   0EF9 10 F2       	DJNZ	RXDAT2
2540   0EFB 79          	LD	A,C
2541   0EFC B7          	OR	A	;CLEAR CARRY FLAG
2542   0EFD E1              POP	HL
2543   0EFE C1          	POP	BC
2544   0EFF C9          	RET
2545   0F00             ;---------------
2546   0F00             ; BIT TIME DELAY
2547   0F00             ;---------------
2548   0F00             ;DELAY FOR ONE SERIAL BIT TIME
2549   0F00             ;ENTRY : HL = DELAY TIME
2550   0F00             ; NO REGISTERS MODIFIED
2551   0F00             ;
2552   0F00 E5          BITIME:	PUSH	HL
2553   0F01 D5          	PUSH	DE
2554   0F02 11 01 00    	LD	DE,0001H
2555   0F05 ED 52       BITIM1:	SBC	HL,DE
2556   0F07 D2 05 0F    	JP	NC,BITIM1
2557   0F0A D1          	POP	DE
2558   0F0B E1          	POP	HL
2559   0F0C C9          	RET
2560   0F0D             
2561   0F0D             
2562   0F0D             ;-----------------
2563   0F0D             ; ONE SECOND DELAY
2564   0F0D             ;-----------------
2565   0F0D             ;
2566   0F0D             ; ENTRY : NONE
2567   0F0D             ; EXIT : FLAG REGISTER MODIFIED
2568   0F0D             ;
2569   0F0D C5          DELONE:	PUSH	BC
2570   0F0E D5          	PUSH	DE
2571   0F0F E5          	PUSH	HL
2572   0F10 11 01 00    	LD	DE,0001H
2573   0F13 21 70 08    	LD	HL,0870H
2574   0F16 06 92       DELON1:	LD	B,92H
2575   0F18 10 FE       DELON2:	DJNZ	DELON2	;INNER LOOP
2576   0F1A ED 52       	SBC	HL,DE
2577   0F1C D2 16 0F    	JP	NC,DELON1	;OUTER LOOP
2578   0F1F E1          	POP	HL
2579   0F20 D1          	POP	DE
2580   0F21 C1          	POP	BC
2581   0F22 C9          	RET
2582   0F23             
2583   0F23             
2584   0F23             
2585   0F23             
2586   0F23             
2587   0F23             
2588   0F23             
2589   0F23             ; **********************************************************************
2590   0F23             ; List devices found on the I2C bus
2591   0F23             ;
2592   0F23             ; Test each I2C device address and reports any that acknowledge
2593   0F23             
2594   0F23 11 18 12    I2CLIST:       LD   DE,LISTMsg        ;Address of message string
2595   0F26 CD C6 0F                CALL StrOut         ;Output string
2596   0F29 16 00                   LD   D,0            ;First I2C device address to test
2597   0F2B D5          LISTLOOP:      PUSH DE             ;Preserve DE
2598   0F2C 7A                      LD   A,D            ;Get device address to be tested
2599   0F2D CD 44 0F                CALL LISTTEST          ;Test if device is present
2600   0F30 D1                      POP  DE             ;Restore DE
2601   0F31 20 07                   JR   NZ,LISTNEXT       ;Skip if no acknowledge
2602   0F33 7A                      LD   A,D            ;Get address of device tested
2603   0F34 CD F5 0F                CALL HexOut         ;Output as two character hex 
2604   0F37 CD C1 0F                CALL SpaceOut       ;Output space character
2605   0F3A 14          LISTNEXT:      INC  D              ;Get next write address
2606   0F3B 14                      INC  D
2607   0F3C 7A                      LD   A,D            ;Address of next device to test
2608   0F3D B7                      OR   A              ;Have we tested all addresses?
2609   0F3E 20 EB                   JR   NZ,LISTLOOP       ;No, so loop again
2610   0F40 CD BE 0F                CALL LineOut        ;Output new line
2611   0F43 C9                      RET
2612   0F44             
2613   0F44             ; Test if device at I2C address A acknowledges
2614   0F44             ;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
2615   0F44             ;   On exit:  Z flagged if device acknowledges
2616   0F44             ;             NZ flagged if devices does not acknowledge
2617   0F44 CD 36 10    LISTTEST:      CALL I2C_Open       ;Open I2C device for write
2618   0F47 C0                      RET  NZ             ;Abort if failed to open
2619   0F48 CD 3D 10                CALL I2C_Close      ;Close I2C device 
2620   0F4B AF                      XOR  A              ;Return with Z flagged
2621   0F4C C9                      RET
2622   0F4D             
2623   0F4D             
2624   0F4D             
2625   0F4D             
2626   0F4D             ; Copy a block from I2C memory to CPU memory
2627   0F4D             ;   On entry: DE = First address in I2C memory
2628   0F4D             ;             HL = First address in CPU memory
2629   0F4D             ;             BC = Number of bytes to be copied
2630   0F4D             ;             SCL = unknown, SDA = unknown
2631   0F4D             ;   On exit:  If successfully A = 0 and Z flagged
2632   0F4D             ;             If unsuccessfully A = Error and NZ flagged
2633   0F4D             ;             IX IY preserved
2634   0F4D C5          I2C_MemRd:  PUSH BC
2635   0F4E 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2636   0F51 3E AE       I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2637   0F53 CD 36 10                CALL I2C_Open       ;Open for write
2638   0F56 28 0A                   JR   Z,I2C_MemRdReady       ;If open okay then skip on
2639   0F58 0B                      DEC  BC
2640   0F59 78                      LD   A,B
2641   0F5A B1                      OR   C              ;Timeout?
2642   0F5B 20 F4                   JR   NZ,I2C_MemRdRepeat     ;No, so go try again
2643   0F5D C1                      POP  BC
2644   0F5E 3E 03                   LD   A,ERR_TOUT     ;Error code
2645   0F60 B7                      OR   A              ;Error, so NZ flagged
2646   0F61 C9                      RET                 ;Return with error
2647   0F62             ; Device opened okay
2648   0F62 C1          I2C_MemRdReady:     POP  BC             ;Restore byte counter
2649   0F63 7A                      LD   A,D            ;Address (hi) in I2C memory
2650   0F64 CD 40 10                CALL I2C_Write      ;Write address
2651   0F67 7B                      LD   A,E            ;Address (lo) in I2C memory
2652   0F68 CD 40 10                CALL I2C_Write      ;Write address
2653   0F6B 3E AF                   LD   A,I2CA_BLOCK+1 ;I2C device to be read from
2654   0F6D CD 36 10                CALL I2C_Open       ;Open for read
2655   0F70 C0                      RET  NZ             ;Abort if error
2656   0F71 0B          I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
2657   0F72 78                      LD   A,B
2658   0F73 B1                      OR   C              ;Last byte to be read?
2659   0F74 CD 7D 10                CALL I2C_Read       ;Read byte with no ack on last byte
2660   0F77 77                      LD   (HL),A         ;Write byte in CPU memory
2661   0F78 23                      INC  HL             ;Increment CPU memory pointer
2662   0F79 78                      LD   A,B
2663   0F7A B1                      OR   C              ;Finished?
2664   0F7B 20 F4                   JR   NZ,I2C_MemRdRead       ;No, so go read next byte
2665   0F7D CD B5 10                CALL I2C_Stop       ;Generate I2C stop
2666   0F80 AF                      XOR  A              ;Return with success (Z flagged)
2667   0F81 C9                      RET
2668   0F82             
2669   0F82             
2670   0F82             ; Copy a block from CPU memory to I2C memory
2671   0F82             ;   On entry: DE = First address in I2C memory
2672   0F82             ;             HL = First address in CPU memory
2673   0F82             ;             BC = Number of bytes to be copied
2674   0F82             ;             SCL = unknown, SDA = unknown
2675   0F82             ;   On exit:  If successfully A = 0 and Z flagged
2676   0F82             ;             If unsuccessfully A = Error and NZ flagged
2677   0F82             ;             IX IY preserved
2678   0F82             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
2679   0F82             ; pages.
2680   0F82 C5          I2C_MemWr:  PUSH BC
2681   0F83 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2682   0F86 3E AE       I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2683   0F88 CD 36 10                CALL I2C_Open       ;Open for write
2684   0F8B 28 0A                   JR   Z,I2C_MemWrReady       ;If open okay then skip on
2685   0F8D 0B                      DEC  BC
2686   0F8E 78                      LD   A,B
2687   0F8F B1                      OR   C              ;Timeout?
2688   0F90 20 F4                   JR   NZ,I2C_MemWrRepeat     ;No, so go try again
2689   0F92 C1                      POP  BC
2690   0F93 3E 03                   LD   A,ERR_TOUT     ;Error code
2691   0F95 B7                      OR   A              ;Error, so NZ flagged
2692   0F96 C9                      RET                 ;Return with error
2693   0F97             ; Device opened okay
2694   0F97 C1          I2C_MemWrReady:     POP  BC             ;Restore byte counter
2695   0F98 7A          I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
2696   0F99 CD 40 10                CALL I2C_Write      ;Write address
2697   0F9C 7B                      LD   A,E            ;Address (lo) in I2C memory
2698   0F9D CD 40 10                CALL I2C_Write      ;Write address
2699   0FA0 7E          I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
2700   0FA1 CD 40 10                CALL I2C_Write      ;Read byte from I2C memory
2701   0FA4 23                      INC  HL             ;Increment CPU memory pointer
2702   0FA5 13                      INC  DE             ;Increment I2C memory pointer
2703   0FA6 0B                      DEC  BC             ;Decrement byte counter
2704   0FA7 78                      LD   A,B
2705   0FA8 B1                      OR   C              ;Finished?
2706   0FA9 28 05                   JR   Z,I2C_MemWrStore       ;Yes, so go store this page
2707   0FAB 7B                      LD   A,E            ;Get address in I2C memory (lo byte)
2708   0FAC E6 3F                   AND  63             ;64 byte page boundary?
2709   0FAE 20 F0                   JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
2710   0FB0 CD B5 10    I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
2711   0FB3 78                      LD   A,B
2712   0FB4 B1                      OR   C              ;Finished?
2713   0FB5 20 CB                   JR   NZ,I2C_MemWr   ;No, so go write some more
2714   0FB7 C9                      RET   
2715   0FB8             
2716   0FB8             
2717   0FB8             
2718   0FB8             
2719   0FB8             
2720   0FB8             
2721   0FB8             
2722   0FB8             
2723   0FB8             
2724   0FB8             
2725   0FB8             ; Display test result
2726   0FB8             ;   On entry: DE = Address of null terminated string
2727   0FB8             ;             H = First value ($H)
2728   0FB8             ;             L = Second value ($L)
2729   0FB8             ;   On exit:  HL IX IY preserved
2730   0FB8             Result:     
2731   0FB8 C3 0D 10                JP   String         ;Output result string to console
2732   0FBB             
2733   0FBB             
2734   0FBB             ; Character output to console
2735   0FBB             ;   On entry: A = Character to be output
2736   0FBB             ;   On exit:  BC DE HL IX IY preserved
2737   0FBB C3 D3 0F    CharOut:    JP   API_Cout
2738   0FBE             
2739   0FBE             ; New line output to console
2740   0FBE             ;   On entry: No parameters required
2741   0FBE             ;   On exit:  BC DE HL IX IY preserved
2742   0FBE C3 DD 0F    LineOut:    JP   API_Lout
2743   0FC1             
2744   0FC1             ; Space character ouput to console
2745   0FC1             ;   On entry: No parameters required
2746   0FC1             ;   On exit:  BC DE HL IX IY preserved
2747   0FC1 3E 20       SpaceOut:   LD   A,$20
2748   0FC3 C3 D3 0F                JP   API_Cout
2749   0FC6             
2750   0FC6             ; String output to console
2751   0FC6             ;   On entry: DE = Address of string
2752   0FC6             ;   On exit:  BC DE HL IX IY preserved
2753   0FC6 C3 E9 0F    StrOut:     JP   API_Sout
2754   0FC9             
2755   0FC9             
2756   0FC9             ; Delay by DE milliseconds (approx)
2757   0FC9             ;   On entry: DE = Delay time in milliseconds
2758   0FC9             ;   On exit:  BC DE HL IX IY preserved
2759   0FC9 C5          API_Delay:  PUSH BC             ;Preserve registers
2760   0FCA D5                      PUSH DE
2761   0FCB E5                      PUSH HL
2762   0FCC CD 50 0D                CALL delay
2763   0FCF E1                      POP  HL             ;Restore registers
2764   0FD0 D1                      POP  DE
2765   0FD1 C1                      POP  BC
2766   0FD2 C9                      RET
2767   0FD3             
2768   0FD3             
2769   0FD3             ; Character output to console device
2770   0FD3             ;   On entry: A = Character to be output
2771   0FD3             ;   On exit:  BC DE HL IX IY preserved
2772   0FD3 C5          API_Cout:   PUSH BC             ;Preserve registers
2773   0FD4 D5                      PUSH DE
2774   0FD5 E5                      PUSH HL
2775   0FD6 CD 08 00                CALL $0008
2776   0FD9 E1                      POP  HL             ;Restore registers
2777   0FDA D1                      POP  DE
2778   0FDB C1                      POP  BC
2779   0FDC C9                      RET
2780   0FDD             
2781   0FDD             
2782   0FDD             ; New line output to console device
2783   0FDD             ;   On entry: No parameters required
2784   0FDD             ;   On exit:  BC DE HL IX IY preserved
2785   0FDD C5          API_Lout:   PUSH BC             ;Preserve registers
2786   0FDE D5                      PUSH DE
2787   0FDF E5                      PUSH HL
2788   0FE0 3E 0D                   LD A, CR ; enter char
2789   0FE2 CD 08 00                CALL $0008
2790   0FE5 E1                      POP  HL             ;Restore registers
2791   0FE6 D1                      POP  DE
2792   0FE7 C1                      POP  BC
2793   0FE8 C9                      RET
2794   0FE9             
2795   0FE9             
2796   0FE9             ; String output to console device
2797   0FE9             ;   On entry: DE = Address of string
2798   0FE9             ;   On exit:  BC DE HL IX IY preserved
2799   0FE9 C5          API_Sout:   PUSH BC             ;Preserve registers
2800   0FEA D5                      PUSH DE
2801   0FEB E5                      PUSH HL
2802   0FEC 62                      LD H, D
2803   0FED 6B                      LD L, E
2804   0FEE CD 7B 0E                CALL SNDLCDMSG
2805   0FF1 E1                      POP  HL             ;Restore registers
2806   0FF2 D1                      POP  DE
2807   0FF3 C1                      POP  BC
2808   0FF4 C9                      RET
2809   0FF5             
2810   0FF5             
2811   0FF5             ; Hex byte output to console
2812   0FF5             ;   On entry: A = Byte to be output in hex
2813   0FF5             ;   On exit:  BC DE HL IX IY preserved
2814   0FF5 F5          HexOut:     PUSH AF             ;Preserve byte to be output
2815   0FF6 1F                      RRA                 ;Shift top nibble to
2816   0FF7 1F                      RRA                 ;  botom four bits..
2817   0FF8 1F                      RRA
2818   0FF9 1F                      RRA
2819   0FFA E6 0F                   AND  $0F           ;Mask off unwanted bits
2820   0FFC CD 02 10                CALL HexOutHex           ;Output hi nibble
2821   0FFF F1                      POP  AF             ;Restore byte to be output
2822   1000 E6 0F                   AND  $0F           ;Mask off unwanted bits
2823   1002             ; Output nibble as ascii character
2824   1002 FE 0A       HexOutHex:       CP   $0A           ;Nibble > 10 ?
2825   1004 38 02                   JR   C,HexOutSkip        ;No, so skip
2826   1006 C6 07                   ADD  A,7            ;Yes, so add 7
2827   1008 C6 30       HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
2828   100A C3 D3 0F                JP   API_Cout       ;Write character
2829   100D             
2830   100D             
2831   100D             ; Output string at DE with substitutions
2832   100D             ;   On entry: A = Address of device on I2C bus (write address)
2833   100D             ;             DE = Address of null terminated string
2834   100D             ;             H = Value to substitute for $H
2835   100D             ;             L = Value to substitute for $L
2836   100D             ;             B = Value to substitute for $B
2837   100D             ;   On exit:  DE = Address of next location after this string
2838   100D             ;             IX IY preserved
2839   100D 1A          String:     LD   A,(DE)         ;Get character from string
2840   100E 13                      INC  DE             ;Point to next character in string
2841   100F B7                      OR   A              ;Null ?
2842   1010 C8                      RET  Z              ;Yes, so we're done
2843   1011 FE 24                   CP   '$'            ;Substitue value?
2844   1013 28 05                   JR   Z,StringSubst       ;Yes, so go handle substitution
2845   1015 CD BB 0F                CALL CharOut        ;Output character to console
2846   1018 18 F3                   JR   String         ;Go get next character from string
2847   101A 1A          StringSubst:     LD   A,(DE)         ;Get character from string
2848   101B 13                      INC  DE             ;Point to next character in string
2849   101C B7                      OR   A              ;Null ?
2850   101D C8                      RET  Z              ;Yes, so we're done
2851   101E FE 48                   CP   'H'            ;Register H
2852   1020 20 03                   JR   NZ,StringNotH       ;No, so skip
2853   1022 7C                      LD   A,H            ;Get value 'H'
2854   1023 18 0C                   JR   StringGotIt         ;Go output it in hex
2855   1025 FE 4C       StringNotH:      CP   'L'            ;Register L
2856   1027 20 03                   JR   NZ,StringNotL       ;No, so skip
2857   1029 7D                      LD   A,L            ;Get value 'L'
2858   102A 18 05                   JR   StringGotIt         ;Go output it in hex
2859   102C FE 42       StringNotL:      CP   'B'            ;Register B
2860   102E 20 04                   JR   NZ,StringNotB       ;No, so skip
2861   1030 78                      LD   A,B            ;Get value 'L'
2862   1031                         ;JR   @GotIt        ;Go output it in hex
2863   1031 CD F5 0F    StringGotIt:     CALL HexOut         ;Output write address in hex
2864   1034 18 D7       StringNotB:      JR   String         ;Go get next character from string
2865   1036             
2866   1036             
2867   1036             ; **********************************************************************
2868   1036             ; I2C support functions
2869   1036             
2870   1036             ; I2C bus open device
2871   1036             ;   On entry: A = Device address (bit zero is read flag)
2872   1036             ;             SCL = unknown, SDA = unknown
2873   1036             ;   On exit:  If successfully A = 0 and Z flagged
2874   1036             ;             If unsuccessfully A = Error and NZ flagged
2875   1036             ;             BC DE HL IX IY preserved
2876   1036 F5          I2C_Open:   PUSH AF
2877   1037 CD AA 10                CALL I2C_Start      ;Output start condition
2878   103A F1                      POP  AF
2879   103B 18 03                   JR   I2C_Write      ;Write data byte
2880   103D             
2881   103D             
2882   103D             ; I2C bus close device
2883   103D             ;   On entry: SCL = unknown, SDA = unknown
2884   103D             ;   On exit:  If successfully A=0 and Z flagged
2885   103D             ;             If unsuccessfully A=Error and NZ flagged
2886   103D             ;             SCL = hi, SDA = hi
2887   103D             ;             BC DE HL IX IY preserved
2888   103D C3 B5 10    I2C_Close:  JP   I2C_Stop       ;Output stop condition
2889   1040             
2890   1040             
2891   1040             ; **********************************************************************
2892   1040             ; **********************************************************************
2893   1040             ; I2C bus master driver
2894   1040             ; **********************************************************************
2895   1040             ; **********************************************************************
2896   1040             
2897   1040             ; Functions provided are:
2898   1040             ;     I2C_Start
2899   1040             ;     I2C_Stop
2900   1040             ;     I2C_Read
2901   1040             ;     I2C_Write
2902   1040             ;
2903   1040             ; This code has delays between all I/O operations to ensure it works
2904   1040             ; with the slowest I2C devices
2905   1040             ;
2906   1040             ; I2C transfer sequence
2907   1040             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2908   1040             ;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
2909   1040             ;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
2910   1040             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2911   1040             ;
2912   1040             ;
2913   1040             ; Start condition                     Stop condition
2914   1040             ; Output by master device             Output by master device
2915   1040             ;       ----+                                      +----
2916   1040             ; SDA       |                         SDA          |
2917   1040             ;           +-------                        -------+
2918   1040             ;       -------+                                +-------
2919   1040             ; SCL          |                      SCL       |
2920   1040             ;              +----                        ----+
2921   1040             ;
2922   1040             ;
2923   1040             ; Address frame
2924   1040             ; Clock and data output from master device
2925   1040             ; Receiving device outputs acknowledge 
2926   1040             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2927   1040             ; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
2928   1040             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2929   1040             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2930   1040             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2931   1040             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2932   1040             ;
2933   1040             ;
2934   1040             ; Data frame 
2935   1040             ; Clock output by master device
2936   1040             ; Data output by transmitting device
2937   1040             ; Receiving device outputs acknowledge 
2938   1040             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2939   1040             ; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
2940   1040             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2941   1040             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2942   1040             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2943   1040             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2944   1040             ;
2945   1040             
2946   1040             
2947   1040             ; **********************************************************************
2948   1040             ; I2C constants
2949   1040             
2950   1040             
2951   1040             ; I2C bus master interface
2952   1040             ; The default device option is for SC126 or compatible
2953   1040             
2954   1040             I2C_PORT:   .EQU $21           ;Host I2C port address
2955   1040             I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
2956   1040             I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
2957   1040             I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
2958   1040             I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
2959   1040             I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
2960   1040             
2961   1040             
2962   1040             ; I2C support constants
2963   1040             ERR_NONE:   .EQU 0              ;Error = None
2964   1040             ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
2965   1040             ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
2966   1040             ERR_TOUT:   .EQU 3              ;Error = Timeout
2967   1040             
2968   1040             
2969   1040             ; **********************************************************************
2970   1040             ; Hardware dependent I2C bus functions
2971   1040             
2972   1040             
2973   1040             ; I2C bus transmit frame (address or data)
2974   1040             ;   On entry: A = Data byte, or
2975   1040             ;                 Address byte (bit zero is read flag)
2976   1040             ;             SCL = low, SDA = low
2977   1040             ;   On exit:  If successful A=0 and Z flagged
2978   1040             ;                SCL = lo, SDA = lo
2979   1040             ;             If unsuccessful A=Error and NZ flagged
2980   1040             ;                SCL = high, SDA = high, I2C closed
2981   1040             ;             BC DE HL IX IY preserved
2982   1040 C5          I2C_Write:  PUSH BC             ;Preserve registers
2983   1041 D5                      PUSH DE
2984   1042 57                      LD   D,A            ;Store byte to be written
2985   1043 06 08                   LD   B,8            ;8 data bits, bit 7 first
2986   1045 CB 12       I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
2987   1047 38 05                   JR   C,I2C_WriteBit_Hi      ;High, so skip
2988   1049 CD DC 10                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
2989   104C 18 03                   JR   I2C_WriteBit_Clk
2990   104E CD D5 10    I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
2991   1051 CD C7 10    I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
2992   1054 CD CE 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
2993   1057 10 EC                   DJNZ I2C_WriteWr_Loop
2994   1059             ; Test for acknowledge from slave (receiver)
2995   1059             ; On arriving here, SCL = lo, SDA = data bit
2996   1059 CD D5 10                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
2997   105C CD C7 10                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
2998   105F CD ED 10                CALL I2C_RdPort     ;Read SDA input
2999   1062 47                      LD   B,A
3000   1063 CD CE 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
3001   1066 CB 78                   BIT  I2C_SDA_RD,B
3002   1068 20 04                   JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
3003   106A D1                      POP  DE             ;Restore registers
3004   106B C1                      POP  BC
3005   106C AF                      XOR  A              ;Return success A=0 and Z flagged
3006   106D C9                      RET
3007   106E             ; I2C STOP required as no acknowledge
3008   106E             ; On arriving here, SCL = lo, SDA = hi
3009   106E CD DC 10    I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
3010   1071 CD C7 10                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
3011   1074 CD D5 10                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
3012   1077 D1                      POP  DE             ;Restore registers
3013   1078 C1                      POP  BC
3014   1079 3E 02                   LD   A,ERR_NOACK    ;Return error = No Acknowledge
3015   107B B7                      OR   A              ;  and NZ flagged
3016   107C C9                      RET
3017   107D             
3018   107D             
3019   107D             ; I2C bus receive frame (data)
3020   107D             ;   On entry: A = Acknowledge flag
3021   107D             ;               If A != 0 the read is acknowledged
3022   107D             ;             SCL low, SDA low
3023   107D             ;   On exit:  If successful A = data byte and Z flagged
3024   107D             ;               SCL = low, SDA = low
3025   107D             ;             If unsuccessul* A = Error and NZ flagged
3026   107D             ;               SCL = low, SDA = low
3027   107D             ;             BC DE HL IX IY preserved
3028   107D             ; *This function always returns successful
3029   107D C5          I2C_Read:   PUSH BC             ;Preserve registers
3030   107E D5                      PUSH DE
3031   107F 5F                      LD   E,A            ;Store acknowledge flag
3032   1080 06 08                   LD   B,8            ;8 data bits, 7 first
3033   1082 CD D5 10                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
3034   1085 CD C7 10    I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
3035   1088 CD ED 10                CALL I2C_RdPort     ;Read SDA input bit
3036   108B 37                      SCF                 ;Set carry flag
3037   108C CB 7F                   BIT  I2C_SDA_RD,A   ;SDA input high?
3038   108E 20 01                   JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
3039   1090 3F                      CCF                 ;Clear carry flag
3040   1091 CB 12       I2C_ReadRotate:    RL   D              ;Rotate result into D
3041   1093 CD CE 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
3042   1096 10 ED                   DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
3043   1098             ; Acknowledge input byte
3044   1098             ; On arriving here, SCL = lo, SDA = hi/input
3045   1098 7B                      LD   A,E            ;Get acknowledge flag
3046   1099 B7                      OR   A              ;A = 0? (indicates no acknowledge)
3047   109A 28 03                   JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
3048   109C CD DC 10                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
3049   109F CD C7 10    I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
3050   10A2 CD CE 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
3051   10A5 7A                      LD   A,D            ;Get data byte received
3052   10A6 D1                      POP  DE             ;Restore registers
3053   10A7 C1                      POP  BC
3054   10A8 BF                      CP   A              ;Return success Z flagged
3055   10A9 C9                      RET
3056   10AA             
3057   10AA             
3058   10AA             ; I2C bus start
3059   10AA             ;   On entry: SCL = unknown, SDA = unknown
3060   10AA             ;   On exit:  SCL = low, SDA = low
3061   10AA             ;             A = 0 and Z flagged as we always succeed
3062   10AA             ;             BC DE HL IX IY preserved
3063   10AA             ; First ensure SDA and SCL are high
3064   10AA CD C3 10    I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
3065   10AD             ;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
3066   10AD             ;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
3067   10AD             ; Generate I2C start condition
3068   10AD CD DC 10                CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
3069   10B0 CD CE 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
3070   10B3 AF                      XOR  A              ;Return success A=0 and Z flagged
3071   10B4 C9                      RET
3072   10B5             
3073   10B5             
3074   10B5             ; I2C bus stop 
3075   10B5             ;   On entry: SCL = unknown, SDA = unknown
3076   10B5             ;   On exit:  SCL = high, SDA = high
3077   10B5             ;             A = 0 and Z flagged as we always succeed
3078   10B5             ;             BC DE HL IX IY preserved
3079   10B5             ; First ensure SDA and SCL are low
3080   10B5 CD DC 10    I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
3081   10B8 CD CE 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
3082   10BB             ; Generate stop condition
3083   10BB CD C7 10                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
3084   10BE CD D5 10                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
3085   10C1 AF                      XOR  A              ;Return success A=0 and Z flagged
3086   10C2 C9                      RET
3087   10C3             
3088   10C3             
3089   10C3             ; **********************************************************************
3090   10C3             ; I2C bus simple I/O functions
3091   10C3             ;   On entry: No parameters required
3092   10C3             ;   On exit:  BC DE HL IX IY preserved
3093   10C3             
3094   10C3 3E 81       I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
3095   10C5 18 1A                   JR   I2C_WrPort
3096   10C7             
3097   10C7 3A 00 D0    I2C_SCL_HI: LD   A,(I2C_RAMCPY)
3098   10CA CB C7                   SET  I2C_SCL_WR,A
3099   10CC 18 13                   JR   I2C_WrPort
3100   10CE             
3101   10CE 3A 00 D0    I2C_SCL_LO: LD   A,(I2C_RAMCPY)
3102   10D1 CB 87                   RES  I2C_SCL_WR,A
3103   10D3 18 0C                   JR   I2C_WrPort
3104   10D5             
3105   10D5 3A 00 D0    I2C_SDA_HI: LD   A,(I2C_RAMCPY)
3106   10D8 CB FF                   SET  I2C_SDA_WR,A
3107   10DA 18 05                   JR   I2C_WrPort
3108   10DC             
3109   10DC 3A 00 D0    I2C_SDA_LO: LD   A,(I2C_RAMCPY)
3110   10DF CB BF                   RES  I2C_SDA_WR,A
3111   10E1                         ;JR   I2C_WrPort
3112   10E1             
3113   10E1 C5          I2C_WrPort: PUSH BC             ;Preserve registers
3114   10E2 06 00                   LD   B,0            ;Set up BC for 16-bit
3115   10E4 0E 21                   LD   C,I2C_PORT     ;  I/O address of I2C port
3116   10E6 ED 79                   OUT  (C),A          ;Write A to I2C I/O port
3117   10E8 32 00 D0                LD   (I2C_RAMCPY),A ;Write A to RAM copy
3118   10EB C1                      POP  BC             ;Restore registers
3119   10EC C9                      RET
3120   10ED             
3121   10ED C5          I2C_RdPort: PUSH BC             ;Preserve registers
3122   10EE 06 00                   LD   B,0            ;Set up BC for 16-bit
3123   10F0 0E 21                   LD   C,I2C_PORT     ;  I/O address of I2C port
3124   10F2 ED 78                   IN   A,(C)          ;Read A from I/O port
3125   10F4 C1                      POP  BC             ;Restore registers
3126   10F5 C9                      RET
3127   10F6             
3128   10F6             
3129   10F6             
3130   10F6 0C0D0D0A5A38WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
3130   10FC 30204D696E6920496E69636961646F0D0A00
3131   110E 5A3830204D49MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H
3131   1114 4E492C204820544F2048454C500D00
3132   1123             
3133   1123 46312052554EMSG_MENU0  .db "F1 RUN (JP $8000)",CR, 00H
3133   1129 20284A50202438303030290D00
3134   1136 463220496E74MSG_MENU1  .db "F2 Intel hex loader",CR, 00H
3134   113C 656C20686578206C6F616465720D00
3135   114B 42202D204261MSG_MENU2  .db "B - Basic",CR, 00H
3135   1151 7369630D00
3136   1156 442041414141MSG_MENU3  .db "D AAAA - DISPLAY",CR,00H
3136   115C 202D20444953504C41590D00
3137   1168 4D2041414141MSG_MENU4  .db "M AAAA - MODIFY",CR,00H
3137   116E 202D204D4F444946590D00
3138   1179 472041414141MSG_MENU5  .db "G AAAA - GO TO",CR, 00H
3138   117F 202D20474F20544F0D00
3139   1189 4F204F757420MSG_MENU6  .db "O Out AA DD",CR, 00H
3139   118F 41412044440D00
3140   1196 4920496E2041MSG_MENU7  .db "I In AA",CR, 00H
3140   119C 410D00
3141   119F 312049324320MSG_MENU8  .db "1 I2C Scan",CR, 00H
3141   11A5 5363616E0D00
3142   11AB 322049324320MSG_MENU9  .db "2 I2C PC -> MEM",CR, 00H
3142   11B1 5043202D3E204D454D0D00
3143   11BC 332049324320MSG_MENU10 .db "3 I2C MEM -> PC",CR, 00H
3143   11C2 4D454D202D3E2050430D00
3144   11CD 342049324320MSG_MENU11 .db "4 I2C WRITE DD",CR, 00H
3144   11D3 57524954452044440D00
3145   11DD 352049324320MSG_MENU12 .db "5 I2C WRITE RR DD",CR, 00H
3145   11E3 57524954452052522044440D00
3146   11F0 362049324320MSG_MENU13 .db "6 I2C READ ONE BYTE",CR, 00H
3146   11F6 52454144204F4E4520425954450D00
3147   1205 372049324320MSG_MENU14 .db "7 I2C READ RR BYTE", 00H ; ultimo não tem CR (nova linha)
3147   120B 52454144205252204259544500
3148   1218             
3149   1218             
3150   1218             
3151   1218 0C4932432064LISTMsg:    .DB  CS,"I2C device found at:",CR,0
3151   121E 657669636520666F756E642061743A0D00
3152   122F 0C434F505920MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
3152   1235 493243204D454D20544F204350550D00
3153   1245 0C434F505920MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H
3153   124B 43505520544F20493243204D454D0D00
3154   125B             
3155   125B 0C5752495445MSG_I2C_WR_DD    .db CS,"WRITE ONE BYTE",CR, 00H
3155   1261 204F4E4520425954450D00
3156   126C 0C5752495445MSG_I2C_WR_RR_DD .db CS,"WRITE REG ONE BYTE",CR, 00H
3156   1272 20524547204F4E4520425954450D00
3157   1281 0C5245414420MSG_I2C_RD       .db CS,"READ ONE BYTE",CR, 00H
3157   1287 4F4E4520425954450D00
3158   1291 0C5245414420MSG_I2C_RD_RR    .db CS,"READ REG ONE BYTE",CR, 00H
3158   1297 524547204F4E4520425954450D00
3159   12A5             
3160   12A5 46524F4D3A20MSG_FROM    .db "FROM: ", 00H
3160   12AB 00
3161   12AC 0D544F3A2000MSG_TO      .db CR,"TO: ", 00H
3162   12B2 0D53495A4528MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
3162   12B8 4259544553293A2000
3163   12C1 0D434F505920MSG_COPYOK  .db CR,"COPY OK", 00H
3163   12C7 4F4B00
3164   12CA 0D434F505920MSG_COPYFAIL  .db CR,"COPY FAIL", 00H
3164   12D0 4641494C00
3165   12D5             
3166   12D5 0D4445564943MSG_DEV_ADDR  .db CR,"DEVICE ADDR(AA): ", 00H
3166   12DB 452041444452284141293A2000
3167   12E8 0D5245474953MSG_DEV_REG   .db CR,"REGISTER(RR): ", 00H
3167   12EE 544552285252293A2000
3168   12F8 0D4441544128MSG_DEV_DATA  .db CR,"DATA(DD): ", 00H
3168   12FE 4444293A2000
3169   1304             
3170   1304             
3171   1304 0C496E74656CMSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
3171   130A 20484558206C6F616465722E2E2E0D00
3172   131A 46494C452052FILEOK    .DB      "FILE RECEIVED OK",CR,00H
3172   1320 45434549564544204F4B0D00
3173   132C 434845434B53CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
3173   1332 554D204552524F520D00
3174   133C             
3175   133C             
3176   133C             
3177   133C             ; **********************************************************************
3178   133C             ; I2C workspace / variables in RAM
3179   133C             
3180   D000                         .ORG  I2CDATA
3181   D000             
3182   D000 00          I2C_RAMCPY: .DB  0              ;RAM copy of output port
3183   D001             
3184   D001 00          RESULTS:    .DB  0              ;Large block of results can start here
3185   D002             
3186   D002             .end
tasm: Number of errors = 0
