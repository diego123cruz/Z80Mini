0001   0000             ; Diego Cruz - Nov 2022
0002   0000             ; 
0003   0000             ; bootV2: 
0004   0000             ;         - CPU Z80@4Mhz
0005   0000             ;         - Lcd Grafico 128x64
0006   0000             ;         - Keyboard 40 keys + Shift
0007   0000             ;         - Rom 32k 0000h - 7FFFh
0008   0000             ;         - Ram 32k 8000h - FFFFh
0009   0000             ;         
0010   0000             ;
0011   0000             ;         - Ports:
0012   0000             ;               - Keyboard: 40H
0013   0000             ;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
0014   0000             ;               - User IN/OUT: C0H
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------
0017   0000             LCDCTRL	    .EQU    70H
0018   0000             LCDDATA     .EQU    71H
0019   0000             KEY_IN      .EQU    40H
0020   0000             KEY_OUT     .EQU    40H
0021   0000             
0022   0000             CTRLC       .EQU    03H             ; Control "C"
0023   0000             CTRLG       .EQU    07H             ; Control "G"
0024   0000             BKSP        .EQU    08H             ; Back space
0025   0000             LF          .EQU    0AH             ; Line feed
0026   0000             VT          .equ    0BH             ; 
0027   0000             CS          .EQU    0CH             ; Clear screen
0028   0000             CR          .EQU    0DH             ; Carriage return [Enter]
0029   0000             CTRLO       .EQU    0FH             ; Control "O"
0030   0000             CTRLQ	    .EQU	11H		        ; Control "Q"
0031   0000             CTRLR       .EQU    12H             ; Control "R"
0032   0000             CTRLS       .EQU    13H             ; Control "S"
0033   0000             CTRLU       .EQU    15H             ; Control "U"
0034   0000             ESC         .EQU    1BH             ; Escape
0035   0000             DEL         .EQU    7FH             ; Delete
0036   0000             
0037   0000             BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
0038   0000             ;
0039   0000             ; BAUD RATE CONSTANTS
0040   0000             ;
0041   0000             B300:	.EQU	0220H	;300 BAUD
0042   0000             B1200:	.EQU	0080H	;1200 BAUD
0043   0000             B2400:	.EQU	003FH	;2400 BAUD
0044   0000             B4800:	.EQU	001BH	;4800 BAUD
0045   0000             B9600:	.EQU	000BH	;9600 BAUD
0046   0000             
0047   0000             SYSTEM:	.EQU 	0FE00H	;INITIAL STACK POINTER
0048   0000             I2CDATA .EQU    0D000H 
0049   0000             
0050   0000             BAUD:	 .EQU	0FFC0H	 ;BAUD RATE
0051   0000             PUTCH:   .EQU   0FFAAH   ;OUTPUT A CHARACTER TO SERIAL
0052   0000             GETCH:   .EQU   0FFACH   ;WAIT FOR A CHARACTER FROM SERIAL
0053   0000             
0054   0000             SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
0055   0000             SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
0056   0000             
0057   0000             
0058   0000             ; LCD TEXT MODE
0059   0000             LCD_LINE1   .EQU    80H
0060   0000             LCD_LINE2   .EQU    90H
0061   0000             LCD_LINE3   .EQU    88H
0062   0000             LCD_LINE4   .EQU    98H
0063   0000             
0064   0000             
0065   0000             ; RAM MAP
0066   0000             
0067   0000             
0068   0000             
0069   0000             LCD_CHAR            .EQU    $E000   ; 1 byte char ex: 'A'
0070   0000             LCD_CHAR_POINT      .EQU    $E001   ; 2 bytes ponteiro para o mapa de caracteres
0071   0000             LCD_TXT_X           .EQU    $E003   ; 1 byte  0-20 (21 col)
0072   0000             LCD_TXT_Y           .EQU    $E004   ; 1 byte  0-7  (8 row)
0073   0000             LCD_BYTE_INDEX      .EQU    $E005   ; 2 bytes pointer pixel(8)
0074   0000             LCD_BIT_INDEX       .EQU    $E007   ; 1 byte pointer pixel(1)
0075   0000             LCD_TXT_X_TMP       .EQU    $E008   ; 2 bytes = LCD_TXT_X * 6
0076   0000             LCD_TXT_Y_TMP       .EQU    $E00A   ; 2 bytes = LCD_TXT_Y * 128
0077   0000             LCD_CHAR_H          .EQU    $E00C   ; 1 byte altura do char
0078   0000             LCD_CHAR_W          .EQU    $E00D   ; 1 byte largura do char
0079   0000             LCD_TMP_POINT       .EQU    $E00E   ; 2 bytes ponteiro do pixel altural do print
0080   0000             LCD_DELETE_CHAR     .EQU    $E00F   ; 1 byte, 0 não, ff delete proximo char
0081   0000             LCD_AUTO_X          .EQU    $E010   ; 1 byte, 0 sim, ff nao
0082   0000             
0083   0000             DISPLAY             .EQU    $E500
0084   0000             
0085   0000             LCD_TEMP        .EQU    $E110
0086   0000             LCD_COOX        .EQU    $E102 ; 1 byte, local onde vai printar
0087   0000             LCD_COOY        .EQU    $E103 ; 1 byte
0088   0000             LCD_PRINT_H     .EQU    $E104 ; 1 byte, tamanho do que vai printar
0089   0000             LCD_PRINT_W     .EQU    $E105 ; 1 byte
0090   0000             LCD_PRINT_IMAGE .EQU    $E106 ; 2 bytes
0091   0000             
0092   0000             
0093   0000                     .ORG 0
0094   0000 F3          RST00	DI
0095   0001 C3 6B 04            JP  INICIO
0096   0004             						
0097   0008                     .ORG     0008H
0098   0008 C3 87 05    RST08   JP  PRINTCHAR
0099   000B             
0100   0010                     .ORG 0010H
0101   0010 C3 AC 08    RST10   JP KEYREADINIT
0102   0013             
0103   0018                     .ORG 0018H ; check break
0104   0018             RST18   ;LD	A, 0
0105   0018                     ;CP	0
0106   0018                     ;RET
0107   0018 C3 97 08    	JP CHKKEY
0108   001B             
0109   001B             KEYMAP:
0110   001B 313233343536.BYTE   "1234567890"
0110   0021 37383930
0111   0025 515745525459.BYTE   "QWERTYUIOP"
0111   002B 55494F50
0112   002F 415344464748.BYTE   "ASDFGHJKL", CR
0112   0035 4A4B4C0D
0113   0039 035A58435642.BYTE   CTRLC, "ZXCVBNM ", DEL
0113   003F 4E4D207F
0114   0043             
0115   0043             SHIFTKEYMAP:
0116   0043 21402324255E.BYTE   "!@#$%^&*()"
0116   0049 262A2829
0117   004D 607E2D5F3D2B.BYTE   "`~-_=+;:'"
0117   0053 3B3A27
0118   0056 22          .BYTE   22h
0119   0057 7B7D5B5D7C5C.BYTE   "{}[]|",$5C,"<>?/"
0119   005D 3C3E3F2F
0120   0061 032C2E202020.BYTE   CTRLC, ",.     ", VT, LF
0120   0067 20200B0A
0121   006B             
0122   006B             
0123   006B             
0124   006B             TABLE:
0125   006B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
0125   0071 0000
0126   0073 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
0126   0079 0000
0127   007B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
0127   0081 0000
0128   0083 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
0128   0089 0000
0129   008B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
0129   0091 0000
0130   0093 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
0130   0099 0000
0131   009B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
0131   00A1 0000
0132   00A3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
0132   00A9 0000
0133   00AB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
0133   00B1 0000
0134   00B3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
0134   00B9 0000
0135   00BB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0135   00C1 0000
0136   00C3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
0136   00C9 0000
0137   00CB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0137   00D1 0000
0138   00D3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
0138   00D9 0000
0139   00DB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0139   00E1 0000
0140   00E3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
0140   00E9 0000
0141   00EB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0141   00F1 0000
0142   00F3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
0142   00F9 0000
0143   00FB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0143   0101 0000
0144   0103 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
0144   0109 0000
0145   010B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0145   0111 0000
0146   0113 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
0146   0119 0000
0147   011B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0147   0121 0000
0148   0123 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
0148   0129 0000
0149   012B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0149   0131 0000
0150   0133 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
0150   0139 0000
0151   013B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0151   0141 0000
0152   0143 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
0152   0149 0000
0153   014B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0153   0151 0000
0154   0153 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
0154   0159 0000
0155   015B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
0155   0161 0000
0156   0163 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
0156   0169 0000
0157   016B             
0158   016B             ; DEC 32
0159   016B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
0159   0171 0000
0160   0173 202020202000.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
0160   0179 2000
0161   017B 505050000000.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
0161   0181 0000
0162   0183 5050F850F850.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
0162   0189 5000
0163   018B 2078A07028F0.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
0163   0191 2000
0164   0193 C0C810204098.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
0164   0199 1800
0165   019B 6090A040A890.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
0165   01A1 6800
0166   01A3 202020000000.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
0166   01A9 0000
0167   01AB 102040404020.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
0167   01B1 1000
0168   01B3 402010101020.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
0168   01B9 4000
0169   01BB 0020A870A820.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0169   01C1 0000
0170   01C3 002020F82020.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
0170   01C9 0000
0171   01CB 000000006020.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0171   01D1 4000
0172   01D3 000000F80000.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
0172   01D9 0000
0173   01DB 000000000060.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0173   01E1 6000
0174   01E3 000008102040.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
0174   01E9 8000
0175   01EB 708898A8C888.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0175   01F1 7000
0176   01F3 206020202020.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
0176   01F9 7000
0177   01FB 708808102040.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0177   0201 F800
0178   0203 F81020100888.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
0178   0209 7000
0179   020B 10305090F810.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0179   0211 1000
0180   0213 F880F0080888.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
0180   0219 7000
0181   021B 304080F08888.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0181   0221 7000
0182   0223 F80810204040.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
0182   0229 4000
0183   022B 708888708888.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0183   0231 7000
0184   0233 708888780810.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
0184   0239 6000
0185   023B 000030300030.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0185   0241 3000
0186   0243 003030003010.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
0186   0249 2000
0187   024B 102040804020.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0187   0251 1000
0188   0253 0000F800F800.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
0188   0259 0000
0189   025B 402010081020.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
0189   0261 4000
0190   0263 304808102000.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
0190   0269 2000
0191   026B 70880868A8A8.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
0191   0271 7000
0192   0273             
0193   0273             ; DEC 65 Maiusculas
0194   0273 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0194   0279 8800
0195   027B F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0195   0281 F000
0196   0283 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0196   0289 7000
0197   028B E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0197   0291 E000
0198   0293 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0198   0299 F800
0199   029B F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0199   02A1 8000
0200   02A3 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0200   02A9 7000
0201   02AB 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0201   02B1 8800
0202   02B3 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0202   02B9 7000
0203   02BB 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0203   02C1 7000
0204   02C3 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0204   02C9 8800
0205   02CB 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0205   02D1 F800
0206   02D3 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0206   02D9 8800
0207   02DB 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0207   02E1 8800
0208   02E3 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0208   02E9 7000
0209   02EB F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0209   02F1 8000
0210   02F3 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0210   02F9 7000
0211   02FB F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0211   0301 8800
0212   0303 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0212   0309 7000
0213   030B F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0213   0311 2000
0214   0313 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0214   0319 7000
0215   031B 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0215   0321 2000
0216   0323 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0216   0329 8800
0217   032B 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0217   0331 8800
0218   0333 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0218   0339 2000
0219   033B F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0219   0341 F800
0220   0343             
0221   0343             ; DEC 91
0222   0343 302020202020.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
0222   0349 3000
0223   034B 008040201008.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0223   0351 0000
0224   0353 602020202020.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
0224   0359 6000
0225   035B 205088000000.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
0225   0361 0000
0226   0363 000000000000.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
0226   0369 F800
0227   036B 402010000000.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
0227   0371 0000
0228   0373             
0229   0373             ; DEC 97 "Minusculas"
0230   0373 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0230   0379 8800
0231   037B F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0231   0381 F000
0232   0383 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0232   0389 7000
0233   038B E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0233   0391 E000
0234   0393 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0234   0399 F800
0235   039B F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0235   03A1 8000
0236   03A3 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0236   03A9 7000
0237   03AB 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0237   03B1 8800
0238   03B3 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0238   03B9 7000
0239   03BB 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0239   03C1 7000
0240   03C3 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0240   03C9 8800
0241   03CB 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0241   03D1 F800
0242   03D3 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0242   03D9 8800
0243   03DB 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0243   03E1 8800
0244   03E3 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0244   03E9 7000
0245   03EB F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0245   03F1 8000
0246   03F3 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0246   03F9 7000
0247   03FB F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0247   0401 8800
0248   0403 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0248   0409 7000
0249   040B F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0249   0411 2000
0250   0413 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0250   0419 7000
0251   041B 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0251   0421 2000
0252   0423 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0252   0429 8800
0253   042B 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0253   0431 8800
0254   0433 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0254   0439 2000
0255   043B F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0255   0441 F800
0256   0443             
0257   0443             ; DEC 123
0258   0443 102020402020.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0258   0449 1000
0259   044B 202020202020.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0259   0451 2000
0260   0453 402020102020.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0260   0459 4000
0261   045B 000050A00000.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0261   0461 0000
0262   0463 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0262   0469 0000
0263   046B             
0264   046B             
0265   046B             
0266   046B             
0267   046B             
0268   046B             
0269   046B             
0270   046B             
0271   046B             ; -----------------------------------------------------------------------------
0272   046B             ;   INICIO
0273   046B             ; -----------------------------------------------------------------------------
0274   046B             INICIO:
0275   046B 31 00 FE        LD  SP, SYSTEM
0276   046E             
0277   046E                 ; init serial
0278   046E CD 40 0A        CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0279   0471 21 DB 09        LD    HL,TXDATA
0280   0474 22 AA FF        LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0281   0477 21 06 0A        LD    HL,RXDATA
0282   047A 22 AC FF        LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
0283   047D                 
0284   047D 21 1B 00        LD	HL,B4800
0285   0480 22 C0 FF    	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
0286   0483             
0287   0483 3E FF           LD A, $FF
0288   0485 D3 C0           OUT (SERIAL_TX_PORT), A
0289   0487             
0290   0487 21 D4 0B        LD HL, WELLCOME
0291   048A CD C1 09        CALL SNDMSG
0292   048D             
0293   048D                 ; CALL INCH
0294   048D                 ; CALL OUTCH
0295   048D             
0296   048D                 ; Init LCD hardware
0297   048D CD 0B 07        CALL INIT_LCD
0298   0490 CD 88 08        call delay
0299   0493             
0300   0493 CD 23 08        call cls_TXT
0301   0496 CD 88 08        call delay
0302   0499             
0303   0499 CD AD 07        CALL enable_grafic
0304   049C CD 88 08        call delay
0305   049F             
0306   049F CD 29 08        call cls_GRAPHIC
0307   04A2 CD 88 08        call delay
0308   04A5             
0309   04A5 CD 9F 07        call lcd_clear
0310   04A8             
0311   04A8 21 00 E5        ld hl, DISPLAY
0312   04AB CD C6 07        call print_image
0313   04AE             
0314   04AE CD 88 08        call delay
0315   04B1             
0316   04B1                 ; Init LCD logical
0317   04B1 CD F8 04        call INIT_TXT_LCD ; set cursor X Y to 0
0318   04B4             
0319   04B4 21 EC 0B        LD HL, MSG_MONITOR
0320   04B7 CD B3 09        CALL SNDLCDMSG
0321   04BA             
0322   04BA 21 03 0C        LD HL, MSG_MENU1
0323   04BD CD B3 09        CALL SNDLCDMSG
0324   04C0             
0325   04C0 21 0E 0C        LD HL, MSG_MENU2
0326   04C3 CD B3 09        CALL SNDLCDMSG
0327   04C6             
0328   04C6 21 24 0C        LD HL, MSG_MENU3
0329   04C9 CD B3 09        CALL SNDLCDMSG
0330   04CC             
0331   04CC 21 38 0C        LD HL, MSG_MENU4
0332   04CF CD B3 09        CALL SNDLCDMSG
0333   04D2             
0334   04D2                 ;JP BASIC
0335   04D2             
0336   04D2             KEY:
0337   04D2 CD AC 08        CALL KEYREADINIT
0338   04D5 FE 42           CP 'B'
0339   04D7 CA 00 60        JP Z, BASIC
0340   04DA             
0341   04DA FE 49           CP 'I'
0342   04DC CA EC 04        JP Z, INTEL_HEX
0343   04DF             
0344   04DF FE 52           CP 'R'
0345   04E1 CA 00 80        JP Z, $8000
0346   04E4             
0347   04E4 FE 31           CP '1'
0348   04E6 CC 56 0A        CALL Z, I2CLIST
0349   04E9             
0350   04E9 C3 D2 04        JP  KEY
0351   04EC             
0352   04EC             
0353   04EC             INTEL_HEX:
0354   04EC CD 00 09        CALL INTHEX
0355   04EF CD 88 08        CALL delay
0356   04F2 CD 88 08        CALL delay
0357   04F5 C3 6B 04        JP INICIO
0358   04F8             
0359   04F8             
0360   04F8             
0361   04F8             
0362   04F8             
0363   04F8             
0364   04F8             
0365   04F8             
0366   04F8             INIT_TXT_LCD:
0367   04F8 3E 00           ld a, 0
0368   04FA 32 03 E0        ld (LCD_TXT_X), a
0369   04FD 32 04 E0        ld (LCD_TXT_Y), a
0370   0500 32 0F E0        ld (LCD_DELETE_CHAR), a
0371   0503 32 10 E0        ld (LCD_AUTO_X), a
0372   0506 21 00 00        ld hl, 0
0373   0509 22 08 E0        ld (LCD_TXT_X_TMP), hl
0374   050C 23              inc hl
0375   050D 22 0A E0        ld (LCD_TXT_Y_TMP), hl
0376   0510 C9              RET
0377   0511             
0378   0511             
0379   0511             DISPLAY_SCROLL_UP:
0380   0511                 ; cada linha tem 128 bytes
0381   0511                 ; temos 8 linhas
0382   0511                 ; total 1024 bytes
0383   0511             
0384   0511                 ; display lines 0 to 7
0385   0511                 ; move line 1 to 0
0386   0511 21 80 E5        ld hl, DISPLAY+128
0387   0514 11 00 E5        ld de, DISPLAY
0388   0517 01 7F 00        ld bc, 127
0389   051A ED B0           ldir
0390   051C             
0391   051C                 ; move line 2 to 1
0392   051C 21 00 E6        ld hl, DISPLAY+256
0393   051F 11 80 E5        ld de, DISPLAY+128
0394   0522 01 7F 00        ld bc, 127
0395   0525 ED B0           ldir
0396   0527             
0397   0527                 ; move line 3 to 2
0398   0527 21 80 E6        ld hl, DISPLAY+384
0399   052A 11 00 E6        ld de, DISPLAY+256
0400   052D 01 7F 00        ld bc, 127
0401   0530 ED B0           ldir
0402   0532             
0403   0532                 ; move line 4 to 3
0404   0532 21 00 E7        ld hl, DISPLAY+512
0405   0535 11 80 E6        ld de, DISPLAY+384
0406   0538 01 7F 00        ld bc, 127
0407   053B ED B0           ldir
0408   053D             
0409   053D                 ; move line 5 to 4
0410   053D 21 80 E7        ld hl, DISPLAY+640
0411   0540 11 00 E7        ld de, DISPLAY+512
0412   0543 01 7F 00        ld bc, 127
0413   0546 ED B0           ldir
0414   0548             
0415   0548                 ; move line 6 to 5
0416   0548 21 00 E8        ld hl, DISPLAY+768
0417   054B 11 80 E7        ld de, DISPLAY+640
0418   054E 01 7F 00        ld bc, 127
0419   0551 ED B0           ldir
0420   0553             
0421   0553                 ; move line 7 to 6
0422   0553 21 80 E8        ld hl, DISPLAY+896
0423   0556 11 00 E8        ld de, DISPLAY+768
0424   0559 01 7F 00        ld bc, 127
0425   055C ED B0           ldir
0426   055E             
0427   055E                 ; clear line 7
0428   055E                 ; 896 to 1024
0429   055E 21 80 E8        ld hl, DISPLAY+896
0430   0561 5D              ld e,l
0431   0562 54              ld d,h
0432   0563 13              inc de
0433   0564 36 00           ld (hl), 0
0434   0566 01 7F 00        ld bc, 127
0435   0569 ED B0           ldir
0436   056B             
0437   056B C9              RET
0438   056C             
0439   056C             DELETE_CHAR:
0440   056C E1              POP HL ; retorno do call
0441   056D 3E 00           LD A, 0
0442   056F 32 0F E0        LD (LCD_DELETE_CHAR), A
0443   0572 3A 03 E0        LD A, (LCD_TXT_X)
0444   0575 3D              DEC A
0445   0576 32 03 E0        LD (LCD_TXT_X), A
0446   0579             
0447   0579 3E FF           LD A, $FF
0448   057B 32 10 E0        LD (LCD_AUTO_X), A
0449   057E             
0450   057E F1              POP AF
0451   057F 3E 20           LD A, ' '
0452   0581 32 00 E0        LD (LCD_CHAR), A
0453   0584 F5              PUSH AF
0454   0585 E5              PUSH HL ; call
0455   0586 C9              RET
0456   0587             
0457   0587             
0458   0587             ; char in A
0459   0587             PRINTCHAR:
0460   0587 32 00 E0        LD (LCD_CHAR), A ; save char to print
0461   058A             
0462   058A F5              PUSH AF
0463   058B C5              PUSH BC
0464   058C D5              PUSH DE
0465   058D E5              PUSH HL
0466   058E             
0467   058E F5              PUSH AF
0468   058F 3E 00           LD A, $0
0469   0591 32 10 E0        LD (LCD_AUTO_X), A
0470   0594 F1              POP AF
0471   0595             
0472   0595             
0473   0595             ver_delete:
0474   0595 F5              PUSH AF
0475   0596 3A 0F E0        LD A, (LCD_DELETE_CHAR)
0476   0599 B7              or a
0477   059A FE FF           CP $FF
0478   059C CC 6C 05        call z, DELETE_CHAR
0479   059F F1              POP AF
0480   05A0 B7              or a
0481   05A1 FE 00           CP $0
0482   05A3 20 08           jr nz, ver_enter
0483   05A5 3E FF           LD A, $FF ; delete proximo char
0484   05A7 32 0F E0        LD (LCD_DELETE_CHAR), A
0485   05AA C3 EA 06        jp print_char_fim
0486   05AD             
0487   05AD                 ; Verificar Enter, clear, etc... SEM PERDER O reg. A
0488   05AD             ver_enter:       
0489   05AD             
0490   05AD                             ; trata dados para o lcd
0491   05AD FE 0D                       CP      CR                     ; compara com ENTER
0492   05AF 20 20                       jr      nz, ver_limpa
0493   05B1             
0494   05B1 3E 00                       LD A,0
0495   05B3 32 03 E0                    LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
0496   05B6             
0497   05B6 3A 04 E0                    LD A, (LCD_TXT_Y)
0498   05B9 3C                          inc a
0499   05BA FE 08                       cp 8
0500   05BC C2 CB 05                    jp nz, ver_enter_incYOK
0501   05BF                             
0502   05BF CD 11 05                    CALL DISPLAY_SCROLL_UP
0503   05C2 21 00 E5                    ld hl, DISPLAY
0504   05C5 CD C6 07                    CALL print_image
0505   05C8                             
0506   05C8 C3 EA 06                    jp print_char_fim
0507   05CB             
0508   05CB             ver_enter_incYOK:
0509   05CB 32 04 E0                    ld (LCD_TXT_Y), a
0510   05CE C3 EA 06                    jp print_char_fim
0511   05D1             
0512   05D1             
0513   05D1             ver_limpa:
0514   05D1 FE 0C                       CP      $0C                     ; compara com limpar tela
0515   05D3 20 14                       jr      NZ, ver_line
0516   05D5                             
0517   05D5                             ;call    clear_lcd_screen
0518   05D5                             ;call    show_lcd_screen
0519   05D5 CD 9F 07                    call lcd_clear
0520   05D8 21 00 E5                    ld hl, DISPLAY
0521   05DB CD C6 07                    call print_image
0522   05DE 3E 00                       LD A, 0
0523   05E0 32 03 E0                    LD (LCD_TXT_X), A
0524   05E3 32 04 E0                    LD (LCD_TXT_Y), A
0525   05E6             
0526   05E6 C3 EA 06                    JP print_char_fim
0527   05E9             
0528   05E9             ver_line:
0529   05E9 FE 0A                       CP      LF                     ; retorna começo da linha
0530   05EB 20 03                       jr      NZ, print_lcd      
0531   05ED             
0532   05ED                                 ;----- verificar se precisa add algo aqui
0533   05ED                             ;call    shift_lcd_up
0534   05ED                             ;call    show_lcd_screen
0535   05ED C3 EA 06                    JP print_char_fim
0536   05F0             
0537   05F0             print_lcd:
0538   05F0                 ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
0539   05F0 26 00           ld H, 0
0540   05F2 6F              ld L, A
0541   05F3 29              ADD HL, HL ; hl x 8
0542   05F4 29              ADD HL, HL
0543   05F5 29              ADD HL, HL
0544   05F6             
0545   05F6 54              LD D, H
0546   05F7 5D              LD E, L
0547   05F8 21 6B 00        ld hl, TABLE
0548   05FB 19              add hl, de
0549   05FC 22 01 E0        ld (LCD_CHAR_POINT), HL ; table
0550   05FF             
0551   05FF             
0552   05FF                 ; ajusta X
0553   05FF 06 06           ld b, 6
0554   0601 3A 03 E0        ld a, (LCD_TXT_X)
0555   0604 B7              or A
0556   0605 CA 0F 06        jp z, ajustX
0557   0608 4F              ld c, a
0558   0609 CD EF 06        call multiplication
0559   060C C3 12 06        jp ajustXOK
0560   060F                 
0561   060F             ajustX:
0562   060F 21 00 00        ld hl, 0
0563   0612             ajustXOK:
0564   0612 22 08 E0        ld (LCD_TXT_X_TMP), HL 
0565   0615             
0566   0615             
0567   0615             
0568   0615                 ; ajuste Y
0569   0615 16 04           ld d, 4
0570   0617 1E 00           ld e, 0 ; = 128x8 proxima linha
0571   0619 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
0572   061C 3A 04 E0        ld a, (LCD_TXT_Y)
0573   061F B7              or a
0574   0620 CA 30 06        JP Z, multYfim
0575   0623 21 00 00        ld hl, 0
0576   0626 47              ld b, a
0577   0627             multY:
0578   0627 19              add hl, de
0579   0628 10 FD           DJNZ multY
0580   062A             
0581   062A 22 0A E0        ld (LCD_TXT_Y_TMP), HL
0582   062D C3 36 06        jp multYfimok
0583   0630             
0584   0630             multYfim:
0585   0630 21 00 00        ld hl, 0
0586   0633 22 0A E0        ld (LCD_TXT_Y_TMP), HL
0587   0636             
0588   0636             multYfimok:
0589   0636             
0590   0636 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
0591   0639 ED 5B 08 E0     ld de, (LCD_TXT_X_TMP)
0592   063D             
0593   063D 19              add hl, de  ; hl tem pos do pix 0-8191
0594   063E             
0595   063E 22 0E E0        ld (LCD_TMP_POINT), hl
0596   0641             
0597   0641             
0598   0641 3E 08           ld a, 8 ; altura do caracter
0599   0643 32 0C E0        ld (LCD_CHAR_H), a
0600   0646             printchar_loopH:
0601   0646 2A 01 E0        ld hl, (LCD_CHAR_POINT)
0602   0649 7E              ld a, (HL)
0603   064A 32 10 E1        ld (LCD_TEMP), a
0604   064D             
0605   064D 3E 06           ld a, 6 ; largura do caracter
0606   064F 32 0D E0        ld (LCD_CHAR_W), a
0607   0652             printchar_loopW:
0608   0652 3A 10 E1        ld a, (LCD_TEMP)
0609   0655 E6 80           and 128
0610   0657 FE 00           cp 0
0611   0659 CA 65 06        jp z, printchar_loopWC
0612   065C 2A 0E E0        ld hl, (LCD_TMP_POINT)
0613   065F CD 2A 07        call lcd_setPixel
0614   0662 C3 6B 06        JP printchar_loopWE
0615   0665             
0616   0665             printchar_loopWC:
0617   0665 2A 0E E0        ld hl, (LCD_TMP_POINT)
0618   0668 CD 63 07        call lcd_clearPixel
0619   066B             
0620   066B             printchar_loopWE:
0621   066B 3A 10 E1        ld a, (LCD_TEMP)
0622   066E CB 27           sla a
0623   0670 32 10 E1        ld (LCD_TEMP), a
0624   0673                 
0625   0673 2A 0E E0        ld hl, (LCD_TMP_POINT)
0626   0676 23              inc hl
0627   0677 22 0E E0        ld (LCD_TMP_POINT), hl
0628   067A             
0629   067A 3A 0D E0        ld a, (LCD_CHAR_W)
0630   067D 3D              dec A
0631   067E 32 0D E0        ld (LCD_CHAR_W), a
0632   0681 FE 00           cp 0
0633   0683 C2 52 06        JP NZ, printchar_loopW
0634   0686             
0635   0686             
0636   0686 2A 0E E0        ld hl, (LCD_TMP_POINT)
0637   0689 2B              dec hl
0638   068A 2B              dec hl
0639   068B 2B              dec hl
0640   068C 2B              dec hl
0641   068D 2B              dec hl
0642   068E 2B              dec hl
0643   068F             
0644   068F 16 00           ld d, 0
0645   0691 1E 80           ld e, 128
0646   0693 19              add hl, de
0647   0694 22 0E E0        ld (LCD_TMP_POINT), HL
0648   0697             
0649   0697 2A 01 E0        ld hl, (LCD_CHAR_POINT)
0650   069A 23              inc hl
0651   069B 22 01 E0        ld (LCD_CHAR_POINT), hl
0652   069E             
0653   069E             
0654   069E 3A 0C E0        ld a, (LCD_CHAR_H)
0655   06A1 3D              dec A
0656   06A2 32 0C E0        ld (LCD_CHAR_H), a
0657   06A5 FE 00           cp 0
0658   06A7 C2 46 06        jp NZ, printchar_loopH
0659   06AA             
0660   06AA 21 00 E5        ld hl, DISPLAY
0661   06AD CD C6 07        call print_image
0662   06B0             
0663   06B0             
0664   06B0                 ; check auto x
0665   06B0 3A 10 E0        LD A, (LCD_AUTO_X)
0666   06B3 B7              OR A
0667   06B4 FE FF           CP $FF
0668   06B6 CA EA 06        JP Z, print_char_fim
0669   06B9             
0670   06B9                 ; increment X, Y
0671   06B9 3A 03 E0        ld a, (LCD_TXT_X)
0672   06BC 3C              inc a
0673   06BD FE 15           cp 21
0674   06BF C2 E7 06        jp nz, incXOK
0675   06C2 3E 00           ld a, 0
0676   06C4 32 03 E0        ld (LCD_TXT_X), a
0677   06C7 3A 04 E0        ld a, (LCD_TXT_Y)
0678   06CA 3C              inc a
0679   06CB FE 08           cp 8
0680   06CD C2 E1 06        jp nz, incYOK
0681   06D0 CD 11 05        CALL DISPLAY_SCROLL_UP
0682   06D3 21 00 E5        ld hl, DISPLAY
0683   06D6 CD C6 07        CALL print_image
0684   06D9 3E 00           ld a, 0
0685   06DB 32 03 E0        ld (LCD_TXT_X), a
0686   06DE C3 EA 06        jp print_char_fim
0687   06E1             
0688   06E1             incYOK:
0689   06E1 32 04 E0        ld (LCD_TXT_Y), a
0690   06E4 C3 EA 06        jp print_char_fim
0691   06E7             
0692   06E7             incXOK:
0693   06E7 32 03 E0        ld (LCD_TXT_X), a
0694   06EA             
0695   06EA             print_char_fim:
0696   06EA E1              POP HL
0697   06EB D1              POP DE
0698   06EC C1              POP BC
0699   06ED F1              POP AF
0700   06EE C9              RET
0701   06EF             ;-------- FIM PRINTCHAR ------------------
0702   06EF             
0703   06EF             
0704   06EF             
0705   06EF             ; ----------------------------------
0706   06EF             
0707   06EF             ; INPUT: THE VALUES IN REGISTER B EN C
0708   06EF             ; OUTPUT: HL = B * C
0709   06EF             ; CHANGES: AF,DE,HL,B
0710   06EF             ;
0711   06EF             multiplication:
0712   06EF 21 00 00    	LD HL,0
0713   06F2 78          	LD A,B
0714   06F3 B7          	OR A
0715   06F4 C8          	RET Z
0716   06F5 16 00       	LD D,0
0717   06F7 59          	LD E,C
0718   06F8 19          multiplicationLOOP:	ADD HL,DE
0719   06F9 10 FD       	DJNZ multiplicationLOOP
0720   06FB C9          	RET 
0721   06FC             
0722   06FC             ;-----------------------------------
0723   06FC             
0724   06FC             Div_HL_D:
0725   06FC             ;Inputs:
0726   06FC             ;   HL and D
0727   06FC             ;Outputs:
0728   06FC             ;   HL is the quotient (HL/D)
0729   06FC             ;   A is the remainder
0730   06FC             ;   B is 0
0731   06FC             ;   C,D,E are preserved
0732   06FC AF              xor a         ; Clear upper eight bits of AHL
0733   06FD 06 10           ld b,16       ; Sixteen bits in dividend
0734   06FF             _loop:
0735   06FF 29              add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
0736   0700 17              rla           ; This moves the upper bits of the dividend into A
0737   0701 38 03           jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
0738   0703 BA              cp d          ; Check if we can subtract the divisor
0739   0704 38 02           jr c,_skip    ; Carry means A < D
0740   0706             _overflow:
0741   0706 92              sub d         ; Do subtraction for real this time
0742   0707 2C              inc l         ; Set the next bit of the quotient (currently bit 0)
0743   0708             _skip:
0744   0708 10 F5           djnz _loop
0745   070A C9              ret
0746   070B             
0747   070B             
0748   070B             ; -----------------------------------------------------------------------------
0749   070B             ;   LCD DRIVER
0750   070B             ; -----------------------------------------------------------------------------
0751   070B             ; INIT_LCD - Inicia o lcd em mode texto
0752   070B             ; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
0753   070B             ; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
0754   070B             ; lcd_clear - Limpa buffer do lcd
0755   070B             ; enable_grafic - Coloca o LCD em modo grafico
0756   070B             ; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
0757   070B             ; cls_TXT - Limpa LCD mode text
0758   070B             ; cls_GRAPHIC - Limpa LCD modo grafico
0759   070B             
0760   070B             INIT_LCD:
0761   070B                 ;Initialisation
0762   070B 3E 30       	ld a, 30H
0763   070D CD 4F 08    	call lcd_send_command
0764   0710             
0765   0710 3E A0       	ld a, 0b00100000
0766   0712 CD 4F 08    	call lcd_send_command
0767   0715             
0768   0715 3E 30       	ld a, 30H
0769   0717 CD 4F 08    	call lcd_send_command
0770   071A             
0771   071A 3E 0C       	ld a, 0CH
0772   071C CD 4F 08    	call lcd_send_command
0773   071F             
0774   071F 3E 01       	ld a, 01H
0775   0721 CD 4F 08    	call lcd_send_command
0776   0724             
0777   0724 3E 02       	ld a, 02H
0778   0726 CD 4F 08    	call lcd_send_command
0779   0729 C9              RET
0780   072A             
0781   072A             
0782   072A             ; pixel index in HL
0783   072A             lcd_setPixel:
0784   072A E5              push hl
0785   072B C5              push bc
0786   072C D5              push de
0787   072D F5              push af
0788   072E AF              xor A
0789   072F 32 07 E0        ld (LCD_BIT_INDEX), A
0790   0732 32 05 E0        ld (LCD_BYTE_INDEX), A
0791   0735             
0792   0735 16 08           ld d, 8
0793   0737 CD FC 06        call Div_HL_D
0794   073A 32 07 E0        ld (LCD_BIT_INDEX), A
0795   073D 22 05 E0        ld (LCD_BYTE_INDEX), HL
0796   0740 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
0797   0744 21 00 E5        ld hl, DISPLAY
0798   0747 09              add hl, bc
0799   0748                 
0800   0748 06 80           ld b, 128 ; 1000 0000
0801   074A 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
0802   074D FE 00           cp 0
0803   074F CA 5B 07        jp z, lcd_setPixel_fim
0804   0752             lcd_setPixel_bit:
0805   0752 CB 38           srl B
0806   0754 3D              dec A
0807   0755 CA 5B 07        jp z, lcd_setPixel_fim
0808   0758                 
0809   0758 C3 52 07        jp lcd_setPixel_bit
0810   075B             lcd_setPixel_fim
0811   075B 7E              ld a, (hl)
0812   075C B0              or b
0813   075D 77              ld (hl), a
0814   075E             
0815   075E F1              pop af
0816   075F C1              pop bc
0817   0760 D1              pop de
0818   0761 E1              pop hl
0819   0762 C9              ret
0820   0763             
0821   0763             ;===============================
0822   0763             ; pixel index in HL
0823   0763             lcd_clearPixel:
0824   0763 E5              push hl
0825   0764 C5              push bc
0826   0765 D5              push de
0827   0766 F5              push af
0828   0767 AF              xor A
0829   0768 32 07 E0        ld (LCD_BIT_INDEX), A
0830   076B 32 05 E0        ld (LCD_BYTE_INDEX), A
0831   076E 16 08           ld d, 8
0832   0770 CD FC 06        call Div_HL_D
0833   0773 32 07 E0        ld (LCD_BIT_INDEX), A
0834   0776 22 05 E0        ld (LCD_BYTE_INDEX), HL
0835   0779 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
0836   077D 21 00 E5        ld hl, DISPLAY
0837   0780 09              add hl, bc
0838   0781                 
0839   0781 06 80           ld b, 128 ; 1000 0000
0840   0783 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
0841   0786 FE 00           cp 0
0842   0788 CA 94 07        jp z, lcd_clearPixel_fim
0843   078B             lcd_clearPixel_bit:
0844   078B CB 38           srl B
0845   078D 3D              dec A
0846   078E CA 94 07        jp z, lcd_clearPixel_fim
0847   0791                 
0848   0791 C3 8B 07        jp lcd_clearPixel_bit
0849   0794             lcd_clearPixel_fim
0850   0794 78              ld a, b
0851   0795 2F              cpl     ; NOT B
0852   0796 47              ld b, a
0853   0797             
0854   0797 7E              ld a, (hl)
0855   0798 A0              and b
0856   0799 77              ld (hl), a
0857   079A             
0858   079A F1              pop af
0859   079B C1              pop bc
0860   079C D1              pop de
0861   079D E1              pop hl
0862   079E C9              ret
0863   079F             
0864   079F             
0865   079F             ;;--------------------------------------------------
0866   079F             lcd_clear:
0867   079F                 ;; HL = start address of block
0868   079F 21 00 E5        ld hl, DISPLAY
0869   07A2             
0870   07A2                 ;; DE = HL + 1
0871   07A2 5D              ld e,l
0872   07A3 54              ld d,h
0873   07A4 13              inc de
0874   07A5             
0875   07A5                 ;; initialise first byte of block
0876   07A5                 ;; with data byte (&00)
0877   07A5 36 00           ld (hl), 0
0878   07A7                     
0879   07A7                 ;; BC = length of block in bytes
0880   07A7                 ;; HL+BC-1 = end address of block
0881   07A7             
0882   07A7 01 00 04        ld bc, 1024
0883   07AA             
0884   07AA                 ;; fill memory
0885   07AA ED B0           ldir
0886   07AC C9              ret
0887   07AD             
0888   07AD             
0889   07AD             ;===================
0890   07AD             
0891   07AD             ; grafic mode - enable
0892   07AD             enable_grafic:
0893   07AD 3E 30       	ld a, 30H
0894   07AF CD 4F 08    	call lcd_send_command
0895   07B2 CD 7A 08    	call delayLCD
0896   07B5             	
0897   07B5 3E 34       	ld a, 34H
0898   07B7 CD 4F 08    	call lcd_send_command
0899   07BA CD 7A 08    	call delayLCD
0900   07BD             	
0901   07BD 3E 36       	ld a, 36H
0902   07BF CD 4F 08    	call lcd_send_command
0903   07C2 CD 7A 08    	call delayLCD
0904   07C5 C9              ret
0905   07C6             
0906   07C6             
0907   07C6             ;==========================
0908   07C6             
0909   07C6             print_image:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
0910   07C6             									; HL content the data address
0911   07C6 F5              push af
0912   07C7 D5          	push de
0913   07C8 C5          	push bc
0914   07C9             
0915   07C9             
0916   07C9             ; premiere partie : X de 0 à 127 / Y de 0 à 32
0917   07C9             
0918   07C9 3E 20       	ld a,32
0919   07CB 57          	ld d,a							; boucle Y
0920   07CC 3E 00       	ld a,0
0921   07CE 5F          	ld e,a
0922   07CF             	
0923   07CF             boucle_colonne:
0924   07CF 3E 80       		ld a,$80					; coordonnée Y (0)
0925   07D1 83          		add a,e
0926   07D2 CD 4F 08    		call lcd_send_command
0927   07D5             		
0928   07D5 3E 80       		ld a,$80					; coordonnée X (0)		
0929   07D7 CD 4F 08    		call lcd_send_command
0930   07DA             		
0931   07DA 3E 08       		ld a,8
0932   07DC 47          		ld b,a						; boucle X
0933   07DD             		
0934   07DD             boucle_ligne:	
0935   07DD 7E          			ld a,(hl)
0936   07DE CD 59 08    			call lcd_send_data
0937   07E1 23          			inc hl
0938   07E2 7E          			ld a,(hl)
0939   07E3 CD 59 08    			call lcd_send_data		; auto-increment on screen address
0940   07E6 23          			inc hl
0941   07E7 05          			dec b
0942   07E8 AF          			XOR a
0943   07E9 B0          			OR b
0944   07EA C2 DD 07    			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
0945   07ED             		
0946   07ED 15          		dec d
0947   07EE 1C          		inc e
0948   07EF AF          		XOR a
0949   07F0 B2          		OR d
0950   07F1 C2 CF 07    		jp nz,boucle_colonne
0951   07F4             		
0952   07F4             
0953   07F4             ; seconde partie : X de 128 à 255 / Y de 0 à 32
0954   07F4             
0955   07F4 3E 20       	ld a,32
0956   07F6 57          	ld d,a							; boucle Y
0957   07F7 3E 00       	ld a,0
0958   07F9 5F          	ld e,a
0959   07FA             	
0960   07FA             boucle_colonne2:
0961   07FA 3E 80       		ld a,$80					; coordonnée Y (0)
0962   07FC 83          		add a, e
0963   07FD CD 4F 08    		call lcd_send_command
0964   0800             		
0965   0800 3E 88       		ld a,$88					; coordonnée X (8)		
0966   0802 CD 4F 08    		call lcd_send_command
0967   0805             		
0968   0805 3E 08       		ld a,8
0969   0807 47          		ld b,a						; boucle X
0970   0808             		
0971   0808             boucle_ligne2:	
0972   0808 7E          			ld a,(hl)
0973   0809 CD 59 08    			call lcd_send_data
0974   080C 23          			inc hl
0975   080D 7E          			ld a,(hl)
0976   080E CD 59 08    			call lcd_send_data		; auto-increment on screen address
0977   0811 23          			inc hl
0978   0812 05          			dec b
0979   0813 AF          			XOR a
0980   0814 B0          			OR b
0981   0815 C2 08 08    			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
0982   0818             		
0983   0818 15          		dec d
0984   0819 1C          		inc e
0985   081A AF          		XOR a
0986   081B B2          		OR d
0987   081C C2 FA 07    		jp nz,boucle_colonne2
0988   081F             
0989   081F C1          	pop bc
0990   0820 D1          	pop de
0991   0821 F1              pop af
0992   0822             
0993   0822 C9              ret
0994   0823             
0995   0823             
0996   0823             
0997   0823             ; ======================
0998   0823             cls_TXT:
0999   0823             	; # CLEAR DISPLAY IN TEXT MODE # 
1000   0823 3E 01       	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
1001   0825 CD 4F 08    	call lcd_send_command		; CLEAR DISPLAY	
1002   0828 C9              ret
1003   0829             
1004   0829             ; ========================
1005   0829             
1006   0829             cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
1007   0829             					;	Graphic RAM (GDRAM) use :
1008   0829             					;	1. Set vertical address (Y) for GDRAM
1009   0829             					;	2. Set horizontal address (X) for GDRAM
1010   0829             					;	3. Write D15~D8 to GDRAM (first byte)
1011   0829             					;	4. Write D7~D0 to GDRAM (second byte)
1012   0829 C5          	push bc
1013   082A D5          	push de
1014   082B             
1015   082B 1E 20       	ld e,$20						; e = 32 
1016   082D 16 00       	ld d,$0							; d = 0
1017   082F             Boucle32X:
1018   082F 7A          		ld a,d
1019   0830 F6 80       		OR $80
1020   0832 CD 4F 08    		call lcd_send_command
1021   0835             		
1022   0835 3E 80       		ld a,$80					; Set horizontal address（X） for GDRAM = 0 ($80)
1023   0837 CD 4F 08    		call lcd_send_command
1024   083A             		
1025   083A AF          		xor a							 	
1026   083B 06 10       		ld b,$10							; b = 17
1027   083D             		
1028   083D             Boucle16X:	 
1029   083D CD 59 08    			call lcd_send_data 			; Write D15〜D8 to GDRAM (first byte)
1030   0840 CD 59 08    			call lcd_send_data 			; Write D7〜D0 to GDRAM (second byte)
1031   0843             											; Address counter will automatically increase by one for the next two-byte data												
1032   0843 10 F8       			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
1033   0845             		
1034   0845 1D          		dec e 
1035   0846 14          		inc d
1036   0847 AF          		xor a							; a = 0
1037   0848 B3          		or e
1038   0849 C2 2F 08    		jp nz,Boucle32X
1039   084C             
1040   084C D1          	pop de
1041   084D C1          	pop bc
1042   084E             	
1043   084E C9              ret
1044   084F             
1045   084F             
1046   084F             
1047   084F             
1048   084F             ;******************
1049   084F             ;Send a command byte to the LCD
1050   084F             ;Entry: A= command byte
1051   084F             ;Exit: All preserved
1052   084F             ;******************
1053   084F             lcd_send_command:
1054   084F C5          	push bc				;Preserve
1055   0850 0E 70       	ld c, LCDCTRL   	;Command port
1056   0852             	
1057   0852             lcd_command_wait_loop:	;Busy wait
1058   0852 CD 7A 08    	call delayLCD
1059   0855             	
1060   0855 ED 79       	out (c),a			;Send command
1061   0857 C1          	pop bc				;Restore
1062   0858 C9          	ret
1063   0859             	
1064   0859             ;******************
1065   0859             ;Send a data byte to the LCD
1066   0859             ;Entry: A= data byte
1067   0859             ;Exit: All preserved
1068   0859             ;******************
1069   0859             lcd_send_data:
1070   0859 C5          	push bc				;Preserve
1071   085A 0E 70       	ld c, LCDCTRL	    ;Command port
1072   085C             	
1073   085C                 ;Busy wait
1074   085C CD 7A 08    	call delayLCD
1075   085F             	
1076   085F 0E 71       	ld c, LCDDATA	;Data port
1077   0861 ED 79       	out (c),a			;Send data
1078   0863 C1          	pop bc				;Restore
1079   0864 C9          	ret
1080   0865             
1081   0865             ;******************
1082   0865             ;Send an asciiz string to the LCD
1083   0865             ;Entry: HL=address of string
1084   0865             ;Exit: HL=address of ending zero of the string. All others preserved
1085   0865             ;******************
1086   0865             lcd_send_asciiz:
1087   0865 F5          	push af
1088   0866 C5          	push bc				;Preserve
1089   0867             lcd_asciiz_char_loop:
1090   0867 0E 70       	ld c, LCDCTRL   	;Command port
1091   0869             	
1092   0869             lcd_asciiz_wait_loop:	;Busy wait
1093   0869 CD 7A 08    	call delayLCD
1094   086C             	
1095   086C 7E          	ld a,(hl)			;Get character
1096   086D A7          	and a				;Is it zero?
1097   086E 28 07       	jr z,lcd_asciiz_done	;If so, we're done
1098   0870             	
1099   0870 0E 71       	ld c, LCDDATA	;Data port
1100   0872 ED 79       	out (c),a			;Send data
1101   0874 23          	inc hl				;Next char
1102   0875 18 F0       	jr lcd_asciiz_char_loop
1103   0877             	
1104   0877             lcd_asciiz_done:
1105   0877 C1          	pop bc				;Restore
1106   0878 F1          	pop af
1107   0879 C9          	ret
1108   087A             
1109   087A             ; =========================================================
1110   087A             ; Delay LCD
1111   087A             ; =========================================================
1112   087A             delayLCD:
1113   087A             
1114   087A 00          	NOP
1115   087B 00          	NOP
1116   087C 00          	NOP
1117   087D 00          	NOP
1118   087E 00          	NOP
1119   087F 00          	NOP
1120   0880 00          	NOP
1121   0881 00          	NOP
1122   0882 00          	NOP
1123   0883 00          	NOP
1124   0884 00          	NOP ; KO
1125   0885 00          	NOP
1126   0886 00              NOP
1127   0887 C9              ret
1128   0888             
1129   0888             	
1130   0888             ; =========================================================
1131   0888             ; Delay
1132   0888             ; =========================================================
1133   0888             delay:
1134   0888 C5          	push bc                       ; 2.75 us
1135   0889 06 FF           ld b, 255                     ; 1.75 us
1136   088B             delay_loop_b:
1137   088B 0E FF       	ld c, 255                     ; 1.75 us
1138   088D             delay_loop:
1139   088D 0D          	dec c                         ; 1 us
1140   088E C2 8D 08        jp nz, delay_loop             ; true = 3 us, false 1.75 us
1141   0891 05              dec b                         ; 1 us
1142   0892 C2 8B 08        jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
1143   0895 C1              pop bc                        ; 2.50 us
1144   0896 C9              ret   
1145   0897             
1146   0897             
1147   0897             ; Check break key
1148   0897 3E 40       CHKKEY: LD  A, $40
1149   0899 D3 40       	OUT (KEY_OUT), A ; line 4
1150   089B DB 40       	IN  A, (KEY_IN)
1151   089D FE 01       	CP  1
1152   089F C2 A7 08    	JP  NZ, GRET
1153   08A2 3E 03       	LD  A, CTRLC
1154   08A4 FE 00       	CP	0
1155   08A6 C9          	RET
1156   08A7             GRET:
1157   08A7 3E 00       	LD  A, 0
1158   08A9 FE 00       	CP 0
1159   08AB C9          	RET
1160   08AC             
1161   08AC             
1162   08AC             
1163   08AC             
1164   08AC             ; -----------------------------------------------------------------------------
1165   08AC             ;   KEYREAD - KEY In A
1166   08AC             ; -----------------------------------------------------------------------------
1167   08AC             KEYREADINIT:
1168   08AC C5              PUSH    BC
1169   08AD D5          	PUSH	DE
1170   08AE E5          	PUSH    HL
1171   08AF 1E 00       	LD      E, 0                    ; E will be the last pressed key
1172   08B1             READKEY:        
1173   08B1 26 01           LD      H, 1                    ; H is the line register, start with second
1174   08B3 06 00       	LD      B, 0                    ; Count lines for later multiplication	
1175   08B5 16 00       	LD      D, 0                    ; DE will be the adress for mask
1176   08B7             						
1177   08B7             NEXTKEY:        
1178   08B7 7C              LD      A, H						
1179   08B8 FE 00           CP      0                       ; All lines tried? 
1180   08BA CA F5 08        JP      Z, KEYOUT               ; Then check if there was a key pressed
1181   08BD D3 40       	OUT     (KEY_OUT), A		    ; Put current line to register
1182   08BF DB 40       	IN      A, (KEY_IN)		        ; Input Keys
1183   08C1 E6 1F       	AND     $1F                     ; only 5 bits
1184   08C3 CB 24       	SLA     H                       ; Next line
1185   08C5 04              INC     B
1186   08C6 FE 00           CP      0                       ; Was key zero?
1187   08C8 CA B7 08        JP      Z, NEXTKEY              ; Then try again with next lines
1188   08CB 16 00           LD      D, 0                    ; In D will be the number of the key
1189   08CD             LOGARITHM:      
1190   08CD 14              INC     D	                    ; Add one per shift
1191   08CE CB 3F           SRL     A                       ; Shift key right
1192   08D0 C2 CD 08        JP      NZ, LOGARITHM		    ; If not zero shift again
1193   08D3 15              DEC     D                       ; Was too much
1194   08D4 DB 40       	IN      A, (KEY_IN)
1195   08D6 E6 80           AND     $80                     ; Check if first bit set (shift key pressed)
1196   08D8 C2 E1 08        JP      NZ, LOADSHIFT		    ; Then jump to read with shift
1197   08DB 7A              LD      A, D                    ; Put read key into accu
1198   08DC C6 1B           ADD     A, KEYMAP               ; Add base of key map array
1199   08DE C3 E4 08        JP      ADDOFFSET               ; Jump to load key
1200   08E1             LOADSHIFT:
1201   08E1 7A              LD      A, D
1202   08E2 C6 43           ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
1203   08E4             ADDOFFSET:
1204   08E4 C6 05           ADD     A, 5                    ; Add 5 for every line
1205   08E6 10 FC           DJNZ    ADDOFFSET               ; Jump back (do while loop)
1206   08E8 D6 05       	SUB     5                       ; Since do while is one too much
1207   08EA             TRANSKEY:
1208   08EA A8              XOR     B                       ; Empty B
1209   08EB 4F          	LD      C, A                    ; A will be address in BC
1210   08EC 0A          	LD      A, (BC)	                ; Load key
1211   08ED BB          	CP      E                       ; Same key?
1212   08EE CA B1 08    	JP      Z, READKEY              ; Then from beginning
1213   08F1 5F          	LD      E, A                    ; Otherwise save new key
1214   08F2 C3 B1 08    	JP      READKEY	                ; And restart
1215   08F5             KEYOUT:
1216   08F5 7B              LD      A, E
1217   08F6 1E 00           LD      E, 0                    ; empty it
1218   08F8 B7              OR      A	                    ; Was a key read?
1219   08F9 CA B1 08        JP      Z, READKEY              ; If not restart
1220   08FC E1              POP     HL
1221   08FD D1              POP     DE
1222   08FE C1              POP     BC
1223   08FF C9              RET
1224   0900             
1225   0900             
1226   0900             ;-----------------------
1227   0900             ; RECEIVE INTEL HEX FILE
1228   0900             ;-----------------------       
1229   0900             INTHEX: 
1230   0900 21 46 0C           LD HL, MSG_ILOAD
1231   0903 CD B3 09           CALL  SNDLCDMSG
1232   0906             
1233   0906 21 46 0C           LD HL, MSG_ILOAD
1234   0909 CD C1 09           CALL  SNDMSG
1235   090C                    
1236   090C             
1237   090C CD 2B 09           CALL  INTELH
1238   090F 20 0D              JR    NZ,ITHEX1      
1239   0911             
1240   0911 21 5C 0C           LD    HL,FILEOK
1241   0914 CD B3 09           CALL  SNDLCDMSG   ;GOT FILE OK LCD
1242   0917 21 5C 0C           LD    HL,FILEOK
1243   091A CD C1 09           CALL  SNDMSG      ;GOT FILE OK Serial
1244   091D                    
1245   091D C9                 RET
1246   091E 21 6E 0C    ITHEX1: LD    HL,CSUMERR
1247   0921 CD B3 09           CALL  SNDLCDMSG
1248   0924             
1249   0924 21 6E 0C           LD    HL,CSUMERR
1250   0927 CD C1 09           CALL  SNDMSG      ;CHECKSUM ERROR
1251   092A                    
1252   092A C9                 RET  
1253   092B             
1254   092B             
1255   092B             
1256   092B             
1257   092B             
1258   092B             ;-----------------------
1259   092B             ; RECEIVE INTEL HEX FILE
1260   092B             ;-----------------------
1261   092B DD 21 00 FE INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
1262   092F             ;
1263   092F             ; WAIT FOR RECORD MARK
1264   092F             ;
1265   092F AF          INTEL1:	XOR	A
1266   0930 DD 77 03    	LD	(IX+3),A	;CLEAR CHECKSUM
1267   0933 CD 06 0A    	CALL	RXDATA	;WAIT FOR THE RECORD MARK
1268   0936 FE 3A       	CP	':'	;TO BE TRANSMITTED
1269   0938 20 F5       	JR	NZ,INTEL1	;NOT RECORD MARK
1270   093A             ;
1271   093A             ; GET RECORD LENGTH
1272   093A             ;
1273   093A CD 87 09    	CALL	GETBYT
1274   093D DD 77 00    	LD	(IX+0),A	;NUMBER OF DATA BYTES
1275   0940             ;
1276   0940             ; GET ADDRESS FIELD
1277   0940             ;
1278   0940 CD 87 09    	CALL	GETBYT
1279   0943 DD 77 02    	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
1280   0946 CD 87 09    	CALL	GETBYT
1281   0949 DD 77 01    	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
1282   094C             ;
1283   094C             ; GET RECORD TYPE
1284   094C             ;
1285   094C CD 87 09    	CALL	GETBYT
1286   094F 20 24       	JR	NZ,INTEL4	;END OF FILE RECORD
1287   0951             ;
1288   0951             ; READ IN THE DATA
1289   0951             ;
1290   0951 DD 46 00    	LD	B,(IX+0)	;NUMBER OF DATA BYTES
1291   0954 DD 66 02    	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
1292   0957 DD 6E 01    	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
1293   095A             
1294   095A CD 87 09    INTEL2:	CALL	GETBYT	;GET DATA BYTE
1295   095D 77          	LD	(HL),A	;STORE DATA BYTE
1296   095E 23          	INC	HL
1297   095F 10 F9       	DJNZ	INTEL2	;LOAD MORE BYTES
1298   0961             ;
1299   0961             ; GET CHECKSUM AND COMPARE
1300   0961             ;
1301   0961 DD 7E 03    	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1302   0964 ED 44       	NEG		;TWO'S COMPLEMENT
1303   0966 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
1304   0969 CD 87 09    	CALL	GETBYT
1305   096C DD 77 03    	LD	(IX+3),A	;SAVE RECORD CHECKSUM
1306   096F DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
1307   0972 28 BB       	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
1308   0974 C9              RET             ;NZ=CHECKSUM ERROR
1309   0975             ;
1310   0975             ; END OF FILE RECORD
1311   0975             ;
1312   0975 DD 7E 03    INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1313   0978 ED 44       	NEG		;TWO'S COMPLEMENT
1314   097A DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
1315   097D CD 87 09    	CALL	GETBYT
1316   0980 DD 77 03    	LD	(IX+3),A	;SAVE EOF CHECKSUM
1317   0983 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
1318   0986 C9          	RET  	    ;NZ=CHECKSUM ERROR
1319   0987             ;--------------------------
1320   0987             ; GET BYTE FROM SERIAL PORT
1321   0987             ;--------------------------
1322   0987 C5          GETBYT:	PUSH	BC
1323   0988 CD 06 0A    	CALL	RXDATA
1324   098B CB 77       	BIT	6,A
1325   098D 28 02       	JR	Z,GETBT1
1326   098F C6 09       	ADD	A,09H
1327   0991 E6 0F       GETBT1:	AND	0FH
1328   0993 CB 27       	SLA 	A
1329   0995 CB 27       	SLA	A
1330   0997 CB 27       	SLA	A
1331   0999 CB 27       	SLA	A
1332   099B 4F          	LD	C,A
1333   099C             ;
1334   099C             ; GET LOW NYBBLE
1335   099C             ;
1336   099C CD 06 0A    	CALL	RXDATA
1337   099F CB 77       	BIT	6,A
1338   09A1 28 02       	JR	Z,GETBT2
1339   09A3 C6 09       	ADD	A,09H
1340   09A5 E6 0F       GETBT2:	AND	0FH
1341   09A7 B1          	OR	C
1342   09A8 47          	LD	B,A
1343   09A9 DD 86 03    	ADD	A,(IX+3)
1344   09AC DD 77 03    	LD	(IX+3),A	;ADD TO CHECKSUM
1345   09AF 78          	LD	A,B
1346   09B0 A7          	AND	A	;CLEAR CARRY
1347   09B1 C1              POP	BC
1348   09B2 C9          	RET
1349   09B3             
1350   09B3             ;-----------------------------------------
1351   09B3             ; SEND AN ASCII STRING OUT LCD
1352   09B3             ;-----------------------------------------
1353   09B3             ; 
1354   09B3             ; SENDS A ZERO TERMINATED STRING OR 
1355   09B3             ; 128 CHARACTERS MAX. OUT LCD
1356   09B3             ;
1357   09B3             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
1358   09B3             ;      EXIT  : NONE
1359   09B3             ;
1360   09B3             ;       MODIFIES : A,B,C
1361   09B3             ;          
1362   09B3 06 80       SNDLCDMSG: LD    B,128         ;128 CHARS MAX
1363   09B5 7E          SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
1364   09B6 FE 00              CP    00H          ;ZERO TERMINATOR?
1365   09B8 28 06              JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
1366   09BA CD 87 05           CALL PRINTCHAR         ;TRANSMIT THE CHAR
1367   09BD 23                 INC   HL
1368   09BE 10 F5              DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
1369   09C0 C9          SDLCDMSG2: RET
1370   09C1             
1371   09C1             
1372   09C1             ;-----------------------------------------
1373   09C1             ; SEND AN ASCII STRING OUT THE SERIAL PORT
1374   09C1             ;-----------------------------------------
1375   09C1             ; 
1376   09C1             ; SENDS A ZERO TERMINATED STRING OR 
1377   09C1             ; 128 CHARACTERS MAX. OUT THE SERIAL PORT
1378   09C1             ;
1379   09C1             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
1380   09C1             ;      EXIT  : NONE
1381   09C1             ;
1382   09C1             ;       MODIFIES : A,B,C
1383   09C1             ;          
1384   09C1 06 80       SNDMSG: LD    B,128         ;128 CHARS MAX
1385   09C3 7E          SDMSG1: LD    A,(HL)        ;GET THE CHAR
1386   09C4 FE 00              CP    00H          ;ZERO TERMINATOR?
1387   09C6 28 06              JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
1388   09C8 CD CF 09           CALL  OUTCH         ;TRANSMIT THE CHAR
1389   09CB 23                 INC   HL
1390   09CC 10 F5              DJNZ  SDMSG1        ;128 CHARS MAX!    
1391   09CE C9          SDMSG2: RET
1392   09CF             
1393   09CF             
1394   09CF             
1395   09CF             ;-----------------------------------
1396   09CF             ; OUTPUT A CHARACTER TO THE TERMINAL
1397   09CF             ;-----------------------------------       
1398   09CF DD 2A AA FF OUTCH:  LD   IX,(PUTCH)
1399   09D3 DD E9              JP   (IX)
1400   09D5             ;------------------------------------
1401   09D5             ; INPUT A CHARACTER FROM THE TERMINAL
1402   09D5             ;------------------------------------
1403   09D5 DD 2A AC FF INCH:  LD   IX,(GETCH)
1404   09D9 DD E9             JP   (IX)
1405   09DB             
1406   09DB             
1407   09DB             
1408   09DB             ;------------------------
1409   09DB             ; SERIAL TRANSMIT ROUTINE
1410   09DB             ;------------------------
1411   09DB             ;TRANSMIT BYTE SERIALLY ON DOUT
1412   09DB             ;
1413   09DB             ; ENTRY : A = BYTE TO TRANSMIT
1414   09DB             ;  EXIT : NO REGISTERS MODIFIED
1415   09DB             ;
1416   09DB F5          TXDATA:	PUSH	AF
1417   09DC C5          	PUSH	BC
1418   09DD E5          	PUSH	HL
1419   09DE 2A C0 FF    	LD	HL,(BAUD)
1420   09E1 4F          	LD	C,A
1421   09E2             ;
1422   09E2             ; TRANSMIT START BIT
1423   09E2             ;
1424   09E2 AF          	XOR	A
1425   09E3 D3 C0       	OUT	(SERIAL_TX_PORT),A
1426   09E5 CD 33 0A    	CALL	BITIME
1427   09E8             ;
1428   09E8             ; TRANSMIT DATA
1429   09E8             ;
1430   09E8 06 08       	LD	B,08H
1431   09EA CB 09       	RRC	C
1432   09EC CB 09       NXTBIT:	RRC	C	;SHIFT BITS TO D6,
1433   09EE 79          	LD	A,C	;LSB FIRST AND OUTPUT
1434   09EF E6 40       	AND	40H	;THEM FOR ONE BIT TIME.
1435   09F1 D3 C0       	OUT	(SERIAL_TX_PORT),A
1436   09F3 CD 33 0A    	CALL	BITIME
1437   09F6 10 F4       	DJNZ	NXTBIT
1438   09F8             ;
1439   09F8             ; SEND STOP BITS
1440   09F8             ;
1441   09F8 3E 40       	LD	A,40H
1442   09FA D3 C0       	OUT	(SERIAL_TX_PORT),A
1443   09FC CD 33 0A    	CALL	BITIME
1444   09FF CD 33 0A    	CALL	BITIME
1445   0A02 E1          	POP	HL
1446   0A03 C1          	POP	BC
1447   0A04 F1          	POP	AF
1448   0A05 C9          	RET
1449   0A06             ;-----------------------
1450   0A06             ; SERIAL RECEIVE ROUTINE
1451   0A06             ;-----------------------
1452   0A06             ;RECEIVE SERIAL BYTE FROM DIN
1453   0A06             ;
1454   0A06             ; ENTRY : NONE
1455   0A06             ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
1456   0A06             ;
1457   0A06             ; REGISTERS MODIFIED A AND F
1458   0A06             ;
1459   0A06 C5          RXDATA:	PUSH	BC
1460   0A07 E5          	PUSH	HL
1461   0A08             ;
1462   0A08             ; WAIT FOR START BIT 
1463   0A08             ;
1464   0A08 DB C0       RXDAT1: IN	A,(SERIAL_RX_PORT)
1465   0A0A CB 7F       	    BIT	7,A
1466   0A0C 20 FA       	    JR	NZ,RXDAT1	;NO START BIT
1467   0A0E             ;
1468   0A0E             ; DETECTED START BIT
1469   0A0E             ;
1470   0A0E 2A C0 FF    	LD	HL,(BAUD)
1471   0A11 CB 3C       	SRL	H
1472   0A13 CB 1D       	RR	L 	;DELAY FOR HALF BIT TIME
1473   0A15 CD 33 0A    	CALL 	BITIME
1474   0A18 DB C0       	IN	A,(SERIAL_RX_PORT)
1475   0A1A CB 7F       	BIT	7,A
1476   0A1C 20 EA       	JR	NZ,RXDAT1	;START BIT NOT VALID
1477   0A1E             ;
1478   0A1E             ; DETECTED VALID START BIT,READ IN DATA
1479   0A1E             ;
1480   0A1E 06 08       	LD	B,08H
1481   0A20 2A C0 FF    RXDAT2:	LD	HL,(BAUD)
1482   0A23 CD 33 0A    	CALL	BITIME	;DELAY ONE BIT TIME
1483   0A26 DB C0       	IN	A,(SERIAL_RX_PORT)
1484   0A28 CB 17       	RL	A
1485   0A2A CB 19       	RR	C	;SHIFT BIT INTO DATA REG
1486   0A2C 10 F2       	DJNZ	RXDAT2
1487   0A2E 79          	LD	A,C
1488   0A2F B7          	OR	A	;CLEAR CARRY FLAG
1489   0A30 E1              POP	HL
1490   0A31 C1          	POP	BC
1491   0A32 C9          	RET
1492   0A33             ;---------------
1493   0A33             ; BIT TIME DELAY
1494   0A33             ;---------------
1495   0A33             ;DELAY FOR ONE SERIAL BIT TIME
1496   0A33             ;ENTRY : HL = DELAY TIME
1497   0A33             ; NO REGISTERS MODIFIED
1498   0A33             ;
1499   0A33 E5          BITIME:	PUSH	HL
1500   0A34 D5          	PUSH	DE
1501   0A35 11 01 00    	LD	DE,0001H
1502   0A38 ED 52       BITIM1:	SBC	HL,DE
1503   0A3A D2 38 0A    	JP	NC,BITIM1
1504   0A3D D1          	POP	DE
1505   0A3E E1          	POP	HL
1506   0A3F C9          	RET
1507   0A40             
1508   0A40             
1509   0A40             ;-----------------
1510   0A40             ; ONE SECOND DELAY
1511   0A40             ;-----------------
1512   0A40             ;
1513   0A40             ; ENTRY : NONE
1514   0A40             ; EXIT : FLAG REGISTER MODIFIED
1515   0A40             ;
1516   0A40 C5          DELONE:	PUSH	BC
1517   0A41 D5          	PUSH	DE
1518   0A42 E5          	PUSH	HL
1519   0A43 11 01 00    	LD	DE,0001H
1520   0A46 21 70 08    	LD	HL,0870H
1521   0A49 06 92       DELON1:	LD	B,92H
1522   0A4B 10 FE       DELON2:	DJNZ	DELON2	;INNER LOOP
1523   0A4D ED 52       	SBC	HL,DE
1524   0A4F D2 49 0A    	JP	NC,DELON1	;OUTER LOOP
1525   0A52 E1          	POP	HL
1526   0A53 D1          	POP	DE
1527   0A54 C1          	POP	BC
1528   0A55 C9          	RET
1529   0A56             
1530   0A56             
1531   0A56             
1532   0A56             
1533   0A56             
1534   0A56             
1535   0A56             
1536   0A56             ; **********************************************************************
1537   0A56             ; List devices found on the I2C bus
1538   0A56             ;
1539   0A56             ; Test each I2C device address and reports any that acknowledge
1540   0A56             
1541   0A56 11 80 0A    I2CLIST:       LD   DE,LISTMsg        ;Address of message string
1542   0A59 CD A4 0A                CALL StrOut         ;Output string
1543   0A5C 16 00                   LD   D,0            ;First I2C device address to test
1544   0A5E D5          LISTLOOP:      PUSH DE             ;Preserve DE
1545   0A5F 7A                      LD   A,D            ;Get device address to be tested
1546   0A60 CD 77 0A                CALL LISTTEST          ;Test if device is present
1547   0A63 D1                      POP  DE             ;Restore DE
1548   0A64 20 07                   JR   NZ,LISTNEXT       ;Skip if no acknowledge
1549   0A66 7A                      LD   A,D            ;Get address of device tested
1550   0A67 CD D3 0A                CALL HexOut         ;Output as two character hex 
1551   0A6A CD 9F 0A                CALL SpaceOut       ;Output space character
1552   0A6D 14          LISTNEXT:      INC  D              ;Get next write address
1553   0A6E 14                      INC  D
1554   0A6F 7A                      LD   A,D            ;Address of next device to test
1555   0A70 B7                      OR   A              ;Have we tested all addresses?
1556   0A71 20 EB                   JR   NZ,LISTLOOP       ;No, so loop again
1557   0A73 CD 9C 0A                CALL LineOut        ;Output new line
1558   0A76 C9                      RET
1559   0A77             
1560   0A77             ; Test if device at I2C address A acknowledges
1561   0A77             ;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
1562   0A77             ;   On exit:  Z flagged if device acknowledges
1563   0A77             ;             NZ flagged if devices does not acknowledge
1564   0A77 CD 14 0B    LISTTEST:      CALL I2C_Open       ;Open I2C device for write
1565   0A7A C0                      RET  NZ             ;Abort if failed to open
1566   0A7B CD 1B 0B                CALL I2C_Close      ;Close I2C device 
1567   0A7E AF                      XOR  A              ;Return with Z flagged
1568   0A7F C9                      RET
1569   0A80             
1570   0A80 493243206465LISTMsg:       .DB  "I2C device found at:",CR,0
1570   0A86 7669636520666F756E642061743A0D00
1571   0A96             
1572   0A96             
1573   0A96             
1574   0A96             
1575   0A96             
1576   0A96             
1577   0A96             
1578   0A96             
1579   0A96             
1580   0A96             
1581   0A96             
1582   0A96             
1583   0A96             
1584   0A96             ; Display test result
1585   0A96             ;   On entry: DE = Address of null terminated string
1586   0A96             ;             H = First value ($H)
1587   0A96             ;             L = Second value ($L)
1588   0A96             ;   On exit:  HL IX IY preserved
1589   0A96             Result:     
1590   0A96 C3 EB 0A                JP   String         ;Output result string to console
1591   0A99             
1592   0A99             
1593   0A99             ; Character output to console
1594   0A99             ;   On entry: A = Character to be output
1595   0A99             ;   On exit:  BC DE HL IX IY preserved
1596   0A99 C3 B1 0A    CharOut:    JP   API_Cout
1597   0A9C             
1598   0A9C             ; New line output to console
1599   0A9C             ;   On entry: No parameters required
1600   0A9C             ;   On exit:  BC DE HL IX IY preserved
1601   0A9C C3 BB 0A    LineOut:    JP   API_Lout
1602   0A9F             
1603   0A9F             ; Space character ouput to console
1604   0A9F             ;   On entry: No parameters required
1605   0A9F             ;   On exit:  BC DE HL IX IY preserved
1606   0A9F 3E 20       SpaceOut:   LD   A,$20
1607   0AA1 C3 B1 0A                JP   API_Cout
1608   0AA4             
1609   0AA4             ; String output to console
1610   0AA4             ;   On entry: DE = Address of string
1611   0AA4             ;   On exit:  BC DE HL IX IY preserved
1612   0AA4 C3 C7 0A    StrOut:     JP   API_Sout
1613   0AA7             
1614   0AA7             
1615   0AA7             ; Delay by DE milliseconds (approx)
1616   0AA7             ;   On entry: DE = Delay time in milliseconds
1617   0AA7             ;   On exit:  BC DE HL IX IY preserved
1618   0AA7 C5          API_Delay:  PUSH BC             ;Preserve registers
1619   0AA8 D5                      PUSH DE
1620   0AA9 E5                      PUSH HL
1621   0AAA CD 88 08                CALL delay
1622   0AAD E1                      POP  HL             ;Restore registers
1623   0AAE D1                      POP  DE
1624   0AAF C1                      POP  BC
1625   0AB0 C9                      RET
1626   0AB1             
1627   0AB1             
1628   0AB1             ; Character output to console device
1629   0AB1             ;   On entry: A = Character to be output
1630   0AB1             ;   On exit:  BC DE HL IX IY preserved
1631   0AB1 C5          API_Cout:   PUSH BC             ;Preserve registers
1632   0AB2 D5                      PUSH DE
1633   0AB3 E5                      PUSH HL
1634   0AB4 CD 08 00                CALL $0008
1635   0AB7 E1                      POP  HL             ;Restore registers
1636   0AB8 D1                      POP  DE
1637   0AB9 C1                      POP  BC
1638   0ABA C9                      RET
1639   0ABB             
1640   0ABB             
1641   0ABB             ; New line output to console device
1642   0ABB             ;   On entry: No parameters required
1643   0ABB             ;   On exit:  BC DE HL IX IY preserved
1644   0ABB C5          API_Lout:   PUSH BC             ;Preserve registers
1645   0ABC D5                      PUSH DE
1646   0ABD E5                      PUSH HL
1647   0ABE 3E 0D                   LD A, CR ; enter char
1648   0AC0 CD 08 00                CALL $0008
1649   0AC3 E1                      POP  HL             ;Restore registers
1650   0AC4 D1                      POP  DE
1651   0AC5 C1                      POP  BC
1652   0AC6 C9                      RET
1653   0AC7             
1654   0AC7             
1655   0AC7             ; String output to console device
1656   0AC7             ;   On entry: DE = Address of string
1657   0AC7             ;   On exit:  BC DE HL IX IY preserved
1658   0AC7 C5          API_Sout:   PUSH BC             ;Preserve registers
1659   0AC8 D5                      PUSH DE
1660   0AC9 E5                      PUSH HL
1661   0ACA 62                      LD H, D
1662   0ACB 6B                      LD L, E
1663   0ACC CD B3 09                CALL SNDLCDMSG
1664   0ACF E1                      POP  HL             ;Restore registers
1665   0AD0 D1                      POP  DE
1666   0AD1 C1                      POP  BC
1667   0AD2 C9                      RET
1668   0AD3             
1669   0AD3             
1670   0AD3             ; Hex byte output to console
1671   0AD3             ;   On entry: A = Byte to be output in hex
1672   0AD3             ;   On exit:  BC DE HL IX IY preserved
1673   0AD3 F5          HexOut:     PUSH AF             ;Preserve byte to be output
1674   0AD4 1F                      RRA                 ;Shift top nibble to
1675   0AD5 1F                      RRA                 ;  botom four bits..
1676   0AD6 1F                      RRA
1677   0AD7 1F                      RRA
1678   0AD8 E6 0F                   AND  $0F           ;Mask off unwanted bits
1679   0ADA CD E0 0A                CALL HexOutHex           ;Output hi nibble
1680   0ADD F1                      POP  AF             ;Restore byte to be output
1681   0ADE E6 0F                   AND  $0F           ;Mask off unwanted bits
1682   0AE0             ; Output nibble as ascii character
1683   0AE0 FE 0A       HexOutHex:       CP   $0A           ;Nibble > 10 ?
1684   0AE2 38 02                   JR   C,HexOutSkip        ;No, so skip
1685   0AE4 C6 07                   ADD  A,7            ;Yes, so add 7
1686   0AE6 C6 30       HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
1687   0AE8 C3 B1 0A                JP   API_Cout       ;Write character
1688   0AEB             
1689   0AEB             
1690   0AEB             ; Output string at DE with substitutions
1691   0AEB             ;   On entry: A = Address of device on I2C bus (write address)
1692   0AEB             ;             DE = Address of null terminated string
1693   0AEB             ;             H = Value to substitute for $H
1694   0AEB             ;             L = Value to substitute for $L
1695   0AEB             ;             B = Value to substitute for $B
1696   0AEB             ;   On exit:  DE = Address of next location after this string
1697   0AEB             ;             IX IY preserved
1698   0AEB 1A          String:     LD   A,(DE)         ;Get character from string
1699   0AEC 13                      INC  DE             ;Point to next character in string
1700   0AED B7                      OR   A              ;Null ?
1701   0AEE C8                      RET  Z              ;Yes, so we're done
1702   0AEF FE 24                   CP   '$'            ;Substitue value?
1703   0AF1 28 05                   JR   Z,StringSubst       ;Yes, so go handle substitution
1704   0AF3 CD 99 0A                CALL CharOut        ;Output character to console
1705   0AF6 18 F3                   JR   String         ;Go get next character from string
1706   0AF8 1A          StringSubst:     LD   A,(DE)         ;Get character from string
1707   0AF9 13                      INC  DE             ;Point to next character in string
1708   0AFA B7                      OR   A              ;Null ?
1709   0AFB C8                      RET  Z              ;Yes, so we're done
1710   0AFC FE 48                   CP   'H'            ;Register H
1711   0AFE 20 03                   JR   NZ,StringNotH       ;No, so skip
1712   0B00 7C                      LD   A,H            ;Get value 'H'
1713   0B01 18 0C                   JR   StringGotIt         ;Go output it in hex
1714   0B03 FE 4C       StringNotH:      CP   'L'            ;Register L
1715   0B05 20 03                   JR   NZ,StringNotL       ;No, so skip
1716   0B07 7D                      LD   A,L            ;Get value 'L'
1717   0B08 18 05                   JR   StringGotIt         ;Go output it in hex
1718   0B0A FE 42       StringNotL:      CP   'B'            ;Register B
1719   0B0C 20 04                   JR   NZ,StringNotB       ;No, so skip
1720   0B0E 78                      LD   A,B            ;Get value 'L'
1721   0B0F                         ;JR   @GotIt        ;Go output it in hex
1722   0B0F CD D3 0A    StringGotIt:     CALL HexOut         ;Output write address in hex
1723   0B12 18 D7       StringNotB:      JR   String         ;Go get next character from string
1724   0B14             
1725   0B14             
1726   0B14             ; **********************************************************************
1727   0B14             ; I2C support functions
1728   0B14             
1729   0B14             ; I2C bus open device
1730   0B14             ;   On entry: A = Device address (bit zero is read flag)
1731   0B14             ;             SCL = unknown, SDA = unknown
1732   0B14             ;   On exit:  If successfully A = 0 and Z flagged
1733   0B14             ;             If unsuccessfully A = Error and NZ flagged
1734   0B14             ;             BC DE HL IX IY preserved
1735   0B14 F5          I2C_Open:   PUSH AF
1736   0B15 CD 88 0B                CALL I2C_Start      ;Output start condition
1737   0B18 F1                      POP  AF
1738   0B19 18 03                   JR   I2C_Write      ;Write data byte
1739   0B1B             
1740   0B1B             
1741   0B1B             ; I2C bus close device
1742   0B1B             ;   On entry: SCL = unknown, SDA = unknown
1743   0B1B             ;   On exit:  If successfully A=0 and Z flagged
1744   0B1B             ;             If unsuccessfully A=Error and NZ flagged
1745   0B1B             ;             SCL = hi, SDA = hi
1746   0B1B             ;             BC DE HL IX IY preserved
1747   0B1B C3 93 0B    I2C_Close:  JP   I2C_Stop       ;Output stop condition
1748   0B1E             
1749   0B1E             
1750   0B1E             ; **********************************************************************
1751   0B1E             ; **********************************************************************
1752   0B1E             ; I2C bus master driver
1753   0B1E             ; **********************************************************************
1754   0B1E             ; **********************************************************************
1755   0B1E             
1756   0B1E             ; Functions provided are:
1757   0B1E             ;     I2C_Start
1758   0B1E             ;     I2C_Stop
1759   0B1E             ;     I2C_Read
1760   0B1E             ;     I2C_Write
1761   0B1E             ;
1762   0B1E             ; This code has delays between all I/O operations to ensure it works
1763   0B1E             ; with the slowest I2C devices
1764   0B1E             ;
1765   0B1E             ; I2C transfer sequence
1766   0B1E             ;   +-------+  +---------+  +---------+     +---------+  +-------+
1767   0B1E             ;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
1768   0B1E             ;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
1769   0B1E             ;   +-------+  +---------+  +---------+     +---------+  +-------+
1770   0B1E             ;
1771   0B1E             ;
1772   0B1E             ; Start condition                     Stop condition
1773   0B1E             ; Output by master device             Output by master device
1774   0B1E             ;       ----+                                      +----
1775   0B1E             ; SDA       |                         SDA          |
1776   0B1E             ;           +-------                        -------+
1777   0B1E             ;       -------+                                +-------
1778   0B1E             ; SCL          |                      SCL       |
1779   0B1E             ;              +----                        ----+
1780   0B1E             ;
1781   0B1E             ;
1782   0B1E             ; Address frame
1783   0B1E             ; Clock and data output from master device
1784   0B1E             ; Receiving device outputs acknowledge 
1785   0B1E             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
1786   0B1E             ; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
1787   0B1E             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
1788   0B1E             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
1789   0B1E             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
1790   0B1E             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
1791   0B1E             ;
1792   0B1E             ;
1793   0B1E             ; Data frame 
1794   0B1E             ; Clock output by master device
1795   0B1E             ; Data output by transmitting device
1796   0B1E             ; Receiving device outputs acknowledge 
1797   0B1E             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
1798   0B1E             ; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
1799   0B1E             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
1800   0B1E             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
1801   0B1E             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
1802   0B1E             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
1803   0B1E             ;
1804   0B1E             
1805   0B1E             
1806   0B1E             ; **********************************************************************
1807   0B1E             ; I2C constants
1808   0B1E             
1809   0B1E             
1810   0B1E             ; I2C bus master interface
1811   0B1E             ; The default device option is for SC126 or compatible
1812   0B1E             
1813   0B1E             I2C_PORT:   .EQU $20           ;Host I2C port address
1814   0B1E             I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
1815   0B1E             I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
1816   0B1E             I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
1817   0B1E             I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
1818   0B1E             I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
1819   0B1E             
1820   0B1E             
1821   0B1E             ; I2C support constants
1822   0B1E             ERR_NONE:   .EQU 0              ;Error = None
1823   0B1E             ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
1824   0B1E             ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
1825   0B1E             ERR_TOUT:   .EQU 3              ;Error = Timeout
1826   0B1E             
1827   0B1E             
1828   0B1E             ; **********************************************************************
1829   0B1E             ; Hardware dependent I2C bus functions
1830   0B1E             
1831   0B1E             
1832   0B1E             ; I2C bus transmit frame (address or data)
1833   0B1E             ;   On entry: A = Data byte, or
1834   0B1E             ;                 Address byte (bit zero is read flag)
1835   0B1E             ;             SCL = low, SDA = low
1836   0B1E             ;   On exit:  If successful A=0 and Z flagged
1837   0B1E             ;                SCL = lo, SDA = lo
1838   0B1E             ;             If unsuccessful A=Error and NZ flagged
1839   0B1E             ;                SCL = high, SDA = high, I2C closed
1840   0B1E             ;             BC DE HL IX IY preserved
1841   0B1E C5          I2C_Write:  PUSH BC             ;Preserve registers
1842   0B1F D5                      PUSH DE
1843   0B20 57                      LD   D,A            ;Store byte to be written
1844   0B21 06 08                   LD   B,8            ;8 data bits, bit 7 first
1845   0B23 CB 12       I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
1846   0B25 38 05                   JR   C,I2C_WriteBit_Hi      ;High, so skip
1847   0B27 CD BA 0B                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
1848   0B2A 18 03                   JR   I2C_WriteBit_Clk
1849   0B2C CD B3 0B    I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
1850   0B2F CD A5 0B    I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
1851   0B32 CD AC 0B                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
1852   0B35 10 EC                   DJNZ I2C_WriteWr_Loop
1853   0B37             ; Test for acknowledge from slave (receiver)
1854   0B37             ; On arriving here, SCL = lo, SDA = data bit
1855   0B37 CD B3 0B                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
1856   0B3A CD A5 0B                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
1857   0B3D CD CB 0B                CALL I2C_RdPort     ;Read SDA input
1858   0B40 47                      LD   B,A
1859   0B41 CD AC 0B                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
1860   0B44 CB 78                   BIT  I2C_SDA_RD,B
1861   0B46 20 04                   JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
1862   0B48 D1                      POP  DE             ;Restore registers
1863   0B49 C1                      POP  BC
1864   0B4A AF                      XOR  A              ;Return success A=0 and Z flagged
1865   0B4B C9                      RET
1866   0B4C             ; I2C STOP required as no acknowledge
1867   0B4C             ; On arriving here, SCL = lo, SDA = hi
1868   0B4C CD BA 0B    I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
1869   0B4F CD A5 0B                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
1870   0B52 CD B3 0B                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
1871   0B55 D1                      POP  DE             ;Restore registers
1872   0B56 C1                      POP  BC
1873   0B57 3E 02                   LD   A,ERR_NOACK    ;Return error = No Acknowledge
1874   0B59 B7                      OR   A              ;  and NZ flagged
1875   0B5A C9                      RET
1876   0B5B             
1877   0B5B             
1878   0B5B             ; I2C bus receive frame (data)
1879   0B5B             ;   On entry: A = Acknowledge flag
1880   0B5B             ;               If A != 0 the read is acknowledged
1881   0B5B             ;             SCL low, SDA low
1882   0B5B             ;   On exit:  If successful A = data byte and Z flagged
1883   0B5B             ;               SCL = low, SDA = low
1884   0B5B             ;             If unsuccessul* A = Error and NZ flagged
1885   0B5B             ;               SCL = low, SDA = low
1886   0B5B             ;             BC DE HL IX IY preserved
1887   0B5B             ; *This function always returns successful
1888   0B5B C5          I2C_Read:   PUSH BC             ;Preserve registers
1889   0B5C D5                      PUSH DE
1890   0B5D 5F                      LD   E,A            ;Store acknowledge flag
1891   0B5E 06 08                   LD   B,8            ;8 data bits, 7 first
1892   0B60 CD B3 0B                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
1893   0B63 CD A5 0B    I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
1894   0B66 CD CB 0B                CALL I2C_RdPort     ;Read SDA input bit
1895   0B69 37                      SCF                 ;Set carry flag
1896   0B6A CB 7F                   BIT  I2C_SDA_RD,A   ;SDA input high?
1897   0B6C 20 01                   JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
1898   0B6E 3F                      CCF                 ;Clear carry flag
1899   0B6F CB 12       I2C_ReadRotate:    RL   D              ;Rotate result into D
1900   0B71 CD AC 0B                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
1901   0B74 10 ED                   DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
1902   0B76             ; Acknowledge input byte
1903   0B76             ; On arriving here, SCL = lo, SDA = hi/input
1904   0B76 7B                      LD   A,E            ;Get acknowledge flag
1905   0B77 B7                      OR   A              ;A = 0? (indicates no acknowledge)
1906   0B78 28 03                   JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
1907   0B7A CD BA 0B                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
1908   0B7D CD A5 0B    I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
1909   0B80 CD AC 0B                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
1910   0B83 7A                      LD   A,D            ;Get data byte received
1911   0B84 D1                      POP  DE             ;Restore registers
1912   0B85 C1                      POP  BC
1913   0B86 BF                      CP   A              ;Return success Z flagged
1914   0B87 C9                      RET
1915   0B88             
1916   0B88             
1917   0B88             ; I2C bus start
1918   0B88             ;   On entry: SCL = unknown, SDA = unknown
1919   0B88             ;   On exit:  SCL = low, SDA = low
1920   0B88             ;             A = 0 and Z flagged as we always succeed
1921   0B88             ;             BC DE HL IX IY preserved
1922   0B88             ; First ensure SDA and SCL are high
1923   0B88 CD A1 0B    I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
1924   0B8B             ;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
1925   0B8B             ;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
1926   0B8B             ; Generate I2C start condition
1927   0B8B CD BA 0B                CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
1928   0B8E CD AC 0B                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
1929   0B91 AF                      XOR  A              ;Return success A=0 and Z flagged
1930   0B92 C9                      RET
1931   0B93             
1932   0B93             
1933   0B93             ; I2C bus stop 
1934   0B93             ;   On entry: SCL = unknown, SDA = unknown
1935   0B93             ;   On exit:  SCL = high, SDA = high
1936   0B93             ;             A = 0 and Z flagged as we always succeed
1937   0B93             ;             BC DE HL IX IY preserved
1938   0B93             ; First ensure SDA and SCL are low
1939   0B93 CD BA 0B    I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
1940   0B96 CD AC 0B                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
1941   0B99             ; Generate stop condition
1942   0B99 CD A5 0B                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
1943   0B9C CD B3 0B                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
1944   0B9F AF                      XOR  A              ;Return success A=0 and Z flagged
1945   0BA0 C9                      RET
1946   0BA1             
1947   0BA1             
1948   0BA1             ; **********************************************************************
1949   0BA1             ; I2C bus simple I/O functions
1950   0BA1             ;   On entry: No parameters required
1951   0BA1             ;   On exit:  BC DE HL IX IY preserved
1952   0BA1             
1953   0BA1 3E 81       I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
1954   0BA3 18 1A                   JR   I2C_WrPort
1955   0BA5             
1956   0BA5 3A 00 D0    I2C_SCL_HI: LD   A,(I2C_RAMCPY)
1957   0BA8 CB C7                   SET  I2C_SCL_WR,A
1958   0BAA 18 13                   JR   I2C_WrPort
1959   0BAC             
1960   0BAC 3A 00 D0    I2C_SCL_LO: LD   A,(I2C_RAMCPY)
1961   0BAF CB 87                   RES  I2C_SCL_WR,A
1962   0BB1 18 0C                   JR   I2C_WrPort
1963   0BB3             
1964   0BB3 3A 00 D0    I2C_SDA_HI: LD   A,(I2C_RAMCPY)
1965   0BB6 CB FF                   SET  I2C_SDA_WR,A
1966   0BB8 18 05                   JR   I2C_WrPort
1967   0BBA             
1968   0BBA 3A 00 D0    I2C_SDA_LO: LD   A,(I2C_RAMCPY)
1969   0BBD CB BF                   RES  I2C_SDA_WR,A
1970   0BBF                         ;JR   I2C_WrPort
1971   0BBF             
1972   0BBF C5          I2C_WrPort: PUSH BC             ;Preserve registers
1973   0BC0 06 00                   LD   B,0            ;Set up BC for 16-bit
1974   0BC2 0E 20                   LD   C,I2C_PORT     ;  I/O address of I2C port
1975   0BC4 ED 79                   OUT  (C),A          ;Write A to I2C I/O port
1976   0BC6 32 00 D0                LD   (I2C_RAMCPY),A ;Write A to RAM copy
1977   0BC9 C1                      POP  BC             ;Restore registers
1978   0BCA C9                      RET
1979   0BCB             
1980   0BCB C5          I2C_RdPort: PUSH BC             ;Preserve registers
1981   0BCC 06 00                   LD   B,0            ;Set up BC for 16-bit
1982   0BCE 0E 20                   LD   C,I2C_PORT     ;  I/O address of I2C port
1983   0BD0 ED 78                   IN   A,(C)          ;Read A from I/O port
1984   0BD2 C1                      POP  BC             ;Restore registers
1985   0BD3 C9                      RET
1986   0BD4             
1987   0BD4             
1988   0BD4             
1989   0BD4 0C0D0D0A5A38WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
1989   0BDA 30204D696E6920496E69636961646F0D0A00
1990   0BEC 5A3830204D49MSG_MONITOR .db "Z80 MINI - Monitor v1",CR, 00H
1990   0BF2 4E49202D204D6F6E69746F722076310D00
1991   0C03 42202D204261MSG_MENU1 .db "B - Basic",CR, 00H
1991   0C09 7369630D00
1992   0C0E 49202D20496EMSG_MENU2 .db "I - Intel hex loader",CR, 00H
1992   0C14 74656C20686578206C6F616465720D00
1993   0C24 52202D205255MSG_MENU3 .db "R - RUN (JP $8000)",CR, 00H
1993   0C2A 4E20284A50202438303030290D00
1994   0C38 31202D204932MSG_MENU4 .db "1 - I2C Scan",CR, 00H
1994   0C3E 43205363616E0D00
1995   0C46             
1996   0C46 0C496E74656CMSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
1996   0C4C 20484558206C6F616465722E2E2E0D00
1997   0C5C 46494C452052FILEOK    .DB      "FILE RECEIVED OK",CR,00H
1997   0C62 45434549564544204F4B0D00
1998   0C6E 434845434B53CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
1998   0C74 554D204552524F520D00
1999   0C7E             
2000   0C7E             
2001   0C7E             
2002   0C7E             ; **********************************************************************
2003   0C7E             ; I2C workspace / variables in RAM
2004   0C7E             
2005   D000                         .ORG  I2CDATA
2006   D000             
2007   D000 00          I2C_RAMCPY: .DB  0              ;RAM copy of output port
2008   D001             
2009   D001 00          RESULTS:    .DB  0              ;Large block of results can start here
2010   D002             
2011   D002             .end
tasm: Number of errors = 0
