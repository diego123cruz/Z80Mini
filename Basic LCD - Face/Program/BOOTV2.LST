0001   0000             ; Diego Cruz - Nov 2022
0002   0000             ; 
0003   0000             ; bootV2: 
0004   0000             ;         - CPU Z80@4Mhz
0005   0000             ;         - Lcd Grafico 128x64
0006   0000             ;         - Keyboard 40 keys + Shift
0007   0000             ;         - Rom 32k 0000h - 7FFFh
0008   0000             ;         - Ram 32k 8000h - FFFFh
0009   0000             ;         
0010   0000             ;
0011   0000             ;         - Ports:
0012   0000             ;               - Keyboard: 40H
0013   0000             ;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
0014   0000             ;               - User IN/OUT: C0H
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------
0017   0000             LCDCTRL	    .EQU    70H
0018   0000             LCDDATA     .EQU    71H
0019   0000             KEY_IN      .EQU    40H
0020   0000             KEY_OUT     .EQU    40H
0021   0000             
0022   0000             CTRLC       .EQU    03H             ; Control "C"
0023   0000             CTRLG       .EQU    07H             ; Control "G"
0024   0000             BKSP        .EQU    08H             ; Back space
0025   0000             LF          .EQU    0AH             ; Line feed
0026   0000             VT          .equ    0BH             ; 
0027   0000             CS          .EQU    0CH             ; Clear screen
0028   0000             CR          .EQU    0DH             ; Carriage return [Enter]
0029   0000             CTRLO       .EQU    0FH             ; Control "O"
0030   0000             CTRLQ	    .EQU	11H		        ; Control "Q"
0031   0000             CTRLR       .EQU    12H             ; Control "R"
0032   0000             CTRLS       .EQU    13H             ; Control "S"
0033   0000             CTRLU       .EQU    15H             ; Control "U"
0034   0000             ESC         .EQU    1BH             ; Escape
0035   0000             DEL         .EQU    7FH             ; Delete
0036   0000             
0037   0000             KLEFT       .EQU    $B4             ; Key Left
0038   0000             KRIGHT      .EQU    $B7             ; Key Right
0039   0000             KUP         .EQU    $B5             ; Key Up
0040   0000             KDOWN       .EQU    $B6             ; Key Down
0041   0000             KF1         .EQU    $80             ; Key F1
0042   0000             KF2         .EQU    $81             ; Key F2
0043   0000             KF3         .EQU    $82             ; Key F3
0044   0000             KF4         .EQU    $83             ; Key F4
0045   0000             KF5         .EQU    $84             ; Key F5 (SHIFT)
0046   0000             KF6         .EQU    $85             ; Key F6 (SHIFT)
0047   0000             KF7         .EQU    $86             ; Key F7 (SHIFT)
0048   0000             KF8         .EQU    $87             ; Key F8 (SHIFT)
0049   0000             
0050   0000             kCPUClock:  .EQU 4000000       ;CPU clock speed in Hz
0051   0000             kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
0052   0000             kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
0053   0000             kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
0054   0000             kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
0055   0000             kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop
0056   0000             
0057   0000             BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
0058   0000             ;
0059   0000             ; BAUD RATE CONSTANTS
0060   0000             ;
0061   0000             B300:	.EQU	0220H	;300 BAUD
0062   0000             B1200:	.EQU	0080H	;1200 BAUD
0063   0000             B2400:	.EQU	003FH	;2400 BAUD
0064   0000             B4800:	.EQU	001BH	;4800 BAUD
0065   0000             B9600:	.EQU	000BH	;9600 BAUD
0066   0000             
0067   0000             SYSTEM:	.EQU 	0FD00H	;INITIAL STACK POINTER
0068   0000             I2CDATA .EQU    0D000H 
0069   0000             
0070   0000             I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
0071   0000             TIMEOUT:    .EQU 10000          ;Timeout loop counter
0072   0000             
0073   0000             ADDR:       .EQU 0FEB0H   ;THE ADDRESS  2 bytes
0074   0000             ADDR_FROM   .EQU 0FEB2H   ;THE ADDRESS FROM  2 bytes
0075   0000             ADDR_TO     .EQU 0FEB4H   ;THE ADDRESS TO 2 bytes
0076   0000             ADDR_SIZE   .EQU 0FEB6H   ;THE ADDRESS SIZE 2 bytes
0077   0000             DATA:       .EQU 0FEB8H   ;THE DATA
0078   0000             MSGBUF:     .EQU 0FE00H   ;STRING HANDLING AREA
0079   0000             
0080   0000             PORT_SET    .EQU 0FFB0H ; 1 byte - Define port (input/output) Default 0xC0(onboard)
0081   0000             PORT_OUT_VAL    .EQU 0FFB1H ; 1 byte - save value out port
0082   0000             LCD_DATA        .EQU 0FFB2H ; 1byte
0083   0000             
0084   0000             
0085   0000             BAUD:	 .EQU	0FFC0H	 ;BAUD RATE
0086   0000             PUTCH:   .EQU   0FFAAH   ;OUTPUT A CHARACTER TO SERIAL
0087   0000             GETCH:   .EQU   0FFACH   ;WAIT FOR A CHARACTER FROM SERIAL
0088   0000             
0089   0000             SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
0090   0000             SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
0091   0000             
0092   0000             
0093   0000             ; LCD TEXT MODE
0094   0000             LCD_LINE1   .EQU    80H
0095   0000             LCD_LINE2   .EQU    90H
0096   0000             LCD_LINE3   .EQU    88H
0097   0000             LCD_LINE4   .EQU    98H
0098   0000             
0099   0000             
0100   0000             ; RAM MAP
0101   0000             
0102   0000             
0103   0000             
0104   0000             LCD_CHAR            .EQU    $E000   ; 1 byte char ex: 'A'
0105   0000             LCD_CHAR_POINT      .EQU    $E001   ; 2 bytes ponteiro para o mapa de caracteres
0106   0000             LCD_TXT_X           .EQU    $E003   ; 1 byte  0-20 (21 col)
0107   0000             LCD_TXT_Y           .EQU    $E004   ; 1 byte  0-7  (8 row)
0108   0000             LCD_BYTE_INDEX      .EQU    $E005   ; 2 bytes pointer pixel(8)
0109   0000             LCD_BIT_INDEX       .EQU    $E007   ; 1 byte pointer pixel(1)
0110   0000             LCD_TXT_X_TMP       .EQU    $E008   ; 2 bytes = LCD_TXT_X * 6
0111   0000             LCD_TXT_Y_TMP       .EQU    $E00A   ; 2 bytes = LCD_TXT_Y * 128
0112   0000             LCD_CHAR_H          .EQU    $E00C   ; 1 byte altura do char
0113   0000             LCD_CHAR_W          .EQU    $E00D   ; 1 byte largura do char
0114   0000             LCD_TMP_POINT       .EQU    $E00E   ; 2 bytes ponteiro do pixel altural do print
0115   0000             LCD_DELETE_CHAR     .EQU    $E00F   ; 1 byte, 0 n√£o, ff delete proximo char
0116   0000             LCD_AUTO_X          .EQU    $E010   ; 1 byte, 0 sim, ff nao
0117   0000             
0118   0000             DISPLAY             .EQU    $E500
0119   0000             
0120   0000             LCD_TEMP        .EQU    $E110
0121   0000             LCD_COOX        .EQU    $E102 ; 1 byte, local onde vai printar
0122   0000             LCD_COOY        .EQU    $E103 ; 1 byte
0123   0000             LCD_PRINT_H     .EQU    $E104 ; 1 byte, tamanho do que vai printar
0124   0000             LCD_PRINT_W     .EQU    $E105 ; 1 byte
0125   0000             LCD_PRINT_IMAGE .EQU    $E106 ; 2 bytes
0126   0000             
0127   0000             
0128   0000                     .ORG 0
0129   0000 F3          RST00	DI
0130   0001 C3 93 04            JP  INICIO
0131   0004             						
0132   0008                     .ORG     0008H
0133   0008 C3 CE 08    RST08   JP  PRINTCHAR
0134   000B             
0135   0010                     .ORG 0010H
0136   0010 C3 FF 0B    RST10   JP KEYREADINIT
0137   0013             
0138   0018                     .ORG 0018H ; check break
0139   0018 C3 EA 0B    RST18   JP CHKKEY
0140   001B             
0141   0030                     .ORG 0030H
0142   0030 C3 2E 05    RST30   JP APIHandler
0143   0033             
0144   0033             
0145   0033             KEYMAP:
0146   0033 313233343580.BYTE   "12345",KF1,"67890"
0146   0039 3637383930
0147   003E 815157455254.BYTE   KF2,"QWERT",KF3,"YUIOP"
0147   0044 825955494F50
0148   004A 834153444647.BYTE   KF4,"ASDFG",KLEFT,"HJKL", CR
0148   0050 B4484A4B4C0D
0149   0056 B6035A584356.BYTE   KDOWN,CTRLC, "ZXCV",KRIGHT,"BNM ", DEL, KUP
0149   005C B7424E4D207FB5
0150   0063             
0151   0063             SHIFTKEYMAP:
0152   0063 214023242584.BYTE   "!@#$%",KF5,"^&*()"
0152   0069 5E262A2829
0153   006E 85607E2D5F3D.BYTE   KF6,"`~-_=",KF7,"+;:'" 
0153   0074 862B3B3A27
0154   0079 22          .BYTE 22h,
0155   007A 877B7D5B5D7C.BYTE   KF8,"{}[]|",KLEFT,$5C,"<>?", CR
0155   0080 B45C3C3E3F0D
0156   0086 B61B2F2C2E20.BYTE   KDOWN,ESC,"/,. ",KRIGHT,"    ", DEL, KUP
0156   008C B7202020207FB5
0157   0093             
0158   0093             
0159   0093             
0160   0093             
0161   0093             TABLE:
0162   0093 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
0162   0099 0000
0163   009B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
0163   00A1 0000
0164   00A3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
0164   00A9 0000
0165   00AB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
0165   00B1 0000
0166   00B3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
0166   00B9 0000
0167   00BB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
0167   00C1 0000
0168   00C3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
0168   00C9 0000
0169   00CB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
0169   00D1 0000
0170   00D3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
0170   00D9 0000
0171   00DB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
0171   00E1 0000
0172   00E3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0172   00E9 0000
0173   00EB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
0173   00F1 0000
0174   00F3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0174   00F9 0000
0175   00FB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
0175   0101 0000
0176   0103 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0176   0109 0000
0177   010B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
0177   0111 0000
0178   0113 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0178   0119 0000
0179   011B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
0179   0121 0000
0180   0123 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0180   0129 0000
0181   012B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
0181   0131 0000
0182   0133 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0182   0139 0000
0183   013B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
0183   0141 0000
0184   0143 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0184   0149 0000
0185   014B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
0185   0151 0000
0186   0153 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0186   0159 0000
0187   015B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
0187   0161 0000
0188   0163 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0188   0169 0000
0189   016B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
0189   0171 0000
0190   0173 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0190   0179 0000
0191   017B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
0191   0181 0000
0192   0183 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
0192   0189 0000
0193   018B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
0193   0191 0000
0194   0193             
0195   0193             ; DEC 32
0196   0193 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
0196   0199 0000
0197   019B 202020202000.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
0197   01A1 2000
0198   01A3 505050000000.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
0198   01A9 0000
0199   01AB 5050F850F850.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
0199   01B1 5000
0200   01B3 2078A07028F0.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
0200   01B9 2000
0201   01BB C0C810204098.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
0201   01C1 1800
0202   01C3 6090A040A890.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
0202   01C9 6800
0203   01CB 202020000000.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
0203   01D1 0000
0204   01D3 102040404020.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
0204   01D9 1000
0205   01DB 402010101020.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
0205   01E1 4000
0206   01E3 0020A870A820.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0206   01E9 0000
0207   01EB 002020F82020.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
0207   01F1 0000
0208   01F3 000000006020.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0208   01F9 4000
0209   01FB 000000F80000.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
0209   0201 0000
0210   0203 000000000060.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0210   0209 6000
0211   020B 000008102040.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
0211   0211 8000
0212   0213 708898A8C888.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0212   0219 7000
0213   021B 206020202020.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
0213   0221 7000
0214   0223 708808102040.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0214   0229 F800
0215   022B F81020100888.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
0215   0231 7000
0216   0233 10305090F810.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0216   0239 1000
0217   023B F880F0080888.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
0217   0241 7000
0218   0243 304080F08888.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0218   0249 7000
0219   024B F80810204040.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
0219   0251 4000
0220   0253 708888708888.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0220   0259 7000
0221   025B 708888780810.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
0221   0261 6000
0222   0263 000030300030.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0222   0269 3000
0223   026B 003030003010.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
0223   0271 2000
0224   0273 102040804020.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0224   0279 1000
0225   027B 0000F800F800.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
0225   0281 0000
0226   0283 402010081020.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
0226   0289 4000
0227   028B 304808102000.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
0227   0291 2000
0228   0293 70880868A8A8.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
0228   0299 7000
0229   029B             
0230   029B             ; DEC 65 Maiusculas
0231   029B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0231   02A1 8800
0232   02A3 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0232   02A9 F000
0233   02AB 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0233   02B1 7000
0234   02B3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0234   02B9 E000
0235   02BB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0235   02C1 F800
0236   02C3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0236   02C9 8000
0237   02CB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0237   02D1 7000
0238   02D3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0238   02D9 8800
0239   02DB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0239   02E1 7000
0240   02E3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0240   02E9 7000
0241   02EB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0241   02F1 8800
0242   02F3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0242   02F9 F800
0243   02FB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0243   0301 8800
0244   0303 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0244   0309 8800
0245   030B 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0245   0311 7000
0246   0313 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0246   0319 8000
0247   031B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0247   0321 7000
0248   0323 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0248   0329 8800
0249   032B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0249   0331 7000
0250   0333 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0250   0339 2000
0251   033B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0251   0341 7000
0252   0343 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0252   0349 2000
0253   034B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0253   0351 8800
0254   0353 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0254   0359 8800
0255   035B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0255   0361 2000
0256   0363 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0256   0369 F800
0257   036B             
0258   036B             ; DEC 91
0259   036B 302020202020.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
0259   0371 3000
0260   0373 008040201008.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0260   0379 0000
0261   037B 602020202020.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
0261   0381 6000
0262   0383 205088000000.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
0262   0389 0000
0263   038B 000000000000.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
0263   0391 F800
0264   0393 402010000000.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
0264   0399 0000
0265   039B             
0266   039B             ; DEC 97 "Minusculas"
0267   039B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0267   03A1 8800
0268   03A3 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0268   03A9 F000
0269   03AB 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0269   03B1 7000
0270   03B3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0270   03B9 E000
0271   03BB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0271   03C1 F800
0272   03C3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0272   03C9 8000
0273   03CB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0273   03D1 7000
0274   03D3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0274   03D9 8800
0275   03DB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0275   03E1 7000
0276   03E3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0276   03E9 7000
0277   03EB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0277   03F1 8800
0278   03F3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0278   03F9 F800
0279   03FB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0279   0401 8800
0280   0403 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0280   0409 8800
0281   040B 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0281   0411 7000
0282   0413 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0282   0419 8000
0283   041B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0283   0421 7000
0284   0423 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0284   0429 8800
0285   042B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0285   0431 7000
0286   0433 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0286   0439 2000
0287   043B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0287   0441 7000
0288   0443 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0288   0449 2000
0289   044B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0289   0451 8800
0290   0453 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0290   0459 8800
0291   045B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0291   0461 2000
0292   0463 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0292   0469 F800
0293   046B             
0294   046B             ; DEC 123
0295   046B 102020402020.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0295   0471 1000
0296   0473 202020202020.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0296   0479 2000
0297   047B 402020102020.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0297   0481 4000
0298   0483 000050A00000.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0298   0489 0000
0299   048B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0299   0491 0000
0300   0493             
0301   0493             
0302   0493             
0303   0493             
0304   0493             
0305   0493             ; -----------------------------------------------------------------------------
0306   0493             ;   INICIO
0307   0493             ; -----------------------------------------------------------------------------
0308   0493             INICIO:
0309   0493 31 00 FD        LD  SP, SYSTEM
0310   0496             
0311   0496 3E 00           LD A, 0
0312   0498 32 B1 FF        LD (PORT_OUT_VAL), A
0313   049B             
0314   049B 3E C0           LD A, $c0
0315   049D 32 B0 FF        LD (PORT_SET), A
0316   04A0             
0317   04A0                 ; init serial
0318   04A0 CD 98 0D        CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0319   04A3 21 33 0D        LD    HL,TXDATA
0320   04A6 22 AA FF        LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0321   04A9 21 5E 0D        LD    HL,RXDATA
0322   04AC 22 AC FF        LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
0323   04AF                 
0324   04AF 21 1B 00        LD	HL,B4800
0325   04B2 22 C0 FF    	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
0326   04B5             
0327   04B5 3E FF           LD A, $FF
0328   04B7 D3 C0           OUT (SERIAL_TX_PORT), A
0329   04B9             
0330   04B9 21 81 0F        LD HL, WELLCOME
0331   04BC CD 19 0D        CALL SNDMSG
0332   04BF             
0333   04BF                 ; CALL INCH
0334   04BF                 ; CALL OUTCH
0335   04BF             
0336   04BF                 ; Init LCD hardware
0337   04BF CD 4C 0A        CALL INIT_LCD
0338   04C2 CD DB 0B        call delay
0339   04C5             
0340   04C5 CD 64 0B        call cls_TXT
0341   04C8 CD DB 0B        call delay
0342   04CB             
0343   04CB CD EE 0A        CALL enable_grafic
0344   04CE CD DB 0B        call delay
0345   04D1             
0346   04D1 CD 6A 0B        call cls_GRAPHIC
0347   04D4 CD DB 0B        call delay
0348   04D7             
0349   04D7 CD E0 0A        call lcd_clear
0350   04DA             
0351   04DA 21 00 E5        ld hl, DISPLAY
0352   04DD CD 07 0B        call print_image
0353   04E0             
0354   04E0 CD DB 0B        call delay
0355   04E3             
0356   04E3                 ; Init LCD logical
0357   04E3 CD 3F 08        call INIT_TXT_LCD ; set cursor X Y to 0
0358   04E6             
0359   04E6 21 99 0F        LD HL, MSG_MONITOR
0360   04E9 CD 06 0D        CALL SNDLCDMSG
0361   04EC             
0362   04EC 3E 3E           LD A, '>'
0363   04EE CD CE 08        CALL PRINTCHAR
0364   04F1             
0365   04F1             KEY:
0366   04F1 CD FF 0B        CALL KEYREADINIT
0367   04F4             
0368   04F4 FE 48           CP 'H'
0369   04F6 CC 03 07        CALL Z, SHOWHELP
0370   04F9             
0371   04F9 FE 42           CP 'B'
0372   04FB CA 00 60        JP Z, BASIC
0373   04FE             
0374   04FE FE 49           CP 'I'
0375   0500 CA F7 06        JP Z, INTEL_HEX
0376   0503             
0377   0503 FE 31           CP '1'
0378   0505 CC AE 0D        CALL Z, I2CLIST
0379   0508             
0380   0508 FE 32           CP '2'
0381   050A CC 6C 06        CALL Z, I2CCPUTOMEM
0382   050D             
0383   050D FE 33           CP '3'
0384   050F CC 44 06        CALL Z, I2CMEMTOCPU
0385   0512             
0386   0512 FE 47           CP 'G'
0387   0514 CC 9B 07        CALL Z, GOJUMP
0388   0517             
0389   0517 FE 4D           CP 'M'
0390   0519 CC 39 07        CALL Z, MODIFY
0391   051C             
0392   051C FE 44           CP 'D'
0393   051E CC C6 05        CALL Z, DSPLAY
0394   0521             
0395   0521 3E 0D           LD A, CR 
0396   0523 CD CE 08        CALL PRINTCHAR
0397   0526             
0398   0526 3E 3E           LD A, '>' 
0399   0528 CD CE 08        CALL PRINTCHAR
0400   052B             
0401   052B C3 F1 04        JP  KEY
0402   052E             
0403   052E             
0404   052E             ; **********************************************************************
0405   052E             ; **  Public functions                                                **
0406   052E             ; **********************************************************************
0407   052E             ; API: Main entry point
0408   052E             ;   On entry: C = Function number
0409   052E             ;             A, DE = Parameters (as specified by function)
0410   052E             ;   On exit:  AF,BC,DE,HL = Return values (as specified by function)
0411   052E             ;             IX IY I AF' BC' DE' HL' preserved
0412   052E             ; This handler modifies: F, B, HL but preserves A, C, DE
0413   052E             ; Other registers depend on API function called
0414   052E 21 40 05    APIHandler: LD   HL,APITable    ;Start of function address table
0415   0531 47                      LD   B,A            ;Preserve A
0416   0532 79                      LD   A,C            ;Get function number
0417   0533 FE 14                   CP   kAPILast+1     ;Supported function?
0418   0535 D0                      RET  NC             ;No, so abort
0419   0536 78                      LD   A,B            ;Restore A
0420   0537 06 00                   LD   B,0
0421   0539 09                      ADD  HL,BC          ;Calculate table pointer..
0422   053A 09                      ADD  HL,BC
0423   053B 46                      LD   B,(HL)         ;Read function address from table..
0424   053C 23                      INC  HL
0425   053D 66                      LD   H,(HL)
0426   053E 68                      LD   L,B
0427   053F E9                      JP   (HL)           ;Jump to function address
0428   0540             
0429   0540             
0430   0540             ; API: Function address table
0431   0540             ; This table contains a list of addresses, one for each API function. 
0432   0540             ; Each is the address of the subroutine for the relevant function.
0433   0540 68 05       APITable:   .DW  SysReset           ; 0x00 = System reset
0434   0542 6B 05                   .DW  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
0435   0544 6E 05                   .DW  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
0436   0546 71 05                   .DW  OutLcdNewLine      ; 0x03 = Output new line LCD
0437   0548 B1 05                   .DW  H_Delay            ; 0x04 = Delay in milliseconds
0438   054A 76 05                   .DW  PrtSet             ; 0x05 = Set Port (Default C0)
0439   054C 7A 05                   .DW  PrtOWr             ; 0x06 = Write to output port
0440   054E 86 05                   .DW  PrtORd             ; 0x07 = Read from output port
0441   0550 8A 05                   .DW  PrtIRd             ; 0x08 = Read from input port
0442   0552 E0 08                   .DW  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
0443   0554 91 05                   .DW  DisplayImage128x64 ; 0x0A = Print image (Pointer in DE), 128x64, 1024 bytes
0444   0556 96 05                   .DW  ClearDisplayBuffer ; 0x0B = Clear display buffer and show to lcd
0445   0558 9F 05                   .DW  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
0446   055A 68 05                   .DW  SysReset           ; 0x0D = Reserved
0447   055C 68 05                   .DW  SysReset           ; 0x0E = Reserved
0448   055E 68 05                   .DW  SysReset           ; 0x0F = Reserved
0449   0560 A5 05                   .DW  I2COpen            ; 0x10 = Start i2c (Device address in A)
0450   0562 A8 05                   .DW  I2CClose           ; 0x11 = Close i2c 
0451   0564 AB 05                   .DW  I2CRead            ; 0x12 = I2C Read
0452   0566 AE 05                   .DW  I2CWrite           ; 0x13 = I2C Write
0453   0568             kAPILast:   .EQU $13                ;Last API function number
0454   0568             
0455   0568             
0456   0568             
0457   0568             
0458   0568             
0459   0568             
0460   0568             
0461   0568             SysReset:
0462   0568 C3 93 04        JP INICIO
0463   056B             
0464   056B             InputCharKey:
0465   056B C3 FF 0B        JP KEYREADINIT
0466   056E             
0467   056E             OutLcdChar:
0468   056E C3 CE 08        JP PRINTCHAR
0469   0571             
0470   0571             OutLcdNewLine:
0471   0571 3E 0D           LD A, CR
0472   0573 C3 CE 08        JP PRINTCHAR
0473   0576             
0474   0576             PrtSet:
0475   0576 32 B0 FF        LD (PORT_SET), A ; define a porta padr√£o de entrada e saida
0476   0579 C9              RET
0477   057A             
0478   057A             PrtOWr:
0479   057A 47              LD B, A
0480   057B 3A B0 FF        LD A, (PORT_SET)
0481   057E 4F              LD C, A
0482   057F 78              LD A, B
0483   0580 32 B1 FF        LD (PORT_OUT_VAL), A
0484   0583 ED 79           out (C), A
0485   0585 C9              RET
0486   0586             
0487   0586             PrtORd: ; Return value from output port
0488   0586 3A B1 FF        LD A, (PORT_OUT_VAL)
0489   0589 C9              RET
0490   058A             
0491   058A             PrtIRd: ; Return value from input
0492   058A 3A B0 FF        LD A, (PORT_SET)
0493   058D 4F              LD C, A
0494   058E ED 78           in A, (C)
0495   0590 C9              RET
0496   0591             
0497   0591             DisplayImage128x64:
0498   0591 62              LD H, D
0499   0592 6B              LD L, E
0500   0593 C3 07 0B        JP print_image
0501   0596             
0502   0596             ClearDisplayBuffer:
0503   0596 CD E0 0A        CALL lcd_clear
0504   0599 21 00 E5        LD HL, DISPLAY
0505   059C C3 07 0B        JP print_image
0506   059F             
0507   059F             ShowBufferDisplay:
0508   059F 21 00 E5        LD HL, DISPLAY
0509   05A2 C3 07 0B        JP print_image
0510   05A5             
0511   05A5             I2COpen:
0512   05A5 C3 C1 0E        JP I2C_Open
0513   05A8             
0514   05A8             I2CClose:
0515   05A8 C3 C8 0E        JP I2C_Close
0516   05AB             
0517   05AB             I2CRead:
0518   05AB C3 08 0F        JP I2C_Read
0519   05AE             
0520   05AE             I2CWrite:
0521   05AE C3 CB 0E        JP I2C_Write
0522   05B1             
0523   05B1             
0524   05B1             ; **********************************************************************
0525   05B1             ; Delay by DE milliseconds
0526   05B1             ;   On entry: DE = Delay time in milliseconds
0527   05B1             ;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
0528   05B1 F5          H_Delay:    PUSH AF
0529   05B2 C5                      PUSH BC
0530   05B3 D5                      PUSH DE
0531   05B4             ; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
0532   05B4 01 98 00    LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
0533   05B7             ; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
0534   05B7 0B          LoopBC:    DEC  BC             ;[6]     [4]
0535   05B8 79                      LD   A,C            ;[4]     [4]
0536   05B9 B0                      OR   B              ;[4]     [4]
0537   05BA C2 B7 05                JP   NZ,LoopBC     ;[12/7]  [8/6] 
0538   05BD             ; Have we looped once for each millisecond requested?
0539   05BD 1B                      DEC  DE             ;[6]     [4]
0540   05BE 7B                      LD   A,E            ;[4]     [4]
0541   05BF B2                      OR   D              ;[4]     [4]
0542   05C0 20 F2                   JR   NZ, LoopDE     ;[12/7]  [8/6]
0543   05C2 D1                      POP  DE
0544   05C3 C1                      POP  BC
0545   05C4 F1                      POP  AF
0546   05C5 C9                      RET
0547   05C6             
0548   05C6             ;--------------------------
0549   05C6             ; D DISPLAY MEMORY LOCATION
0550   05C6             ;--------------------------
0551   05C6 3E 44       DSPLAY: LD A, 'D'
0552   05C8 CD CE 08            CALL PRINTCHAR
0553   05CB CD C3 07            CALL  OUTSP       ;A SPACE
0554   05CE CD CF 07           CALL  GETCHR
0555   05D1 D8                 RET   C         
0556   05D2 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0557   05D5 CD CF 07           CALL  GETCHR
0558   05D8 D8                 RET   C
0559   05D9 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0560   05DC             ;
0561   05DC             ; WAIT FOR CR OR ESC
0562   05DC             ;
0563   05DC CD FF 0B    DPLAY1: CALL  KEYREADINIT
0564   05DF FE 1B              CP    ESC
0565   05E1 C8                 RET   Z
0566   05E2 FE 0D              CP    CR
0567   05E4 20 F6              JR    NZ,DPLAY1          
0568   05E6 CD C9 07           CALL  TXCRLF      ;NEWLINE
0569   05E9             ;
0570   05E9             ; DISPLAY THE LINE
0571   05E9             ;
0572   05E9 CD FE 05    DPLAY2: CALL  DPLINE
0573   05EC ED 53 B0 FE        LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
0574   05F0             ;
0575   05F0             ; DISPLAY MORE LINES OR EXIT
0576   05F0             ;       
0577   05F0 CD FF 0B    DPLAY3: CALL  KEYREADINIT
0578   05F3 38 FB              JR    C,DPLAY3   
0579   05F5 FE 0D              CP    CR        ;ENTER DISPLAYS THE NEXT LINE
0580   05F7 28 F0              JR    Z,DPLAY2
0581   05F9 FE 1B              CP    ESC         ;ESC EXITS (SHIFT + C)
0582   05FB 20 F3              JR    NZ,DPLAY3     
0583   05FD C9                 RET   
0584   05FE             ;-------------------------
0585   05FE             ; DISPLAY A LINE OF MEMORY
0586   05FE             ;-------------------------      
0587   05FE ED 5B B0 FE DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
0588   0602 21 00 FE           LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
0589   0605             ;
0590   0605             ; DISPLAY THE ADDRESS
0591   0605             ;         
0592   0605 CD 26 08           CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
0593   0608 CD 3E 06           CALL  SPCBUF        
0594   060B             ;
0595   060B             ; DISPLAY 4 BYTES
0596   060B             ;
0597   060B 06 04              LD    B,4 ;16
0598   060D 1A          DLINE1: LD    A,(DE)
0599   060E CD 2B 08           CALL  BYTASC
0600   0611 CD 3E 06           CALL  SPCBUF
0601   0614 13                 INC   DE        
0602   0615 10 F6              DJNZ  DLINE1
0603   0617                    ;CALL  SPCBUF
0604   0617             ;
0605   0617             ; NOW DISPLAY THE ASCII CHARACTER
0606   0617             ; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
0607   0617             ; BE DIFFERENT BETWEEN THE TWO PASSES!
0608   0617             ;
0609   0617 ED 5B B0 FE        LD    DE,(ADDR)    
0610   061B 06 04              LD    B,4 ;16
0611   061D 1A          DLINE2: LD    A,(DE)   
0612   061E FE 20              CP    20H
0613   0620 38 07              JR    C,DOT
0614   0622 FE 7F              CP    7FH
0615   0624 30 03              JR    NC,DOT
0616   0626 C3 2B 06           JP    NDOT
0617   0629 3E 2E       DOT:    LD    A,'.'
0618   062B CD 40 06    NDOT:   CALL  INBUF
0619   062E 13                 INC   DE       
0620   062F 10 EC              DJNZ  DLINE2
0621   0631             ;         
0622   0631             ;TERMINATE AND DISPLAY STRING
0623   0631             ;       
0624   0631 CD 43 06           CALL  BCRLF
0625   0634 3E 00              LD    A,00H
0626   0636 77                 LD    (HL),A
0627   0637 21 00 FE           LD    HL,MSGBUF
0628   063A CD 06 0D           CALL  SNDLCDMSG
0629   063D C9                 RET
0630   063E             
0631   063E             
0632   063E             ;
0633   063E             ; PUT A SPACE IN THE BUFFER
0634   063E             ;
0635   063E 3E 08       SPCBUF: LD    A, 8 ;20H(32dec)
0636   0640 77          INBUF:  LD    (HL),A
0637   0641 23                 INC   HL
0638   0642 C9                 RET
0639   0643             ;
0640   0643             ; PUT A CR LF IN THE BUFFER
0641   0643             ;        
0642   0643             BCRLF:  ;LD    A,CR  
0643   0643                    ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
0644   0643 C9                 RET
0645   0644             
0646   0644             
0647   0644             
0648   0644             
0649   0644             
0650   0644             
0651   0644             I2CMEMTOCPU:
0652   0644                 ; Get parameters to copy a block from I2C memory to CPU memory
0653   0644             ;   On entry: DE = First address in I2C memory
0654   0644             ;             HL = First address in CPU memory
0655   0644             ;             BC = Number of bytes to be copied
0656   0644             ;             SCL = unknown, SDA = unknown
0657   0644             ;   On exit:  If successfully A = 0 and Z flagged
0658   0644             ;             If unsuccessfully A = Error and NZ flagged
0659   0644             ;             IX IY preserved
0660   0644             
0661   0644 21 CA 10        LD HL, MSG_MEM2CPU
0662   0647 CD 06 0D        CALL SNDLCDMSG
0663   064A             
0664   064A CD 94 06        CALL GET_FROM_TO_SIZE
0665   064D             
0666   064D             ;    DE = First address in I2C memory
0667   064D             ;    HL = First address in CPU memory
0668   064D             ;    BC = Number of bytes to be copied
0669   064D             
0670   064D ED 5B B2 FE     LD DE, (ADDR_FROM)
0671   0651 2A B4 FE        LD HL, (ADDR_TO)
0672   0654 ED 4B B6 FE     LD BC, (ADDR_SIZE)
0673   0658 CD D8 0D        CALL I2C_MemRd  
0674   065B             
0675   065B CA 65 06        JP Z, I2CMEMTOCPU_OK
0676   065E 21 1B 11        LD HL, MSG_COPYFAIL
0677   0661 CD 06 0D        CALL SNDLCDMSG
0678   0664 C9              RET
0679   0665             I2CMEMTOCPU_OK:
0680   0665 21 12 11        LD HL, MSG_COPYOK
0681   0668 CD 06 0D        CALL SNDLCDMSG
0682   066B C9              RET
0683   066C             
0684   066C             
0685   066C             I2CCPUTOMEM:
0686   066C             ; Get parameters to copy a block from CPU memory to I2C memory
0687   066C             ;   On entry: DE = First address in I2C memory
0688   066C             ;             HL = First address in CPU memory
0689   066C             ;             BC = Number of bytes to be copied
0690   066C             ;             SCL = unknown, SDA = unknown
0691   066C             ;   On exit:  If successfully A = 0 and Z flagged
0692   066C             ;             If unsuccessfully A = Error and NZ flagged
0693   066C             ;             IX IY preserved
0694   066C             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
0695   066C             ; pages.
0696   066C 21 E0 10        LD HL, MSG_CPU2MEM
0697   066F CD 06 0D        CALL SNDLCDMSG
0698   0672             
0699   0672 CD 94 06        CALL GET_FROM_TO_SIZE
0700   0675             
0701   0675             ;    DE = First address in I2C memory
0702   0675             ;    HL = First address in CPU memory
0703   0675             ;    BC = Number of bytes to be copied
0704   0675             
0705   0675 2A B2 FE        LD HL, (ADDR_FROM)
0706   0678 ED 5B B4 FE     LD DE, (ADDR_TO)
0707   067C ED 4B B6 FE     LD BC, (ADDR_SIZE)
0708   0680 CD 0D 0E        CALL I2C_MemWr
0709   0683                 
0710   0683 CA 8D 06        JP Z, I2CCPUTOMEM_OK
0711   0686 21 1B 11        LD HL, MSG_COPYFAIL
0712   0689 CD 06 0D        CALL SNDLCDMSG
0713   068C C9              RET
0714   068D             I2CCPUTOMEM_OK:
0715   068D 21 12 11        LD HL, MSG_COPYOK
0716   0690 CD 06 0D        CALL SNDLCDMSG
0717   0693 C9              RET
0718   0694             
0719   0694             
0720   0694             
0721   0694             
0722   0694             
0723   0694             
0724   0694             GET_FROM_TO_SIZE:
0725   0694                 ; FROM
0726   0694 21 F6 10        LD HL, MSG_FROM
0727   0697 CD 06 0D        CALL SNDLCDMSG
0728   069A                 ;
0729   069A                 ;GET THE ADDRESS  FROM
0730   069A                 ;
0731   069A CD CF 07        CALL  GETCHR 
0732   069D D8              RET   C        
0733   069E 32 B3 FE        LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
0734   06A1 CD CF 07        CALL  GETCHR
0735   06A4 D8              RET   C
0736   06A5 32 B2 FE        LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW
0737   06A8             
0738   06A8 CD FF 0B        CALL  KEYREADINIT
0739   06AB FE 1B           CP    ESC         ;ESC KEY?
0740   06AD C8              RET   Z
0741   06AE FE 0D           CP    CR
0742   06B0 28 08           JR Z, GET_FROM_TO_SIZE_TO
0743   06B2 3E 0D           LD A, CR
0744   06B4 CD CE 08        CALL PRINTCHAR
0745   06B7 C3 94 06        JP GET_FROM_TO_SIZE
0746   06BA             
0747   06BA             GET_FROM_TO_SIZE_TO:
0748   06BA                 ; TO
0749   06BA 21 FD 10        LD HL, MSG_TO
0750   06BD CD 06 0D        CALL SNDLCDMSG
0751   06C0                 ;
0752   06C0                 ;GET THE ADDRESS  TO
0753   06C0                 ;
0754   06C0 CD CF 07        CALL  GETCHR 
0755   06C3 D8              RET   C        
0756   06C4 32 B5 FE        LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
0757   06C7 CD CF 07        CALL  GETCHR
0758   06CA D8              RET   C
0759   06CB 32 B4 FE        LD    (ADDR_TO),A    ;SAVE ADDRESS LOW
0760   06CE             
0761   06CE CD FF 0B        CALL  KEYREADINIT
0762   06D1 FE 1B           CP    ESC         ;ESC KEY?
0763   06D3 C8              RET   Z
0764   06D4 FE 0D           CP    CR
0765   06D6 20 E2           JR NZ, GET_FROM_TO_SIZE_TO
0766   06D8             
0767   06D8             GET_FROM_TO_SIZE_SIZE:
0768   06D8                 ; SIZE
0769   06D8 21 03 11        LD HL, MSG_SIZE
0770   06DB CD 06 0D        CALL SNDLCDMSG
0771   06DE                 ;
0772   06DE                 ;GET THE SIZE
0773   06DE                 ;
0774   06DE CD CF 07        CALL  GETCHR 
0775   06E1 D8              RET   C        
0776   06E2 32 B7 FE        LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
0777   06E5 CD CF 07        CALL  GETCHR
0778   06E8 D8              RET   C
0779   06E9 32 B6 FE        LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW
0780   06EC             
0781   06EC CD FF 0B        CALL  KEYREADINIT
0782   06EF FE 1B           CP    ESC         ;ESC KEY?
0783   06F1 C8              RET   Z
0784   06F2 FE 0D           CP    CR
0785   06F4 20 E2           JR NZ, GET_FROM_TO_SIZE_SIZE
0786   06F6 C9              RET
0787   06F7             
0788   06F7             
0789   06F7             INTEL_HEX:
0790   06F7 CD 53 0C        CALL INTHEX
0791   06FA CD DB 0B        CALL delay
0792   06FD CD DB 0B        CALL delay
0793   0700 C3 93 04        JP INICIO
0794   0703             
0795   0703             SHOWHELP:
0796   0703 3E 0C           LD A, $0C ; limpar tela
0797   0705 CD CE 08        CALL PRINTCHAR
0798   0708             
0799   0708 21 AE 0F        LD HL, MSG_MENU1
0800   070B CD 06 0D        CALL SNDLCDMSG
0801   070E             
0802   070E 21 C4 0F        LD HL, MSG_MENU2
0803   0711 CD 06 0D        CALL SNDLCDMSG
0804   0714             
0805   0714 21 CF 0F        LD HL, MSG_MENU3
0806   0717 CD 06 0D        CALL SNDLCDMSG
0807   071A             
0808   071A 21 E1 0F        LD HL, MSG_MENU4
0809   071D CD 06 0D        CALL SNDLCDMSG
0810   0720             
0811   0720 21 F2 0F        LD HL, MSG_MENU5
0812   0723 CD 06 0D        CALL SNDLCDMSG
0813   0726             
0814   0726 21 02 10        LD HL, MSG_MENU6
0815   0729 CD 06 0D        CALL SNDLCDMSG
0816   072C             
0817   072C 21 10 10        LD HL, MSG_MENU7
0818   072F CD 06 0D        CALL SNDLCDMSG
0819   0732             
0820   0732 21 23 10        LD HL, MSG_MENU8
0821   0735 CD 06 0D        CALL SNDLCDMSG
0822   0738             
0823   0738 C9              RET
0824   0739             
0825   0739             
0826   0739             ;----------------------------
0827   0739             ; M DISPLAY AND MODIFY MEMORY
0828   0739             ;----------------------------
0829   0739 3E 4D       MODIFY: LD A, 'M'
0830   073B CD CE 08            CALL PRINTCHAR
0831   073E CD C3 07         CALL  OUTSP
0832   0741             ;
0833   0741             ;GET THE ADDRESS        
0834   0741             ;
0835   0741 CD CF 07           CALL  GETCHR 
0836   0744 D8                 RET   C        
0837   0745 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0838   0748 CD CF 07           CALL  GETCHR
0839   074B D8                 RET   C
0840   074C 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0841   074F             ;
0842   074F             ; DISPLAY ON A NEW LINE
0843   074F             ;       
0844   074F CD C9 07    MDIFY1: CALL  TXCRLF       
0845   0752 ED 5B B0 FE        LD    DE,(ADDR)    
0846   0756 21 00 FE           LD    HL,MSGBUF   
0847   0759 CD 26 08           CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
0848   075C 21 00 FE           LD    HL,MSGBUF
0849   075F CD 1A 08           CALL  WRDOUT      ;OUTPUT THE ADDRESS
0850   0762 CD C3 07           CALL  OUTSP    
0851   0765             ;      
0852   0765             ;GET THE DATA AT THE ADDRESS        
0853   0765             ;
0854   0765 2A B0 FE            LD   HL,(ADDR)       
0855   0768 7E                  LD   A,(HL)
0856   0769             ;
0857   0769             ; DISPLAY THE DATA
0858   0769             ;        
0859   0769 21 00 FE           LD    HL,MSGBUF
0860   076C CD 2B 08           CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
0861   076F 21 00 FE           LD    HL,MSGBUF
0862   0772 CD 1D 08           CALL  BYTOUT      ;OUTPUT THE BYTE
0863   0775 CD C3 07           CALL  OUTSP
0864   0778             ;
0865   0778             ; GET NEW DATA,EXIT OR CONTINUE
0866   0778             ;
0867   0778 CD CF 07           CALL  GETCHR
0868   077B D8                 RET   C
0869   077C 47                 LD    B,A         ;SAVE IT FOR LATER
0870   077D 2A B0 FE           LD    HL,(ADDR)
0871   0780 77                 LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
0872   0781 78                 LD    A,B
0873   0782 BE                 CP    (HL)
0874   0783 28 05              JR    Z,MDIFY2
0875   0785 3E 3F              LD    A,'?'
0876   0787 CD CE 08           CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
0877   078A             ;
0878   078A             ; INCREMENT THE ADDRESS
0879   078A             ;
0880   078A 23          MDIFY2: INC   HL
0881   078B 22 B0 FE           LD    (ADDR),HL
0882   078E C3 4F 07           JP    MDIFY1
0883   0791             
0884   0791             
0885   0791             
0886   0791             ;------------------------------
0887   0791             ; GO <ADDR>
0888   0791             ; TRANSFERS EXECUTION TO <ADDR>
0889   0791             ;------------------------------
0890   0791             GOJUMP_new:
0891   0791 3E 0D           LD A, CR
0892   0793 CD CE 08        CALL PRINTCHAR
0893   0796             
0894   0796 3E 3E           LD A, '>'
0895   0798 CD CE 08        CALL PRINTCHAR
0896   079B             
0897   079B 3E 47       GOJUMP: LD A, 'G'
0898   079D CD CE 08            CALL PRINTCHAR
0899   07A0 CD C3 07           CALL  OUTSP       
0900   07A3 CD CF 07           CALL  GETCHR      ;GET ADDRESS HIGH BYTE
0901   07A6 D8                 RET   C
0902   07A7 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0903   07AA CD CF 07           CALL  GETCHR      ;GET ADDRESS LOW BYTE
0904   07AD D8                 RET   C
0905   07AE 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0906   07B1             ;
0907   07B1             ; WAIT FOR A CR OR ESC
0908   07B1             ;       
0909   07B1 CD FF 0B    GOJMP1: CALL  KEYREADINIT
0910   07B4 FE 1B              CP    ESC         ;ESC KEY?
0911   07B6 C8                 RET   Z
0912   07B7 FE 0D              CP    CR
0913   07B9                    ;JR    NZ,GOJMP1
0914   07B9 20 D6              JR NZ, GOJUMP_new
0915   07BB CD C9 07           CALL  TXCRLF
0916   07BE E1                 POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
0917   07BF 2A B0 FE           LD    HL,(ADDR)
0918   07C2 E9                 JP    (HL)        ;GOOD LUCK WITH THAT!
0919   07C3             
0920   07C3             
0921   07C3             ;---------------
0922   07C3             ; OUTPUT A SPACE
0923   07C3             ;---------------
0924   07C3 3E 20       OUTSP:  LD    A, ' '
0925   07C5 CD CE 08           CALL  PRINTCHAR
0926   07C8 C9                 RET
0927   07C9             
0928   07C9             ;-------------      
0929   07C9             ; OUTPUT CRLF
0930   07C9             ;------------
0931   07C9 3E 0D       TXCRLF: LD   A,CR
0932   07CB CD CE 08           CALL PRINTCHAR   
0933   07CE C9                 RET
0934   07CF             
0935   07CF             ;-----------------------------
0936   07CF             ; GET A BYTE FROM THE TERMINAL
0937   07CF             ;-----------------------------
0938   07CF CD FF 0B    GETCHR: CALL KEYREADINIT ; read key
0939   07D2 FE 1B              CP    ESC
0940   07D4 28 27              JR    Z,GETOUT
0941   07D6 47                 LD    B,A                ;SAVE TO ECHO      
0942   07D7 CD FF 07           CALL  ASC2HEX
0943   07DA 30 F3              JR    NC,GETCHR          ;REJECT NON HEX CHARS    
0944   07DC 21 B8 FE           LD    HL,DATA
0945   07DF 77                 LD    (HL),A 
0946   07E0 78                 LD    A,B         
0947   07E1 CD CE 08           CALL  PRINTCHAR             ;ECHO VALID HEX
0948   07E4                    
0949   07E4 CD FF 0B    GETNYB: CALL  KEYREADINIT
0950   07E7 FE 1B              CP    ESC
0951   07E9 28 12              JR    Z,GETOUT
0952   07EB 47                 LD    B,A               ;SAVE TO ECHO
0953   07EC CD FF 07           CALL  ASC2HEX
0954   07EF 30 F3              JR    NC,GETNYB         ;REJECT NON HEX CHARS
0955   07F1 ED 6F              RLD
0956   07F3 78                 LD    A,B
0957   07F4 CD CE 08           CALL  PRINTCHAR             ;ECHO VALID HEX
0958   07F7 7E                 LD    A,(HL)
0959   07F8 CD FD 07           CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
0960   07FB 3F                 CCF                    ;AND THEN COMPLEMENTING IT
0961   07FC C9                 RET   
0962   07FD 37          GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
0963   07FE C9                 RET
0964   07FF             
0965   07FF             
0966   07FF             ;----------------------------------------
0967   07FF             ; CONVERT ASCII CHARACTER INTO HEX NYBBLE
0968   07FF             ;----------------------------------------
0969   07FF             ; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
0970   07FF             ; ENTRY OTHER THAN HEXADECIMAL KEYS
0971   07FF             ;
0972   07FF             ;CONVERTS ASCII 0-9,A-F INTO HEX LSN
0973   07FF             ;ENTRY : A= ASCII 0-9,A-F
0974   07FF             ;EXIT  : CARRY =  1
0975   07FF             ;          A= HEX 0-F IN LSN    
0976   07FF             ;      : CARRY = 0
0977   07FF             ;          A= OUT OF RANGE CHARACTER & 7FH
0978   07FF             ; A AND F REGISTERS MODIFIED
0979   07FF             ;
0980   07FF E6 7F       ASC2HEX: AND   7FH        ;STRIP OUT PARITY
0981   0801 FE 30              CP    30H
0982   0803 38 12              JR    C,AC2HEX3    ;LESS THAN 0
0983   0805 FE 3A              CP    3AH
0984   0807 30 02              JR    NC,AC2HEX2   ;MORE THAN 9
0985   0809 37          AC2HEX1: SCF               ;SET THE CARRY - IS HEX
0986   080A C9                 RET
0987   080B             ;     
0988   080B FE 41       AC2HEX2: CP    41H
0989   080D 38 08              JR    C,AC2HEX3    ;LESS THAN A
0990   080F FE 47              CP    47H
0991   0811 30 04              JR    NC,AC2HEX3   ;MORE THAN F
0992   0813 D6 07              SUB   07H        ;CONVERT TO NYBBLE
0993   0815 18 F2              JR    AC2HEX1  
0994   0817 E6 FF       AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
0995   0819 C9                 RET
0996   081A             
0997   081A             
0998   081A             ;----------------------     
0999   081A             ; SEND ASCII HEX VALUES        
1000   081A             ;----------------------
1001   081A             ;
1002   081A             ; OUTPUT THE 4 BYTE, WRDOUT
1003   081A             ; THE 2 BYTE, BYTOUT
1004   081A             ; OR THE SINGLE BYTE, NYBOUT
1005   081A             ; ASCII STRING AT HL TO THE SERIAL PORT
1006   081A             ;
1007   081A CD 1D 08    WRDOUT: CALL  BYTOUT
1008   081D CD 20 08    BYTOUT: CALL  NYBOUT
1009   0820 7E          NYBOUT: LD    A,(HL)
1010   0821 CD CE 08           CALL  PRINTCHAR
1011   0824 23                 INC   HL
1012   0825 C9                 RET       
1013   0826             ;----------------
1014   0826             ;CONVERT TO ASCII 
1015   0826             ;----------------
1016   0826             ;
1017   0826             ; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
1018   0826             ;
1019   0826             ;         ENTRY :  A = BINARY TO CONVERT
1020   0826             ;                  HL = CHARACTER BUFFER ADDRESS   
1021   0826             ;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
1022   0826             ;   
1023   0826             ;        MODIFIES : DE
1024   0826             
1025   0826 7A          WRDASC: LD    A,D         ;CONVERT AND
1026   0827 CD 2B 08           CALL  BYTASC      ;OUTPUT D
1027   082A 7B                 LD    A,E         ;THEN E
1028   082B             ;
1029   082B             ;CONVERT A BYTE TO ASCII 
1030   082B             ;
1031   082B F5          BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
1032   082C 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
1033   082D 0F                 RRCA
1034   082E 0F                 RRCA
1035   082F 0F                 RRCA
1036   0830 CD 34 08           CALL NYBASC       ;CALL NYBBLE CONVERTER 
1037   0833 F1                 POP AF            ;RESTORE LOW NYBBLE
1038   0834             
1039   0834             ;           
1040   0834             ; CONVERT A NYBBLE TO ASCII
1041   0834             ;
1042   0834 E6 0F       NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
1043   0836 C6 90              ADD   A,90H       ;CONVERT TO
1044   0838 27                 DAA               ;ASCII
1045   0839 CE 40              ADC   A,40H
1046   083B 27                 DAA
1047   083C             ;            
1048   083C             ; SAVE IN STRING
1049   083C             ;
1050   083C 77          INSBUF: LD    (HL),A
1051   083D 23                 INC   HL 
1052   083E C9                 RET 
1053   083F             
1054   083F             
1055   083F             
1056   083F             INIT_TXT_LCD:
1057   083F 3E 00           ld a, 0
1058   0841 32 03 E0        ld (LCD_TXT_X), a
1059   0844 32 04 E0        ld (LCD_TXT_Y), a
1060   0847 32 0F E0        ld (LCD_DELETE_CHAR), a
1061   084A 32 10 E0        ld (LCD_AUTO_X), a
1062   084D 21 00 00        ld hl, 0
1063   0850 22 08 E0        ld (LCD_TXT_X_TMP), hl
1064   0853 23              inc hl
1065   0854 22 0A E0        ld (LCD_TXT_Y_TMP), hl
1066   0857 C9              RET
1067   0858             
1068   0858             
1069   0858             DISPLAY_SCROLL_UP:
1070   0858                 ; cada linha tem 128 bytes
1071   0858                 ; temos 8 linhas
1072   0858                 ; total 1024 bytes
1073   0858             
1074   0858                 ; display lines 0 to 7
1075   0858                 ; move line 1 to 0
1076   0858 21 80 E5        ld hl, DISPLAY+128
1077   085B 11 00 E5        ld de, DISPLAY
1078   085E 01 7F 00        ld bc, 127
1079   0861 ED B0           ldir
1080   0863             
1081   0863                 ; move line 2 to 1
1082   0863 21 00 E6        ld hl, DISPLAY+256
1083   0866 11 80 E5        ld de, DISPLAY+128
1084   0869 01 7F 00        ld bc, 127
1085   086C ED B0           ldir
1086   086E             
1087   086E                 ; move line 3 to 2
1088   086E 21 80 E6        ld hl, DISPLAY+384
1089   0871 11 00 E6        ld de, DISPLAY+256
1090   0874 01 7F 00        ld bc, 127
1091   0877 ED B0           ldir
1092   0879             
1093   0879                 ; move line 4 to 3
1094   0879 21 00 E7        ld hl, DISPLAY+512
1095   087C 11 80 E6        ld de, DISPLAY+384
1096   087F 01 7F 00        ld bc, 127
1097   0882 ED B0           ldir
1098   0884             
1099   0884                 ; move line 5 to 4
1100   0884 21 80 E7        ld hl, DISPLAY+640
1101   0887 11 00 E7        ld de, DISPLAY+512
1102   088A 01 7F 00        ld bc, 127
1103   088D ED B0           ldir
1104   088F             
1105   088F                 ; move line 6 to 5
1106   088F 21 00 E8        ld hl, DISPLAY+768
1107   0892 11 80 E7        ld de, DISPLAY+640
1108   0895 01 7F 00        ld bc, 127
1109   0898 ED B0           ldir
1110   089A             
1111   089A                 ; move line 7 to 6
1112   089A 21 80 E8        ld hl, DISPLAY+896
1113   089D 11 00 E8        ld de, DISPLAY+768
1114   08A0 01 7F 00        ld bc, 127
1115   08A3 ED B0           ldir
1116   08A5             
1117   08A5                 ; clear line 7
1118   08A5                 ; 896 to 1024
1119   08A5 21 80 E8        ld hl, DISPLAY+896
1120   08A8 5D              ld e,l
1121   08A9 54              ld d,h
1122   08AA 13              inc de
1123   08AB 36 00           ld (hl), 0
1124   08AD 01 7F 00        ld bc, 127
1125   08B0 ED B0           ldir
1126   08B2             
1127   08B2 C9              RET
1128   08B3             
1129   08B3             DELETE_CHAR:
1130   08B3 E1              POP HL ; retorno do call
1131   08B4 3E 00           LD A, 0
1132   08B6 32 0F E0        LD (LCD_DELETE_CHAR), A
1133   08B9 3A 03 E0        LD A, (LCD_TXT_X)
1134   08BC 3D              DEC A
1135   08BD 32 03 E0        LD (LCD_TXT_X), A
1136   08C0             
1137   08C0 3E FF           LD A, $FF
1138   08C2 32 10 E0        LD (LCD_AUTO_X), A
1139   08C5             
1140   08C5 F1              POP AF
1141   08C6 3E 20           LD A, ' '
1142   08C8 32 00 E0        LD (LCD_CHAR), A
1143   08CB F5              PUSH AF
1144   08CC E5              PUSH HL ; call
1145   08CD C9              RET
1146   08CE             
1147   08CE             
1148   08CE             ; Print char in buffer and show to lcd
1149   08CE             ; char in A
1150   08CE             PRINTCHAR:
1151   08CE F5              PUSH AF
1152   08CF C5              PUSH BC
1153   08D0 D5              PUSH DE
1154   08D1 E5              PUSH HL
1155   08D2 CD E0 08        CALL PrintBufferChar
1156   08D5 21 00 E5        LD HL, DISPLAY
1157   08D8 CD 07 0B        CALL print_image
1158   08DB E1              POP HL
1159   08DC D1              POP DE
1160   08DD C1              POP BC
1161   08DE F1              POP AF
1162   08DF C9              RET
1163   08E0             
1164   08E0             
1165   08E0             ; Print char in buffer lcd (without show to lcd)
1166   08E0             ; char in A
1167   08E0             PrintBufferChar:
1168   08E0 32 00 E0        LD (LCD_CHAR), A ; save char to print
1169   08E3             
1170   08E3 F5              PUSH AF
1171   08E4 C5              PUSH BC
1172   08E5 D5              PUSH DE
1173   08E6 E5              PUSH HL
1174   08E7             
1175   08E7 F5              PUSH AF
1176   08E8 3E 00           LD A, $0
1177   08EA 32 10 E0        LD (LCD_AUTO_X), A
1178   08ED F1              POP AF
1179   08EE             
1180   08EE             
1181   08EE             ver_delete:
1182   08EE F5              PUSH AF
1183   08EF 3A 0F E0        LD A, (LCD_DELETE_CHAR)
1184   08F2 B7              or a
1185   08F3 FE FF           CP $FF
1186   08F5 CC B3 08        call z, DELETE_CHAR
1187   08F8 F1              POP AF
1188   08F9 B7              or a
1189   08FA FE 00           CP $0
1190   08FC 20 08           jr nz, ver_enter
1191   08FE 3E FF           LD A, $FF ; delete proximo char
1192   0900 32 0F E0        LD (LCD_DELETE_CHAR), A
1193   0903 C3 2B 0A        jp print_char_fim
1194   0906             
1195   0906                 ; Verificar Enter, clear, etc... SEM PERDER O reg. A
1196   0906             ver_enter:       
1197   0906             
1198   0906                             ; trata dados para o lcd
1199   0906 FE 0D                       CP      CR                     ; compara com ENTER
1200   0908 20 1A                       jr      nz, ver_limpa
1201   090A             
1202   090A 3E 00                       LD A,0
1203   090C 32 03 E0                    LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
1204   090F             
1205   090F 3A 04 E0                    LD A, (LCD_TXT_Y)
1206   0912 3C                          inc a
1207   0913 FE 08                       cp 8
1208   0915 C2 1E 09                    jp nz, ver_enter_incYOK
1209   0918                             
1210   0918 CD 58 08                    CALL DISPLAY_SCROLL_UP
1211   091B                             ;ld hl, DISPLAY
1212   091B                             ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1213   091B                             
1214   091B C3 2B 0A                    jp print_char_fim
1215   091E             
1216   091E             ver_enter_incYOK:
1217   091E 32 04 E0                    ld (LCD_TXT_Y), a
1218   0921 C3 2B 0A                    jp print_char_fim
1219   0924             
1220   0924             
1221   0924             ver_limpa:
1222   0924 FE 0C                       CP      $0C                     ; compara com limpar tela
1223   0926 20 0E                       jr      NZ, ver_line
1224   0928                             
1225   0928                             ;call    clear_lcd_screen
1226   0928                             ;call    show_lcd_screen
1227   0928 CD E0 0A                    call lcd_clear
1228   092B                             ;ld hl, DISPLAY
1229   092B                             ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1230   092B 3E 00                       LD A, 0
1231   092D 32 03 E0                    LD (LCD_TXT_X), A
1232   0930 32 04 E0                    LD (LCD_TXT_Y), A
1233   0933             
1234   0933 C3 2B 0A                    JP print_char_fim
1235   0936             
1236   0936             ver_line:
1237   0936 FE 0A                       CP      LF                     ; retorna come√ßo da linha
1238   0938 20 03                       jr      NZ, print_lcd      
1239   093A             
1240   093A                                 ;----- verificar se precisa add algo aqui
1241   093A                             ;call    shift_lcd_up
1242   093A                             ;call    show_lcd_screen
1243   093A C3 2B 0A                    JP print_char_fim
1244   093D             
1245   093D             print_lcd:
1246   093D                 ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
1247   093D 26 00           ld H, 0
1248   093F 6F              ld L, A
1249   0940 29              ADD HL, HL ; hl x 8
1250   0941 29              ADD HL, HL
1251   0942 29              ADD HL, HL
1252   0943             
1253   0943 54              LD D, H
1254   0944 5D              LD E, L
1255   0945 21 93 00        ld hl, TABLE
1256   0948 19              add hl, de
1257   0949 22 01 E0        ld (LCD_CHAR_POINT), HL ; table
1258   094C             
1259   094C             
1260   094C                 ; ajusta X
1261   094C 06 06           ld b, 6
1262   094E 3A 03 E0        ld a, (LCD_TXT_X)
1263   0951 B7              or A
1264   0952 CA 5C 09        jp z, ajustX
1265   0955 4F              ld c, a
1266   0956 CD 30 0A        call multiplication
1267   0959 C3 5F 09        jp ajustXOK
1268   095C                 
1269   095C             ajustX:
1270   095C 21 00 00        ld hl, 0
1271   095F             ajustXOK:
1272   095F 22 08 E0        ld (LCD_TXT_X_TMP), HL 
1273   0962             
1274   0962             
1275   0962             
1276   0962                 ; ajuste Y
1277   0962 16 04           ld d, 4
1278   0964 1E 00           ld e, 0 ; = 128x8 proxima linha
1279   0966 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1280   0969 3A 04 E0        ld a, (LCD_TXT_Y)
1281   096C B7              or a
1282   096D CA 7D 09        JP Z, multYfim
1283   0970 21 00 00        ld hl, 0
1284   0973 47              ld b, a
1285   0974             multY:
1286   0974 19              add hl, de
1287   0975 10 FD           DJNZ multY
1288   0977             
1289   0977 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1290   097A C3 83 09        jp multYfimok
1291   097D             
1292   097D             multYfim:
1293   097D 21 00 00        ld hl, 0
1294   0980 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1295   0983             
1296   0983             multYfimok:
1297   0983             
1298   0983 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1299   0986 ED 5B 08 E0     ld de, (LCD_TXT_X_TMP)
1300   098A             
1301   098A 19              add hl, de  ; hl tem pos do pix 0-8191
1302   098B             
1303   098B 22 0E E0        ld (LCD_TMP_POINT), hl
1304   098E             
1305   098E             
1306   098E 3E 08           ld a, 8 ; altura do caracter
1307   0990 32 0C E0        ld (LCD_CHAR_H), a
1308   0993             printchar_loopH:
1309   0993 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1310   0996 7E              ld a, (HL)
1311   0997 32 10 E1        ld (LCD_TEMP), a
1312   099A             
1313   099A 3E 06           ld a, 6 ; largura do caracter
1314   099C 32 0D E0        ld (LCD_CHAR_W), a
1315   099F             printchar_loopW:
1316   099F 3A 10 E1        ld a, (LCD_TEMP)
1317   09A2 E6 80           and 128
1318   09A4 FE 00           cp 0
1319   09A6 CA B2 09        jp z, printchar_loopWC
1320   09A9 2A 0E E0        ld hl, (LCD_TMP_POINT)
1321   09AC CD 6B 0A        call lcd_setPixel
1322   09AF C3 B8 09        JP printchar_loopWE
1323   09B2             
1324   09B2             printchar_loopWC:
1325   09B2 2A 0E E0        ld hl, (LCD_TMP_POINT)
1326   09B5 CD A4 0A        call lcd_clearPixel
1327   09B8             
1328   09B8             printchar_loopWE:
1329   09B8 3A 10 E1        ld a, (LCD_TEMP)
1330   09BB CB 27           sla a
1331   09BD 32 10 E1        ld (LCD_TEMP), a
1332   09C0                 
1333   09C0 2A 0E E0        ld hl, (LCD_TMP_POINT)
1334   09C3 23              inc hl
1335   09C4 22 0E E0        ld (LCD_TMP_POINT), hl
1336   09C7             
1337   09C7 3A 0D E0        ld a, (LCD_CHAR_W)
1338   09CA 3D              dec A
1339   09CB 32 0D E0        ld (LCD_CHAR_W), a
1340   09CE FE 00           cp 0
1341   09D0 C2 9F 09        JP NZ, printchar_loopW
1342   09D3             
1343   09D3             
1344   09D3 2A 0E E0        ld hl, (LCD_TMP_POINT)
1345   09D6 2B              dec hl
1346   09D7 2B              dec hl
1347   09D8 2B              dec hl
1348   09D9 2B              dec hl
1349   09DA 2B              dec hl
1350   09DB 2B              dec hl
1351   09DC             
1352   09DC 16 00           ld d, 0
1353   09DE 1E 80           ld e, 128
1354   09E0 19              add hl, de
1355   09E1 22 0E E0        ld (LCD_TMP_POINT), HL
1356   09E4             
1357   09E4 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1358   09E7 23              inc hl
1359   09E8 22 01 E0        ld (LCD_CHAR_POINT), hl
1360   09EB             
1361   09EB             
1362   09EB 3A 0C E0        ld a, (LCD_CHAR_H)
1363   09EE 3D              dec A
1364   09EF 32 0C E0        ld (LCD_CHAR_H), a
1365   09F2 FE 00           cp 0
1366   09F4 C2 93 09        jp NZ, printchar_loopH
1367   09F7             
1368   09F7                 ;ld hl, DISPLAY
1369   09F7                 ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1370   09F7             
1371   09F7             
1372   09F7                 ; check auto x
1373   09F7 3A 10 E0        LD A, (LCD_AUTO_X)
1374   09FA B7              OR A
1375   09FB FE FF           CP $FF
1376   09FD CA 2B 0A        JP Z, print_char_fim
1377   0A00             
1378   0A00                 ; increment X, Y
1379   0A00 3A 03 E0        ld a, (LCD_TXT_X)
1380   0A03 3C              inc a
1381   0A04 FE 15           cp 21
1382   0A06 C2 28 0A        jp nz, incXOK
1383   0A09 3E 00           ld a, 0
1384   0A0B 32 03 E0        ld (LCD_TXT_X), a
1385   0A0E 3A 04 E0        ld a, (LCD_TXT_Y)
1386   0A11 3C              inc a
1387   0A12 FE 08           cp 8
1388   0A14 C2 22 0A        jp nz, incYOK
1389   0A17 CD 58 08        CALL DISPLAY_SCROLL_UP
1390   0A1A                 ;ld hl, DISPLAY
1391   0A1A                 ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1392   0A1A 3E 00           ld a, 0
1393   0A1C 32 03 E0        ld (LCD_TXT_X), a
1394   0A1F C3 2B 0A        jp print_char_fim
1395   0A22             
1396   0A22             incYOK:
1397   0A22 32 04 E0        ld (LCD_TXT_Y), a
1398   0A25 C3 2B 0A        jp print_char_fim
1399   0A28             
1400   0A28             incXOK:
1401   0A28 32 03 E0        ld (LCD_TXT_X), a
1402   0A2B             
1403   0A2B             print_char_fim:
1404   0A2B                 ;ld hl, DISPLAY
1405   0A2B                 ;CALL print_image
1406   0A2B E1              POP HL
1407   0A2C D1              POP DE
1408   0A2D C1              POP BC
1409   0A2E F1              POP AF
1410   0A2F C9              RET
1411   0A30             ;-------- FIM PRINTCHAR ------------------
1412   0A30             
1413   0A30             
1414   0A30             
1415   0A30             ; ----------------------------------
1416   0A30             
1417   0A30             ; INPUT: THE VALUES IN REGISTER B EN C
1418   0A30             ; OUTPUT: HL = B * C
1419   0A30             ; CHANGES: AF,DE,HL,B
1420   0A30             ;
1421   0A30             multiplication:
1422   0A30 21 00 00    	LD HL,0
1423   0A33 78          	LD A,B
1424   0A34 B7          	OR A
1425   0A35 C8          	RET Z
1426   0A36 16 00       	LD D,0
1427   0A38 59          	LD E,C
1428   0A39 19          multiplicationLOOP:	ADD HL,DE
1429   0A3A 10 FD       	DJNZ multiplicationLOOP
1430   0A3C C9          	RET 
1431   0A3D             
1432   0A3D             ;-----------------------------------
1433   0A3D             
1434   0A3D             Div_HL_D:
1435   0A3D             ;Inputs:
1436   0A3D             ;   HL and D
1437   0A3D             ;Outputs:
1438   0A3D             ;   HL is the quotient (HL/D)
1439   0A3D             ;   A is the remainder
1440   0A3D             ;   B is 0
1441   0A3D             ;   C,D,E are preserved
1442   0A3D AF              xor a         ; Clear upper eight bits of AHL
1443   0A3E 06 10           ld b,16       ; Sixteen bits in dividend
1444   0A40             _loop:
1445   0A40 29              add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
1446   0A41 17              rla           ; This moves the upper bits of the dividend into A
1447   0A42 38 03           jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
1448   0A44 BA              cp d          ; Check if we can subtract the divisor
1449   0A45 38 02           jr c,_skip    ; Carry means A < D
1450   0A47             _overflow:
1451   0A47 92              sub d         ; Do subtraction for real this time
1452   0A48 2C              inc l         ; Set the next bit of the quotient (currently bit 0)
1453   0A49             _skip:
1454   0A49 10 F5           djnz _loop
1455   0A4B C9              ret
1456   0A4C             
1457   0A4C             
1458   0A4C             ; -----------------------------------------------------------------------------
1459   0A4C             ;   LCD DRIVER
1460   0A4C             ; -----------------------------------------------------------------------------
1461   0A4C             ; INIT_LCD - Inicia o lcd em mode texto
1462   0A4C             ; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
1463   0A4C             ; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
1464   0A4C             ; lcd_clear - Limpa buffer do lcd
1465   0A4C             ; enable_grafic - Coloca o LCD em modo grafico
1466   0A4C             ; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
1467   0A4C             ; cls_TXT - Limpa LCD mode text
1468   0A4C             ; cls_GRAPHIC - Limpa LCD modo grafico
1469   0A4C             
1470   0A4C             INIT_LCD:
1471   0A4C                 ;Initialisation
1472   0A4C 3E 30       	ld a, 30H
1473   0A4E CD 90 0B    	call lcd_send_command
1474   0A51             
1475   0A51 3E A0       	ld a, 0b00100000
1476   0A53 CD 90 0B    	call lcd_send_command
1477   0A56             
1478   0A56 3E 30       	ld a, 30H
1479   0A58 CD 90 0B    	call lcd_send_command
1480   0A5B             
1481   0A5B 3E 0C       	ld a, 0CH
1482   0A5D CD 90 0B    	call lcd_send_command
1483   0A60             
1484   0A60 3E 01       	ld a, 01H
1485   0A62 CD 9A 0B    	call lcd_send_command_clear ;; clear
1486   0A65             
1487   0A65 3E 02       	ld a, 02H
1488   0A67 CD 90 0B    	call lcd_send_command
1489   0A6A C9              RET
1490   0A6B             
1491   0A6B             
1492   0A6B             ; pixel index in HL
1493   0A6B             lcd_setPixel:
1494   0A6B E5              push hl
1495   0A6C C5              push bc
1496   0A6D D5              push de
1497   0A6E F5              push af
1498   0A6F AF              xor A
1499   0A70 32 07 E0        ld (LCD_BIT_INDEX), A
1500   0A73 32 05 E0        ld (LCD_BYTE_INDEX), A
1501   0A76             
1502   0A76 16 08           ld d, 8
1503   0A78 CD 3D 0A        call Div_HL_D
1504   0A7B 32 07 E0        ld (LCD_BIT_INDEX), A
1505   0A7E 22 05 E0        ld (LCD_BYTE_INDEX), HL
1506   0A81 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1507   0A85 21 00 E5        ld hl, DISPLAY
1508   0A88 09              add hl, bc
1509   0A89                 
1510   0A89 06 80           ld b, 128 ; 1000 0000
1511   0A8B 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1512   0A8E FE 00           cp 0
1513   0A90 CA 9C 0A        jp z, lcd_setPixel_fim
1514   0A93             lcd_setPixel_bit:
1515   0A93 CB 38           srl B
1516   0A95 3D              dec A
1517   0A96 CA 9C 0A        jp z, lcd_setPixel_fim
1518   0A99                 
1519   0A99 C3 93 0A        jp lcd_setPixel_bit
1520   0A9C             lcd_setPixel_fim
1521   0A9C 7E              ld a, (hl)
1522   0A9D B0              or b
1523   0A9E 77              ld (hl), a
1524   0A9F             
1525   0A9F F1              pop af
1526   0AA0 C1              pop bc
1527   0AA1 D1              pop de
1528   0AA2 E1              pop hl
1529   0AA3 C9              ret
1530   0AA4             
1531   0AA4             ;===============================
1532   0AA4             ; pixel index in HL
1533   0AA4             lcd_clearPixel:
1534   0AA4 E5              push hl
1535   0AA5 C5              push bc
1536   0AA6 D5              push de
1537   0AA7 F5              push af
1538   0AA8 AF              xor A
1539   0AA9 32 07 E0        ld (LCD_BIT_INDEX), A
1540   0AAC 32 05 E0        ld (LCD_BYTE_INDEX), A
1541   0AAF 16 08           ld d, 8
1542   0AB1 CD 3D 0A        call Div_HL_D
1543   0AB4 32 07 E0        ld (LCD_BIT_INDEX), A
1544   0AB7 22 05 E0        ld (LCD_BYTE_INDEX), HL
1545   0ABA ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1546   0ABE 21 00 E5        ld hl, DISPLAY
1547   0AC1 09              add hl, bc
1548   0AC2                 
1549   0AC2 06 80           ld b, 128 ; 1000 0000
1550   0AC4 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1551   0AC7 FE 00           cp 0
1552   0AC9 CA D5 0A        jp z, lcd_clearPixel_fim
1553   0ACC             lcd_clearPixel_bit:
1554   0ACC CB 38           srl B
1555   0ACE 3D              dec A
1556   0ACF CA D5 0A        jp z, lcd_clearPixel_fim
1557   0AD2                 
1558   0AD2 C3 CC 0A        jp lcd_clearPixel_bit
1559   0AD5             lcd_clearPixel_fim
1560   0AD5 78              ld a, b
1561   0AD6 2F              cpl     ; NOT B
1562   0AD7 47              ld b, a
1563   0AD8             
1564   0AD8 7E              ld a, (hl)
1565   0AD9 A0              and b
1566   0ADA 77              ld (hl), a
1567   0ADB             
1568   0ADB F1              pop af
1569   0ADC C1              pop bc
1570   0ADD D1              pop de
1571   0ADE E1              pop hl
1572   0ADF C9              ret
1573   0AE0             
1574   0AE0             
1575   0AE0             ;;--------------------------------------------------
1576   0AE0             lcd_clear:
1577   0AE0                 ;; HL = start address of block
1578   0AE0 21 00 E5        ld hl, DISPLAY
1579   0AE3             
1580   0AE3                 ;; DE = HL + 1
1581   0AE3 5D              ld e,l
1582   0AE4 54              ld d,h
1583   0AE5 13              inc de
1584   0AE6             
1585   0AE6                 ;; initialise first byte of block
1586   0AE6                 ;; with data byte (&00)
1587   0AE6 36 00           ld (hl), 0
1588   0AE8                     
1589   0AE8                 ;; BC = length of block in bytes
1590   0AE8                 ;; HL+BC-1 = end address of block
1591   0AE8             
1592   0AE8 01 00 04        ld bc, 1024
1593   0AEB             
1594   0AEB                 ;; fill memory
1595   0AEB ED B0           ldir
1596   0AED C9              ret
1597   0AEE             
1598   0AEE             
1599   0AEE             ;===================
1600   0AEE             
1601   0AEE             ; grafic mode - enable
1602   0AEE             enable_grafic:
1603   0AEE 3E 30       	ld a, 30H
1604   0AF0 CD 90 0B    	call lcd_send_command
1605   0AF3 CD C3 0B    	call delayLCD
1606   0AF6             	
1607   0AF6 3E 34       	ld a, 34H
1608   0AF8 CD 90 0B    	call lcd_send_command
1609   0AFB CD C3 0B    	call delayLCD
1610   0AFE             	
1611   0AFE 3E 36       	ld a, 36H
1612   0B00 CD 90 0B    	call lcd_send_command
1613   0B03 CD C3 0B    	call delayLCD
1614   0B06 C9              ret
1615   0B07             
1616   0B07             
1617   0B07             ;==========================
1618   0B07             
1619   0B07             print_image:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
1620   0B07             									; HL content the data address
1621   0B07 F5              push af
1622   0B08 D5          	push de
1623   0B09 C5          	push bc
1624   0B0A             
1625   0B0A             
1626   0B0A             ; premiere partie : X de 0 √† 127 / Y de 0 √† 32
1627   0B0A             
1628   0B0A 3E 20       	ld a,32
1629   0B0C 57          	ld d,a							; boucle Y
1630   0B0D 3E 00       	ld a,0
1631   0B0F 5F          	ld e,a
1632   0B10             	
1633   0B10             boucle_colonne:
1634   0B10 3E 80       		ld a,$80					; coordonn√©e Y (0)
1635   0B12 83          		add a,e
1636   0B13 CD 90 0B    		call lcd_send_command
1637   0B16             		
1638   0B16 3E 80       		ld a,$80					; coordonn√©e X (0)		
1639   0B18 CD 90 0B    		call lcd_send_command
1640   0B1B             		
1641   0B1B 3E 08       		ld a,8
1642   0B1D 47          		ld b,a						; boucle X
1643   0B1E             		
1644   0B1E             boucle_ligne:	
1645   0B1E 7E          			ld a,(hl)
1646   0B1F CD A4 0B    			call lcd_send_data
1647   0B22 23          			inc hl
1648   0B23 7E          			ld a,(hl)
1649   0B24 CD A4 0B    			call lcd_send_data		; auto-increment on screen address
1650   0B27 23          			inc hl
1651   0B28 05          			dec b
1652   0B29 AF          			XOR a
1653   0B2A B0          			OR b
1654   0B2B C2 1E 0B    			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
1655   0B2E             		
1656   0B2E 15          		dec d
1657   0B2F 1C          		inc e
1658   0B30 AF          		XOR a
1659   0B31 B2          		OR d
1660   0B32 C2 10 0B    		jp nz,boucle_colonne
1661   0B35             		
1662   0B35             
1663   0B35             ; seconde partie : X de 128 √† 255 / Y de 0 √† 32
1664   0B35             
1665   0B35 3E 20       	ld a,32
1666   0B37 57          	ld d,a							; boucle Y
1667   0B38 3E 00       	ld a,0
1668   0B3A 5F          	ld e,a
1669   0B3B             	
1670   0B3B             boucle_colonne2:
1671   0B3B 3E 80       		ld a,$80					; coordonn√©e Y (0)
1672   0B3D 83          		add a, e
1673   0B3E CD 90 0B    		call lcd_send_command
1674   0B41             		
1675   0B41 3E 88       		ld a,$88					; coordonn√©e X (8)		
1676   0B43 CD 90 0B    		call lcd_send_command
1677   0B46             		
1678   0B46 3E 08       		ld a,8
1679   0B48 47          		ld b,a						; boucle X
1680   0B49             		
1681   0B49             boucle_ligne2:	
1682   0B49 7E          			ld a,(hl)
1683   0B4A CD A4 0B    			call lcd_send_data
1684   0B4D 23          			inc hl
1685   0B4E 7E          			ld a,(hl)
1686   0B4F CD A4 0B    			call lcd_send_data		; auto-increment on screen address
1687   0B52 23          			inc hl
1688   0B53 05          			dec b
1689   0B54 AF          			XOR a
1690   0B55 B0          			OR b
1691   0B56 C2 49 0B    			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
1692   0B59             		
1693   0B59 15          		dec d
1694   0B5A 1C          		inc e
1695   0B5B AF          		XOR a
1696   0B5C B2          		OR d
1697   0B5D C2 3B 0B    		jp nz,boucle_colonne2
1698   0B60             
1699   0B60 C1          	pop bc
1700   0B61 D1          	pop de
1701   0B62 F1              pop af
1702   0B63             
1703   0B63 C9              ret
1704   0B64             
1705   0B64             
1706   0B64             
1707   0B64             ; ======================
1708   0B64             cls_TXT:
1709   0B64             	; # CLEAR DISPLAY IN TEXT MODE # 
1710   0B64 3E 01       	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
1711   0B66 CD 9A 0B    	call lcd_send_command_clear		; CLEAR DISPLAY	
1712   0B69 C9              ret
1713   0B6A             
1714   0B6A             ; ========================
1715   0B6A             
1716   0B6A             cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
1717   0B6A             					;	Graphic RAM (GDRAM) use :
1718   0B6A             					;	1. Set vertical address (Y) for GDRAM
1719   0B6A             					;	2. Set horizontal address (X) for GDRAM
1720   0B6A             					;	3. Write D15~D8 to GDRAM (first byte)
1721   0B6A             					;	4. Write D7~D0 to GDRAM (second byte)
1722   0B6A C5          	push bc
1723   0B6B D5          	push de
1724   0B6C             
1725   0B6C 1E 20       	ld e,$20						; e = 32 
1726   0B6E 16 00       	ld d,$0							; d = 0
1727   0B70             Boucle32X:
1728   0B70 7A          		ld a,d
1729   0B71 F6 80       		OR $80
1730   0B73 CD 90 0B    		call lcd_send_command
1731   0B76             		
1732   0B76 3E 80       		ld a,$80					; Set horizontal addressÔºàXÔºâ for GDRAM = 0 ($80)
1733   0B78 CD 90 0B    		call lcd_send_command
1734   0B7B             		
1735   0B7B AF          		xor a							 	
1736   0B7C 06 10       		ld b,$10							; b = 17
1737   0B7E             		
1738   0B7E             Boucle16X:	 
1739   0B7E CD A4 0B    			call lcd_send_data 			; Write D15„ÄúD8 to GDRAM (first byte)
1740   0B81 CD A4 0B    			call lcd_send_data 			; Write D7„ÄúD0 to GDRAM (second byte)
1741   0B84             											; Address counter will automatically increase by one for the next two-byte data												
1742   0B84 10 F8       			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
1743   0B86             		
1744   0B86 1D          		dec e 
1745   0B87 14          		inc d
1746   0B88 AF          		xor a							; a = 0
1747   0B89 B3          		or e
1748   0B8A C2 70 0B    		jp nz,Boucle32X
1749   0B8D             
1750   0B8D D1          	pop de
1751   0B8E C1          	pop bc
1752   0B8F             	
1753   0B8F C9              ret
1754   0B90             
1755   0B90             
1756   0B90             
1757   0B90             ;******************
1758   0B90             ;Send a command byte to the LCD
1759   0B90             ;Entry: A= command byte
1760   0B90             ;Exit: All preserved
1761   0B90             ;******************
1762   0B90             lcd_send_command:
1763   0B90 C5          	push bc				;Preserve
1764   0B91 0E 70       	ld c, LCDCTRL   	;Command port
1765   0B93             	
1766   0B93 CD C3 0B    	call delayLCD
1767   0B96             	
1768   0B96 ED 79       	out (c),a			;Send command
1769   0B98 C1          	pop bc				;Restore
1770   0B99 C9          	ret
1771   0B9A             
1772   0B9A             
1773   0B9A             ;******************
1774   0B9A             ;Send a command byte to the LCD
1775   0B9A             ;Entry: A= command byte
1776   0B9A             ;Exit: All preserved
1777   0B9A             ;******************
1778   0B9A             lcd_send_command_clear:
1779   0B9A C5          	push bc				;Preserve
1780   0B9B             	
1781   0B9B CD CD 0B    	call delayLCDclear
1782   0B9E             	
1783   0B9E 0E 70           ld c, LCDCTRL   	;Command port
1784   0BA0 ED 79       	out (c),a			;Send command
1785   0BA2 C1          	pop bc				;Restore
1786   0BA3 C9          	ret
1787   0BA4             	
1788   0BA4             ;******************
1789   0BA4             ;Send a data byte to the LCD
1790   0BA4             ;Entry: A= data byte
1791   0BA4             ;Exit: All preserved
1792   0BA4             ;******************
1793   0BA4             lcd_send_data:
1794   0BA4 C5          	push bc				;Preserve
1795   0BA5             	
1796   0BA5                 ;Busy wait
1797   0BA5 CD C3 0B    	call delayLCD
1798   0BA8             
1799   0BA8 0E 71       	ld c, LCDDATA	;Data port $71
1800   0BAA ED 79       	out (c),a			;Send data
1801   0BAC C1          	pop bc				;Restore
1802   0BAD C9          	ret
1803   0BAE             
1804   0BAE             
1805   0BAE             
1806   0BAE             
1807   0BAE             ;******************
1808   0BAE             ;Send an asciiz string to the LCD
1809   0BAE             ;Entry: HL=address of string
1810   0BAE             ;Exit: HL=address of ending zero of the string. All others preserved
1811   0BAE             ;******************
1812   0BAE             lcd_send_asciiz:
1813   0BAE F5          	push af
1814   0BAF C5          	push bc				;Preserve
1815   0BB0             lcd_asciiz_char_loop:
1816   0BB0 0E 70       	ld c, LCDCTRL   	;Command port
1817   0BB2             	
1818   0BB2             lcd_asciiz_wait_loop:	;Busy wait
1819   0BB2 CD C3 0B    	call delayLCD
1820   0BB5             	
1821   0BB5 7E          	ld a,(hl)			;Get character
1822   0BB6 A7          	and a				;Is it zero?
1823   0BB7 28 07       	jr z,lcd_asciiz_done	;If so, we're done
1824   0BB9             	
1825   0BB9 0E 71       	ld c, LCDDATA	;Data port
1826   0BBB ED 79       	out (c),a			;Send data
1827   0BBD 23          	inc hl				;Next char
1828   0BBE 18 F0       	jr lcd_asciiz_char_loop
1829   0BC0             	
1830   0BC0             lcd_asciiz_done:
1831   0BC0 C1          	pop bc				;Restore
1832   0BC1 F1          	pop af
1833   0BC2 C9          	ret
1834   0BC3             
1835   0BC3             ; =========================================================
1836   0BC3             ; Delay LCD
1837   0BC3             ; =========================================================
1838   0BC3             delayLCD:
1839   0BC3 00          	NOP
1840   0BC4 00          	NOP
1841   0BC5 00          	NOP
1842   0BC6 00          	NOP
1843   0BC7 00          	NOP
1844   0BC8 00          	NOP
1845   0BC9 00          	NOP
1846   0BCA 00          	NOP
1847   0BCB 00              NOP
1848   0BCC C9              ret
1849   0BCD             
1850   0BCD             delayLCDclear:
1851   0BCD 00          	NOP
1852   0BCE 00          	NOP
1853   0BCF 00          	NOP
1854   0BD0 00          	NOP
1855   0BD1 00          	NOP
1856   0BD2 00          	NOP
1857   0BD3 00          	NOP
1858   0BD4 00          	NOP
1859   0BD5 00          	NOP
1860   0BD6 00          	NOP
1861   0BD7 00          	NOP
1862   0BD8 00          	NOP
1863   0BD9 00              NOP
1864   0BDA C9              ret
1865   0BDB             
1866   0BDB             	
1867   0BDB             ; =========================================================
1868   0BDB             ; Delay
1869   0BDB             ; =========================================================
1870   0BDB             delay:
1871   0BDB C5          	push bc                       ; 2.75 us
1872   0BDC 06 01           ld b, 1                     ; 1.75 us
1873   0BDE             delay_loop_b:
1874   0BDE 0E FF       	ld c, 255                     ; 1.75 us
1875   0BE0             delay_loop:
1876   0BE0 0D          	dec c                         ; 1 us
1877   0BE1 C2 E0 0B        jp nz, delay_loop             ; true = 3 us, false 1.75 us
1878   0BE4 05              dec b                         ; 1 us
1879   0BE5 C2 DE 0B        jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
1880   0BE8 C1              pop bc                        ; 2.50 us
1881   0BE9 C9              ret   
1882   0BEA             
1883   0BEA             
1884   0BEA             ; Check break key
1885   0BEA 3E 40       CHKKEY: LD  A, $40
1886   0BEC D3 40       	OUT (KEY_OUT), A ; line 4
1887   0BEE DB 40       	IN  A, (KEY_IN)
1888   0BF0 FE 01       	CP  1
1889   0BF2 C2 FA 0B    	JP  NZ, GRET
1890   0BF5 3E 03       	LD  A, CTRLC
1891   0BF7 FE 00       	CP	0
1892   0BF9 C9          	RET
1893   0BFA             GRET:
1894   0BFA 3E 00       	LD  A, 0
1895   0BFC FE 00       	CP 0
1896   0BFE C9          	RET
1897   0BFF             
1898   0BFF             
1899   0BFF             
1900   0BFF             
1901   0BFF             ; -----------------------------------------------------------------------------
1902   0BFF             ;   KEYREAD - KEY In A
1903   0BFF             ; -----------------------------------------------------------------------------
1904   0BFF             KEYREADINIT:
1905   0BFF C5              PUSH    BC
1906   0C00 D5          	PUSH	DE
1907   0C01 E5          	PUSH    HL
1908   0C02 1E 00       	LD      E, 0                    ; E will be the last pressed key
1909   0C04             READKEY:        
1910   0C04 26 01           LD      H, 1                    ; H is the line register, start with second
1911   0C06 06 00       	LD      B, 0                    ; Count lines for later multiplication	
1912   0C08 16 00       	LD      D, 0                    ; DE will be the adress for mask
1913   0C0A             						
1914   0C0A             NEXTKEY:        
1915   0C0A 7C              LD      A, H						
1916   0C0B FE 00           CP      0                       ; All lines tried? 
1917   0C0D CA 48 0C        JP      Z, KEYOUT               ; Then check if there was a key pressed
1918   0C10 D3 40       	OUT     (KEY_OUT), A		    ; Put current line to register
1919   0C12 DB 40       	IN      A, (KEY_IN)		        ; Input Keys
1920   0C14 E6 3F       	AND     $3F                     ; only 6 bits
1921   0C16 CB 24       	SLA     H                       ; Next line
1922   0C18 04              INC     B
1923   0C19 FE 00           CP      0                       ; Was key zero?
1924   0C1B CA 0A 0C        JP      Z, NEXTKEY              ; Then try again with next lines
1925   0C1E 16 00           LD      D, 0                    ; In D will be the number of the key
1926   0C20             LOGARITHM:      
1927   0C20 14              INC     D	                    ; Add one per shift
1928   0C21 CB 3F           SRL     A                       ; Shift key right
1929   0C23 C2 20 0C        JP      NZ, LOGARITHM		    ; If not zero shift again
1930   0C26 15              DEC     D                       ; Was too much
1931   0C27 DB 40       	IN      A, (KEY_IN)
1932   0C29 E6 80           AND     $80                     ; Check if first bit set (shift key pressed)
1933   0C2B C2 34 0C        JP      NZ, LOADSHIFT		    ; Then jump to read with shift
1934   0C2E 7A              LD      A, D                    ; Put read key into accu
1935   0C2F C6 33           ADD     A, KEYMAP               ; Add base of key map array
1936   0C31 C3 37 0C        JP      ADDOFFSET               ; Jump to load key
1937   0C34             LOADSHIFT:
1938   0C34 7A              LD      A, D
1939   0C35 C6 63           ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
1940   0C37             ADDOFFSET:
1941   0C37 C6 06           ADD     A, 6                    ; Add 6 for every line
1942   0C39 10 FC           DJNZ    ADDOFFSET               ; Jump back (do while loop)
1943   0C3B D6 06       	SUB     6                       ; Since do while is one too much
1944   0C3D             TRANSKEY:
1945   0C3D A8              XOR     B                       ; Empty B
1946   0C3E 4F          	LD      C, A                    ; A will be address in BC
1947   0C3F 0A          	LD      A, (BC)	                ; Load key
1948   0C40 BB          	CP      E                       ; Same key?
1949   0C41 CA 04 0C    	JP      Z, READKEY              ; Then from beginning
1950   0C44 5F          	LD      E, A                    ; Otherwise save new key
1951   0C45 C3 04 0C    	JP      READKEY	                ; And restart
1952   0C48             KEYOUT:
1953   0C48 7B              LD      A, E
1954   0C49 1E 00           LD      E, 0                    ; empty it
1955   0C4B B7              OR      A	                    ; Was a key read?
1956   0C4C CA 04 0C        JP      Z, READKEY              ; If not restart
1957   0C4F E1              POP     HL
1958   0C50 D1              POP     DE
1959   0C51 C1              POP     BC
1960   0C52 C9              RET
1961   0C53             
1962   0C53             
1963   0C53             ;-----------------------
1964   0C53             ; RECEIVE INTEL HEX FILE
1965   0C53             ;-----------------------       
1966   0C53             INTHEX: 
1967   0C53 21 26 11           LD HL, MSG_ILOAD
1968   0C56 CD 06 0D           CALL  SNDLCDMSG
1969   0C59             
1970   0C59 21 26 11           LD HL, MSG_ILOAD
1971   0C5C CD 19 0D           CALL  SNDMSG
1972   0C5F                    
1973   0C5F             
1974   0C5F CD 7E 0C           CALL  INTELH
1975   0C62 20 0D              JR    NZ,ITHEX1      
1976   0C64             
1977   0C64 21 3C 11           LD    HL,FILEOK
1978   0C67 CD 06 0D           CALL  SNDLCDMSG   ;GOT FILE OK LCD
1979   0C6A 21 3C 11           LD    HL,FILEOK
1980   0C6D CD 19 0D           CALL  SNDMSG      ;GOT FILE OK Serial
1981   0C70                    
1982   0C70 C9                 RET
1983   0C71 21 4E 11    ITHEX1: LD    HL,CSUMERR
1984   0C74 CD 06 0D           CALL  SNDLCDMSG
1985   0C77             
1986   0C77 21 4E 11           LD    HL,CSUMERR
1987   0C7A CD 19 0D           CALL  SNDMSG      ;CHECKSUM ERROR
1988   0C7D                    
1989   0C7D C9                 RET  
1990   0C7E             
1991   0C7E             
1992   0C7E             
1993   0C7E             
1994   0C7E             
1995   0C7E             ;-----------------------
1996   0C7E             ; RECEIVE INTEL HEX FILE
1997   0C7E             ;-----------------------
1998   0C7E DD 21 00 FD INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
1999   0C82             ;
2000   0C82             ; WAIT FOR RECORD MARK
2001   0C82             ;
2002   0C82 AF          INTEL1:	XOR	A
2003   0C83 DD 77 03    	LD	(IX+3),A	;CLEAR CHECKSUM
2004   0C86 CD 5E 0D    	CALL	RXDATA	;WAIT FOR THE RECORD MARK
2005   0C89 FE 3A       	CP	':'	;TO BE TRANSMITTED
2006   0C8B 20 F5       	JR	NZ,INTEL1	;NOT RECORD MARK
2007   0C8D             ;
2008   0C8D             ; GET RECORD LENGTH
2009   0C8D             ;
2010   0C8D CD DA 0C    	CALL	GETBYT
2011   0C90 DD 77 00    	LD	(IX+0),A	;NUMBER OF DATA BYTES
2012   0C93             ;
2013   0C93             ; GET ADDRESS FIELD
2014   0C93             ;
2015   0C93 CD DA 0C    	CALL	GETBYT
2016   0C96 DD 77 02    	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
2017   0C99 CD DA 0C    	CALL	GETBYT
2018   0C9C DD 77 01    	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
2019   0C9F             ;
2020   0C9F             ; GET RECORD TYPE
2021   0C9F             ;
2022   0C9F CD DA 0C    	CALL	GETBYT
2023   0CA2 20 24       	JR	NZ,INTEL4	;END OF FILE RECORD
2024   0CA4             ;
2025   0CA4             ; READ IN THE DATA
2026   0CA4             ;
2027   0CA4 DD 46 00    	LD	B,(IX+0)	;NUMBER OF DATA BYTES
2028   0CA7 DD 66 02    	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
2029   0CAA DD 6E 01    	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
2030   0CAD             
2031   0CAD CD DA 0C    INTEL2:	CALL	GETBYT	;GET DATA BYTE
2032   0CB0 77          	LD	(HL),A	;STORE DATA BYTE
2033   0CB1 23          	INC	HL
2034   0CB2 10 F9       	DJNZ	INTEL2	;LOAD MORE BYTES
2035   0CB4             ;
2036   0CB4             ; GET CHECKSUM AND COMPARE
2037   0CB4             ;
2038   0CB4 DD 7E 03    	LD	A,(IX+3)	;CONVERT CHECKSUM TO
2039   0CB7 ED 44       	NEG		;TWO'S COMPLEMENT
2040   0CB9 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
2041   0CBC CD DA 0C    	CALL	GETBYT
2042   0CBF DD 77 03    	LD	(IX+3),A	;SAVE RECORD CHECKSUM
2043   0CC2 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
2044   0CC5 28 BB       	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
2045   0CC7 C9              RET             ;NZ=CHECKSUM ERROR
2046   0CC8             ;
2047   0CC8             ; END OF FILE RECORD
2048   0CC8             ;
2049   0CC8 DD 7E 03    INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
2050   0CCB ED 44       	NEG		;TWO'S COMPLEMENT
2051   0CCD DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
2052   0CD0 CD DA 0C    	CALL	GETBYT
2053   0CD3 DD 77 03    	LD	(IX+3),A	;SAVE EOF CHECKSUM
2054   0CD6 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
2055   0CD9 C9          	RET  	    ;NZ=CHECKSUM ERROR
2056   0CDA             ;--------------------------
2057   0CDA             ; GET BYTE FROM SERIAL PORT
2058   0CDA             ;--------------------------
2059   0CDA C5          GETBYT:	PUSH	BC
2060   0CDB CD 5E 0D    	CALL	RXDATA
2061   0CDE CB 77       	BIT	6,A
2062   0CE0 28 02       	JR	Z,GETBT1
2063   0CE2 C6 09       	ADD	A,09H
2064   0CE4 E6 0F       GETBT1:	AND	0FH
2065   0CE6 CB 27       	SLA 	A
2066   0CE8 CB 27       	SLA	A
2067   0CEA CB 27       	SLA	A
2068   0CEC CB 27       	SLA	A
2069   0CEE 4F          	LD	C,A
2070   0CEF             ;
2071   0CEF             ; GET LOW NYBBLE
2072   0CEF             ;
2073   0CEF CD 5E 0D    	CALL	RXDATA
2074   0CF2 CB 77       	BIT	6,A
2075   0CF4 28 02       	JR	Z,GETBT2
2076   0CF6 C6 09       	ADD	A,09H
2077   0CF8 E6 0F       GETBT2:	AND	0FH
2078   0CFA B1          	OR	C
2079   0CFB 47          	LD	B,A
2080   0CFC DD 86 03    	ADD	A,(IX+3)
2081   0CFF DD 77 03    	LD	(IX+3),A	;ADD TO CHECKSUM
2082   0D02 78          	LD	A,B
2083   0D03 A7          	AND	A	;CLEAR CARRY
2084   0D04 C1              POP	BC
2085   0D05 C9          	RET
2086   0D06             
2087   0D06             ;-----------------------------------------
2088   0D06             ; SEND AN ASCII STRING OUT LCD
2089   0D06             ;-----------------------------------------
2090   0D06             ; 
2091   0D06             ; SENDS A ZERO TERMINATED STRING OR 
2092   0D06             ; 128 CHARACTERS MAX. OUT LCD
2093   0D06             ;
2094   0D06             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2095   0D06             ;      EXIT  : NONE
2096   0D06             ;
2097   0D06             ;       MODIFIES : A,B,C
2098   0D06             ;          
2099   0D06 06 80       SNDLCDMSG: LD    B,128         ;128 CHARS MAX
2100   0D08 7E          SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
2101   0D09 FE 00              CP    00H          ;ZERO TERMINATOR?
2102   0D0B 28 06              JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2103   0D0D CD E0 08           CALL PrintBufferChar         ;TRANSMIT THE CHAR
2104   0D10 23                 INC   HL
2105   0D11 10 F5              DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
2106   0D13             SDLCDMSG2: 
2107   0D13 21 00 E5        LD HL, DISPLAY
2108   0D16 CD 07 0B        CALL print_image
2109   0D19             RET
2110   0D19             
2111   0D19             ;-----------------------------------------
2112   0D19             ; SEND AN ASCII STRING OUT THE SERIAL PORT
2113   0D19             ;-----------------------------------------
2114   0D19             ; 
2115   0D19             ; SENDS A ZERO TERMINATED STRING OR 
2116   0D19             ; 128 CHARACTERS MAX. OUT THE SERIAL PORT
2117   0D19             ;
2118   0D19             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2119   0D19             ;      EXIT  : NONE
2120   0D19             ;
2121   0D19             ;       MODIFIES : A,B,C
2122   0D19             ;          
2123   0D19 06 80       SNDMSG: LD    B,128         ;128 CHARS MAX
2124   0D1B 7E          SDMSG1: LD    A,(HL)        ;GET THE CHAR
2125   0D1C FE 00              CP    00H          ;ZERO TERMINATOR?
2126   0D1E 28 06              JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2127   0D20 CD 27 0D           CALL  OUTCH         ;TRANSMIT THE CHAR
2128   0D23 23                 INC   HL
2129   0D24 10 F5              DJNZ  SDMSG1        ;128 CHARS MAX!    
2130   0D26 C9          SDMSG2: RET
2131   0D27             
2132   0D27             
2133   0D27             
2134   0D27             ;-----------------------------------
2135   0D27             ; OUTPUT A CHARACTER TO THE TERMINAL
2136   0D27             ;-----------------------------------       
2137   0D27 DD 2A AA FF OUTCH:  LD   IX,(PUTCH)
2138   0D2B DD E9              JP   (IX)
2139   0D2D             ;------------------------------------
2140   0D2D             ; INPUT A CHARACTER FROM THE TERMINAL
2141   0D2D             ;------------------------------------
2142   0D2D DD 2A AC FF INCH:  LD   IX,(GETCH)
2143   0D31 DD E9             JP   (IX)
2144   0D33             
2145   0D33             
2146   0D33             
2147   0D33             ;------------------------
2148   0D33             ; SERIAL TRANSMIT ROUTINE
2149   0D33             ;------------------------
2150   0D33             ;TRANSMIT BYTE SERIALLY ON DOUT
2151   0D33             ;
2152   0D33             ; ENTRY : A = BYTE TO TRANSMIT
2153   0D33             ;  EXIT : NO REGISTERS MODIFIED
2154   0D33             ;
2155   0D33 F5          TXDATA:	PUSH	AF
2156   0D34 C5          	PUSH	BC
2157   0D35 E5          	PUSH	HL
2158   0D36 2A C0 FF    	LD	HL,(BAUD)
2159   0D39 4F          	LD	C,A
2160   0D3A             ;
2161   0D3A             ; TRANSMIT START BIT
2162   0D3A             ;
2163   0D3A AF          	XOR	A
2164   0D3B D3 C0       	OUT	(SERIAL_TX_PORT),A
2165   0D3D CD 8B 0D    	CALL	BITIME
2166   0D40             ;
2167   0D40             ; TRANSMIT DATA
2168   0D40             ;
2169   0D40 06 08       	LD	B,08H
2170   0D42 CB 09       	RRC	C
2171   0D44 CB 09       NXTBIT:	RRC	C	;SHIFT BITS TO D6,
2172   0D46 79          	LD	A,C	;LSB FIRST AND OUTPUT
2173   0D47 E6 40       	AND	40H	;THEM FOR ONE BIT TIME.
2174   0D49 D3 C0       	OUT	(SERIAL_TX_PORT),A
2175   0D4B CD 8B 0D    	CALL	BITIME
2176   0D4E 10 F4       	DJNZ	NXTBIT
2177   0D50             ;
2178   0D50             ; SEND STOP BITS
2179   0D50             ;
2180   0D50 3E 40       	LD	A,40H
2181   0D52 D3 C0       	OUT	(SERIAL_TX_PORT),A
2182   0D54 CD 8B 0D    	CALL	BITIME
2183   0D57 CD 8B 0D    	CALL	BITIME
2184   0D5A E1          	POP	HL
2185   0D5B C1          	POP	BC
2186   0D5C F1          	POP	AF
2187   0D5D C9          	RET
2188   0D5E             ;-----------------------
2189   0D5E             ; SERIAL RECEIVE ROUTINE
2190   0D5E             ;-----------------------
2191   0D5E             ;RECEIVE SERIAL BYTE FROM DIN
2192   0D5E             ;
2193   0D5E             ; ENTRY : NONE
2194   0D5E             ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
2195   0D5E             ;
2196   0D5E             ; REGISTERS MODIFIED A AND F
2197   0D5E             ;
2198   0D5E C5          RXDATA:	PUSH	BC
2199   0D5F E5          	PUSH	HL
2200   0D60             ;
2201   0D60             ; WAIT FOR START BIT 
2202   0D60             ;
2203   0D60 DB C0       RXDAT1: IN	A,(SERIAL_RX_PORT)
2204   0D62 CB 7F       	    BIT	7,A
2205   0D64 20 FA       	    JR	NZ,RXDAT1	;NO START BIT
2206   0D66             ;
2207   0D66             ; DETECTED START BIT
2208   0D66             ;
2209   0D66 2A C0 FF    	LD	HL,(BAUD)
2210   0D69 CB 3C       	SRL	H
2211   0D6B CB 1D       	RR	L 	;DELAY FOR HALF BIT TIME
2212   0D6D CD 8B 0D    	CALL 	BITIME
2213   0D70 DB C0       	IN	A,(SERIAL_RX_PORT)
2214   0D72 CB 7F       	BIT	7,A
2215   0D74 20 EA       	JR	NZ,RXDAT1	;START BIT NOT VALID
2216   0D76             ;
2217   0D76             ; DETECTED VALID START BIT,READ IN DATA
2218   0D76             ;
2219   0D76 06 08       	LD	B,08H
2220   0D78 2A C0 FF    RXDAT2:	LD	HL,(BAUD)
2221   0D7B CD 8B 0D    	CALL	BITIME	;DELAY ONE BIT TIME
2222   0D7E DB C0       	IN	A,(SERIAL_RX_PORT)
2223   0D80 CB 17       	RL	A
2224   0D82 CB 19       	RR	C	;SHIFT BIT INTO DATA REG
2225   0D84 10 F2       	DJNZ	RXDAT2
2226   0D86 79          	LD	A,C
2227   0D87 B7          	OR	A	;CLEAR CARRY FLAG
2228   0D88 E1              POP	HL
2229   0D89 C1          	POP	BC
2230   0D8A C9          	RET
2231   0D8B             ;---------------
2232   0D8B             ; BIT TIME DELAY
2233   0D8B             ;---------------
2234   0D8B             ;DELAY FOR ONE SERIAL BIT TIME
2235   0D8B             ;ENTRY : HL = DELAY TIME
2236   0D8B             ; NO REGISTERS MODIFIED
2237   0D8B             ;
2238   0D8B E5          BITIME:	PUSH	HL
2239   0D8C D5          	PUSH	DE
2240   0D8D 11 01 00    	LD	DE,0001H
2241   0D90 ED 52       BITIM1:	SBC	HL,DE
2242   0D92 D2 90 0D    	JP	NC,BITIM1
2243   0D95 D1          	POP	DE
2244   0D96 E1          	POP	HL
2245   0D97 C9          	RET
2246   0D98             
2247   0D98             
2248   0D98             ;-----------------
2249   0D98             ; ONE SECOND DELAY
2250   0D98             ;-----------------
2251   0D98             ;
2252   0D98             ; ENTRY : NONE
2253   0D98             ; EXIT : FLAG REGISTER MODIFIED
2254   0D98             ;
2255   0D98 C5          DELONE:	PUSH	BC
2256   0D99 D5          	PUSH	DE
2257   0D9A E5          	PUSH	HL
2258   0D9B 11 01 00    	LD	DE,0001H
2259   0D9E 21 70 08    	LD	HL,0870H
2260   0DA1 06 92       DELON1:	LD	B,92H
2261   0DA3 10 FE       DELON2:	DJNZ	DELON2	;INNER LOOP
2262   0DA5 ED 52       	SBC	HL,DE
2263   0DA7 D2 A1 0D    	JP	NC,DELON1	;OUTER LOOP
2264   0DAA E1          	POP	HL
2265   0DAB D1          	POP	DE
2266   0DAC C1          	POP	BC
2267   0DAD C9          	RET
2268   0DAE             
2269   0DAE             
2270   0DAE             
2271   0DAE             
2272   0DAE             
2273   0DAE             
2274   0DAE             
2275   0DAE             ; **********************************************************************
2276   0DAE             ; List devices found on the I2C bus
2277   0DAE             ;
2278   0DAE             ; Test each I2C device address and reports any that acknowledge
2279   0DAE             
2280   0DAE 11 B3 10    I2CLIST:       LD   DE,LISTMsg        ;Address of message string
2281   0DB1 CD 51 0E                CALL StrOut         ;Output string
2282   0DB4 16 00                   LD   D,0            ;First I2C device address to test
2283   0DB6 D5          LISTLOOP:      PUSH DE             ;Preserve DE
2284   0DB7 7A                      LD   A,D            ;Get device address to be tested
2285   0DB8 CD CF 0D                CALL LISTTEST          ;Test if device is present
2286   0DBB D1                      POP  DE             ;Restore DE
2287   0DBC 20 07                   JR   NZ,LISTNEXT       ;Skip if no acknowledge
2288   0DBE 7A                      LD   A,D            ;Get address of device tested
2289   0DBF CD 80 0E                CALL HexOut         ;Output as two character hex 
2290   0DC2 CD 4C 0E                CALL SpaceOut       ;Output space character
2291   0DC5 14          LISTNEXT:      INC  D              ;Get next write address
2292   0DC6 14                      INC  D
2293   0DC7 7A                      LD   A,D            ;Address of next device to test
2294   0DC8 B7                      OR   A              ;Have we tested all addresses?
2295   0DC9 20 EB                   JR   NZ,LISTLOOP       ;No, so loop again
2296   0DCB CD 49 0E                CALL LineOut        ;Output new line
2297   0DCE C9                      RET
2298   0DCF             
2299   0DCF             ; Test if device at I2C address A acknowledges
2300   0DCF             ;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
2301   0DCF             ;   On exit:  Z flagged if device acknowledges
2302   0DCF             ;             NZ flagged if devices does not acknowledge
2303   0DCF CD C1 0E    LISTTEST:      CALL I2C_Open       ;Open I2C device for write
2304   0DD2 C0                      RET  NZ             ;Abort if failed to open
2305   0DD3 CD C8 0E                CALL I2C_Close      ;Close I2C device 
2306   0DD6 AF                      XOR  A              ;Return with Z flagged
2307   0DD7 C9                      RET
2308   0DD8             
2309   0DD8             
2310   0DD8             
2311   0DD8             
2312   0DD8             ; Copy a block from I2C memory to CPU memory
2313   0DD8             ;   On entry: DE = First address in I2C memory
2314   0DD8             ;             HL = First address in CPU memory
2315   0DD8             ;             BC = Number of bytes to be copied
2316   0DD8             ;             SCL = unknown, SDA = unknown
2317   0DD8             ;   On exit:  If successfully A = 0 and Z flagged
2318   0DD8             ;             If unsuccessfully A = Error and NZ flagged
2319   0DD8             ;             IX IY preserved
2320   0DD8 C5          I2C_MemRd:  PUSH BC
2321   0DD9 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2322   0DDC 3E AE       I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2323   0DDE CD C1 0E                CALL I2C_Open       ;Open for write
2324   0DE1 28 0A                   JR   Z,I2C_MemRdReady       ;If open okay then skip on
2325   0DE3 0B                      DEC  BC
2326   0DE4 78                      LD   A,B
2327   0DE5 B1                      OR   C              ;Timeout?
2328   0DE6 20 F4                   JR   NZ,I2C_MemRdRepeat     ;No, so go try again
2329   0DE8 C1                      POP  BC
2330   0DE9 3E 03                   LD   A,ERR_TOUT     ;Error code
2331   0DEB B7                      OR   A              ;Error, so NZ flagged
2332   0DEC C9                      RET                 ;Return with error
2333   0DED             ; Device opened okay
2334   0DED C1          I2C_MemRdReady:     POP  BC             ;Restore byte counter
2335   0DEE 7A                      LD   A,D            ;Address (hi) in I2C memory
2336   0DEF CD CB 0E                CALL I2C_Write      ;Write address
2337   0DF2 7B                      LD   A,E            ;Address (lo) in I2C memory
2338   0DF3 CD CB 0E                CALL I2C_Write      ;Write address
2339   0DF6 3E AF                   LD   A,I2CA_BLOCK+1 ;I2C device to be read from
2340   0DF8 CD C1 0E                CALL I2C_Open       ;Open for read
2341   0DFB C0                      RET  NZ             ;Abort if error
2342   0DFC 0B          I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
2343   0DFD 78                      LD   A,B
2344   0DFE B1                      OR   C              ;Last byte to be read?
2345   0DFF CD 08 0F                CALL I2C_Read       ;Read byte with no ack on last byte
2346   0E02 77                      LD   (HL),A         ;Write byte in CPU memory
2347   0E03 23                      INC  HL             ;Increment CPU memory pointer
2348   0E04 78                      LD   A,B
2349   0E05 B1                      OR   C              ;Finished?
2350   0E06 20 F4                   JR   NZ,I2C_MemRdRead       ;No, so go read next byte
2351   0E08 CD 40 0F                CALL I2C_Stop       ;Generate I2C stop
2352   0E0B AF                      XOR  A              ;Return with success (Z flagged)
2353   0E0C C9                      RET
2354   0E0D             
2355   0E0D             
2356   0E0D             ; Copy a block from CPU memory to I2C memory
2357   0E0D             ;   On entry: DE = First address in I2C memory
2358   0E0D             ;             HL = First address in CPU memory
2359   0E0D             ;             BC = Number of bytes to be copied
2360   0E0D             ;             SCL = unknown, SDA = unknown
2361   0E0D             ;   On exit:  If successfully A = 0 and Z flagged
2362   0E0D             ;             If unsuccessfully A = Error and NZ flagged
2363   0E0D             ;             IX IY preserved
2364   0E0D             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
2365   0E0D             ; pages.
2366   0E0D C5          I2C_MemWr:  PUSH BC
2367   0E0E 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2368   0E11 3E AE       I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2369   0E13 CD C1 0E                CALL I2C_Open       ;Open for write
2370   0E16 28 0A                   JR   Z,I2C_MemWrReady       ;If open okay then skip on
2371   0E18 0B                      DEC  BC
2372   0E19 78                      LD   A,B
2373   0E1A B1                      OR   C              ;Timeout?
2374   0E1B 20 F4                   JR   NZ,I2C_MemWrRepeat     ;No, so go try again
2375   0E1D C1                      POP  BC
2376   0E1E 3E 03                   LD   A,ERR_TOUT     ;Error code
2377   0E20 B7                      OR   A              ;Error, so NZ flagged
2378   0E21 C9                      RET                 ;Return with error
2379   0E22             ; Device opened okay
2380   0E22 C1          I2C_MemWrReady:     POP  BC             ;Restore byte counter
2381   0E23 7A          I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
2382   0E24 CD CB 0E                CALL I2C_Write      ;Write address
2383   0E27 7B                      LD   A,E            ;Address (lo) in I2C memory
2384   0E28 CD CB 0E                CALL I2C_Write      ;Write address
2385   0E2B 7E          I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
2386   0E2C CD CB 0E                CALL I2C_Write      ;Read byte from I2C memory
2387   0E2F 23                      INC  HL             ;Increment CPU memory pointer
2388   0E30 13                      INC  DE             ;Increment I2C memory pointer
2389   0E31 0B                      DEC  BC             ;Decrement byte counter
2390   0E32 78                      LD   A,B
2391   0E33 B1                      OR   C              ;Finished?
2392   0E34 28 05                   JR   Z,I2C_MemWrStore       ;Yes, so go store this page
2393   0E36 7B                      LD   A,E            ;Get address in I2C memory (lo byte)
2394   0E37 E6 3F                   AND  63             ;64 byte page boundary?
2395   0E39 20 F0                   JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
2396   0E3B CD 40 0F    I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
2397   0E3E 78                      LD   A,B
2398   0E3F B1                      OR   C              ;Finished?
2399   0E40 20 CB                   JR   NZ,I2C_MemWr   ;No, so go write some more
2400   0E42 C9                      RET   
2401   0E43             
2402   0E43             
2403   0E43             
2404   0E43             
2405   0E43             
2406   0E43             
2407   0E43             
2408   0E43             
2409   0E43             
2410   0E43             
2411   0E43             ; Display test result
2412   0E43             ;   On entry: DE = Address of null terminated string
2413   0E43             ;             H = First value ($H)
2414   0E43             ;             L = Second value ($L)
2415   0E43             ;   On exit:  HL IX IY preserved
2416   0E43             Result:     
2417   0E43 C3 98 0E                JP   String         ;Output result string to console
2418   0E46             
2419   0E46             
2420   0E46             ; Character output to console
2421   0E46             ;   On entry: A = Character to be output
2422   0E46             ;   On exit:  BC DE HL IX IY preserved
2423   0E46 C3 5E 0E    CharOut:    JP   API_Cout
2424   0E49             
2425   0E49             ; New line output to console
2426   0E49             ;   On entry: No parameters required
2427   0E49             ;   On exit:  BC DE HL IX IY preserved
2428   0E49 C3 68 0E    LineOut:    JP   API_Lout
2429   0E4C             
2430   0E4C             ; Space character ouput to console
2431   0E4C             ;   On entry: No parameters required
2432   0E4C             ;   On exit:  BC DE HL IX IY preserved
2433   0E4C 3E 20       SpaceOut:   LD   A,$20
2434   0E4E C3 5E 0E                JP   API_Cout
2435   0E51             
2436   0E51             ; String output to console
2437   0E51             ;   On entry: DE = Address of string
2438   0E51             ;   On exit:  BC DE HL IX IY preserved
2439   0E51 C3 74 0E    StrOut:     JP   API_Sout
2440   0E54             
2441   0E54             
2442   0E54             ; Delay by DE milliseconds (approx)
2443   0E54             ;   On entry: DE = Delay time in milliseconds
2444   0E54             ;   On exit:  BC DE HL IX IY preserved
2445   0E54 C5          API_Delay:  PUSH BC             ;Preserve registers
2446   0E55 D5                      PUSH DE
2447   0E56 E5                      PUSH HL
2448   0E57 CD DB 0B                CALL delay
2449   0E5A E1                      POP  HL             ;Restore registers
2450   0E5B D1                      POP  DE
2451   0E5C C1                      POP  BC
2452   0E5D C9                      RET
2453   0E5E             
2454   0E5E             
2455   0E5E             ; Character output to console device
2456   0E5E             ;   On entry: A = Character to be output
2457   0E5E             ;   On exit:  BC DE HL IX IY preserved
2458   0E5E C5          API_Cout:   PUSH BC             ;Preserve registers
2459   0E5F D5                      PUSH DE
2460   0E60 E5                      PUSH HL
2461   0E61 CD 08 00                CALL $0008
2462   0E64 E1                      POP  HL             ;Restore registers
2463   0E65 D1                      POP  DE
2464   0E66 C1                      POP  BC
2465   0E67 C9                      RET
2466   0E68             
2467   0E68             
2468   0E68             ; New line output to console device
2469   0E68             ;   On entry: No parameters required
2470   0E68             ;   On exit:  BC DE HL IX IY preserved
2471   0E68 C5          API_Lout:   PUSH BC             ;Preserve registers
2472   0E69 D5                      PUSH DE
2473   0E6A E5                      PUSH HL
2474   0E6B 3E 0D                   LD A, CR ; enter char
2475   0E6D CD 08 00                CALL $0008
2476   0E70 E1                      POP  HL             ;Restore registers
2477   0E71 D1                      POP  DE
2478   0E72 C1                      POP  BC
2479   0E73 C9                      RET
2480   0E74             
2481   0E74             
2482   0E74             ; String output to console device
2483   0E74             ;   On entry: DE = Address of string
2484   0E74             ;   On exit:  BC DE HL IX IY preserved
2485   0E74 C5          API_Sout:   PUSH BC             ;Preserve registers
2486   0E75 D5                      PUSH DE
2487   0E76 E5                      PUSH HL
2488   0E77 62                      LD H, D
2489   0E78 6B                      LD L, E
2490   0E79 CD 06 0D                CALL SNDLCDMSG
2491   0E7C E1                      POP  HL             ;Restore registers
2492   0E7D D1                      POP  DE
2493   0E7E C1                      POP  BC
2494   0E7F C9                      RET
2495   0E80             
2496   0E80             
2497   0E80             ; Hex byte output to console
2498   0E80             ;   On entry: A = Byte to be output in hex
2499   0E80             ;   On exit:  BC DE HL IX IY preserved
2500   0E80 F5          HexOut:     PUSH AF             ;Preserve byte to be output
2501   0E81 1F                      RRA                 ;Shift top nibble to
2502   0E82 1F                      RRA                 ;  botom four bits..
2503   0E83 1F                      RRA
2504   0E84 1F                      RRA
2505   0E85 E6 0F                   AND  $0F           ;Mask off unwanted bits
2506   0E87 CD 8D 0E                CALL HexOutHex           ;Output hi nibble
2507   0E8A F1                      POP  AF             ;Restore byte to be output
2508   0E8B E6 0F                   AND  $0F           ;Mask off unwanted bits
2509   0E8D             ; Output nibble as ascii character
2510   0E8D FE 0A       HexOutHex:       CP   $0A           ;Nibble > 10 ?
2511   0E8F 38 02                   JR   C,HexOutSkip        ;No, so skip
2512   0E91 C6 07                   ADD  A,7            ;Yes, so add 7
2513   0E93 C6 30       HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
2514   0E95 C3 5E 0E                JP   API_Cout       ;Write character
2515   0E98             
2516   0E98             
2517   0E98             ; Output string at DE with substitutions
2518   0E98             ;   On entry: A = Address of device on I2C bus (write address)
2519   0E98             ;             DE = Address of null terminated string
2520   0E98             ;             H = Value to substitute for $H
2521   0E98             ;             L = Value to substitute for $L
2522   0E98             ;             B = Value to substitute for $B
2523   0E98             ;   On exit:  DE = Address of next location after this string
2524   0E98             ;             IX IY preserved
2525   0E98 1A          String:     LD   A,(DE)         ;Get character from string
2526   0E99 13                      INC  DE             ;Point to next character in string
2527   0E9A B7                      OR   A              ;Null ?
2528   0E9B C8                      RET  Z              ;Yes, so we're done
2529   0E9C FE 24                   CP   '$'            ;Substitue value?
2530   0E9E 28 05                   JR   Z,StringSubst       ;Yes, so go handle substitution
2531   0EA0 CD 46 0E                CALL CharOut        ;Output character to console
2532   0EA3 18 F3                   JR   String         ;Go get next character from string
2533   0EA5 1A          StringSubst:     LD   A,(DE)         ;Get character from string
2534   0EA6 13                      INC  DE             ;Point to next character in string
2535   0EA7 B7                      OR   A              ;Null ?
2536   0EA8 C8                      RET  Z              ;Yes, so we're done
2537   0EA9 FE 48                   CP   'H'            ;Register H
2538   0EAB 20 03                   JR   NZ,StringNotH       ;No, so skip
2539   0EAD 7C                      LD   A,H            ;Get value 'H'
2540   0EAE 18 0C                   JR   StringGotIt         ;Go output it in hex
2541   0EB0 FE 4C       StringNotH:      CP   'L'            ;Register L
2542   0EB2 20 03                   JR   NZ,StringNotL       ;No, so skip
2543   0EB4 7D                      LD   A,L            ;Get value 'L'
2544   0EB5 18 05                   JR   StringGotIt         ;Go output it in hex
2545   0EB7 FE 42       StringNotL:      CP   'B'            ;Register B
2546   0EB9 20 04                   JR   NZ,StringNotB       ;No, so skip
2547   0EBB 78                      LD   A,B            ;Get value 'L'
2548   0EBC                         ;JR   @GotIt        ;Go output it in hex
2549   0EBC CD 80 0E    StringGotIt:     CALL HexOut         ;Output write address in hex
2550   0EBF 18 D7       StringNotB:      JR   String         ;Go get next character from string
2551   0EC1             
2552   0EC1             
2553   0EC1             ; **********************************************************************
2554   0EC1             ; I2C support functions
2555   0EC1             
2556   0EC1             ; I2C bus open device
2557   0EC1             ;   On entry: A = Device address (bit zero is read flag)
2558   0EC1             ;             SCL = unknown, SDA = unknown
2559   0EC1             ;   On exit:  If successfully A = 0 and Z flagged
2560   0EC1             ;             If unsuccessfully A = Error and NZ flagged
2561   0EC1             ;             BC DE HL IX IY preserved
2562   0EC1 F5          I2C_Open:   PUSH AF
2563   0EC2 CD 35 0F                CALL I2C_Start      ;Output start condition
2564   0EC5 F1                      POP  AF
2565   0EC6 18 03                   JR   I2C_Write      ;Write data byte
2566   0EC8             
2567   0EC8             
2568   0EC8             ; I2C bus close device
2569   0EC8             ;   On entry: SCL = unknown, SDA = unknown
2570   0EC8             ;   On exit:  If successfully A=0 and Z flagged
2571   0EC8             ;             If unsuccessfully A=Error and NZ flagged
2572   0EC8             ;             SCL = hi, SDA = hi
2573   0EC8             ;             BC DE HL IX IY preserved
2574   0EC8 C3 40 0F    I2C_Close:  JP   I2C_Stop       ;Output stop condition
2575   0ECB             
2576   0ECB             
2577   0ECB             ; **********************************************************************
2578   0ECB             ; **********************************************************************
2579   0ECB             ; I2C bus master driver
2580   0ECB             ; **********************************************************************
2581   0ECB             ; **********************************************************************
2582   0ECB             
2583   0ECB             ; Functions provided are:
2584   0ECB             ;     I2C_Start
2585   0ECB             ;     I2C_Stop
2586   0ECB             ;     I2C_Read
2587   0ECB             ;     I2C_Write
2588   0ECB             ;
2589   0ECB             ; This code has delays between all I/O operations to ensure it works
2590   0ECB             ; with the slowest I2C devices
2591   0ECB             ;
2592   0ECB             ; I2C transfer sequence
2593   0ECB             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2594   0ECB             ;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
2595   0ECB             ;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
2596   0ECB             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2597   0ECB             ;
2598   0ECB             ;
2599   0ECB             ; Start condition                     Stop condition
2600   0ECB             ; Output by master device             Output by master device
2601   0ECB             ;       ----+                                      +----
2602   0ECB             ; SDA       |                         SDA          |
2603   0ECB             ;           +-------                        -------+
2604   0ECB             ;       -------+                                +-------
2605   0ECB             ; SCL          |                      SCL       |
2606   0ECB             ;              +----                        ----+
2607   0ECB             ;
2608   0ECB             ;
2609   0ECB             ; Address frame
2610   0ECB             ; Clock and data output from master device
2611   0ECB             ; Receiving device outputs acknowledge 
2612   0ECB             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2613   0ECB             ; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
2614   0ECB             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2615   0ECB             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2616   0ECB             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2617   0ECB             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2618   0ECB             ;
2619   0ECB             ;
2620   0ECB             ; Data frame 
2621   0ECB             ; Clock output by master device
2622   0ECB             ; Data output by transmitting device
2623   0ECB             ; Receiving device outputs acknowledge 
2624   0ECB             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2625   0ECB             ; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
2626   0ECB             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2627   0ECB             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2628   0ECB             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2629   0ECB             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2630   0ECB             ;
2631   0ECB             
2632   0ECB             
2633   0ECB             ; **********************************************************************
2634   0ECB             ; I2C constants
2635   0ECB             
2636   0ECB             
2637   0ECB             ; I2C bus master interface
2638   0ECB             ; The default device option is for SC126 or compatible
2639   0ECB             
2640   0ECB             I2C_PORT:   .EQU $21           ;Host I2C port address
2641   0ECB             I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
2642   0ECB             I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
2643   0ECB             I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
2644   0ECB             I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
2645   0ECB             I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
2646   0ECB             
2647   0ECB             
2648   0ECB             ; I2C support constants
2649   0ECB             ERR_NONE:   .EQU 0              ;Error = None
2650   0ECB             ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
2651   0ECB             ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
2652   0ECB             ERR_TOUT:   .EQU 3              ;Error = Timeout
2653   0ECB             
2654   0ECB             
2655   0ECB             ; **********************************************************************
2656   0ECB             ; Hardware dependent I2C bus functions
2657   0ECB             
2658   0ECB             
2659   0ECB             ; I2C bus transmit frame (address or data)
2660   0ECB             ;   On entry: A = Data byte, or
2661   0ECB             ;                 Address byte (bit zero is read flag)
2662   0ECB             ;             SCL = low, SDA = low
2663   0ECB             ;   On exit:  If successful A=0 and Z flagged
2664   0ECB             ;                SCL = lo, SDA = lo
2665   0ECB             ;             If unsuccessful A=Error and NZ flagged
2666   0ECB             ;                SCL = high, SDA = high, I2C closed
2667   0ECB             ;             BC DE HL IX IY preserved
2668   0ECB C5          I2C_Write:  PUSH BC             ;Preserve registers
2669   0ECC D5                      PUSH DE
2670   0ECD 57                      LD   D,A            ;Store byte to be written
2671   0ECE 06 08                   LD   B,8            ;8 data bits, bit 7 first
2672   0ED0 CB 12       I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
2673   0ED2 38 05                   JR   C,I2C_WriteBit_Hi      ;High, so skip
2674   0ED4 CD 67 0F                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
2675   0ED7 18 03                   JR   I2C_WriteBit_Clk
2676   0ED9 CD 60 0F    I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
2677   0EDC CD 52 0F    I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
2678   0EDF CD 59 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
2679   0EE2 10 EC                   DJNZ I2C_WriteWr_Loop
2680   0EE4             ; Test for acknowledge from slave (receiver)
2681   0EE4             ; On arriving here, SCL = lo, SDA = data bit
2682   0EE4 CD 60 0F                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
2683   0EE7 CD 52 0F                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
2684   0EEA CD 78 0F                CALL I2C_RdPort     ;Read SDA input
2685   0EED 47                      LD   B,A
2686   0EEE CD 59 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
2687   0EF1 CB 78                   BIT  I2C_SDA_RD,B
2688   0EF3 20 04                   JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
2689   0EF5 D1                      POP  DE             ;Restore registers
2690   0EF6 C1                      POP  BC
2691   0EF7 AF                      XOR  A              ;Return success A=0 and Z flagged
2692   0EF8 C9                      RET
2693   0EF9             ; I2C STOP required as no acknowledge
2694   0EF9             ; On arriving here, SCL = lo, SDA = hi
2695   0EF9 CD 67 0F    I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
2696   0EFC CD 52 0F                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
2697   0EFF CD 60 0F                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
2698   0F02 D1                      POP  DE             ;Restore registers
2699   0F03 C1                      POP  BC
2700   0F04 3E 02                   LD   A,ERR_NOACK    ;Return error = No Acknowledge
2701   0F06 B7                      OR   A              ;  and NZ flagged
2702   0F07 C9                      RET
2703   0F08             
2704   0F08             
2705   0F08             ; I2C bus receive frame (data)
2706   0F08             ;   On entry: A = Acknowledge flag
2707   0F08             ;               If A != 0 the read is acknowledged
2708   0F08             ;             SCL low, SDA low
2709   0F08             ;   On exit:  If successful A = data byte and Z flagged
2710   0F08             ;               SCL = low, SDA = low
2711   0F08             ;             If unsuccessul* A = Error and NZ flagged
2712   0F08             ;               SCL = low, SDA = low
2713   0F08             ;             BC DE HL IX IY preserved
2714   0F08             ; *This function always returns successful
2715   0F08 C5          I2C_Read:   PUSH BC             ;Preserve registers
2716   0F09 D5                      PUSH DE
2717   0F0A 5F                      LD   E,A            ;Store acknowledge flag
2718   0F0B 06 08                   LD   B,8            ;8 data bits, 7 first
2719   0F0D CD 60 0F                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
2720   0F10 CD 52 0F    I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
2721   0F13 CD 78 0F                CALL I2C_RdPort     ;Read SDA input bit
2722   0F16 37                      SCF                 ;Set carry flag
2723   0F17 CB 7F                   BIT  I2C_SDA_RD,A   ;SDA input high?
2724   0F19 20 01                   JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
2725   0F1B 3F                      CCF                 ;Clear carry flag
2726   0F1C CB 12       I2C_ReadRotate:    RL   D              ;Rotate result into D
2727   0F1E CD 59 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
2728   0F21 10 ED                   DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
2729   0F23             ; Acknowledge input byte
2730   0F23             ; On arriving here, SCL = lo, SDA = hi/input
2731   0F23 7B                      LD   A,E            ;Get acknowledge flag
2732   0F24 B7                      OR   A              ;A = 0? (indicates no acknowledge)
2733   0F25 28 03                   JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
2734   0F27 CD 67 0F                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
2735   0F2A CD 52 0F    I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
2736   0F2D CD 59 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2737   0F30 7A                      LD   A,D            ;Get data byte received
2738   0F31 D1                      POP  DE             ;Restore registers
2739   0F32 C1                      POP  BC
2740   0F33 BF                      CP   A              ;Return success Z flagged
2741   0F34 C9                      RET
2742   0F35             
2743   0F35             
2744   0F35             ; I2C bus start
2745   0F35             ;   On entry: SCL = unknown, SDA = unknown
2746   0F35             ;   On exit:  SCL = low, SDA = low
2747   0F35             ;             A = 0 and Z flagged as we always succeed
2748   0F35             ;             BC DE HL IX IY preserved
2749   0F35             ; First ensure SDA and SCL are high
2750   0F35 CD 4E 0F    I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
2751   0F38             ;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
2752   0F38             ;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
2753   0F38             ; Generate I2C start condition
2754   0F38 CD 67 0F                CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2755   0F3B CD 59 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2756   0F3E AF                      XOR  A              ;Return success A=0 and Z flagged
2757   0F3F C9                      RET
2758   0F40             
2759   0F40             
2760   0F40             ; I2C bus stop 
2761   0F40             ;   On entry: SCL = unknown, SDA = unknown
2762   0F40             ;   On exit:  SCL = high, SDA = high
2763   0F40             ;             A = 0 and Z flagged as we always succeed
2764   0F40             ;             BC DE HL IX IY preserved
2765   0F40             ; First ensure SDA and SCL are low
2766   0F40 CD 67 0F    I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2767   0F43 CD 59 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2768   0F46             ; Generate stop condition
2769   0F46 CD 52 0F                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
2770   0F49 CD 60 0F                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
2771   0F4C AF                      XOR  A              ;Return success A=0 and Z flagged
2772   0F4D C9                      RET
2773   0F4E             
2774   0F4E             
2775   0F4E             ; **********************************************************************
2776   0F4E             ; I2C bus simple I/O functions
2777   0F4E             ;   On entry: No parameters required
2778   0F4E             ;   On exit:  BC DE HL IX IY preserved
2779   0F4E             
2780   0F4E 3E 81       I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
2781   0F50 18 1A                   JR   I2C_WrPort
2782   0F52             
2783   0F52 3A 00 D0    I2C_SCL_HI: LD   A,(I2C_RAMCPY)
2784   0F55 CB C7                   SET  I2C_SCL_WR,A
2785   0F57 18 13                   JR   I2C_WrPort
2786   0F59             
2787   0F59 3A 00 D0    I2C_SCL_LO: LD   A,(I2C_RAMCPY)
2788   0F5C CB 87                   RES  I2C_SCL_WR,A
2789   0F5E 18 0C                   JR   I2C_WrPort
2790   0F60             
2791   0F60 3A 00 D0    I2C_SDA_HI: LD   A,(I2C_RAMCPY)
2792   0F63 CB FF                   SET  I2C_SDA_WR,A
2793   0F65 18 05                   JR   I2C_WrPort
2794   0F67             
2795   0F67 3A 00 D0    I2C_SDA_LO: LD   A,(I2C_RAMCPY)
2796   0F6A CB BF                   RES  I2C_SDA_WR,A
2797   0F6C                         ;JR   I2C_WrPort
2798   0F6C             
2799   0F6C C5          I2C_WrPort: PUSH BC             ;Preserve registers
2800   0F6D 06 00                   LD   B,0            ;Set up BC for 16-bit
2801   0F6F 0E 21                   LD   C,I2C_PORT     ;  I/O address of I2C port
2802   0F71 ED 79                   OUT  (C),A          ;Write A to I2C I/O port
2803   0F73 32 00 D0                LD   (I2C_RAMCPY),A ;Write A to RAM copy
2804   0F76 C1                      POP  BC             ;Restore registers
2805   0F77 C9                      RET
2806   0F78             
2807   0F78 C5          I2C_RdPort: PUSH BC             ;Preserve registers
2808   0F79 06 00                   LD   B,0            ;Set up BC for 16-bit
2809   0F7B 0E 21                   LD   C,I2C_PORT     ;  I/O address of I2C port
2810   0F7D ED 78                   IN   A,(C)          ;Read A from I/O port
2811   0F7F C1                      POP  BC             ;Restore registers
2812   0F80 C9                      RET
2813   0F81             
2814   0F81             
2815   0F81             
2816   0F81 0C0D0D0A5A38WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
2816   0F87 30204D696E6920496E69636961646F0D0A00
2817   0F99 5A3830204D49MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H
2817   0F9F 4E492C204820544F2048454C500D00
2818   0FAE             
2819   0FAE 49202D20496EMSG_MENU1 .db "I - Intel hex loader",CR, 00H
2819   0FB4 74656C20686578206C6F616465720D00
2820   0FC4 42202D204261MSG_MENU2 .db "B - Basic",CR, 00H
2820   0FCA 7369630D00
2821   0FCF 442041414141MSG_MENU3 .db "D AAAA - DISPLAY",CR,00H
2821   0FD5 202D20444953504C41590D00
2822   0FE1 4D2041414141MSG_MENU4 .db "M AAAA - MODIFY",CR,00H
2822   0FE7 202D204D4F444946590D00
2823   0FF2 472041414141MSG_MENU5 .db "G AAAA - GO TO",CR, 00H
2823   0FF8 202D20474F20544F0D00
2824   1002 31202D204932MSG_MENU6 .db "1 - I2C Scan",CR, 00H
2824   1008 43205363616E0D00
2825   1010 32202D204932MSG_MENU7 .db "2 - I2C PC -> MEM",CR, 00H
2825   1016 43205043202D3E204D454D0D00
2826   1023 33202D204932MSG_MENU8 .db "3 - I2C MEM -> PC", 00H
2826   1029 43204D454D202D3E20504300
2827   1035             
2828   1035 34202D204932MSG_MENU9  .db "4 - I2C MEM -> PC", 00H
2828   103B 43204D454D202D3E20504300
2829   1047 35202D204932MSG_MENU10 .db "5 - I2C MEM -> PC", 00H
2829   104D 43204D454D202D3E20504300
2830   1059 36202D204932MSG_MENU11 .db "6 - I2C MEM -> PC", 00H
2830   105F 43204D454D202D3E20504300
2831   106B 37202D204932MSG_MENU12 .db "7 - I2C MEM -> PC", 00H
2831   1071 43204D454D202D3E20504300
2832   107D 38202D204932MSG_MENU13 .db "8 - I2C MEM -> PC", 00H
2832   1083 43204D454D202D3E20504300
2833   108F 39202D204932MSG_MENU14 .db "9 - I2C MEM -> PC", 00H
2833   1095 43204D454D202D3E20504300
2834   10A1 30202D204932MSG_MENU15 .db "0 - I2C MEM -> PC", 00H
2834   10A7 43204D454D202D3E20504300
2835   10B3             
2836   10B3 0C4932432064LISTMsg:    .DB  CS,"I2C device found at:",CR,0
2836   10B9 657669636520666F756E642061743A0D00
2837   10CA 0C434F505920MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
2837   10D0 493243204D454D20544F204350550D00
2838   10E0 0C434F505920MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H
2838   10E6 43505520544F20493243204D454D0D00
2839   10F6 46524F4D3A20MSG_FROM    .db "FROM: ", 00H
2839   10FC 00
2840   10FD 0D544F3A2000MSG_TO      .db CR,"TO: ", 00H
2841   1103 0D53495A4528MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
2841   1109 4259544553293A2000
2842   1112 0D434F505920MSG_COPYOK  .db CR,"COPY OK", 00H
2842   1118 4F4B00
2843   111B 0D434F505920MSG_COPYFAIL  .db CR,"COPY FAIL", 00H
2843   1121 4641494C00
2844   1126             
2845   1126             
2846   1126 0C496E74656CMSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
2846   112C 20484558206C6F616465722E2E2E0D00
2847   113C 46494C452052FILEOK    .DB      "FILE RECEIVED OK",CR,00H
2847   1142 45434549564544204F4B0D00
2848   114E 434845434B53CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
2848   1154 554D204552524F520D00
2849   115E             
2850   115E             
2851   115E             
2852   115E             ; **********************************************************************
2853   115E             ; I2C workspace / variables in RAM
2854   115E             
2855   D000                         .ORG  I2CDATA
2856   D000             
2857   D000 00          I2C_RAMCPY: .DB  0              ;RAM copy of output port
2858   D001             
2859   D001 00          RESULTS:    .DB  0              ;Large block of results can start here
2860   D002             
2861   D002             .end
tasm: Number of errors = 0
