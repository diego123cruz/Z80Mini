0001   0000             ; Diego Cruz - Nov 2022
0002   0000             ; 
0003   0000             ; bootV2: 
0004   0000             ;         - CPU Z80@4Mhz
0005   0000             ;         - Lcd Grafico 128x64
0006   0000             ;         - Keyboard 40 keys + Shift
0007   0000             ;         - Rom 32k 0000h - 7FFFh
0008   0000             ;         - Ram 32k 8000h - FFFFh
0009   0000             ;         
0010   0000             ;
0011   0000             ;         - Ports:
0012   0000             ;               - Keyboard: 40H
0013   0000             ;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
0014   0000             ;               - User IN/OUT: C0H
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------
0017   0000             LCDCTRL	    .EQU    70H
0018   0000             LCDDATA     .EQU    71H
0019   0000             KEY_IN      .EQU    40H
0020   0000             KEY_OUT     .EQU    40H
0021   0000             
0022   0000             CTRLC       .EQU    03H             ; Control "C"
0023   0000             CTRLG       .EQU    07H             ; Control "G"
0024   0000             BKSP        .EQU    08H             ; Back space
0025   0000             LF          .EQU    0AH             ; Line feed
0026   0000             VT          .equ    0BH             ; 
0027   0000             CS          .EQU    0CH             ; Clear screen
0028   0000             CR          .EQU    0DH             ; Carriage return [Enter]
0029   0000             CTRLO       .EQU    0FH             ; Control "O"
0030   0000             CTRLQ	    .EQU	11H		        ; Control "Q"
0031   0000             CTRLR       .EQU    12H             ; Control "R"
0032   0000             CTRLS       .EQU    13H             ; Control "S"
0033   0000             CTRLU       .EQU    15H             ; Control "U"
0034   0000             ESC         .EQU    1BH             ; Escape
0035   0000             DEL         .EQU    7FH             ; Delete
0036   0000             
0037   0000             kCPUClock:  .EQU 4000000       ;CPU clock speed in Hz
0038   0000             kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
0039   0000             kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
0040   0000             kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
0041   0000             kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
0042   0000             kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop
0043   0000             
0044   0000             BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
0045   0000             ;
0046   0000             ; BAUD RATE CONSTANTS
0047   0000             ;
0048   0000             B300:	.EQU	0220H	;300 BAUD
0049   0000             B1200:	.EQU	0080H	;1200 BAUD
0050   0000             B2400:	.EQU	003FH	;2400 BAUD
0051   0000             B4800:	.EQU	001BH	;4800 BAUD
0052   0000             B9600:	.EQU	000BH	;9600 BAUD
0053   0000             
0054   0000             SYSTEM:	.EQU 	0FD00H	;INITIAL STACK POINTER
0055   0000             I2CDATA .EQU    0D000H 
0056   0000             
0057   0000             I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
0058   0000             TIMEOUT:    .EQU 10000          ;Timeout loop counter
0059   0000             
0060   0000             ADDR:       .EQU 0FEB0H   ;THE ADDRESS  2 bytes
0061   0000             ADDR_FROM   .EQU 0FEB2H   ;THE ADDRESS FROM  2 bytes
0062   0000             ADDR_TO     .EQU 0FEB4H   ;THE ADDRESS TO 2 bytes
0063   0000             ADDR_SIZE   .EQU 0FEB6H   ;THE ADDRESS SIZE 2 bytes
0064   0000             DATA:       .EQU 0FEB8H   ;THE DATA
0065   0000             MSGBUF:     .EQU 0FE00H   ;STRING HANDLING AREA
0066   0000             
0067   0000             PORT_SET    .EQU 0FFB0H ; 1 byte - Define port (input/output) Default 0xC0(onboard)
0068   0000             PORT_OUT_VAL    .EQU 0FFB1H ; 1 byte - save value out port
0069   0000             
0070   0000             
0071   0000             BAUD:	 .EQU	0FFC0H	 ;BAUD RATE
0072   0000             PUTCH:   .EQU   0FFAAH   ;OUTPUT A CHARACTER TO SERIAL
0073   0000             GETCH:   .EQU   0FFACH   ;WAIT FOR A CHARACTER FROM SERIAL
0074   0000             
0075   0000             SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
0076   0000             SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
0077   0000             
0078   0000             
0079   0000             ; LCD TEXT MODE
0080   0000             LCD_LINE1   .EQU    80H
0081   0000             LCD_LINE2   .EQU    90H
0082   0000             LCD_LINE3   .EQU    88H
0083   0000             LCD_LINE4   .EQU    98H
0084   0000             
0085   0000             
0086   0000             ; RAM MAP
0087   0000             
0088   0000             
0089   0000             
0090   0000             LCD_CHAR            .EQU    $E000   ; 1 byte char ex: 'A'
0091   0000             LCD_CHAR_POINT      .EQU    $E001   ; 2 bytes ponteiro para o mapa de caracteres
0092   0000             LCD_TXT_X           .EQU    $E003   ; 1 byte  0-20 (21 col)
0093   0000             LCD_TXT_Y           .EQU    $E004   ; 1 byte  0-7  (8 row)
0094   0000             LCD_BYTE_INDEX      .EQU    $E005   ; 2 bytes pointer pixel(8)
0095   0000             LCD_BIT_INDEX       .EQU    $E007   ; 1 byte pointer pixel(1)
0096   0000             LCD_TXT_X_TMP       .EQU    $E008   ; 2 bytes = LCD_TXT_X * 6
0097   0000             LCD_TXT_Y_TMP       .EQU    $E00A   ; 2 bytes = LCD_TXT_Y * 128
0098   0000             LCD_CHAR_H          .EQU    $E00C   ; 1 byte altura do char
0099   0000             LCD_CHAR_W          .EQU    $E00D   ; 1 byte largura do char
0100   0000             LCD_TMP_POINT       .EQU    $E00E   ; 2 bytes ponteiro do pixel altural do print
0101   0000             LCD_DELETE_CHAR     .EQU    $E00F   ; 1 byte, 0 não, ff delete proximo char
0102   0000             LCD_AUTO_X          .EQU    $E010   ; 1 byte, 0 sim, ff nao
0103   0000             
0104   0000             DISPLAY             .EQU    $E500
0105   0000             
0106   0000             LCD_TEMP        .EQU    $E110
0107   0000             LCD_COOX        .EQU    $E102 ; 1 byte, local onde vai printar
0108   0000             LCD_COOY        .EQU    $E103 ; 1 byte
0109   0000             LCD_PRINT_H     .EQU    $E104 ; 1 byte, tamanho do que vai printar
0110   0000             LCD_PRINT_W     .EQU    $E105 ; 1 byte
0111   0000             LCD_PRINT_IMAGE .EQU    $E106 ; 2 bytes
0112   0000             
0113   0000             
0114   0000                     .ORG 0
0115   0000 F3          RST00	DI
0116   0001 C3 83 04            JP  INICIO
0117   0004             						
0118   0008                     .ORG     0008H
0119   0008 C3 88 08    RST08   JP  PRINTCHAR
0120   000B             
0121   0010                     .ORG 0010H
0122   0010 C3 AF 0B    RST10   JP KEYREADINIT
0123   0013             
0124   0018                     .ORG 0018H ; check break
0125   0018 C3 9A 0B    RST18   JP CHKKEY
0126   001B             
0127   0030                     .ORG 0030H
0128   0030 C3 1E 05    RST30   JP APIHandler
0129   0033             
0130   0033             KEYMAP:
0131   0033 313233343536.BYTE   "1234567890"
0131   0039 37383930
0132   003D 515745525459.BYTE   "QWERTYUIOP"
0132   0043 55494F50
0133   0047 415344464748.BYTE   "ASDFGHJKL", CR
0133   004D 4A4B4C0D
0134   0051 035A58435642.BYTE   CTRLC, "ZXCVBNM ", DEL
0134   0057 4E4D207F
0135   005B             
0136   005B             SHIFTKEYMAP:
0137   005B 21402324255E.BYTE   "!@#$%^&*()"
0137   0061 262A2829
0138   0065 607E2D5F3D2B.BYTE   "`~-_=+;:'"
0138   006B 3B3A27
0139   006E 22          .BYTE   22h
0140   006F 7B7D5B5D7C5C.BYTE   "{}[]|",$5C,"<>?/"
0140   0075 3C3E3F2F
0141   0079 032C2E1B2020.BYTE   CTRLC,",.",ESC,"    ", VT, LF
0141   007F 20200B0A
0142   0083             
0143   0083             
0144   0083             
0145   0083             TABLE:
0146   0083 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
0146   0089 0000
0147   008B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
0147   0091 0000
0148   0093 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
0148   0099 0000
0149   009B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
0149   00A1 0000
0150   00A3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
0150   00A9 0000
0151   00AB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
0151   00B1 0000
0152   00B3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
0152   00B9 0000
0153   00BB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
0153   00C1 0000
0154   00C3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
0154   00C9 0000
0155   00CB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
0155   00D1 0000
0156   00D3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0156   00D9 0000
0157   00DB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
0157   00E1 0000
0158   00E3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0158   00E9 0000
0159   00EB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
0159   00F1 0000
0160   00F3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0160   00F9 0000
0161   00FB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
0161   0101 0000
0162   0103 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0162   0109 0000
0163   010B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
0163   0111 0000
0164   0113 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0164   0119 0000
0165   011B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
0165   0121 0000
0166   0123 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0166   0129 0000
0167   012B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
0167   0131 0000
0168   0133 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0168   0139 0000
0169   013B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
0169   0141 0000
0170   0143 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0170   0149 0000
0171   014B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
0171   0151 0000
0172   0153 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0172   0159 0000
0173   015B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
0173   0161 0000
0174   0163 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0174   0169 0000
0175   016B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
0175   0171 0000
0176   0173 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
0176   0179 0000
0177   017B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
0177   0181 0000
0178   0183             
0179   0183             ; DEC 32
0180   0183 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
0180   0189 0000
0181   018B 202020202000.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
0181   0191 2000
0182   0193 505050000000.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
0182   0199 0000
0183   019B 5050F850F850.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
0183   01A1 5000
0184   01A3 2078A07028F0.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
0184   01A9 2000
0185   01AB C0C810204098.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
0185   01B1 1800
0186   01B3 6090A040A890.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
0186   01B9 6800
0187   01BB 202020000000.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
0187   01C1 0000
0188   01C3 102040404020.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
0188   01C9 1000
0189   01CB 402010101020.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
0189   01D1 4000
0190   01D3 0020A870A820.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0190   01D9 0000
0191   01DB 002020F82020.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
0191   01E1 0000
0192   01E3 000000006020.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0192   01E9 4000
0193   01EB 000000F80000.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
0193   01F1 0000
0194   01F3 000000000060.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0194   01F9 6000
0195   01FB 000008102040.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
0195   0201 8000
0196   0203 708898A8C888.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0196   0209 7000
0197   020B 206020202020.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
0197   0211 7000
0198   0213 708808102040.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0198   0219 F800
0199   021B F81020100888.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
0199   0221 7000
0200   0223 10305090F810.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0200   0229 1000
0201   022B F880F0080888.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
0201   0231 7000
0202   0233 304080F08888.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0202   0239 7000
0203   023B F80810204040.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
0203   0241 4000
0204   0243 708888708888.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0204   0249 7000
0205   024B 708888780810.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
0205   0251 6000
0206   0253 000030300030.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0206   0259 3000
0207   025B 003030003010.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
0207   0261 2000
0208   0263 102040804020.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0208   0269 1000
0209   026B 0000F800F800.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
0209   0271 0000
0210   0273 402010081020.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
0210   0279 4000
0211   027B 304808102000.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
0211   0281 2000
0212   0283 70880868A8A8.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
0212   0289 7000
0213   028B             
0214   028B             ; DEC 65 Maiusculas
0215   028B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0215   0291 8800
0216   0293 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0216   0299 F000
0217   029B 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0217   02A1 7000
0218   02A3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0218   02A9 E000
0219   02AB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0219   02B1 F800
0220   02B3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0220   02B9 8000
0221   02BB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0221   02C1 7000
0222   02C3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0222   02C9 8800
0223   02CB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0223   02D1 7000
0224   02D3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0224   02D9 7000
0225   02DB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0225   02E1 8800
0226   02E3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0226   02E9 F800
0227   02EB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0227   02F1 8800
0228   02F3 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0228   02F9 8800
0229   02FB 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0229   0301 7000
0230   0303 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0230   0309 8000
0231   030B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0231   0311 7000
0232   0313 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0232   0319 8800
0233   031B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0233   0321 7000
0234   0323 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0234   0329 2000
0235   032B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0235   0331 7000
0236   0333 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0236   0339 2000
0237   033B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0237   0341 8800
0238   0343 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0238   0349 8800
0239   034B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0239   0351 2000
0240   0353 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0240   0359 F800
0241   035B             
0242   035B             ; DEC 91
0243   035B 302020202020.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
0243   0361 3000
0244   0363 008040201008.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0244   0369 0000
0245   036B 602020202020.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
0245   0371 6000
0246   0373 205088000000.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
0246   0379 0000
0247   037B 000000000000.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
0247   0381 F800
0248   0383 402010000000.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
0248   0389 0000
0249   038B             
0250   038B             ; DEC 97 "Minusculas"
0251   038B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0251   0391 8800
0252   0393 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0252   0399 F000
0253   039B 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0253   03A1 7000
0254   03A3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0254   03A9 E000
0255   03AB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0255   03B1 F800
0256   03B3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0256   03B9 8000
0257   03BB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0257   03C1 7000
0258   03C3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0258   03C9 8800
0259   03CB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0259   03D1 7000
0260   03D3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0260   03D9 7000
0261   03DB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0261   03E1 8800
0262   03E3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0262   03E9 F800
0263   03EB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0263   03F1 8800
0264   03F3 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0264   03F9 8800
0265   03FB 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0265   0401 7000
0266   0403 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0266   0409 8000
0267   040B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0267   0411 7000
0268   0413 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0268   0419 8800
0269   041B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0269   0421 7000
0270   0423 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0270   0429 2000
0271   042B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0271   0431 7000
0272   0433 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0272   0439 2000
0273   043B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0273   0441 8800
0274   0443 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0274   0449 8800
0275   044B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0275   0451 2000
0276   0453 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0276   0459 F800
0277   045B             
0278   045B             ; DEC 123
0279   045B 102020402020.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0279   0461 1000
0280   0463 202020202020.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0280   0469 2000
0281   046B 402020102020.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0281   0471 4000
0282   0473 000050A00000.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0282   0479 0000
0283   047B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0283   0481 0000
0284   0483             
0285   0483             
0286   0483             
0287   0483             
0288   0483             
0289   0483             ; -----------------------------------------------------------------------------
0290   0483             ;   INICIO
0291   0483             ; -----------------------------------------------------------------------------
0292   0483             INICIO:
0293   0483 31 00 FD        LD  SP, SYSTEM
0294   0486             
0295   0486 3E 00           LD A, 0
0296   0488 32 B1 FF        LD (PORT_OUT_VAL), A
0297   048B             
0298   048B 3E C0           LD A, $c0
0299   048D 32 B0 FF        LD (PORT_SET), A
0300   0490             
0301   0490                 ; init serial
0302   0490 CD 43 0D        CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0303   0493 21 DE 0C        LD    HL,TXDATA
0304   0496 22 AA FF        LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0305   0499 21 09 0D        LD    HL,RXDATA
0306   049C 22 AC FF        LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
0307   049F                 
0308   049F 21 1B 00        LD	HL,B4800
0309   04A2 22 C0 FF    	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
0310   04A5             
0311   04A5 3E FF           LD A, $FF
0312   04A7 D3 C0           OUT (SERIAL_TX_PORT), A
0313   04A9             
0314   04A9 21 2C 0F        LD HL, WELLCOME
0315   04AC CD C4 0C        CALL SNDMSG
0316   04AF             
0317   04AF                 ; CALL INCH
0318   04AF                 ; CALL OUTCH
0319   04AF             
0320   04AF                 ; Init LCD hardware
0321   04AF CD FA 09        CALL INIT_LCD
0322   04B2 CD 8B 0B        call delay
0323   04B5             
0324   04B5 CD 12 0B        call cls_TXT
0325   04B8 CD 8B 0B        call delay
0326   04BB             
0327   04BB CD 9C 0A        CALL enable_grafic
0328   04BE CD 8B 0B        call delay
0329   04C1             
0330   04C1 CD 18 0B        call cls_GRAPHIC
0331   04C4 CD 8B 0B        call delay
0332   04C7             
0333   04C7 CD 8E 0A        call lcd_clear
0334   04CA             
0335   04CA 21 00 E5        ld hl, DISPLAY
0336   04CD CD B5 0A        call print_image
0337   04D0             
0338   04D0 CD 8B 0B        call delay
0339   04D3             
0340   04D3                 ; Init LCD logical
0341   04D3 CD F9 07        call INIT_TXT_LCD ; set cursor X Y to 0
0342   04D6             
0343   04D6 21 44 0F        LD HL, MSG_MONITOR
0344   04D9 CD B6 0C        CALL SNDLCDMSG
0345   04DC             
0346   04DC 3E 3E           LD A, '>'
0347   04DE CD 88 08        CALL PRINTCHAR
0348   04E1             
0349   04E1             KEY:
0350   04E1 CD AF 0B        CALL KEYREADINIT
0351   04E4             
0352   04E4 FE 48           CP 'H'
0353   04E6 CC BD 06        CALL Z, SHOWHELP
0354   04E9             
0355   04E9 FE 42           CP 'B'
0356   04EB CA 00 60        JP Z, BASIC
0357   04EE             
0358   04EE FE 49           CP 'I'
0359   04F0 CA B1 06        JP Z, INTEL_HEX
0360   04F3             
0361   04F3 FE 31           CP '1'
0362   04F5 CC 59 0D        CALL Z, I2CLIST
0363   04F8             
0364   04F8 FE 32           CP '2'
0365   04FA CC 26 06        CALL Z, I2CCPUTOMEM
0366   04FD             
0367   04FD FE 33           CP '3'
0368   04FF CC FE 05        CALL Z, I2CMEMTOCPU
0369   0502             
0370   0502 FE 47           CP 'G'
0371   0504 CC 55 07        CALL Z, GOJUMP
0372   0507             
0373   0507 FE 4D           CP 'M'
0374   0509 CC F3 06        CALL Z, MODIFY
0375   050C             
0376   050C FE 44           CP 'D'
0377   050E CC 80 05        CALL Z, DSPLAY
0378   0511             
0379   0511 3E 0D           LD A, CR 
0380   0513 CD 88 08        CALL PRINTCHAR
0381   0516             
0382   0516 3E 3E           LD A, '>' 
0383   0518 CD 88 08        CALL PRINTCHAR
0384   051B             
0385   051B C3 E1 04        JP  KEY
0386   051E             
0387   051E             
0388   051E             ; **********************************************************************
0389   051E             ; **  Public functions                                                **
0390   051E             ; **********************************************************************
0391   051E             ; API: Main entry point
0392   051E             ;   On entry: C = Function number
0393   051E             ;             A, DE = Parameters (as specified by function)
0394   051E             ;   On exit:  AF,BC,DE,HL = Return values (as specified by function)
0395   051E             ;             IX IY I AF' BC' DE' HL' preserved
0396   051E             ; This handler modifies: F, B, HL but preserves A, C, DE
0397   051E             ; Other registers depend on API function called
0398   051E 21 30 05    APIHandler: LD   HL,APITable    ;Start of function address table
0399   0521 47                      LD   B,A            ;Preserve A
0400   0522 79                      LD   A,C            ;Get function number
0401   0523 FE 09                   CP   kAPILast+1     ;Supported function?
0402   0525 D0                      RET  NC             ;No, so abort
0403   0526 78                      LD   A,B            ;Restore A
0404   0527 06 00                   LD   B,0
0405   0529 09                      ADD  HL,BC          ;Calculate table pointer..
0406   052A 09                      ADD  HL,BC
0407   052B 46                      LD   B,(HL)         ;Read function address from table..
0408   052C 23                      INC  HL
0409   052D 66                      LD   H,(HL)
0410   052E 68                      LD   L,B
0411   052F E9                      JP   (HL)           ;Jump to function address
0412   0530             
0413   0530             
0414   0530             ; API: Function address table
0415   0530             ; This table contains a list of addresses, one for each API function. 
0416   0530             ; Each is the address of the subroutine for the relevant function.
0417   0530 42 05       APITable:   .DW  SysReset       ; 0x00 = System reset
0418   0532 45 05                   .DW  InputCharKey   ; 0x01 = Input character KeyboardOnboard (Char in A)
0419   0534 48 05                   .DW  OutLcdChar     ; 0x02 = Output character LCD (Char in A)
0420   0536 4B 05                   .DW  OutLcdNewLine  ; 0x03 = Output new line LCD
0421   0538 6B 05                   .DW  H_Delay        ; 0x04 = Delay in milliseconds
0422   053A 50 05                   .DW  PrtSet         ; 0x05 = Set Port (Default C0)
0423   053C 54 05                   .DW  PrtOWr         ; 0x06 = Write to output port
0424   053E 60 05                   .DW  PrtORd         ; 0x07 = Read from output port
0425   0540 64 05                   .DW  PrtIRd         ; 0x08 = Read from input port
0426   0542             kAPILast:   .EQU $08           ;Last API function number
0427   0542             
0428   0542             
0429   0542             SysReset:
0430   0542 C3 83 04        JP INICIO
0431   0545             
0432   0545             InputCharKey:
0433   0545 C3 AF 0B        JP KEYREADINIT
0434   0548             
0435   0548             OutLcdChar:
0436   0548 C3 88 08        JP PRINTCHAR
0437   054B             
0438   054B             OutLcdNewLine:
0439   054B 3E 0D           LD A, CR
0440   054D C3 88 08        JP PRINTCHAR
0441   0550             
0442   0550             PrtSet:
0443   0550 32 B0 FF        LD (PORT_SET), A ; define a porta padrão de entrada e saida
0444   0553 C9              RET
0445   0554             
0446   0554             PrtOWr:
0447   0554 47              LD B, A
0448   0555 3A B0 FF        LD A, (PORT_SET)
0449   0558 4F              LD C, A
0450   0559 78              LD A, B
0451   055A 32 B1 FF        LD (PORT_OUT_VAL), A
0452   055D ED 79           out (C), A
0453   055F C9              RET
0454   0560             
0455   0560             PrtORd: ; Return value from output port
0456   0560 3A B1 FF        LD A, (PORT_OUT_VAL)
0457   0563 C9              RET
0458   0564             
0459   0564             PrtIRd: ; Return value from input
0460   0564 3A B0 FF        LD A, (PORT_SET)
0461   0567 4F              LD C, A
0462   0568 ED 78           in A, (C)
0463   056A C9              RET
0464   056B             
0465   056B             
0466   056B             ; **********************************************************************
0467   056B             ; Delay by DE milliseconds
0468   056B             ;   On entry: DE = Delay time in milliseconds
0469   056B             ;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
0470   056B F5          H_Delay:    PUSH AF
0471   056C C5                      PUSH BC
0472   056D D5                      PUSH DE
0473   056E             ; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
0474   056E 01 98 00    LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
0475   0571             ; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
0476   0571 0B          LoopBC:    DEC  BC             ;[6]     [4]
0477   0572 79                      LD   A,C            ;[4]     [4]
0478   0573 B0                      OR   B              ;[4]     [4]
0479   0574 C2 71 05                JP   NZ,LoopBC     ;[12/7]  [8/6] 
0480   0577             ; Have we looped once for each millisecond requested?
0481   0577 1B                      DEC  DE             ;[6]     [4]
0482   0578 7B                      LD   A,E            ;[4]     [4]
0483   0579 B2                      OR   D              ;[4]     [4]
0484   057A 20 F2                   JR   NZ, LoopDE     ;[12/7]  [8/6]
0485   057C D1                      POP  DE
0486   057D C1                      POP  BC
0487   057E F1                      POP  AF
0488   057F C9                      RET
0489   0580             
0490   0580             ;--------------------------
0491   0580             ; D DISPLAY MEMORY LOCATION
0492   0580             ;--------------------------
0493   0580 3E 44       DSPLAY: LD A, 'D'
0494   0582 CD 88 08            CALL PRINTCHAR
0495   0585 CD 7D 07            CALL  OUTSP       ;A SPACE
0496   0588 CD 89 07           CALL  GETCHR
0497   058B D8                 RET   C         
0498   058C 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0499   058F CD 89 07           CALL  GETCHR
0500   0592 D8                 RET   C
0501   0593 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0502   0596             ;
0503   0596             ; WAIT FOR CR OR ESC
0504   0596             ;
0505   0596 CD AF 0B    DPLAY1: CALL  KEYREADINIT
0506   0599 FE 1B              CP    ESC
0507   059B C8                 RET   Z
0508   059C FE 0D              CP    CR
0509   059E 20 F6              JR    NZ,DPLAY1          
0510   05A0 CD 83 07           CALL  TXCRLF      ;NEWLINE
0511   05A3             ;
0512   05A3             ; DISPLAY THE LINE
0513   05A3             ;
0514   05A3 CD B8 05    DPLAY2: CALL  DPLINE
0515   05A6 ED 53 B0 FE        LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
0516   05AA             ;
0517   05AA             ; DISPLAY MORE LINES OR EXIT
0518   05AA             ;       
0519   05AA CD AF 0B    DPLAY3: CALL  KEYREADINIT
0520   05AD 38 FB              JR    C,DPLAY3   
0521   05AF FE 0D              CP    CR        ;ENTER DISPLAYS THE NEXT LINE
0522   05B1 28 F0              JR    Z,DPLAY2
0523   05B3 FE 1B              CP    ESC         ;ESC EXITS (SHIFT + C)
0524   05B5 20 F3              JR    NZ,DPLAY3     
0525   05B7 C9                 RET   
0526   05B8             ;-------------------------
0527   05B8             ; DISPLAY A LINE OF MEMORY
0528   05B8             ;-------------------------      
0529   05B8 ED 5B B0 FE DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
0530   05BC 21 00 FE           LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
0531   05BF             ;
0532   05BF             ; DISPLAY THE ADDRESS
0533   05BF             ;         
0534   05BF CD E0 07           CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
0535   05C2 CD F8 05           CALL  SPCBUF        
0536   05C5             ;
0537   05C5             ; DISPLAY 4 BYTES
0538   05C5             ;
0539   05C5 06 04              LD    B,4 ;16
0540   05C7 1A          DLINE1: LD    A,(DE)
0541   05C8 CD E5 07           CALL  BYTASC
0542   05CB CD F8 05           CALL  SPCBUF
0543   05CE 13                 INC   DE        
0544   05CF 10 F6              DJNZ  DLINE1
0545   05D1                    ;CALL  SPCBUF
0546   05D1             ;
0547   05D1             ; NOW DISPLAY THE ASCII CHARACTER
0548   05D1             ; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
0549   05D1             ; BE DIFFERENT BETWEEN THE TWO PASSES!
0550   05D1             ;
0551   05D1 ED 5B B0 FE        LD    DE,(ADDR)    
0552   05D5 06 04              LD    B,4 ;16
0553   05D7 1A          DLINE2: LD    A,(DE)   
0554   05D8 FE 20              CP    20H
0555   05DA 38 07              JR    C,DOT
0556   05DC FE 7F              CP    7FH
0557   05DE 30 03              JR    NC,DOT
0558   05E0 C3 E5 05           JP    NDOT
0559   05E3 3E 2E       DOT:    LD    A,'.'
0560   05E5 CD FA 05    NDOT:   CALL  INBUF
0561   05E8 13                 INC   DE       
0562   05E9 10 EC              DJNZ  DLINE2
0563   05EB             ;         
0564   05EB             ;TERMINATE AND DISPLAY STRING
0565   05EB             ;       
0566   05EB CD FD 05           CALL  BCRLF
0567   05EE 3E 00              LD    A,00H
0568   05F0 77                 LD    (HL),A
0569   05F1 21 00 FE           LD    HL,MSGBUF
0570   05F4 CD B6 0C           CALL  SNDLCDMSG
0571   05F7 C9                 RET
0572   05F8             
0573   05F8             
0574   05F8             ;
0575   05F8             ; PUT A SPACE IN THE BUFFER
0576   05F8             ;
0577   05F8 3E 08       SPCBUF: LD    A, 8 ;20H(32dec)
0578   05FA 77          INBUF:  LD    (HL),A
0579   05FB 23                 INC   HL
0580   05FC C9                 RET
0581   05FD             ;
0582   05FD             ; PUT A CR LF IN THE BUFFER
0583   05FD             ;        
0584   05FD             BCRLF:  ;LD    A,CR  
0585   05FD                    ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
0586   05FD C9                 RET
0587   05FE             
0588   05FE             
0589   05FE             
0590   05FE             
0591   05FE             
0592   05FE             
0593   05FE             I2CMEMTOCPU:
0594   05FE                 ; Get parameters to copy a block from I2C memory to CPU memory
0595   05FE             ;   On entry: DE = First address in I2C memory
0596   05FE             ;             HL = First address in CPU memory
0597   05FE             ;             BC = Number of bytes to be copied
0598   05FE             ;             SCL = unknown, SDA = unknown
0599   05FE             ;   On exit:  If successfully A = 0 and Z flagged
0600   05FE             ;             If unsuccessfully A = Error and NZ flagged
0601   05FE             ;             IX IY preserved
0602   05FE             
0603   05FE 21 F7 0F        LD HL, MSG_MEM2CPU
0604   0601 CD B6 0C        CALL SNDLCDMSG
0605   0604             
0606   0604 CD 4E 06        CALL GET_FROM_TO_SIZE
0607   0607             
0608   0607             ;    DE = First address in I2C memory
0609   0607             ;    HL = First address in CPU memory
0610   0607             ;    BC = Number of bytes to be copied
0611   0607             
0612   0607 ED 5B B2 FE     LD DE, (ADDR_FROM)
0613   060B 2A B4 FE        LD HL, (ADDR_TO)
0614   060E ED 4B B6 FE     LD BC, (ADDR_SIZE)
0615   0612 CD 83 0D        CALL I2C_MemRd  
0616   0615             
0617   0615 CA 1F 06        JP Z, I2CMEMTOCPU_OK
0618   0618 21 48 10        LD HL, MSG_COPYFAIL
0619   061B CD B6 0C        CALL SNDLCDMSG
0620   061E C9              RET
0621   061F             I2CMEMTOCPU_OK:
0622   061F 21 3F 10        LD HL, MSG_COPYOK
0623   0622 CD B6 0C        CALL SNDLCDMSG
0624   0625 C9              RET
0625   0626             
0626   0626             
0627   0626             I2CCPUTOMEM:
0628   0626             ; Get parameters to copy a block from CPU memory to I2C memory
0629   0626             ;   On entry: DE = First address in I2C memory
0630   0626             ;             HL = First address in CPU memory
0631   0626             ;             BC = Number of bytes to be copied
0632   0626             ;             SCL = unknown, SDA = unknown
0633   0626             ;   On exit:  If successfully A = 0 and Z flagged
0634   0626             ;             If unsuccessfully A = Error and NZ flagged
0635   0626             ;             IX IY preserved
0636   0626             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
0637   0626             ; pages.
0638   0626 21 0D 10        LD HL, MSG_CPU2MEM
0639   0629 CD B6 0C        CALL SNDLCDMSG
0640   062C             
0641   062C CD 4E 06        CALL GET_FROM_TO_SIZE
0642   062F             
0643   062F             ;    DE = First address in I2C memory
0644   062F             ;    HL = First address in CPU memory
0645   062F             ;    BC = Number of bytes to be copied
0646   062F             
0647   062F 2A B2 FE        LD HL, (ADDR_FROM)
0648   0632 ED 5B B4 FE     LD DE, (ADDR_TO)
0649   0636 ED 4B B6 FE     LD BC, (ADDR_SIZE)
0650   063A CD B8 0D        CALL I2C_MemWr
0651   063D                 
0652   063D CA 47 06        JP Z, I2CCPUTOMEM_OK
0653   0640 21 48 10        LD HL, MSG_COPYFAIL
0654   0643 CD B6 0C        CALL SNDLCDMSG
0655   0646 C9              RET
0656   0647             I2CCPUTOMEM_OK:
0657   0647 21 3F 10        LD HL, MSG_COPYOK
0658   064A CD B6 0C        CALL SNDLCDMSG
0659   064D C9              RET
0660   064E             
0661   064E             
0662   064E             
0663   064E             
0664   064E             
0665   064E             
0666   064E             GET_FROM_TO_SIZE:
0667   064E                 ; FROM
0668   064E 21 23 10        LD HL, MSG_FROM
0669   0651 CD B6 0C        CALL SNDLCDMSG
0670   0654                 ;
0671   0654                 ;GET THE ADDRESS  FROM
0672   0654                 ;
0673   0654 CD 89 07        CALL  GETCHR 
0674   0657 D8              RET   C        
0675   0658 32 B3 FE        LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
0676   065B CD 89 07        CALL  GETCHR
0677   065E D8              RET   C
0678   065F 32 B2 FE        LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW
0679   0662             
0680   0662 CD AF 0B        CALL  KEYREADINIT
0681   0665 FE 1B           CP    ESC         ;ESC KEY?
0682   0667 C8              RET   Z
0683   0668 FE 0D           CP    CR
0684   066A 28 08           JR Z, GET_FROM_TO_SIZE_TO
0685   066C 3E 0D           LD A, CR
0686   066E CD 88 08        CALL PRINTCHAR
0687   0671 C3 4E 06        JP GET_FROM_TO_SIZE
0688   0674             
0689   0674             GET_FROM_TO_SIZE_TO:
0690   0674                 ; TO
0691   0674 21 2A 10        LD HL, MSG_TO
0692   0677 CD B6 0C        CALL SNDLCDMSG
0693   067A                 ;
0694   067A                 ;GET THE ADDRESS  TO
0695   067A                 ;
0696   067A CD 89 07        CALL  GETCHR 
0697   067D D8              RET   C        
0698   067E 32 B5 FE        LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
0699   0681 CD 89 07        CALL  GETCHR
0700   0684 D8              RET   C
0701   0685 32 B4 FE        LD    (ADDR_TO),A    ;SAVE ADDRESS LOW
0702   0688             
0703   0688 CD AF 0B        CALL  KEYREADINIT
0704   068B FE 1B           CP    ESC         ;ESC KEY?
0705   068D C8              RET   Z
0706   068E FE 0D           CP    CR
0707   0690 20 E2           JR NZ, GET_FROM_TO_SIZE_TO
0708   0692             
0709   0692             GET_FROM_TO_SIZE_SIZE:
0710   0692                 ; SIZE
0711   0692 21 30 10        LD HL, MSG_SIZE
0712   0695 CD B6 0C        CALL SNDLCDMSG
0713   0698                 ;
0714   0698                 ;GET THE SIZE
0715   0698                 ;
0716   0698 CD 89 07        CALL  GETCHR 
0717   069B D8              RET   C        
0718   069C 32 B7 FE        LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
0719   069F CD 89 07        CALL  GETCHR
0720   06A2 D8              RET   C
0721   06A3 32 B6 FE        LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW
0722   06A6             
0723   06A6 CD AF 0B        CALL  KEYREADINIT
0724   06A9 FE 1B           CP    ESC         ;ESC KEY?
0725   06AB C8              RET   Z
0726   06AC FE 0D           CP    CR
0727   06AE 20 E2           JR NZ, GET_FROM_TO_SIZE_SIZE
0728   06B0 C9              RET
0729   06B1             
0730   06B1             
0731   06B1             INTEL_HEX:
0732   06B1 CD 03 0C        CALL INTHEX
0733   06B4 CD 8B 0B        CALL delay
0734   06B7 CD 8B 0B        CALL delay
0735   06BA C3 83 04        JP INICIO
0736   06BD             
0737   06BD             SHOWHELP:
0738   06BD 3E 0C           LD A, $0C ; limpar tela
0739   06BF CD 88 08        CALL PRINTCHAR
0740   06C2             
0741   06C2 21 59 0F        LD HL, MSG_MENU1
0742   06C5 CD B6 0C        CALL SNDLCDMSG
0743   06C8             
0744   06C8 21 6F 0F        LD HL, MSG_MENU2
0745   06CB CD B6 0C        CALL SNDLCDMSG
0746   06CE             
0747   06CE 21 7A 0F        LD HL, MSG_MENU3
0748   06D1 CD B6 0C        CALL SNDLCDMSG
0749   06D4             
0750   06D4 21 8C 0F        LD HL, MSG_MENU4
0751   06D7 CD B6 0C        CALL SNDLCDMSG
0752   06DA             
0753   06DA 21 9D 0F        LD HL, MSG_MENU5
0754   06DD CD B6 0C        CALL SNDLCDMSG
0755   06E0             
0756   06E0 21 AD 0F        LD HL, MSG_MENU6
0757   06E3 CD B6 0C        CALL SNDLCDMSG
0758   06E6             
0759   06E6 21 BB 0F        LD HL, MSG_MENU7
0760   06E9 CD B6 0C        CALL SNDLCDMSG
0761   06EC             
0762   06EC 21 CE 0F        LD HL, MSG_MENU8
0763   06EF CD B6 0C        CALL SNDLCDMSG
0764   06F2             
0765   06F2 C9              RET
0766   06F3             
0767   06F3             
0768   06F3             ;----------------------------
0769   06F3             ; M DISPLAY AND MODIFY MEMORY
0770   06F3             ;----------------------------
0771   06F3 3E 4D       MODIFY: LD A, 'M'
0772   06F5 CD 88 08            CALL PRINTCHAR
0773   06F8 CD 7D 07         CALL  OUTSP
0774   06FB             ;
0775   06FB             ;GET THE ADDRESS        
0776   06FB             ;
0777   06FB CD 89 07           CALL  GETCHR 
0778   06FE D8                 RET   C        
0779   06FF 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0780   0702 CD 89 07           CALL  GETCHR
0781   0705 D8                 RET   C
0782   0706 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0783   0709             ;
0784   0709             ; DISPLAY ON A NEW LINE
0785   0709             ;       
0786   0709 CD 83 07    MDIFY1: CALL  TXCRLF       
0787   070C ED 5B B0 FE        LD    DE,(ADDR)    
0788   0710 21 00 FE           LD    HL,MSGBUF   
0789   0713 CD E0 07           CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
0790   0716 21 00 FE           LD    HL,MSGBUF
0791   0719 CD D4 07           CALL  WRDOUT      ;OUTPUT THE ADDRESS
0792   071C CD 7D 07           CALL  OUTSP    
0793   071F             ;      
0794   071F             ;GET THE DATA AT THE ADDRESS        
0795   071F             ;
0796   071F 2A B0 FE            LD   HL,(ADDR)       
0797   0722 7E                  LD   A,(HL)
0798   0723             ;
0799   0723             ; DISPLAY THE DATA
0800   0723             ;        
0801   0723 21 00 FE           LD    HL,MSGBUF
0802   0726 CD E5 07           CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
0803   0729 21 00 FE           LD    HL,MSGBUF
0804   072C CD D7 07           CALL  BYTOUT      ;OUTPUT THE BYTE
0805   072F CD 7D 07           CALL  OUTSP
0806   0732             ;
0807   0732             ; GET NEW DATA,EXIT OR CONTINUE
0808   0732             ;
0809   0732 CD 89 07           CALL  GETCHR
0810   0735 D8                 RET   C
0811   0736 47                 LD    B,A         ;SAVE IT FOR LATER
0812   0737 2A B0 FE           LD    HL,(ADDR)
0813   073A 77                 LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
0814   073B 78                 LD    A,B
0815   073C BE                 CP    (HL)
0816   073D 28 05              JR    Z,MDIFY2
0817   073F 3E 3F              LD    A,'?'
0818   0741 CD 88 08           CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
0819   0744             ;
0820   0744             ; INCREMENT THE ADDRESS
0821   0744             ;
0822   0744 23          MDIFY2: INC   HL
0823   0745 22 B0 FE           LD    (ADDR),HL
0824   0748 C3 09 07           JP    MDIFY1
0825   074B             
0826   074B             
0827   074B             
0828   074B             ;------------------------------
0829   074B             ; GO <ADDR>
0830   074B             ; TRANSFERS EXECUTION TO <ADDR>
0831   074B             ;------------------------------
0832   074B             GOJUMP_new:
0833   074B 3E 0D           LD A, CR
0834   074D CD 88 08        CALL PRINTCHAR
0835   0750             
0836   0750 3E 3E           LD A, '>'
0837   0752 CD 88 08        CALL PRINTCHAR
0838   0755             
0839   0755 3E 47       GOJUMP: LD A, 'G'
0840   0757 CD 88 08            CALL PRINTCHAR
0841   075A CD 7D 07           CALL  OUTSP       
0842   075D CD 89 07           CALL  GETCHR      ;GET ADDRESS HIGH BYTE
0843   0760 D8                 RET   C
0844   0761 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0845   0764 CD 89 07           CALL  GETCHR      ;GET ADDRESS LOW BYTE
0846   0767 D8                 RET   C
0847   0768 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0848   076B             ;
0849   076B             ; WAIT FOR A CR OR ESC
0850   076B             ;       
0851   076B CD AF 0B    GOJMP1: CALL  KEYREADINIT
0852   076E FE 1B              CP    ESC         ;ESC KEY?
0853   0770 C8                 RET   Z
0854   0771 FE 0D              CP    CR
0855   0773                    ;JR    NZ,GOJMP1
0856   0773 20 D6              JR NZ, GOJUMP_new
0857   0775 CD 83 07           CALL  TXCRLF
0858   0778 E1                 POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
0859   0779 2A B0 FE           LD    HL,(ADDR)
0860   077C E9                 JP    (HL)        ;GOOD LUCK WITH THAT!
0861   077D             
0862   077D             
0863   077D             ;---------------
0864   077D             ; OUTPUT A SPACE
0865   077D             ;---------------
0866   077D 3E 20       OUTSP:  LD    A, ' '
0867   077F CD 88 08           CALL  PRINTCHAR
0868   0782 C9                 RET
0869   0783             
0870   0783             ;-------------      
0871   0783             ; OUTPUT CRLF
0872   0783             ;------------
0873   0783 3E 0D       TXCRLF: LD   A,CR
0874   0785 CD 88 08           CALL PRINTCHAR   
0875   0788 C9                 RET
0876   0789             
0877   0789             ;-----------------------------
0878   0789             ; GET A BYTE FROM THE TERMINAL
0879   0789             ;-----------------------------
0880   0789 CD AF 0B    GETCHR: CALL KEYREADINIT ; read key
0881   078C FE 1B              CP    ESC
0882   078E 28 27              JR    Z,GETOUT
0883   0790 47                 LD    B,A                ;SAVE TO ECHO      
0884   0791 CD B9 07           CALL  ASC2HEX
0885   0794 30 F3              JR    NC,GETCHR          ;REJECT NON HEX CHARS    
0886   0796 21 B8 FE           LD    HL,DATA
0887   0799 77                 LD    (HL),A 
0888   079A 78                 LD    A,B         
0889   079B CD 88 08           CALL  PRINTCHAR             ;ECHO VALID HEX
0890   079E                    
0891   079E CD AF 0B    GETNYB: CALL  KEYREADINIT
0892   07A1 FE 1B              CP    ESC
0893   07A3 28 12              JR    Z,GETOUT
0894   07A5 47                 LD    B,A               ;SAVE TO ECHO
0895   07A6 CD B9 07           CALL  ASC2HEX
0896   07A9 30 F3              JR    NC,GETNYB         ;REJECT NON HEX CHARS
0897   07AB ED 6F              RLD
0898   07AD 78                 LD    A,B
0899   07AE CD 88 08           CALL  PRINTCHAR             ;ECHO VALID HEX
0900   07B1 7E                 LD    A,(HL)
0901   07B2 CD B7 07           CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
0902   07B5 3F                 CCF                    ;AND THEN COMPLEMENTING IT
0903   07B6 C9                 RET   
0904   07B7 37          GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
0905   07B8 C9                 RET
0906   07B9             
0907   07B9             
0908   07B9             ;----------------------------------------
0909   07B9             ; CONVERT ASCII CHARACTER INTO HEX NYBBLE
0910   07B9             ;----------------------------------------
0911   07B9             ; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
0912   07B9             ; ENTRY OTHER THAN HEXADECIMAL KEYS
0913   07B9             ;
0914   07B9             ;CONVERTS ASCII 0-9,A-F INTO HEX LSN
0915   07B9             ;ENTRY : A= ASCII 0-9,A-F
0916   07B9             ;EXIT  : CARRY =  1
0917   07B9             ;          A= HEX 0-F IN LSN    
0918   07B9             ;      : CARRY = 0
0919   07B9             ;          A= OUT OF RANGE CHARACTER & 7FH
0920   07B9             ; A AND F REGISTERS MODIFIED
0921   07B9             ;
0922   07B9 E6 7F       ASC2HEX: AND   7FH        ;STRIP OUT PARITY
0923   07BB FE 30              CP    30H
0924   07BD 38 12              JR    C,AC2HEX3    ;LESS THAN 0
0925   07BF FE 3A              CP    3AH
0926   07C1 30 02              JR    NC,AC2HEX2   ;MORE THAN 9
0927   07C3 37          AC2HEX1: SCF               ;SET THE CARRY - IS HEX
0928   07C4 C9                 RET
0929   07C5             ;     
0930   07C5 FE 41       AC2HEX2: CP    41H
0931   07C7 38 08              JR    C,AC2HEX3    ;LESS THAN A
0932   07C9 FE 47              CP    47H
0933   07CB 30 04              JR    NC,AC2HEX3   ;MORE THAN F
0934   07CD D6 07              SUB   07H        ;CONVERT TO NYBBLE
0935   07CF 18 F2              JR    AC2HEX1  
0936   07D1 E6 FF       AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
0937   07D3 C9                 RET
0938   07D4             
0939   07D4             
0940   07D4             ;----------------------     
0941   07D4             ; SEND ASCII HEX VALUES        
0942   07D4             ;----------------------
0943   07D4             ;
0944   07D4             ; OUTPUT THE 4 BYTE, WRDOUT
0945   07D4             ; THE 2 BYTE, BYTOUT
0946   07D4             ; OR THE SINGLE BYTE, NYBOUT
0947   07D4             ; ASCII STRING AT HL TO THE SERIAL PORT
0948   07D4             ;
0949   07D4 CD D7 07    WRDOUT: CALL  BYTOUT
0950   07D7 CD DA 07    BYTOUT: CALL  NYBOUT
0951   07DA 7E          NYBOUT: LD    A,(HL)
0952   07DB CD 88 08           CALL  PRINTCHAR
0953   07DE 23                 INC   HL
0954   07DF C9                 RET       
0955   07E0             ;----------------
0956   07E0             ;CONVERT TO ASCII 
0957   07E0             ;----------------
0958   07E0             ;
0959   07E0             ; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
0960   07E0             ;
0961   07E0             ;         ENTRY :  A = BINARY TO CONVERT
0962   07E0             ;                  HL = CHARACTER BUFFER ADDRESS   
0963   07E0             ;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
0964   07E0             ;   
0965   07E0             ;        MODIFIES : DE
0966   07E0             
0967   07E0 7A          WRDASC: LD    A,D         ;CONVERT AND
0968   07E1 CD E5 07           CALL  BYTASC      ;OUTPUT D
0969   07E4 7B                 LD    A,E         ;THEN E
0970   07E5             ;
0971   07E5             ;CONVERT A BYTE TO ASCII 
0972   07E5             ;
0973   07E5 F5          BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
0974   07E6 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
0975   07E7 0F                 RRCA
0976   07E8 0F                 RRCA
0977   07E9 0F                 RRCA
0978   07EA CD EE 07           CALL NYBASC       ;CALL NYBBLE CONVERTER 
0979   07ED F1                 POP AF            ;RESTORE LOW NYBBLE
0980   07EE             
0981   07EE             ;           
0982   07EE             ; CONVERT A NYBBLE TO ASCII
0983   07EE             ;
0984   07EE E6 0F       NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
0985   07F0 C6 90              ADD   A,90H       ;CONVERT TO
0986   07F2 27                 DAA               ;ASCII
0987   07F3 CE 40              ADC   A,40H
0988   07F5 27                 DAA
0989   07F6             ;            
0990   07F6             ; SAVE IN STRING
0991   07F6             ;
0992   07F6 77          INSBUF: LD    (HL),A
0993   07F7 23                 INC   HL 
0994   07F8 C9                 RET 
0995   07F9             
0996   07F9             
0997   07F9             
0998   07F9             INIT_TXT_LCD:
0999   07F9 3E 00           ld a, 0
1000   07FB 32 03 E0        ld (LCD_TXT_X), a
1001   07FE 32 04 E0        ld (LCD_TXT_Y), a
1002   0801 32 0F E0        ld (LCD_DELETE_CHAR), a
1003   0804 32 10 E0        ld (LCD_AUTO_X), a
1004   0807 21 00 00        ld hl, 0
1005   080A 22 08 E0        ld (LCD_TXT_X_TMP), hl
1006   080D 23              inc hl
1007   080E 22 0A E0        ld (LCD_TXT_Y_TMP), hl
1008   0811 C9              RET
1009   0812             
1010   0812             
1011   0812             DISPLAY_SCROLL_UP:
1012   0812                 ; cada linha tem 128 bytes
1013   0812                 ; temos 8 linhas
1014   0812                 ; total 1024 bytes
1015   0812             
1016   0812                 ; display lines 0 to 7
1017   0812                 ; move line 1 to 0
1018   0812 21 80 E5        ld hl, DISPLAY+128
1019   0815 11 00 E5        ld de, DISPLAY
1020   0818 01 7F 00        ld bc, 127
1021   081B ED B0           ldir
1022   081D             
1023   081D                 ; move line 2 to 1
1024   081D 21 00 E6        ld hl, DISPLAY+256
1025   0820 11 80 E5        ld de, DISPLAY+128
1026   0823 01 7F 00        ld bc, 127
1027   0826 ED B0           ldir
1028   0828             
1029   0828                 ; move line 3 to 2
1030   0828 21 80 E6        ld hl, DISPLAY+384
1031   082B 11 00 E6        ld de, DISPLAY+256
1032   082E 01 7F 00        ld bc, 127
1033   0831 ED B0           ldir
1034   0833             
1035   0833                 ; move line 4 to 3
1036   0833 21 00 E7        ld hl, DISPLAY+512
1037   0836 11 80 E6        ld de, DISPLAY+384
1038   0839 01 7F 00        ld bc, 127
1039   083C ED B0           ldir
1040   083E             
1041   083E                 ; move line 5 to 4
1042   083E 21 80 E7        ld hl, DISPLAY+640
1043   0841 11 00 E7        ld de, DISPLAY+512
1044   0844 01 7F 00        ld bc, 127
1045   0847 ED B0           ldir
1046   0849             
1047   0849                 ; move line 6 to 5
1048   0849 21 00 E8        ld hl, DISPLAY+768
1049   084C 11 80 E7        ld de, DISPLAY+640
1050   084F 01 7F 00        ld bc, 127
1051   0852 ED B0           ldir
1052   0854             
1053   0854                 ; move line 7 to 6
1054   0854 21 80 E8        ld hl, DISPLAY+896
1055   0857 11 00 E8        ld de, DISPLAY+768
1056   085A 01 7F 00        ld bc, 127
1057   085D ED B0           ldir
1058   085F             
1059   085F                 ; clear line 7
1060   085F                 ; 896 to 1024
1061   085F 21 80 E8        ld hl, DISPLAY+896
1062   0862 5D              ld e,l
1063   0863 54              ld d,h
1064   0864 13              inc de
1065   0865 36 00           ld (hl), 0
1066   0867 01 7F 00        ld bc, 127
1067   086A ED B0           ldir
1068   086C             
1069   086C C9              RET
1070   086D             
1071   086D             DELETE_CHAR:
1072   086D E1              POP HL ; retorno do call
1073   086E 3E 00           LD A, 0
1074   0870 32 0F E0        LD (LCD_DELETE_CHAR), A
1075   0873 3A 03 E0        LD A, (LCD_TXT_X)
1076   0876 3D              DEC A
1077   0877 32 03 E0        LD (LCD_TXT_X), A
1078   087A             
1079   087A 3E FF           LD A, $FF
1080   087C 32 10 E0        LD (LCD_AUTO_X), A
1081   087F             
1082   087F F1              POP AF
1083   0880 3E 20           LD A, ' '
1084   0882 32 00 E0        LD (LCD_CHAR), A
1085   0885 F5              PUSH AF
1086   0886 E5              PUSH HL ; call
1087   0887 C9              RET
1088   0888             
1089   0888             
1090   0888             ; char in A
1091   0888             PRINTCHAR:
1092   0888 32 00 E0        LD (LCD_CHAR), A ; save char to print
1093   088B             
1094   088B F5              PUSH AF
1095   088C C5              PUSH BC
1096   088D D5              PUSH DE
1097   088E E5              PUSH HL
1098   088F             
1099   088F F5              PUSH AF
1100   0890 3E 00           LD A, $0
1101   0892 32 10 E0        LD (LCD_AUTO_X), A
1102   0895 F1              POP AF
1103   0896             
1104   0896             
1105   0896             ver_delete:
1106   0896 F5              PUSH AF
1107   0897 3A 0F E0        LD A, (LCD_DELETE_CHAR)
1108   089A B7              or a
1109   089B FE FF           CP $FF
1110   089D CC 6D 08        call z, DELETE_CHAR
1111   08A0 F1              POP AF
1112   08A1 B7              or a
1113   08A2 FE 00           CP $0
1114   08A4 20 08           jr nz, ver_enter
1115   08A6 3E FF           LD A, $FF ; delete proximo char
1116   08A8 32 0F E0        LD (LCD_DELETE_CHAR), A
1117   08AB C3 D3 09        jp print_char_fim
1118   08AE             
1119   08AE                 ; Verificar Enter, clear, etc... SEM PERDER O reg. A
1120   08AE             ver_enter:       
1121   08AE             
1122   08AE                             ; trata dados para o lcd
1123   08AE FE 0D                       CP      CR                     ; compara com ENTER
1124   08B0 20 1A                       jr      nz, ver_limpa
1125   08B2             
1126   08B2 3E 00                       LD A,0
1127   08B4 32 03 E0                    LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
1128   08B7             
1129   08B7 3A 04 E0                    LD A, (LCD_TXT_Y)
1130   08BA 3C                          inc a
1131   08BB FE 08                       cp 8
1132   08BD C2 C6 08                    jp nz, ver_enter_incYOK
1133   08C0                             
1134   08C0 CD 12 08                    CALL DISPLAY_SCROLL_UP
1135   08C3                             ;ld hl, DISPLAY
1136   08C3                             ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1137   08C3                             
1138   08C3 C3 D3 09                    jp print_char_fim
1139   08C6             
1140   08C6             ver_enter_incYOK:
1141   08C6 32 04 E0                    ld (LCD_TXT_Y), a
1142   08C9 C3 D3 09                    jp print_char_fim
1143   08CC             
1144   08CC             
1145   08CC             ver_limpa:
1146   08CC FE 0C                       CP      $0C                     ; compara com limpar tela
1147   08CE 20 0E                       jr      NZ, ver_line
1148   08D0                             
1149   08D0                             ;call    clear_lcd_screen
1150   08D0                             ;call    show_lcd_screen
1151   08D0 CD 8E 0A                    call lcd_clear
1152   08D3                             ;ld hl, DISPLAY
1153   08D3                             ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1154   08D3 3E 00                       LD A, 0
1155   08D5 32 03 E0                    LD (LCD_TXT_X), A
1156   08D8 32 04 E0                    LD (LCD_TXT_Y), A
1157   08DB             
1158   08DB C3 D3 09                    JP print_char_fim
1159   08DE             
1160   08DE             ver_line:
1161   08DE FE 0A                       CP      LF                     ; retorna começo da linha
1162   08E0 20 03                       jr      NZ, print_lcd      
1163   08E2             
1164   08E2                                 ;----- verificar se precisa add algo aqui
1165   08E2                             ;call    shift_lcd_up
1166   08E2                             ;call    show_lcd_screen
1167   08E2 C3 D3 09                    JP print_char_fim
1168   08E5             
1169   08E5             print_lcd:
1170   08E5                 ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
1171   08E5 26 00           ld H, 0
1172   08E7 6F              ld L, A
1173   08E8 29              ADD HL, HL ; hl x 8
1174   08E9 29              ADD HL, HL
1175   08EA 29              ADD HL, HL
1176   08EB             
1177   08EB 54              LD D, H
1178   08EC 5D              LD E, L
1179   08ED 21 83 00        ld hl, TABLE
1180   08F0 19              add hl, de
1181   08F1 22 01 E0        ld (LCD_CHAR_POINT), HL ; table
1182   08F4             
1183   08F4             
1184   08F4                 ; ajusta X
1185   08F4 06 06           ld b, 6
1186   08F6 3A 03 E0        ld a, (LCD_TXT_X)
1187   08F9 B7              or A
1188   08FA CA 04 09        jp z, ajustX
1189   08FD 4F              ld c, a
1190   08FE CD DE 09        call multiplication
1191   0901 C3 07 09        jp ajustXOK
1192   0904                 
1193   0904             ajustX:
1194   0904 21 00 00        ld hl, 0
1195   0907             ajustXOK:
1196   0907 22 08 E0        ld (LCD_TXT_X_TMP), HL 
1197   090A             
1198   090A             
1199   090A             
1200   090A                 ; ajuste Y
1201   090A 16 04           ld d, 4
1202   090C 1E 00           ld e, 0 ; = 128x8 proxima linha
1203   090E 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1204   0911 3A 04 E0        ld a, (LCD_TXT_Y)
1205   0914 B7              or a
1206   0915 CA 25 09        JP Z, multYfim
1207   0918 21 00 00        ld hl, 0
1208   091B 47              ld b, a
1209   091C             multY:
1210   091C 19              add hl, de
1211   091D 10 FD           DJNZ multY
1212   091F             
1213   091F 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1214   0922 C3 2B 09        jp multYfimok
1215   0925             
1216   0925             multYfim:
1217   0925 21 00 00        ld hl, 0
1218   0928 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1219   092B             
1220   092B             multYfimok:
1221   092B             
1222   092B 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1223   092E ED 5B 08 E0     ld de, (LCD_TXT_X_TMP)
1224   0932             
1225   0932 19              add hl, de  ; hl tem pos do pix 0-8191
1226   0933             
1227   0933 22 0E E0        ld (LCD_TMP_POINT), hl
1228   0936             
1229   0936             
1230   0936 3E 08           ld a, 8 ; altura do caracter
1231   0938 32 0C E0        ld (LCD_CHAR_H), a
1232   093B             printchar_loopH:
1233   093B 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1234   093E 7E              ld a, (HL)
1235   093F 32 10 E1        ld (LCD_TEMP), a
1236   0942             
1237   0942 3E 06           ld a, 6 ; largura do caracter
1238   0944 32 0D E0        ld (LCD_CHAR_W), a
1239   0947             printchar_loopW:
1240   0947 3A 10 E1        ld a, (LCD_TEMP)
1241   094A E6 80           and 128
1242   094C FE 00           cp 0
1243   094E CA 5A 09        jp z, printchar_loopWC
1244   0951 2A 0E E0        ld hl, (LCD_TMP_POINT)
1245   0954 CD 19 0A        call lcd_setPixel
1246   0957 C3 60 09        JP printchar_loopWE
1247   095A             
1248   095A             printchar_loopWC:
1249   095A 2A 0E E0        ld hl, (LCD_TMP_POINT)
1250   095D CD 52 0A        call lcd_clearPixel
1251   0960             
1252   0960             printchar_loopWE:
1253   0960 3A 10 E1        ld a, (LCD_TEMP)
1254   0963 CB 27           sla a
1255   0965 32 10 E1        ld (LCD_TEMP), a
1256   0968                 
1257   0968 2A 0E E0        ld hl, (LCD_TMP_POINT)
1258   096B 23              inc hl
1259   096C 22 0E E0        ld (LCD_TMP_POINT), hl
1260   096F             
1261   096F 3A 0D E0        ld a, (LCD_CHAR_W)
1262   0972 3D              dec A
1263   0973 32 0D E0        ld (LCD_CHAR_W), a
1264   0976 FE 00           cp 0
1265   0978 C2 47 09        JP NZ, printchar_loopW
1266   097B             
1267   097B             
1268   097B 2A 0E E0        ld hl, (LCD_TMP_POINT)
1269   097E 2B              dec hl
1270   097F 2B              dec hl
1271   0980 2B              dec hl
1272   0981 2B              dec hl
1273   0982 2B              dec hl
1274   0983 2B              dec hl
1275   0984             
1276   0984 16 00           ld d, 0
1277   0986 1E 80           ld e, 128
1278   0988 19              add hl, de
1279   0989 22 0E E0        ld (LCD_TMP_POINT), HL
1280   098C             
1281   098C 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1282   098F 23              inc hl
1283   0990 22 01 E0        ld (LCD_CHAR_POINT), hl
1284   0993             
1285   0993             
1286   0993 3A 0C E0        ld a, (LCD_CHAR_H)
1287   0996 3D              dec A
1288   0997 32 0C E0        ld (LCD_CHAR_H), a
1289   099A FE 00           cp 0
1290   099C C2 3B 09        jp NZ, printchar_loopH
1291   099F             
1292   099F                 ;ld hl, DISPLAY
1293   099F                 ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1294   099F             
1295   099F             
1296   099F                 ; check auto x
1297   099F 3A 10 E0        LD A, (LCD_AUTO_X)
1298   09A2 B7              OR A
1299   09A3 FE FF           CP $FF
1300   09A5 CA D3 09        JP Z, print_char_fim
1301   09A8             
1302   09A8                 ; increment X, Y
1303   09A8 3A 03 E0        ld a, (LCD_TXT_X)
1304   09AB 3C              inc a
1305   09AC FE 15           cp 21
1306   09AE C2 D0 09        jp nz, incXOK
1307   09B1 3E 00           ld a, 0
1308   09B3 32 03 E0        ld (LCD_TXT_X), a
1309   09B6 3A 04 E0        ld a, (LCD_TXT_Y)
1310   09B9 3C              inc a
1311   09BA FE 08           cp 8
1312   09BC C2 CA 09        jp nz, incYOK
1313   09BF CD 12 08        CALL DISPLAY_SCROLL_UP
1314   09C2                 ;ld hl, DISPLAY
1315   09C2                 ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1316   09C2 3E 00           ld a, 0
1317   09C4 32 03 E0        ld (LCD_TXT_X), a
1318   09C7 C3 D3 09        jp print_char_fim
1319   09CA             
1320   09CA             incYOK:
1321   09CA 32 04 E0        ld (LCD_TXT_Y), a
1322   09CD C3 D3 09        jp print_char_fim
1323   09D0             
1324   09D0             incXOK:
1325   09D0 32 03 E0        ld (LCD_TXT_X), a
1326   09D3             
1327   09D3             print_char_fim:
1328   09D3 21 00 E5        ld hl, DISPLAY
1329   09D6 CD B5 0A        CALL print_image
1330   09D9 E1              POP HL
1331   09DA D1              POP DE
1332   09DB C1              POP BC
1333   09DC F1              POP AF
1334   09DD C9              RET
1335   09DE             ;-------- FIM PRINTCHAR ------------------
1336   09DE             
1337   09DE             
1338   09DE             
1339   09DE             ; ----------------------------------
1340   09DE             
1341   09DE             ; INPUT: THE VALUES IN REGISTER B EN C
1342   09DE             ; OUTPUT: HL = B * C
1343   09DE             ; CHANGES: AF,DE,HL,B
1344   09DE             ;
1345   09DE             multiplication:
1346   09DE 21 00 00    	LD HL,0
1347   09E1 78          	LD A,B
1348   09E2 B7          	OR A
1349   09E3 C8          	RET Z
1350   09E4 16 00       	LD D,0
1351   09E6 59          	LD E,C
1352   09E7 19          multiplicationLOOP:	ADD HL,DE
1353   09E8 10 FD       	DJNZ multiplicationLOOP
1354   09EA C9          	RET 
1355   09EB             
1356   09EB             ;-----------------------------------
1357   09EB             
1358   09EB             Div_HL_D:
1359   09EB             ;Inputs:
1360   09EB             ;   HL and D
1361   09EB             ;Outputs:
1362   09EB             ;   HL is the quotient (HL/D)
1363   09EB             ;   A is the remainder
1364   09EB             ;   B is 0
1365   09EB             ;   C,D,E are preserved
1366   09EB AF              xor a         ; Clear upper eight bits of AHL
1367   09EC 06 10           ld b,16       ; Sixteen bits in dividend
1368   09EE             _loop:
1369   09EE 29              add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
1370   09EF 17              rla           ; This moves the upper bits of the dividend into A
1371   09F0 38 03           jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
1372   09F2 BA              cp d          ; Check if we can subtract the divisor
1373   09F3 38 02           jr c,_skip    ; Carry means A < D
1374   09F5             _overflow:
1375   09F5 92              sub d         ; Do subtraction for real this time
1376   09F6 2C              inc l         ; Set the next bit of the quotient (currently bit 0)
1377   09F7             _skip:
1378   09F7 10 F5           djnz _loop
1379   09F9 C9              ret
1380   09FA             
1381   09FA             
1382   09FA             ; -----------------------------------------------------------------------------
1383   09FA             ;   LCD DRIVER
1384   09FA             ; -----------------------------------------------------------------------------
1385   09FA             ; INIT_LCD - Inicia o lcd em mode texto
1386   09FA             ; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
1387   09FA             ; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
1388   09FA             ; lcd_clear - Limpa buffer do lcd
1389   09FA             ; enable_grafic - Coloca o LCD em modo grafico
1390   09FA             ; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
1391   09FA             ; cls_TXT - Limpa LCD mode text
1392   09FA             ; cls_GRAPHIC - Limpa LCD modo grafico
1393   09FA             
1394   09FA             INIT_LCD:
1395   09FA                 ;Initialisation
1396   09FA 3E 30       	ld a, 30H
1397   09FC CD 3E 0B    	call lcd_send_command
1398   09FF             
1399   09FF 3E A0       	ld a, 0b00100000
1400   0A01 CD 3E 0B    	call lcd_send_command
1401   0A04             
1402   0A04 3E 30       	ld a, 30H
1403   0A06 CD 3E 0B    	call lcd_send_command
1404   0A09             
1405   0A09 3E 0C       	ld a, 0CH
1406   0A0B CD 3E 0B    	call lcd_send_command
1407   0A0E             
1408   0A0E 3E 01       	ld a, 01H
1409   0A10 CD 48 0B    	call lcd_send_command_clear ;; clear
1410   0A13             
1411   0A13 3E 02       	ld a, 02H
1412   0A15 CD 3E 0B    	call lcd_send_command
1413   0A18 C9              RET
1414   0A19             
1415   0A19             
1416   0A19             ; pixel index in HL
1417   0A19             lcd_setPixel:
1418   0A19 E5              push hl
1419   0A1A C5              push bc
1420   0A1B D5              push de
1421   0A1C F5              push af
1422   0A1D AF              xor A
1423   0A1E 32 07 E0        ld (LCD_BIT_INDEX), A
1424   0A21 32 05 E0        ld (LCD_BYTE_INDEX), A
1425   0A24             
1426   0A24 16 08           ld d, 8
1427   0A26 CD EB 09        call Div_HL_D
1428   0A29 32 07 E0        ld (LCD_BIT_INDEX), A
1429   0A2C 22 05 E0        ld (LCD_BYTE_INDEX), HL
1430   0A2F ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1431   0A33 21 00 E5        ld hl, DISPLAY
1432   0A36 09              add hl, bc
1433   0A37                 
1434   0A37 06 80           ld b, 128 ; 1000 0000
1435   0A39 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1436   0A3C FE 00           cp 0
1437   0A3E CA 4A 0A        jp z, lcd_setPixel_fim
1438   0A41             lcd_setPixel_bit:
1439   0A41 CB 38           srl B
1440   0A43 3D              dec A
1441   0A44 CA 4A 0A        jp z, lcd_setPixel_fim
1442   0A47                 
1443   0A47 C3 41 0A        jp lcd_setPixel_bit
1444   0A4A             lcd_setPixel_fim
1445   0A4A 7E              ld a, (hl)
1446   0A4B B0              or b
1447   0A4C 77              ld (hl), a
1448   0A4D             
1449   0A4D F1              pop af
1450   0A4E C1              pop bc
1451   0A4F D1              pop de
1452   0A50 E1              pop hl
1453   0A51 C9              ret
1454   0A52             
1455   0A52             ;===============================
1456   0A52             ; pixel index in HL
1457   0A52             lcd_clearPixel:
1458   0A52 E5              push hl
1459   0A53 C5              push bc
1460   0A54 D5              push de
1461   0A55 F5              push af
1462   0A56 AF              xor A
1463   0A57 32 07 E0        ld (LCD_BIT_INDEX), A
1464   0A5A 32 05 E0        ld (LCD_BYTE_INDEX), A
1465   0A5D 16 08           ld d, 8
1466   0A5F CD EB 09        call Div_HL_D
1467   0A62 32 07 E0        ld (LCD_BIT_INDEX), A
1468   0A65 22 05 E0        ld (LCD_BYTE_INDEX), HL
1469   0A68 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1470   0A6C 21 00 E5        ld hl, DISPLAY
1471   0A6F 09              add hl, bc
1472   0A70                 
1473   0A70 06 80           ld b, 128 ; 1000 0000
1474   0A72 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1475   0A75 FE 00           cp 0
1476   0A77 CA 83 0A        jp z, lcd_clearPixel_fim
1477   0A7A             lcd_clearPixel_bit:
1478   0A7A CB 38           srl B
1479   0A7C 3D              dec A
1480   0A7D CA 83 0A        jp z, lcd_clearPixel_fim
1481   0A80                 
1482   0A80 C3 7A 0A        jp lcd_clearPixel_bit
1483   0A83             lcd_clearPixel_fim
1484   0A83 78              ld a, b
1485   0A84 2F              cpl     ; NOT B
1486   0A85 47              ld b, a
1487   0A86             
1488   0A86 7E              ld a, (hl)
1489   0A87 A0              and b
1490   0A88 77              ld (hl), a
1491   0A89             
1492   0A89 F1              pop af
1493   0A8A C1              pop bc
1494   0A8B D1              pop de
1495   0A8C E1              pop hl
1496   0A8D C9              ret
1497   0A8E             
1498   0A8E             
1499   0A8E             ;;--------------------------------------------------
1500   0A8E             lcd_clear:
1501   0A8E                 ;; HL = start address of block
1502   0A8E 21 00 E5        ld hl, DISPLAY
1503   0A91             
1504   0A91                 ;; DE = HL + 1
1505   0A91 5D              ld e,l
1506   0A92 54              ld d,h
1507   0A93 13              inc de
1508   0A94             
1509   0A94                 ;; initialise first byte of block
1510   0A94                 ;; with data byte (&00)
1511   0A94 36 00           ld (hl), 0
1512   0A96                     
1513   0A96                 ;; BC = length of block in bytes
1514   0A96                 ;; HL+BC-1 = end address of block
1515   0A96             
1516   0A96 01 00 04        ld bc, 1024
1517   0A99             
1518   0A99                 ;; fill memory
1519   0A99 ED B0           ldir
1520   0A9B C9              ret
1521   0A9C             
1522   0A9C             
1523   0A9C             ;===================
1524   0A9C             
1525   0A9C             ; grafic mode - enable
1526   0A9C             enable_grafic:
1527   0A9C 3E 30       	ld a, 30H
1528   0A9E CD 3E 0B    	call lcd_send_command
1529   0AA1 CD 73 0B    	call delayLCD
1530   0AA4             	
1531   0AA4 3E 34       	ld a, 34H
1532   0AA6 CD 3E 0B    	call lcd_send_command
1533   0AA9 CD 73 0B    	call delayLCD
1534   0AAC             	
1535   0AAC 3E 36       	ld a, 36H
1536   0AAE CD 3E 0B    	call lcd_send_command
1537   0AB1 CD 73 0B    	call delayLCD
1538   0AB4 C9              ret
1539   0AB5             
1540   0AB5             
1541   0AB5             ;==========================
1542   0AB5             
1543   0AB5             print_image:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
1544   0AB5             									; HL content the data address
1545   0AB5 F5              push af
1546   0AB6 D5          	push de
1547   0AB7 C5          	push bc
1548   0AB8             
1549   0AB8             
1550   0AB8             ; premiere partie : X de 0 à 127 / Y de 0 à 32
1551   0AB8             
1552   0AB8 3E 20       	ld a,32
1553   0ABA 57          	ld d,a							; boucle Y
1554   0ABB 3E 00       	ld a,0
1555   0ABD 5F          	ld e,a
1556   0ABE             	
1557   0ABE             boucle_colonne:
1558   0ABE 3E 80       		ld a,$80					; coordonnée Y (0)
1559   0AC0 83          		add a,e
1560   0AC1 CD 3E 0B    		call lcd_send_command
1561   0AC4             		
1562   0AC4 3E 80       		ld a,$80					; coordonnée X (0)		
1563   0AC6 CD 3E 0B    		call lcd_send_command
1564   0AC9             		
1565   0AC9 3E 08       		ld a,8
1566   0ACB 47          		ld b,a						; boucle X
1567   0ACC             		
1568   0ACC             boucle_ligne:	
1569   0ACC 7E          			ld a,(hl)
1570   0ACD CD 52 0B    			call lcd_send_data
1571   0AD0 23          			inc hl
1572   0AD1 7E          			ld a,(hl)
1573   0AD2 CD 52 0B    			call lcd_send_data		; auto-increment on screen address
1574   0AD5 23          			inc hl
1575   0AD6 05          			dec b
1576   0AD7 AF          			XOR a
1577   0AD8 B0          			OR b
1578   0AD9 C2 CC 0A    			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
1579   0ADC             		
1580   0ADC 15          		dec d
1581   0ADD 1C          		inc e
1582   0ADE AF          		XOR a
1583   0ADF B2          		OR d
1584   0AE0 C2 BE 0A    		jp nz,boucle_colonne
1585   0AE3             		
1586   0AE3             
1587   0AE3             ; seconde partie : X de 128 à 255 / Y de 0 à 32
1588   0AE3             
1589   0AE3 3E 20       	ld a,32
1590   0AE5 57          	ld d,a							; boucle Y
1591   0AE6 3E 00       	ld a,0
1592   0AE8 5F          	ld e,a
1593   0AE9             	
1594   0AE9             boucle_colonne2:
1595   0AE9 3E 80       		ld a,$80					; coordonnée Y (0)
1596   0AEB 83          		add a, e
1597   0AEC CD 3E 0B    		call lcd_send_command
1598   0AEF             		
1599   0AEF 3E 88       		ld a,$88					; coordonnée X (8)		
1600   0AF1 CD 3E 0B    		call lcd_send_command
1601   0AF4             		
1602   0AF4 3E 08       		ld a,8
1603   0AF6 47          		ld b,a						; boucle X
1604   0AF7             		
1605   0AF7             boucle_ligne2:	
1606   0AF7 7E          			ld a,(hl)
1607   0AF8 CD 52 0B    			call lcd_send_data
1608   0AFB 23          			inc hl
1609   0AFC 7E          			ld a,(hl)
1610   0AFD CD 52 0B    			call lcd_send_data		; auto-increment on screen address
1611   0B00 23          			inc hl
1612   0B01 05          			dec b
1613   0B02 AF          			XOR a
1614   0B03 B0          			OR b
1615   0B04 C2 F7 0A    			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
1616   0B07             		
1617   0B07 15          		dec d
1618   0B08 1C          		inc e
1619   0B09 AF          		XOR a
1620   0B0A B2          		OR d
1621   0B0B C2 E9 0A    		jp nz,boucle_colonne2
1622   0B0E             
1623   0B0E C1          	pop bc
1624   0B0F D1          	pop de
1625   0B10 F1              pop af
1626   0B11             
1627   0B11 C9              ret
1628   0B12             
1629   0B12             
1630   0B12             
1631   0B12             ; ======================
1632   0B12             cls_TXT:
1633   0B12             	; # CLEAR DISPLAY IN TEXT MODE # 
1634   0B12 3E 01       	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
1635   0B14 CD 48 0B    	call lcd_send_command_clear		; CLEAR DISPLAY	
1636   0B17 C9              ret
1637   0B18             
1638   0B18             ; ========================
1639   0B18             
1640   0B18             cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
1641   0B18             					;	Graphic RAM (GDRAM) use :
1642   0B18             					;	1. Set vertical address (Y) for GDRAM
1643   0B18             					;	2. Set horizontal address (X) for GDRAM
1644   0B18             					;	3. Write D15~D8 to GDRAM (first byte)
1645   0B18             					;	4. Write D7~D0 to GDRAM (second byte)
1646   0B18 C5          	push bc
1647   0B19 D5          	push de
1648   0B1A             
1649   0B1A 1E 20       	ld e,$20						; e = 32 
1650   0B1C 16 00       	ld d,$0							; d = 0
1651   0B1E             Boucle32X:
1652   0B1E 7A          		ld a,d
1653   0B1F F6 80       		OR $80
1654   0B21 CD 3E 0B    		call lcd_send_command
1655   0B24             		
1656   0B24 3E 80       		ld a,$80					; Set horizontal address（X） for GDRAM = 0 ($80)
1657   0B26 CD 3E 0B    		call lcd_send_command
1658   0B29             		
1659   0B29 AF          		xor a							 	
1660   0B2A 06 10       		ld b,$10							; b = 17
1661   0B2C             		
1662   0B2C             Boucle16X:	 
1663   0B2C CD 52 0B    			call lcd_send_data 			; Write D15〜D8 to GDRAM (first byte)
1664   0B2F CD 52 0B    			call lcd_send_data 			; Write D7〜D0 to GDRAM (second byte)
1665   0B32             											; Address counter will automatically increase by one for the next two-byte data												
1666   0B32 10 F8       			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
1667   0B34             		
1668   0B34 1D          		dec e 
1669   0B35 14          		inc d
1670   0B36 AF          		xor a							; a = 0
1671   0B37 B3          		or e
1672   0B38 C2 1E 0B    		jp nz,Boucle32X
1673   0B3B             
1674   0B3B D1          	pop de
1675   0B3C C1          	pop bc
1676   0B3D             	
1677   0B3D C9              ret
1678   0B3E             
1679   0B3E             
1680   0B3E             
1681   0B3E             ;******************
1682   0B3E             ;Send a command byte to the LCD
1683   0B3E             ;Entry: A= command byte
1684   0B3E             ;Exit: All preserved
1685   0B3E             ;******************
1686   0B3E             lcd_send_command:
1687   0B3E C5          	push bc				;Preserve
1688   0B3F 0E 70       	ld c, LCDCTRL   	;Command port
1689   0B41             	
1690   0B41 CD 73 0B    	call delayLCD
1691   0B44             	
1692   0B44 ED 79       	out (c),a			;Send command
1693   0B46 C1          	pop bc				;Restore
1694   0B47 C9          	ret
1695   0B48             
1696   0B48             
1697   0B48             ;******************
1698   0B48             ;Send a command byte to the LCD
1699   0B48             ;Entry: A= command byte
1700   0B48             ;Exit: All preserved
1701   0B48             ;******************
1702   0B48             lcd_send_command_clear:
1703   0B48 C5          	push bc				;Preserve
1704   0B49 0E 70       	ld c, LCDCTRL   	;Command port
1705   0B4B             	
1706   0B4B CD 7D 0B    	call delayLCDclear
1707   0B4E             	
1708   0B4E ED 79       	out (c),a			;Send command
1709   0B50 C1          	pop bc				;Restore
1710   0B51 C9          	ret
1711   0B52             	
1712   0B52             ;******************
1713   0B52             ;Send a data byte to the LCD
1714   0B52             ;Entry: A= data byte
1715   0B52             ;Exit: All preserved
1716   0B52             ;******************
1717   0B52             lcd_send_data:
1718   0B52 C5          	push bc				;Preserve
1719   0B53 0E 70       	ld c, LCDCTRL	    ;Command port
1720   0B55             	
1721   0B55                 ;Busy wait
1722   0B55 CD 73 0B    	call delayLCD
1723   0B58             	
1724   0B58 0E 71       	ld c, LCDDATA	;Data port
1725   0B5A ED 79       	out (c),a			;Send data
1726   0B5C C1          	pop bc				;Restore
1727   0B5D C9          	ret
1728   0B5E             
1729   0B5E             ;******************
1730   0B5E             ;Send an asciiz string to the LCD
1731   0B5E             ;Entry: HL=address of string
1732   0B5E             ;Exit: HL=address of ending zero of the string. All others preserved
1733   0B5E             ;******************
1734   0B5E             lcd_send_asciiz:
1735   0B5E F5          	push af
1736   0B5F C5          	push bc				;Preserve
1737   0B60             lcd_asciiz_char_loop:
1738   0B60 0E 70       	ld c, LCDCTRL   	;Command port
1739   0B62             	
1740   0B62             lcd_asciiz_wait_loop:	;Busy wait
1741   0B62 CD 73 0B    	call delayLCD
1742   0B65             	
1743   0B65 7E          	ld a,(hl)			;Get character
1744   0B66 A7          	and a				;Is it zero?
1745   0B67 28 07       	jr z,lcd_asciiz_done	;If so, we're done
1746   0B69             	
1747   0B69 0E 71       	ld c, LCDDATA	;Data port
1748   0B6B ED 79       	out (c),a			;Send data
1749   0B6D 23          	inc hl				;Next char
1750   0B6E 18 F0       	jr lcd_asciiz_char_loop
1751   0B70             	
1752   0B70             lcd_asciiz_done:
1753   0B70 C1          	pop bc				;Restore
1754   0B71 F1          	pop af
1755   0B72 C9          	ret
1756   0B73             
1757   0B73             ; =========================================================
1758   0B73             ; Delay LCD
1759   0B73             ; =========================================================
1760   0B73             delayLCD:
1761   0B73 00          	NOP
1762   0B74 00          	NOP
1763   0B75 00          	NOP
1764   0B76 00          	NOP
1765   0B77 00          	NOP
1766   0B78 00          	NOP
1767   0B79 00          	NOP
1768   0B7A 00          	NOP
1769   0B7B 00              NOP
1770   0B7C C9              ret
1771   0B7D             
1772   0B7D             delayLCDclear:
1773   0B7D 00          	NOP
1774   0B7E 00          	NOP
1775   0B7F 00          	NOP
1776   0B80 00          	NOP
1777   0B81 00          	NOP
1778   0B82 00          	NOP
1779   0B83 00          	NOP
1780   0B84 00          	NOP
1781   0B85 00          	NOP
1782   0B86 00          	NOP
1783   0B87 00          	NOP
1784   0B88 00          	NOP
1785   0B89 00              NOP
1786   0B8A C9              ret
1787   0B8B             
1788   0B8B             	
1789   0B8B             ; =========================================================
1790   0B8B             ; Delay
1791   0B8B             ; =========================================================
1792   0B8B             delay:
1793   0B8B C5          	push bc                       ; 2.75 us
1794   0B8C 06 01           ld b, 1                     ; 1.75 us
1795   0B8E             delay_loop_b:
1796   0B8E 0E FF       	ld c, 255                     ; 1.75 us
1797   0B90             delay_loop:
1798   0B90 0D          	dec c                         ; 1 us
1799   0B91 C2 90 0B        jp nz, delay_loop             ; true = 3 us, false 1.75 us
1800   0B94 05              dec b                         ; 1 us
1801   0B95 C2 8E 0B        jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
1802   0B98 C1              pop bc                        ; 2.50 us
1803   0B99 C9              ret   
1804   0B9A             
1805   0B9A             
1806   0B9A             ; Check break key
1807   0B9A 3E 40       CHKKEY: LD  A, $40
1808   0B9C D3 40       	OUT (KEY_OUT), A ; line 4
1809   0B9E DB 40       	IN  A, (KEY_IN)
1810   0BA0 FE 01       	CP  1
1811   0BA2 C2 AA 0B    	JP  NZ, GRET
1812   0BA5 3E 03       	LD  A, CTRLC
1813   0BA7 FE 00       	CP	0
1814   0BA9 C9          	RET
1815   0BAA             GRET:
1816   0BAA 3E 00       	LD  A, 0
1817   0BAC FE 00       	CP 0
1818   0BAE C9          	RET
1819   0BAF             
1820   0BAF             
1821   0BAF             
1822   0BAF             
1823   0BAF             ; -----------------------------------------------------------------------------
1824   0BAF             ;   KEYREAD - KEY In A
1825   0BAF             ; -----------------------------------------------------------------------------
1826   0BAF             KEYREADINIT:
1827   0BAF C5              PUSH    BC
1828   0BB0 D5          	PUSH	DE
1829   0BB1 E5          	PUSH    HL
1830   0BB2 1E 00       	LD      E, 0                    ; E will be the last pressed key
1831   0BB4             READKEY:        
1832   0BB4 26 01           LD      H, 1                    ; H is the line register, start with second
1833   0BB6 06 00       	LD      B, 0                    ; Count lines for later multiplication	
1834   0BB8 16 00       	LD      D, 0                    ; DE will be the adress for mask
1835   0BBA             						
1836   0BBA             NEXTKEY:        
1837   0BBA 7C              LD      A, H						
1838   0BBB FE 00           CP      0                       ; All lines tried? 
1839   0BBD CA F8 0B        JP      Z, KEYOUT               ; Then check if there was a key pressed
1840   0BC0 D3 40       	OUT     (KEY_OUT), A		    ; Put current line to register
1841   0BC2 DB 40       	IN      A, (KEY_IN)		        ; Input Keys
1842   0BC4 E6 1F       	AND     $1F                     ; only 5 bits
1843   0BC6 CB 24       	SLA     H                       ; Next line
1844   0BC8 04              INC     B
1845   0BC9 FE 00           CP      0                       ; Was key zero?
1846   0BCB CA BA 0B        JP      Z, NEXTKEY              ; Then try again with next lines
1847   0BCE 16 00           LD      D, 0                    ; In D will be the number of the key
1848   0BD0             LOGARITHM:      
1849   0BD0 14              INC     D	                    ; Add one per shift
1850   0BD1 CB 3F           SRL     A                       ; Shift key right
1851   0BD3 C2 D0 0B        JP      NZ, LOGARITHM		    ; If not zero shift again
1852   0BD6 15              DEC     D                       ; Was too much
1853   0BD7 DB 40       	IN      A, (KEY_IN)
1854   0BD9 E6 80           AND     $80                     ; Check if first bit set (shift key pressed)
1855   0BDB C2 E4 0B        JP      NZ, LOADSHIFT		    ; Then jump to read with shift
1856   0BDE 7A              LD      A, D                    ; Put read key into accu
1857   0BDF C6 33           ADD     A, KEYMAP               ; Add base of key map array
1858   0BE1 C3 E7 0B        JP      ADDOFFSET               ; Jump to load key
1859   0BE4             LOADSHIFT:
1860   0BE4 7A              LD      A, D
1861   0BE5 C6 5B           ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
1862   0BE7             ADDOFFSET:
1863   0BE7 C6 05           ADD     A, 5                    ; Add 5 for every line
1864   0BE9 10 FC           DJNZ    ADDOFFSET               ; Jump back (do while loop)
1865   0BEB D6 05       	SUB     5                       ; Since do while is one too much
1866   0BED             TRANSKEY:
1867   0BED A8              XOR     B                       ; Empty B
1868   0BEE 4F          	LD      C, A                    ; A will be address in BC
1869   0BEF 0A          	LD      A, (BC)	                ; Load key
1870   0BF0 BB          	CP      E                       ; Same key?
1871   0BF1 CA B4 0B    	JP      Z, READKEY              ; Then from beginning
1872   0BF4 5F          	LD      E, A                    ; Otherwise save new key
1873   0BF5 C3 B4 0B    	JP      READKEY	                ; And restart
1874   0BF8             KEYOUT:
1875   0BF8 7B              LD      A, E
1876   0BF9 1E 00           LD      E, 0                    ; empty it
1877   0BFB B7              OR      A	                    ; Was a key read?
1878   0BFC CA B4 0B        JP      Z, READKEY              ; If not restart
1879   0BFF E1              POP     HL
1880   0C00 D1              POP     DE
1881   0C01 C1              POP     BC
1882   0C02 C9              RET
1883   0C03             
1884   0C03             
1885   0C03             ;-----------------------
1886   0C03             ; RECEIVE INTEL HEX FILE
1887   0C03             ;-----------------------       
1888   0C03             INTHEX: 
1889   0C03 21 53 10           LD HL, MSG_ILOAD
1890   0C06 CD B6 0C           CALL  SNDLCDMSG
1891   0C09             
1892   0C09 21 53 10           LD HL, MSG_ILOAD
1893   0C0C CD C4 0C           CALL  SNDMSG
1894   0C0F                    
1895   0C0F             
1896   0C0F CD 2E 0C           CALL  INTELH
1897   0C12 20 0D              JR    NZ,ITHEX1      
1898   0C14             
1899   0C14 21 69 10           LD    HL,FILEOK
1900   0C17 CD B6 0C           CALL  SNDLCDMSG   ;GOT FILE OK LCD
1901   0C1A 21 69 10           LD    HL,FILEOK
1902   0C1D CD C4 0C           CALL  SNDMSG      ;GOT FILE OK Serial
1903   0C20                    
1904   0C20 C9                 RET
1905   0C21 21 7B 10    ITHEX1: LD    HL,CSUMERR
1906   0C24 CD B6 0C           CALL  SNDLCDMSG
1907   0C27             
1908   0C27 21 7B 10           LD    HL,CSUMERR
1909   0C2A CD C4 0C           CALL  SNDMSG      ;CHECKSUM ERROR
1910   0C2D                    
1911   0C2D C9                 RET  
1912   0C2E             
1913   0C2E             
1914   0C2E             
1915   0C2E             
1916   0C2E             
1917   0C2E             ;-----------------------
1918   0C2E             ; RECEIVE INTEL HEX FILE
1919   0C2E             ;-----------------------
1920   0C2E DD 21 00 FD INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
1921   0C32             ;
1922   0C32             ; WAIT FOR RECORD MARK
1923   0C32             ;
1924   0C32 AF          INTEL1:	XOR	A
1925   0C33 DD 77 03    	LD	(IX+3),A	;CLEAR CHECKSUM
1926   0C36 CD 09 0D    	CALL	RXDATA	;WAIT FOR THE RECORD MARK
1927   0C39 FE 3A       	CP	':'	;TO BE TRANSMITTED
1928   0C3B 20 F5       	JR	NZ,INTEL1	;NOT RECORD MARK
1929   0C3D             ;
1930   0C3D             ; GET RECORD LENGTH
1931   0C3D             ;
1932   0C3D CD 8A 0C    	CALL	GETBYT
1933   0C40 DD 77 00    	LD	(IX+0),A	;NUMBER OF DATA BYTES
1934   0C43             ;
1935   0C43             ; GET ADDRESS FIELD
1936   0C43             ;
1937   0C43 CD 8A 0C    	CALL	GETBYT
1938   0C46 DD 77 02    	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
1939   0C49 CD 8A 0C    	CALL	GETBYT
1940   0C4C DD 77 01    	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
1941   0C4F             ;
1942   0C4F             ; GET RECORD TYPE
1943   0C4F             ;
1944   0C4F CD 8A 0C    	CALL	GETBYT
1945   0C52 20 24       	JR	NZ,INTEL4	;END OF FILE RECORD
1946   0C54             ;
1947   0C54             ; READ IN THE DATA
1948   0C54             ;
1949   0C54 DD 46 00    	LD	B,(IX+0)	;NUMBER OF DATA BYTES
1950   0C57 DD 66 02    	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
1951   0C5A DD 6E 01    	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
1952   0C5D             
1953   0C5D CD 8A 0C    INTEL2:	CALL	GETBYT	;GET DATA BYTE
1954   0C60 77          	LD	(HL),A	;STORE DATA BYTE
1955   0C61 23          	INC	HL
1956   0C62 10 F9       	DJNZ	INTEL2	;LOAD MORE BYTES
1957   0C64             ;
1958   0C64             ; GET CHECKSUM AND COMPARE
1959   0C64             ;
1960   0C64 DD 7E 03    	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1961   0C67 ED 44       	NEG		;TWO'S COMPLEMENT
1962   0C69 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
1963   0C6C CD 8A 0C    	CALL	GETBYT
1964   0C6F DD 77 03    	LD	(IX+3),A	;SAVE RECORD CHECKSUM
1965   0C72 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
1966   0C75 28 BB       	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
1967   0C77 C9              RET             ;NZ=CHECKSUM ERROR
1968   0C78             ;
1969   0C78             ; END OF FILE RECORD
1970   0C78             ;
1971   0C78 DD 7E 03    INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1972   0C7B ED 44       	NEG		;TWO'S COMPLEMENT
1973   0C7D DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
1974   0C80 CD 8A 0C    	CALL	GETBYT
1975   0C83 DD 77 03    	LD	(IX+3),A	;SAVE EOF CHECKSUM
1976   0C86 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
1977   0C89 C9          	RET  	    ;NZ=CHECKSUM ERROR
1978   0C8A             ;--------------------------
1979   0C8A             ; GET BYTE FROM SERIAL PORT
1980   0C8A             ;--------------------------
1981   0C8A C5          GETBYT:	PUSH	BC
1982   0C8B CD 09 0D    	CALL	RXDATA
1983   0C8E CB 77       	BIT	6,A
1984   0C90 28 02       	JR	Z,GETBT1
1985   0C92 C6 09       	ADD	A,09H
1986   0C94 E6 0F       GETBT1:	AND	0FH
1987   0C96 CB 27       	SLA 	A
1988   0C98 CB 27       	SLA	A
1989   0C9A CB 27       	SLA	A
1990   0C9C CB 27       	SLA	A
1991   0C9E 4F          	LD	C,A
1992   0C9F             ;
1993   0C9F             ; GET LOW NYBBLE
1994   0C9F             ;
1995   0C9F CD 09 0D    	CALL	RXDATA
1996   0CA2 CB 77       	BIT	6,A
1997   0CA4 28 02       	JR	Z,GETBT2
1998   0CA6 C6 09       	ADD	A,09H
1999   0CA8 E6 0F       GETBT2:	AND	0FH
2000   0CAA B1          	OR	C
2001   0CAB 47          	LD	B,A
2002   0CAC DD 86 03    	ADD	A,(IX+3)
2003   0CAF DD 77 03    	LD	(IX+3),A	;ADD TO CHECKSUM
2004   0CB2 78          	LD	A,B
2005   0CB3 A7          	AND	A	;CLEAR CARRY
2006   0CB4 C1              POP	BC
2007   0CB5 C9          	RET
2008   0CB6             
2009   0CB6             ;-----------------------------------------
2010   0CB6             ; SEND AN ASCII STRING OUT LCD
2011   0CB6             ;-----------------------------------------
2012   0CB6             ; 
2013   0CB6             ; SENDS A ZERO TERMINATED STRING OR 
2014   0CB6             ; 128 CHARACTERS MAX. OUT LCD
2015   0CB6             ;
2016   0CB6             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2017   0CB6             ;      EXIT  : NONE
2018   0CB6             ;
2019   0CB6             ;       MODIFIES : A,B,C
2020   0CB6             ;          
2021   0CB6 06 80       SNDLCDMSG: LD    B,128         ;128 CHARS MAX
2022   0CB8 7E          SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
2023   0CB9 FE 00              CP    00H          ;ZERO TERMINATOR?
2024   0CBB 28 06              JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2025   0CBD CD 88 08           CALL PRINTCHAR         ;TRANSMIT THE CHAR
2026   0CC0 23                 INC   HL
2027   0CC1 10 F5              DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
2028   0CC3 C9          SDLCDMSG2: RET
2029   0CC4             
2030   0CC4             
2031   0CC4             ;-----------------------------------------
2032   0CC4             ; SEND AN ASCII STRING OUT THE SERIAL PORT
2033   0CC4             ;-----------------------------------------
2034   0CC4             ; 
2035   0CC4             ; SENDS A ZERO TERMINATED STRING OR 
2036   0CC4             ; 128 CHARACTERS MAX. OUT THE SERIAL PORT
2037   0CC4             ;
2038   0CC4             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2039   0CC4             ;      EXIT  : NONE
2040   0CC4             ;
2041   0CC4             ;       MODIFIES : A,B,C
2042   0CC4             ;          
2043   0CC4 06 80       SNDMSG: LD    B,128         ;128 CHARS MAX
2044   0CC6 7E          SDMSG1: LD    A,(HL)        ;GET THE CHAR
2045   0CC7 FE 00              CP    00H          ;ZERO TERMINATOR?
2046   0CC9 28 06              JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2047   0CCB CD D2 0C           CALL  OUTCH         ;TRANSMIT THE CHAR
2048   0CCE 23                 INC   HL
2049   0CCF 10 F5              DJNZ  SDMSG1        ;128 CHARS MAX!    
2050   0CD1 C9          SDMSG2: RET
2051   0CD2             
2052   0CD2             
2053   0CD2             
2054   0CD2             ;-----------------------------------
2055   0CD2             ; OUTPUT A CHARACTER TO THE TERMINAL
2056   0CD2             ;-----------------------------------       
2057   0CD2 DD 2A AA FF OUTCH:  LD   IX,(PUTCH)
2058   0CD6 DD E9              JP   (IX)
2059   0CD8             ;------------------------------------
2060   0CD8             ; INPUT A CHARACTER FROM THE TERMINAL
2061   0CD8             ;------------------------------------
2062   0CD8 DD 2A AC FF INCH:  LD   IX,(GETCH)
2063   0CDC DD E9             JP   (IX)
2064   0CDE             
2065   0CDE             
2066   0CDE             
2067   0CDE             ;------------------------
2068   0CDE             ; SERIAL TRANSMIT ROUTINE
2069   0CDE             ;------------------------
2070   0CDE             ;TRANSMIT BYTE SERIALLY ON DOUT
2071   0CDE             ;
2072   0CDE             ; ENTRY : A = BYTE TO TRANSMIT
2073   0CDE             ;  EXIT : NO REGISTERS MODIFIED
2074   0CDE             ;
2075   0CDE F5          TXDATA:	PUSH	AF
2076   0CDF C5          	PUSH	BC
2077   0CE0 E5          	PUSH	HL
2078   0CE1 2A C0 FF    	LD	HL,(BAUD)
2079   0CE4 4F          	LD	C,A
2080   0CE5             ;
2081   0CE5             ; TRANSMIT START BIT
2082   0CE5             ;
2083   0CE5 AF          	XOR	A
2084   0CE6 D3 C0       	OUT	(SERIAL_TX_PORT),A
2085   0CE8 CD 36 0D    	CALL	BITIME
2086   0CEB             ;
2087   0CEB             ; TRANSMIT DATA
2088   0CEB             ;
2089   0CEB 06 08       	LD	B,08H
2090   0CED CB 09       	RRC	C
2091   0CEF CB 09       NXTBIT:	RRC	C	;SHIFT BITS TO D6,
2092   0CF1 79          	LD	A,C	;LSB FIRST AND OUTPUT
2093   0CF2 E6 40       	AND	40H	;THEM FOR ONE BIT TIME.
2094   0CF4 D3 C0       	OUT	(SERIAL_TX_PORT),A
2095   0CF6 CD 36 0D    	CALL	BITIME
2096   0CF9 10 F4       	DJNZ	NXTBIT
2097   0CFB             ;
2098   0CFB             ; SEND STOP BITS
2099   0CFB             ;
2100   0CFB 3E 40       	LD	A,40H
2101   0CFD D3 C0       	OUT	(SERIAL_TX_PORT),A
2102   0CFF CD 36 0D    	CALL	BITIME
2103   0D02 CD 36 0D    	CALL	BITIME
2104   0D05 E1          	POP	HL
2105   0D06 C1          	POP	BC
2106   0D07 F1          	POP	AF
2107   0D08 C9          	RET
2108   0D09             ;-----------------------
2109   0D09             ; SERIAL RECEIVE ROUTINE
2110   0D09             ;-----------------------
2111   0D09             ;RECEIVE SERIAL BYTE FROM DIN
2112   0D09             ;
2113   0D09             ; ENTRY : NONE
2114   0D09             ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
2115   0D09             ;
2116   0D09             ; REGISTERS MODIFIED A AND F
2117   0D09             ;
2118   0D09 C5          RXDATA:	PUSH	BC
2119   0D0A E5          	PUSH	HL
2120   0D0B             ;
2121   0D0B             ; WAIT FOR START BIT 
2122   0D0B             ;
2123   0D0B DB C0       RXDAT1: IN	A,(SERIAL_RX_PORT)
2124   0D0D CB 7F       	    BIT	7,A
2125   0D0F 20 FA       	    JR	NZ,RXDAT1	;NO START BIT
2126   0D11             ;
2127   0D11             ; DETECTED START BIT
2128   0D11             ;
2129   0D11 2A C0 FF    	LD	HL,(BAUD)
2130   0D14 CB 3C       	SRL	H
2131   0D16 CB 1D       	RR	L 	;DELAY FOR HALF BIT TIME
2132   0D18 CD 36 0D    	CALL 	BITIME
2133   0D1B DB C0       	IN	A,(SERIAL_RX_PORT)
2134   0D1D CB 7F       	BIT	7,A
2135   0D1F 20 EA       	JR	NZ,RXDAT1	;START BIT NOT VALID
2136   0D21             ;
2137   0D21             ; DETECTED VALID START BIT,READ IN DATA
2138   0D21             ;
2139   0D21 06 08       	LD	B,08H
2140   0D23 2A C0 FF    RXDAT2:	LD	HL,(BAUD)
2141   0D26 CD 36 0D    	CALL	BITIME	;DELAY ONE BIT TIME
2142   0D29 DB C0       	IN	A,(SERIAL_RX_PORT)
2143   0D2B CB 17       	RL	A
2144   0D2D CB 19       	RR	C	;SHIFT BIT INTO DATA REG
2145   0D2F 10 F2       	DJNZ	RXDAT2
2146   0D31 79          	LD	A,C
2147   0D32 B7          	OR	A	;CLEAR CARRY FLAG
2148   0D33 E1              POP	HL
2149   0D34 C1          	POP	BC
2150   0D35 C9          	RET
2151   0D36             ;---------------
2152   0D36             ; BIT TIME DELAY
2153   0D36             ;---------------
2154   0D36             ;DELAY FOR ONE SERIAL BIT TIME
2155   0D36             ;ENTRY : HL = DELAY TIME
2156   0D36             ; NO REGISTERS MODIFIED
2157   0D36             ;
2158   0D36 E5          BITIME:	PUSH	HL
2159   0D37 D5          	PUSH	DE
2160   0D38 11 01 00    	LD	DE,0001H
2161   0D3B ED 52       BITIM1:	SBC	HL,DE
2162   0D3D D2 3B 0D    	JP	NC,BITIM1
2163   0D40 D1          	POP	DE
2164   0D41 E1          	POP	HL
2165   0D42 C9          	RET
2166   0D43             
2167   0D43             
2168   0D43             ;-----------------
2169   0D43             ; ONE SECOND DELAY
2170   0D43             ;-----------------
2171   0D43             ;
2172   0D43             ; ENTRY : NONE
2173   0D43             ; EXIT : FLAG REGISTER MODIFIED
2174   0D43             ;
2175   0D43 C5          DELONE:	PUSH	BC
2176   0D44 D5          	PUSH	DE
2177   0D45 E5          	PUSH	HL
2178   0D46 11 01 00    	LD	DE,0001H
2179   0D49 21 70 08    	LD	HL,0870H
2180   0D4C 06 92       DELON1:	LD	B,92H
2181   0D4E 10 FE       DELON2:	DJNZ	DELON2	;INNER LOOP
2182   0D50 ED 52       	SBC	HL,DE
2183   0D52 D2 4C 0D    	JP	NC,DELON1	;OUTER LOOP
2184   0D55 E1          	POP	HL
2185   0D56 D1          	POP	DE
2186   0D57 C1          	POP	BC
2187   0D58 C9          	RET
2188   0D59             
2189   0D59             
2190   0D59             
2191   0D59             
2192   0D59             
2193   0D59             
2194   0D59             
2195   0D59             ; **********************************************************************
2196   0D59             ; List devices found on the I2C bus
2197   0D59             ;
2198   0D59             ; Test each I2C device address and reports any that acknowledge
2199   0D59             
2200   0D59 11 E0 0F    I2CLIST:       LD   DE,LISTMsg        ;Address of message string
2201   0D5C CD FC 0D                CALL StrOut         ;Output string
2202   0D5F 16 00                   LD   D,0            ;First I2C device address to test
2203   0D61 D5          LISTLOOP:      PUSH DE             ;Preserve DE
2204   0D62 7A                      LD   A,D            ;Get device address to be tested
2205   0D63 CD 7A 0D                CALL LISTTEST          ;Test if device is present
2206   0D66 D1                      POP  DE             ;Restore DE
2207   0D67 20 07                   JR   NZ,LISTNEXT       ;Skip if no acknowledge
2208   0D69 7A                      LD   A,D            ;Get address of device tested
2209   0D6A CD 2B 0E                CALL HexOut         ;Output as two character hex 
2210   0D6D CD F7 0D                CALL SpaceOut       ;Output space character
2211   0D70 14          LISTNEXT:      INC  D              ;Get next write address
2212   0D71 14                      INC  D
2213   0D72 7A                      LD   A,D            ;Address of next device to test
2214   0D73 B7                      OR   A              ;Have we tested all addresses?
2215   0D74 20 EB                   JR   NZ,LISTLOOP       ;No, so loop again
2216   0D76 CD F4 0D                CALL LineOut        ;Output new line
2217   0D79 C9                      RET
2218   0D7A             
2219   0D7A             ; Test if device at I2C address A acknowledges
2220   0D7A             ;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
2221   0D7A             ;   On exit:  Z flagged if device acknowledges
2222   0D7A             ;             NZ flagged if devices does not acknowledge
2223   0D7A CD 6C 0E    LISTTEST:      CALL I2C_Open       ;Open I2C device for write
2224   0D7D C0                      RET  NZ             ;Abort if failed to open
2225   0D7E CD 73 0E                CALL I2C_Close      ;Close I2C device 
2226   0D81 AF                      XOR  A              ;Return with Z flagged
2227   0D82 C9                      RET
2228   0D83             
2229   0D83             
2230   0D83             
2231   0D83             
2232   0D83             ; Copy a block from I2C memory to CPU memory
2233   0D83             ;   On entry: DE = First address in I2C memory
2234   0D83             ;             HL = First address in CPU memory
2235   0D83             ;             BC = Number of bytes to be copied
2236   0D83             ;             SCL = unknown, SDA = unknown
2237   0D83             ;   On exit:  If successfully A = 0 and Z flagged
2238   0D83             ;             If unsuccessfully A = Error and NZ flagged
2239   0D83             ;             IX IY preserved
2240   0D83 C5          I2C_MemRd:  PUSH BC
2241   0D84 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2242   0D87 3E AE       I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2243   0D89 CD 6C 0E                CALL I2C_Open       ;Open for write
2244   0D8C 28 0A                   JR   Z,I2C_MemRdReady       ;If open okay then skip on
2245   0D8E 0B                      DEC  BC
2246   0D8F 78                      LD   A,B
2247   0D90 B1                      OR   C              ;Timeout?
2248   0D91 20 F4                   JR   NZ,I2C_MemRdRepeat     ;No, so go try again
2249   0D93 C1                      POP  BC
2250   0D94 3E 03                   LD   A,ERR_TOUT     ;Error code
2251   0D96 B7                      OR   A              ;Error, so NZ flagged
2252   0D97 C9                      RET                 ;Return with error
2253   0D98             ; Device opened okay
2254   0D98 C1          I2C_MemRdReady:     POP  BC             ;Restore byte counter
2255   0D99 7A                      LD   A,D            ;Address (hi) in I2C memory
2256   0D9A CD 76 0E                CALL I2C_Write      ;Write address
2257   0D9D 7B                      LD   A,E            ;Address (lo) in I2C memory
2258   0D9E CD 76 0E                CALL I2C_Write      ;Write address
2259   0DA1 3E AF                   LD   A,I2CA_BLOCK+1 ;I2C device to be read from
2260   0DA3 CD 6C 0E                CALL I2C_Open       ;Open for read
2261   0DA6 C0                      RET  NZ             ;Abort if error
2262   0DA7 0B          I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
2263   0DA8 78                      LD   A,B
2264   0DA9 B1                      OR   C              ;Last byte to be read?
2265   0DAA CD B3 0E                CALL I2C_Read       ;Read byte with no ack on last byte
2266   0DAD 77                      LD   (HL),A         ;Write byte in CPU memory
2267   0DAE 23                      INC  HL             ;Increment CPU memory pointer
2268   0DAF 78                      LD   A,B
2269   0DB0 B1                      OR   C              ;Finished?
2270   0DB1 20 F4                   JR   NZ,I2C_MemRdRead       ;No, so go read next byte
2271   0DB3 CD EB 0E                CALL I2C_Stop       ;Generate I2C stop
2272   0DB6 AF                      XOR  A              ;Return with success (Z flagged)
2273   0DB7 C9                      RET
2274   0DB8             
2275   0DB8             
2276   0DB8             ; Copy a block from CPU memory to I2C memory
2277   0DB8             ;   On entry: DE = First address in I2C memory
2278   0DB8             ;             HL = First address in CPU memory
2279   0DB8             ;             BC = Number of bytes to be copied
2280   0DB8             ;             SCL = unknown, SDA = unknown
2281   0DB8             ;   On exit:  If successfully A = 0 and Z flagged
2282   0DB8             ;             If unsuccessfully A = Error and NZ flagged
2283   0DB8             ;             IX IY preserved
2284   0DB8             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
2285   0DB8             ; pages.
2286   0DB8 C5          I2C_MemWr:  PUSH BC
2287   0DB9 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2288   0DBC 3E AE       I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2289   0DBE CD 6C 0E                CALL I2C_Open       ;Open for write
2290   0DC1 28 0A                   JR   Z,I2C_MemWrReady       ;If open okay then skip on
2291   0DC3 0B                      DEC  BC
2292   0DC4 78                      LD   A,B
2293   0DC5 B1                      OR   C              ;Timeout?
2294   0DC6 20 F4                   JR   NZ,I2C_MemWrRepeat     ;No, so go try again
2295   0DC8 C1                      POP  BC
2296   0DC9 3E 03                   LD   A,ERR_TOUT     ;Error code
2297   0DCB B7                      OR   A              ;Error, so NZ flagged
2298   0DCC C9                      RET                 ;Return with error
2299   0DCD             ; Device opened okay
2300   0DCD C1          I2C_MemWrReady:     POP  BC             ;Restore byte counter
2301   0DCE 7A          I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
2302   0DCF CD 76 0E                CALL I2C_Write      ;Write address
2303   0DD2 7B                      LD   A,E            ;Address (lo) in I2C memory
2304   0DD3 CD 76 0E                CALL I2C_Write      ;Write address
2305   0DD6 7E          I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
2306   0DD7 CD 76 0E                CALL I2C_Write      ;Read byte from I2C memory
2307   0DDA 23                      INC  HL             ;Increment CPU memory pointer
2308   0DDB 13                      INC  DE             ;Increment I2C memory pointer
2309   0DDC 0B                      DEC  BC             ;Decrement byte counter
2310   0DDD 78                      LD   A,B
2311   0DDE B1                      OR   C              ;Finished?
2312   0DDF 28 05                   JR   Z,I2C_MemWrStore       ;Yes, so go store this page
2313   0DE1 7B                      LD   A,E            ;Get address in I2C memory (lo byte)
2314   0DE2 E6 3F                   AND  63             ;64 byte page boundary?
2315   0DE4 20 F0                   JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
2316   0DE6 CD EB 0E    I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
2317   0DE9 78                      LD   A,B
2318   0DEA B1                      OR   C              ;Finished?
2319   0DEB 20 CB                   JR   NZ,I2C_MemWr   ;No, so go write some more
2320   0DED C9                      RET   
2321   0DEE             
2322   0DEE             
2323   0DEE             
2324   0DEE             
2325   0DEE             
2326   0DEE             
2327   0DEE             
2328   0DEE             
2329   0DEE             
2330   0DEE             
2331   0DEE             ; Display test result
2332   0DEE             ;   On entry: DE = Address of null terminated string
2333   0DEE             ;             H = First value ($H)
2334   0DEE             ;             L = Second value ($L)
2335   0DEE             ;   On exit:  HL IX IY preserved
2336   0DEE             Result:     
2337   0DEE C3 43 0E                JP   String         ;Output result string to console
2338   0DF1             
2339   0DF1             
2340   0DF1             ; Character output to console
2341   0DF1             ;   On entry: A = Character to be output
2342   0DF1             ;   On exit:  BC DE HL IX IY preserved
2343   0DF1 C3 09 0E    CharOut:    JP   API_Cout
2344   0DF4             
2345   0DF4             ; New line output to console
2346   0DF4             ;   On entry: No parameters required
2347   0DF4             ;   On exit:  BC DE HL IX IY preserved
2348   0DF4 C3 13 0E    LineOut:    JP   API_Lout
2349   0DF7             
2350   0DF7             ; Space character ouput to console
2351   0DF7             ;   On entry: No parameters required
2352   0DF7             ;   On exit:  BC DE HL IX IY preserved
2353   0DF7 3E 20       SpaceOut:   LD   A,$20
2354   0DF9 C3 09 0E                JP   API_Cout
2355   0DFC             
2356   0DFC             ; String output to console
2357   0DFC             ;   On entry: DE = Address of string
2358   0DFC             ;   On exit:  BC DE HL IX IY preserved
2359   0DFC C3 1F 0E    StrOut:     JP   API_Sout
2360   0DFF             
2361   0DFF             
2362   0DFF             ; Delay by DE milliseconds (approx)
2363   0DFF             ;   On entry: DE = Delay time in milliseconds
2364   0DFF             ;   On exit:  BC DE HL IX IY preserved
2365   0DFF C5          API_Delay:  PUSH BC             ;Preserve registers
2366   0E00 D5                      PUSH DE
2367   0E01 E5                      PUSH HL
2368   0E02 CD 8B 0B                CALL delay
2369   0E05 E1                      POP  HL             ;Restore registers
2370   0E06 D1                      POP  DE
2371   0E07 C1                      POP  BC
2372   0E08 C9                      RET
2373   0E09             
2374   0E09             
2375   0E09             ; Character output to console device
2376   0E09             ;   On entry: A = Character to be output
2377   0E09             ;   On exit:  BC DE HL IX IY preserved
2378   0E09 C5          API_Cout:   PUSH BC             ;Preserve registers
2379   0E0A D5                      PUSH DE
2380   0E0B E5                      PUSH HL
2381   0E0C CD 08 00                CALL $0008
2382   0E0F E1                      POP  HL             ;Restore registers
2383   0E10 D1                      POP  DE
2384   0E11 C1                      POP  BC
2385   0E12 C9                      RET
2386   0E13             
2387   0E13             
2388   0E13             ; New line output to console device
2389   0E13             ;   On entry: No parameters required
2390   0E13             ;   On exit:  BC DE HL IX IY preserved
2391   0E13 C5          API_Lout:   PUSH BC             ;Preserve registers
2392   0E14 D5                      PUSH DE
2393   0E15 E5                      PUSH HL
2394   0E16 3E 0D                   LD A, CR ; enter char
2395   0E18 CD 08 00                CALL $0008
2396   0E1B E1                      POP  HL             ;Restore registers
2397   0E1C D1                      POP  DE
2398   0E1D C1                      POP  BC
2399   0E1E C9                      RET
2400   0E1F             
2401   0E1F             
2402   0E1F             ; String output to console device
2403   0E1F             ;   On entry: DE = Address of string
2404   0E1F             ;   On exit:  BC DE HL IX IY preserved
2405   0E1F C5          API_Sout:   PUSH BC             ;Preserve registers
2406   0E20 D5                      PUSH DE
2407   0E21 E5                      PUSH HL
2408   0E22 62                      LD H, D
2409   0E23 6B                      LD L, E
2410   0E24 CD B6 0C                CALL SNDLCDMSG
2411   0E27 E1                      POP  HL             ;Restore registers
2412   0E28 D1                      POP  DE
2413   0E29 C1                      POP  BC
2414   0E2A C9                      RET
2415   0E2B             
2416   0E2B             
2417   0E2B             ; Hex byte output to console
2418   0E2B             ;   On entry: A = Byte to be output in hex
2419   0E2B             ;   On exit:  BC DE HL IX IY preserved
2420   0E2B F5          HexOut:     PUSH AF             ;Preserve byte to be output
2421   0E2C 1F                      RRA                 ;Shift top nibble to
2422   0E2D 1F                      RRA                 ;  botom four bits..
2423   0E2E 1F                      RRA
2424   0E2F 1F                      RRA
2425   0E30 E6 0F                   AND  $0F           ;Mask off unwanted bits
2426   0E32 CD 38 0E                CALL HexOutHex           ;Output hi nibble
2427   0E35 F1                      POP  AF             ;Restore byte to be output
2428   0E36 E6 0F                   AND  $0F           ;Mask off unwanted bits
2429   0E38             ; Output nibble as ascii character
2430   0E38 FE 0A       HexOutHex:       CP   $0A           ;Nibble > 10 ?
2431   0E3A 38 02                   JR   C,HexOutSkip        ;No, so skip
2432   0E3C C6 07                   ADD  A,7            ;Yes, so add 7
2433   0E3E C6 30       HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
2434   0E40 C3 09 0E                JP   API_Cout       ;Write character
2435   0E43             
2436   0E43             
2437   0E43             ; Output string at DE with substitutions
2438   0E43             ;   On entry: A = Address of device on I2C bus (write address)
2439   0E43             ;             DE = Address of null terminated string
2440   0E43             ;             H = Value to substitute for $H
2441   0E43             ;             L = Value to substitute for $L
2442   0E43             ;             B = Value to substitute for $B
2443   0E43             ;   On exit:  DE = Address of next location after this string
2444   0E43             ;             IX IY preserved
2445   0E43 1A          String:     LD   A,(DE)         ;Get character from string
2446   0E44 13                      INC  DE             ;Point to next character in string
2447   0E45 B7                      OR   A              ;Null ?
2448   0E46 C8                      RET  Z              ;Yes, so we're done
2449   0E47 FE 24                   CP   '$'            ;Substitue value?
2450   0E49 28 05                   JR   Z,StringSubst       ;Yes, so go handle substitution
2451   0E4B CD F1 0D                CALL CharOut        ;Output character to console
2452   0E4E 18 F3                   JR   String         ;Go get next character from string
2453   0E50 1A          StringSubst:     LD   A,(DE)         ;Get character from string
2454   0E51 13                      INC  DE             ;Point to next character in string
2455   0E52 B7                      OR   A              ;Null ?
2456   0E53 C8                      RET  Z              ;Yes, so we're done
2457   0E54 FE 48                   CP   'H'            ;Register H
2458   0E56 20 03                   JR   NZ,StringNotH       ;No, so skip
2459   0E58 7C                      LD   A,H            ;Get value 'H'
2460   0E59 18 0C                   JR   StringGotIt         ;Go output it in hex
2461   0E5B FE 4C       StringNotH:      CP   'L'            ;Register L
2462   0E5D 20 03                   JR   NZ,StringNotL       ;No, so skip
2463   0E5F 7D                      LD   A,L            ;Get value 'L'
2464   0E60 18 05                   JR   StringGotIt         ;Go output it in hex
2465   0E62 FE 42       StringNotL:      CP   'B'            ;Register B
2466   0E64 20 04                   JR   NZ,StringNotB       ;No, so skip
2467   0E66 78                      LD   A,B            ;Get value 'L'
2468   0E67                         ;JR   @GotIt        ;Go output it in hex
2469   0E67 CD 2B 0E    StringGotIt:     CALL HexOut         ;Output write address in hex
2470   0E6A 18 D7       StringNotB:      JR   String         ;Go get next character from string
2471   0E6C             
2472   0E6C             
2473   0E6C             ; **********************************************************************
2474   0E6C             ; I2C support functions
2475   0E6C             
2476   0E6C             ; I2C bus open device
2477   0E6C             ;   On entry: A = Device address (bit zero is read flag)
2478   0E6C             ;             SCL = unknown, SDA = unknown
2479   0E6C             ;   On exit:  If successfully A = 0 and Z flagged
2480   0E6C             ;             If unsuccessfully A = Error and NZ flagged
2481   0E6C             ;             BC DE HL IX IY preserved
2482   0E6C F5          I2C_Open:   PUSH AF
2483   0E6D CD E0 0E                CALL I2C_Start      ;Output start condition
2484   0E70 F1                      POP  AF
2485   0E71 18 03                   JR   I2C_Write      ;Write data byte
2486   0E73             
2487   0E73             
2488   0E73             ; I2C bus close device
2489   0E73             ;   On entry: SCL = unknown, SDA = unknown
2490   0E73             ;   On exit:  If successfully A=0 and Z flagged
2491   0E73             ;             If unsuccessfully A=Error and NZ flagged
2492   0E73             ;             SCL = hi, SDA = hi
2493   0E73             ;             BC DE HL IX IY preserved
2494   0E73 C3 EB 0E    I2C_Close:  JP   I2C_Stop       ;Output stop condition
2495   0E76             
2496   0E76             
2497   0E76             ; **********************************************************************
2498   0E76             ; **********************************************************************
2499   0E76             ; I2C bus master driver
2500   0E76             ; **********************************************************************
2501   0E76             ; **********************************************************************
2502   0E76             
2503   0E76             ; Functions provided are:
2504   0E76             ;     I2C_Start
2505   0E76             ;     I2C_Stop
2506   0E76             ;     I2C_Read
2507   0E76             ;     I2C_Write
2508   0E76             ;
2509   0E76             ; This code has delays between all I/O operations to ensure it works
2510   0E76             ; with the slowest I2C devices
2511   0E76             ;
2512   0E76             ; I2C transfer sequence
2513   0E76             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2514   0E76             ;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
2515   0E76             ;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
2516   0E76             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2517   0E76             ;
2518   0E76             ;
2519   0E76             ; Start condition                     Stop condition
2520   0E76             ; Output by master device             Output by master device
2521   0E76             ;       ----+                                      +----
2522   0E76             ; SDA       |                         SDA          |
2523   0E76             ;           +-------                        -------+
2524   0E76             ;       -------+                                +-------
2525   0E76             ; SCL          |                      SCL       |
2526   0E76             ;              +----                        ----+
2527   0E76             ;
2528   0E76             ;
2529   0E76             ; Address frame
2530   0E76             ; Clock and data output from master device
2531   0E76             ; Receiving device outputs acknowledge 
2532   0E76             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2533   0E76             ; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
2534   0E76             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2535   0E76             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2536   0E76             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2537   0E76             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2538   0E76             ;
2539   0E76             ;
2540   0E76             ; Data frame 
2541   0E76             ; Clock output by master device
2542   0E76             ; Data output by transmitting device
2543   0E76             ; Receiving device outputs acknowledge 
2544   0E76             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2545   0E76             ; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
2546   0E76             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2547   0E76             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2548   0E76             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2549   0E76             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2550   0E76             ;
2551   0E76             
2552   0E76             
2553   0E76             ; **********************************************************************
2554   0E76             ; I2C constants
2555   0E76             
2556   0E76             
2557   0E76             ; I2C bus master interface
2558   0E76             ; The default device option is for SC126 or compatible
2559   0E76             
2560   0E76             I2C_PORT:   .EQU $20           ;Host I2C port address
2561   0E76             I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
2562   0E76             I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
2563   0E76             I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
2564   0E76             I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
2565   0E76             I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
2566   0E76             
2567   0E76             
2568   0E76             ; I2C support constants
2569   0E76             ERR_NONE:   .EQU 0              ;Error = None
2570   0E76             ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
2571   0E76             ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
2572   0E76             ERR_TOUT:   .EQU 3              ;Error = Timeout
2573   0E76             
2574   0E76             
2575   0E76             ; **********************************************************************
2576   0E76             ; Hardware dependent I2C bus functions
2577   0E76             
2578   0E76             
2579   0E76             ; I2C bus transmit frame (address or data)
2580   0E76             ;   On entry: A = Data byte, or
2581   0E76             ;                 Address byte (bit zero is read flag)
2582   0E76             ;             SCL = low, SDA = low
2583   0E76             ;   On exit:  If successful A=0 and Z flagged
2584   0E76             ;                SCL = lo, SDA = lo
2585   0E76             ;             If unsuccessful A=Error and NZ flagged
2586   0E76             ;                SCL = high, SDA = high, I2C closed
2587   0E76             ;             BC DE HL IX IY preserved
2588   0E76 C5          I2C_Write:  PUSH BC             ;Preserve registers
2589   0E77 D5                      PUSH DE
2590   0E78 57                      LD   D,A            ;Store byte to be written
2591   0E79 06 08                   LD   B,8            ;8 data bits, bit 7 first
2592   0E7B CB 12       I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
2593   0E7D 38 05                   JR   C,I2C_WriteBit_Hi      ;High, so skip
2594   0E7F CD 12 0F                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
2595   0E82 18 03                   JR   I2C_WriteBit_Clk
2596   0E84 CD 0B 0F    I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
2597   0E87 CD FD 0E    I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
2598   0E8A CD 04 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
2599   0E8D 10 EC                   DJNZ I2C_WriteWr_Loop
2600   0E8F             ; Test for acknowledge from slave (receiver)
2601   0E8F             ; On arriving here, SCL = lo, SDA = data bit
2602   0E8F CD 0B 0F                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
2603   0E92 CD FD 0E                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
2604   0E95 CD 23 0F                CALL I2C_RdPort     ;Read SDA input
2605   0E98 47                      LD   B,A
2606   0E99 CD 04 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
2607   0E9C CB 78                   BIT  I2C_SDA_RD,B
2608   0E9E 20 04                   JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
2609   0EA0 D1                      POP  DE             ;Restore registers
2610   0EA1 C1                      POP  BC
2611   0EA2 AF                      XOR  A              ;Return success A=0 and Z flagged
2612   0EA3 C9                      RET
2613   0EA4             ; I2C STOP required as no acknowledge
2614   0EA4             ; On arriving here, SCL = lo, SDA = hi
2615   0EA4 CD 12 0F    I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
2616   0EA7 CD FD 0E                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
2617   0EAA CD 0B 0F                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
2618   0EAD D1                      POP  DE             ;Restore registers
2619   0EAE C1                      POP  BC
2620   0EAF 3E 02                   LD   A,ERR_NOACK    ;Return error = No Acknowledge
2621   0EB1 B7                      OR   A              ;  and NZ flagged
2622   0EB2 C9                      RET
2623   0EB3             
2624   0EB3             
2625   0EB3             ; I2C bus receive frame (data)
2626   0EB3             ;   On entry: A = Acknowledge flag
2627   0EB3             ;               If A != 0 the read is acknowledged
2628   0EB3             ;             SCL low, SDA low
2629   0EB3             ;   On exit:  If successful A = data byte and Z flagged
2630   0EB3             ;               SCL = low, SDA = low
2631   0EB3             ;             If unsuccessul* A = Error and NZ flagged
2632   0EB3             ;               SCL = low, SDA = low
2633   0EB3             ;             BC DE HL IX IY preserved
2634   0EB3             ; *This function always returns successful
2635   0EB3 C5          I2C_Read:   PUSH BC             ;Preserve registers
2636   0EB4 D5                      PUSH DE
2637   0EB5 5F                      LD   E,A            ;Store acknowledge flag
2638   0EB6 06 08                   LD   B,8            ;8 data bits, 7 first
2639   0EB8 CD 0B 0F                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
2640   0EBB CD FD 0E    I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
2641   0EBE CD 23 0F                CALL I2C_RdPort     ;Read SDA input bit
2642   0EC1 37                      SCF                 ;Set carry flag
2643   0EC2 CB 7F                   BIT  I2C_SDA_RD,A   ;SDA input high?
2644   0EC4 20 01                   JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
2645   0EC6 3F                      CCF                 ;Clear carry flag
2646   0EC7 CB 12       I2C_ReadRotate:    RL   D              ;Rotate result into D
2647   0EC9 CD 04 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
2648   0ECC 10 ED                   DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
2649   0ECE             ; Acknowledge input byte
2650   0ECE             ; On arriving here, SCL = lo, SDA = hi/input
2651   0ECE 7B                      LD   A,E            ;Get acknowledge flag
2652   0ECF B7                      OR   A              ;A = 0? (indicates no acknowledge)
2653   0ED0 28 03                   JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
2654   0ED2 CD 12 0F                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
2655   0ED5 CD FD 0E    I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
2656   0ED8 CD 04 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2657   0EDB 7A                      LD   A,D            ;Get data byte received
2658   0EDC D1                      POP  DE             ;Restore registers
2659   0EDD C1                      POP  BC
2660   0EDE BF                      CP   A              ;Return success Z flagged
2661   0EDF C9                      RET
2662   0EE0             
2663   0EE0             
2664   0EE0             ; I2C bus start
2665   0EE0             ;   On entry: SCL = unknown, SDA = unknown
2666   0EE0             ;   On exit:  SCL = low, SDA = low
2667   0EE0             ;             A = 0 and Z flagged as we always succeed
2668   0EE0             ;             BC DE HL IX IY preserved
2669   0EE0             ; First ensure SDA and SCL are high
2670   0EE0 CD F9 0E    I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
2671   0EE3             ;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
2672   0EE3             ;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
2673   0EE3             ; Generate I2C start condition
2674   0EE3 CD 12 0F                CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2675   0EE6 CD 04 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2676   0EE9 AF                      XOR  A              ;Return success A=0 and Z flagged
2677   0EEA C9                      RET
2678   0EEB             
2679   0EEB             
2680   0EEB             ; I2C bus stop 
2681   0EEB             ;   On entry: SCL = unknown, SDA = unknown
2682   0EEB             ;   On exit:  SCL = high, SDA = high
2683   0EEB             ;             A = 0 and Z flagged as we always succeed
2684   0EEB             ;             BC DE HL IX IY preserved
2685   0EEB             ; First ensure SDA and SCL are low
2686   0EEB CD 12 0F    I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2687   0EEE CD 04 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2688   0EF1             ; Generate stop condition
2689   0EF1 CD FD 0E                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
2690   0EF4 CD 0B 0F                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
2691   0EF7 AF                      XOR  A              ;Return success A=0 and Z flagged
2692   0EF8 C9                      RET
2693   0EF9             
2694   0EF9             
2695   0EF9             ; **********************************************************************
2696   0EF9             ; I2C bus simple I/O functions
2697   0EF9             ;   On entry: No parameters required
2698   0EF9             ;   On exit:  BC DE HL IX IY preserved
2699   0EF9             
2700   0EF9 3E 81       I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
2701   0EFB 18 1A                   JR   I2C_WrPort
2702   0EFD             
2703   0EFD 3A 00 D0    I2C_SCL_HI: LD   A,(I2C_RAMCPY)
2704   0F00 CB C7                   SET  I2C_SCL_WR,A
2705   0F02 18 13                   JR   I2C_WrPort
2706   0F04             
2707   0F04 3A 00 D0    I2C_SCL_LO: LD   A,(I2C_RAMCPY)
2708   0F07 CB 87                   RES  I2C_SCL_WR,A
2709   0F09 18 0C                   JR   I2C_WrPort
2710   0F0B             
2711   0F0B 3A 00 D0    I2C_SDA_HI: LD   A,(I2C_RAMCPY)
2712   0F0E CB FF                   SET  I2C_SDA_WR,A
2713   0F10 18 05                   JR   I2C_WrPort
2714   0F12             
2715   0F12 3A 00 D0    I2C_SDA_LO: LD   A,(I2C_RAMCPY)
2716   0F15 CB BF                   RES  I2C_SDA_WR,A
2717   0F17                         ;JR   I2C_WrPort
2718   0F17             
2719   0F17 C5          I2C_WrPort: PUSH BC             ;Preserve registers
2720   0F18 06 00                   LD   B,0            ;Set up BC for 16-bit
2721   0F1A 0E 20                   LD   C,I2C_PORT     ;  I/O address of I2C port
2722   0F1C ED 79                   OUT  (C),A          ;Write A to I2C I/O port
2723   0F1E 32 00 D0                LD   (I2C_RAMCPY),A ;Write A to RAM copy
2724   0F21 C1                      POP  BC             ;Restore registers
2725   0F22 C9                      RET
2726   0F23             
2727   0F23 C5          I2C_RdPort: PUSH BC             ;Preserve registers
2728   0F24 06 00                   LD   B,0            ;Set up BC for 16-bit
2729   0F26 0E 20                   LD   C,I2C_PORT     ;  I/O address of I2C port
2730   0F28 ED 78                   IN   A,(C)          ;Read A from I/O port
2731   0F2A C1                      POP  BC             ;Restore registers
2732   0F2B C9                      RET
2733   0F2C             
2734   0F2C             
2735   0F2C             
2736   0F2C 0C0D0D0A5A38WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
2736   0F32 30204D696E6920496E69636961646F0D0A00
2737   0F44 5A3830204D49MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H
2737   0F4A 4E492C204820544F2048454C500D00
2738   0F59             
2739   0F59 49202D20496EMSG_MENU1 .db "I - Intel hex loader",CR, 00H
2739   0F5F 74656C20686578206C6F616465720D00
2740   0F6F 42202D204261MSG_MENU2 .db "B - Basic",CR, 00H
2740   0F75 7369630D00
2741   0F7A 442041414141MSG_MENU3 .db "D AAAA - DISPLAY",CR,00H
2741   0F80 202D20444953504C41590D00
2742   0F8C 4D2041414141MSG_MENU4 .db "M AAAA - MODIFY",CR,00H
2742   0F92 202D204D4F444946590D00
2743   0F9D 472041414141MSG_MENU5 .db "G AAAA - GO TO",CR, 00H
2743   0FA3 202D20474F20544F0D00
2744   0FAD 31202D204932MSG_MENU6 .db "1 - I2C Scan",CR, 00H
2744   0FB3 43205363616E0D00
2745   0FBB 32202D204932MSG_MENU7 .db "2 - I2C PC -> MEM",CR, 00H
2745   0FC1 43205043202D3E204D454D0D00
2746   0FCE 33202D204932MSG_MENU8 .db "3 - I2C MEM -> PC", 00H
2746   0FD4 43204D454D202D3E20504300
2747   0FE0             
2748   0FE0 0C4932432064LISTMsg:    .DB  CS,"I2C device found at:",CR,0
2748   0FE6 657669636520666F756E642061743A0D00
2749   0FF7 0C434F505920MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
2749   0FFD 493243204D454D20544F204350550D00
2750   100D 0C434F505920MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H
2750   1013 43505520544F20493243204D454D0D00
2751   1023 46524F4D3A20MSG_FROM    .db "FROM: ", 00H
2751   1029 00
2752   102A 0D544F3A2000MSG_TO      .db CR,"TO: ", 00H
2753   1030 0D53495A4528MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
2753   1036 4259544553293A2000
2754   103F 0D434F505920MSG_COPYOK  .db CR,"COPY OK", 00H
2754   1045 4F4B00
2755   1048 0D434F505920MSG_COPYFAIL  .db CR,"COPY FAIL", 00H
2755   104E 4641494C00
2756   1053             
2757   1053             
2758   1053 0C496E74656CMSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
2758   1059 20484558206C6F616465722E2E2E0D00
2759   1069 46494C452052FILEOK    .DB      "FILE RECEIVED OK",CR,00H
2759   106F 45434549564544204F4B0D00
2760   107B 434845434B53CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
2760   1081 554D204552524F520D00
2761   108B             
2762   108B             
2763   108B             
2764   108B             ; **********************************************************************
2765   108B             ; I2C workspace / variables in RAM
2766   108B             
2767   D000                         .ORG  I2CDATA
2768   D000             
2769   D000 00          I2C_RAMCPY: .DB  0              ;RAM copy of output port
2770   D001             
2771   D001 00          RESULTS:    .DB  0              ;Large block of results can start here
2772   D002             
2773   D002             .end
tasm: Number of errors = 0
