0001   0000             ; Diego Cruz - Nov 2022
0002   0000             ; 
0003   0000             ; bootV2: 
0004   0000             ;         - CPU Z80@4Mhz
0005   0000             ;         - Lcd Grafico 128x64
0006   0000             ;         - Keyboard 40 keys + Shift
0007   0000             ;         - Rom 32k 0000h - 7FFFh
0008   0000             ;         - Ram 32k 8000h - FFFFh
0009   0000             ;         
0010   0000             ;
0011   0000             ;         - Ports:
0012   0000             ;               - Keyboard: 40H
0013   0000             ;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
0014   0000             ;               - User IN/OUT: C0H
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------
0017   0000             LCDCTRL	    .EQU    70H
0018   0000             LCDDATA     .EQU    71H
0019   0000             KEY_IN      .EQU    40H
0020   0000             KEY_OUT     .EQU    40H
0021   0000             
0022   0000             CTRLC       .EQU    03H             ; Control "C"
0023   0000             CTRLG       .EQU    07H             ; Control "G"
0024   0000             BKSP        .EQU    08H             ; Back space
0025   0000             LF          .EQU    0AH             ; Line feed
0026   0000             VT          .equ    0BH             ; 
0027   0000             CS          .EQU    0CH             ; Clear screen
0028   0000             CR          .EQU    0DH             ; Carriage return [Enter]
0029   0000             CTRLO       .EQU    0FH             ; Control "O"
0030   0000             CTRLQ	    .EQU	11H		        ; Control "Q"
0031   0000             CTRLR       .EQU    12H             ; Control "R"
0032   0000             CTRLS       .EQU    13H             ; Control "S"
0033   0000             CTRLU       .EQU    15H             ; Control "U"
0034   0000             ESC         .EQU    1BH             ; Escape
0035   0000             DEL         .EQU    7FH             ; Delete
0036   0000             
0037   0000             BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
0038   0000             ;
0039   0000             ; BAUD RATE CONSTANTS
0040   0000             ;
0041   0000             B300:	.EQU	0220H	;300 BAUD
0042   0000             B1200:	.EQU	0080H	;1200 BAUD
0043   0000             B2400:	.EQU	003FH	;2400 BAUD
0044   0000             B4800:	.EQU	001BH	;4800 BAUD
0045   0000             B9600:	.EQU	000BH	;9600 BAUD
0046   0000             
0047   0000             SYSTEM:	.EQU 	0FD00H	;INITIAL STACK POINTER
0048   0000             I2CDATA .EQU    0D000H 
0049   0000             
0050   0000             I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
0051   0000             TIMEOUT:    .EQU 10000          ;Timeout loop counter
0052   0000             
0053   0000             ADDR:       .EQU 0FEB0H   ;THE ADDRESS  2 bytes
0054   0000             ADDR_FROM   .EQU 0FEB2H   ;THE ADDRESS FROM  2 bytes
0055   0000             ADDR_TO     .EQU 0FEB4H   ;THE ADDRESS TO 2 bytes
0056   0000             ADDR_SIZE   .EQU 0FEB6H   ;THE ADDRESS SIZE 2 bytesdelay:
0057   0000             DATA:       .EQU 0FEB8H   ;THE DATA
0058   0000             MSGBUF:     .EQU 0FE00H   ;STRING HANDLING AREA
0059   0000             
0060   0000             BAUD:	 .EQU	0FFC0H	 ;BAUD RATE
0061   0000             PUTCH:   .EQU   0FFAAH   ;OUTPUT A CHARACTER TO SERIAL
0062   0000             GETCH:   .EQU   0FFACH   ;WAIT FOR A CHARACTER FROM SERIAL
0063   0000             
0064   0000             SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
0065   0000             SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
0066   0000             
0067   0000             
0068   0000             ; LCD TEXT MODE
0069   0000             LCD_LINE1   .EQU    80H
0070   0000             LCD_LINE2   .EQU    90H
0071   0000             LCD_LINE3   .EQU    88H
0072   0000             LCD_LINE4   .EQU    98H
0073   0000             
0074   0000             
0075   0000             ; RAM MAP
0076   0000             
0077   0000             
0078   0000             
0079   0000             LCD_CHAR            .EQU    $E000   ; 1 byte char ex: 'A'
0080   0000             LCD_CHAR_POINT      .EQU    $E001   ; 2 bytes ponteiro para o mapa de caracteres
0081   0000             LCD_TXT_X           .EQU    $E003   ; 1 byte  0-20 (21 col)
0082   0000             LCD_TXT_Y           .EQU    $E004   ; 1 byte  0-7  (8 row)
0083   0000             LCD_BYTE_INDEX      .EQU    $E005   ; 2 bytes pointer pixel(8)
0084   0000             LCD_BIT_INDEX       .EQU    $E007   ; 1 byte pointer pixel(1)
0085   0000             LCD_TXT_X_TMP       .EQU    $E008   ; 2 bytes = LCD_TXT_X * 6
0086   0000             LCD_TXT_Y_TMP       .EQU    $E00A   ; 2 bytes = LCD_TXT_Y * 128
0087   0000             LCD_CHAR_H          .EQU    $E00C   ; 1 byte altura do char
0088   0000             LCD_CHAR_W          .EQU    $E00D   ; 1 byte largura do char
0089   0000             LCD_TMP_POINT       .EQU    $E00E   ; 2 bytes ponteiro do pixel altural do print
0090   0000             LCD_DELETE_CHAR     .EQU    $E00F   ; 1 byte, 0 n√£o, ff delete proximo char
0091   0000             LCD_AUTO_X          .EQU    $E010   ; 1 byte, 0 sim, ff nao
0092   0000             
0093   0000             DISPLAY             .EQU    $E500
0094   0000             
0095   0000             LCD_TEMP        .EQU    $E110
0096   0000             LCD_COOX        .EQU    $E102 ; 1 byte, local onde vai printar
0097   0000             LCD_COOY        .EQU    $E103 ; 1 byte
0098   0000             LCD_PRINT_H     .EQU    $E104 ; 1 byte, tamanho do que vai printar
0099   0000             LCD_PRINT_W     .EQU    $E105 ; 1 byte
0100   0000             LCD_PRINT_IMAGE .EQU    $E106 ; 2 bytes
0101   0000             
0102   0000             
0103   0000                     .ORG 0
0104   0000 F3          RST00	DI
0105   0001 C3 6B 04            JP  INICIO
0106   0004             						
0107   0008                     .ORG     0008H
0108   0008 C3 04 08    RST08   JP  PRINTCHAR
0109   000B             
0110   0010                     .ORG 0010H
0111   0010 C3 3D 0B    RST10   JP KEYREADINIT
0112   0013             
0113   0018                     .ORG 0018H ; check break
0114   0018             RST18   ;LD	A, 0
0115   0018                     ;CP	0
0116   0018                     ;RET
0117   0018 C3 28 0B    	JP CHKKEY
0118   001B             
0119   001B             KEYMAP:
0120   001B 313233343536.BYTE   "1234567890"
0120   0021 37383930
0121   0025 515745525459.BYTE   "QWERTYUIOP"
0121   002B 55494F50
0122   002F 415344464748.BYTE   "ASDFGHJKL", CR
0122   0035 4A4B4C0D
0123   0039 035A58435642.BYTE   CTRLC, "ZXCVBNM ", DEL
0123   003F 4E4D207F
0124   0043             
0125   0043             SHIFTKEYMAP:
0126   0043 21402324255E.BYTE   "!@#$%^&*()"
0126   0049 262A2829
0127   004D 607E2D5F3D2B.BYTE   "`~-_=+;:'"
0127   0053 3B3A27
0128   0056 22          .BYTE   22h
0129   0057 7B7D5B5D7C5C.BYTE   "{}[]|",$5C,"<>?/"
0129   005D 3C3E3F2F
0130   0061 032C2E1B2020.BYTE   CTRLC,",.",ESC,"    ", VT, LF
0130   0067 20200B0A
0131   006B             
0132   006B             
0133   006B             
0134   006B             TABLE:
0135   006B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
0135   0071 0000
0136   0073 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
0136   0079 0000
0137   007B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
0137   0081 0000
0138   0083 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
0138   0089 0000
0139   008B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
0139   0091 0000
0140   0093 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
0140   0099 0000
0141   009B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
0141   00A1 0000
0142   00A3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
0142   00A9 0000
0143   00AB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
0143   00B1 0000
0144   00B3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
0144   00B9 0000
0145   00BB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0145   00C1 0000
0146   00C3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
0146   00C9 0000
0147   00CB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0147   00D1 0000
0148   00D3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
0148   00D9 0000
0149   00DB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0149   00E1 0000
0150   00E3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
0150   00E9 0000
0151   00EB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0151   00F1 0000
0152   00F3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
0152   00F9 0000
0153   00FB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0153   0101 0000
0154   0103 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
0154   0109 0000
0155   010B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0155   0111 0000
0156   0113 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
0156   0119 0000
0157   011B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0157   0121 0000
0158   0123 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
0158   0129 0000
0159   012B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0159   0131 0000
0160   0133 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
0160   0139 0000
0161   013B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0161   0141 0000
0162   0143 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
0162   0149 0000
0163   014B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0163   0151 0000
0164   0153 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
0164   0159 0000
0165   015B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
0165   0161 0000
0166   0163 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
0166   0169 0000
0167   016B             
0168   016B             ; DEC 32
0169   016B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
0169   0171 0000
0170   0173 202020202000.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
0170   0179 2000
0171   017B 505050000000.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
0171   0181 0000
0172   0183 5050F850F850.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
0172   0189 5000
0173   018B 2078A07028F0.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
0173   0191 2000
0174   0193 C0C810204098.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
0174   0199 1800
0175   019B 6090A040A890.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
0175   01A1 6800
0176   01A3 202020000000.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
0176   01A9 0000
0177   01AB 102040404020.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
0177   01B1 1000
0178   01B3 402010101020.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
0178   01B9 4000
0179   01BB 0020A870A820.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0179   01C1 0000
0180   01C3 002020F82020.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
0180   01C9 0000
0181   01CB 000000006020.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0181   01D1 4000
0182   01D3 000000F80000.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
0182   01D9 0000
0183   01DB 000000000060.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0183   01E1 6000
0184   01E3 000008102040.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
0184   01E9 8000
0185   01EB 708898A8C888.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0185   01F1 7000
0186   01F3 206020202020.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
0186   01F9 7000
0187   01FB 708808102040.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0187   0201 F800
0188   0203 F81020100888.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
0188   0209 7000
0189   020B 10305090F810.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0189   0211 1000
0190   0213 F880F0080888.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
0190   0219 7000
0191   021B 304080F08888.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0191   0221 7000
0192   0223 F80810204040.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
0192   0229 4000
0193   022B 708888708888.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0193   0231 7000
0194   0233 708888780810.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
0194   0239 6000
0195   023B 000030300030.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0195   0241 3000
0196   0243 003030003010.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
0196   0249 2000
0197   024B 102040804020.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0197   0251 1000
0198   0253 0000F800F800.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
0198   0259 0000
0199   025B 402010081020.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
0199   0261 4000
0200   0263 304808102000.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
0200   0269 2000
0201   026B 70880868A8A8.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
0201   0271 7000
0202   0273             
0203   0273             ; DEC 65 Maiusculas
0204   0273 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0204   0279 8800
0205   027B F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0205   0281 F000
0206   0283 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0206   0289 7000
0207   028B E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0207   0291 E000
0208   0293 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0208   0299 F800
0209   029B F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0209   02A1 8000
0210   02A3 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0210   02A9 7000
0211   02AB 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0211   02B1 8800
0212   02B3 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0212   02B9 7000
0213   02BB 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0213   02C1 7000
0214   02C3 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0214   02C9 8800
0215   02CB 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0215   02D1 F800
0216   02D3 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0216   02D9 8800
0217   02DB 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0217   02E1 8800
0218   02E3 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0218   02E9 7000
0219   02EB F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0219   02F1 8000
0220   02F3 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0220   02F9 7000
0221   02FB F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0221   0301 8800
0222   0303 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0222   0309 7000
0223   030B F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0223   0311 2000
0224   0313 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0224   0319 7000
0225   031B 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0225   0321 2000
0226   0323 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0226   0329 8800
0227   032B 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0227   0331 8800
0228   0333 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0228   0339 2000
0229   033B F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0229   0341 F800
0230   0343             
0231   0343             ; DEC 91
0232   0343 302020202020.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
0232   0349 3000
0233   034B 008040201008.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0233   0351 0000
0234   0353 602020202020.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
0234   0359 6000
0235   035B 205088000000.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
0235   0361 0000
0236   0363 000000000000.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
0236   0369 F800
0237   036B 402010000000.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
0237   0371 0000
0238   0373             
0239   0373             ; DEC 97 "Minusculas"
0240   0373 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0240   0379 8800
0241   037B F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0241   0381 F000
0242   0383 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0242   0389 7000
0243   038B E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0243   0391 E000
0244   0393 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0244   0399 F800
0245   039B F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0245   03A1 8000
0246   03A3 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0246   03A9 7000
0247   03AB 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0247   03B1 8800
0248   03B3 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0248   03B9 7000
0249   03BB 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0249   03C1 7000
0250   03C3 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0250   03C9 8800
0251   03CB 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0251   03D1 F800
0252   03D3 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0252   03D9 8800
0253   03DB 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0253   03E1 8800
0254   03E3 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0254   03E9 7000
0255   03EB F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0255   03F1 8000
0256   03F3 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0256   03F9 7000
0257   03FB F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0257   0401 8800
0258   0403 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0258   0409 7000
0259   040B F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0259   0411 2000
0260   0413 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0260   0419 7000
0261   041B 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0261   0421 2000
0262   0423 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0262   0429 8800
0263   042B 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0263   0431 8800
0264   0433 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0264   0439 2000
0265   043B F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0265   0441 F800
0266   0443             
0267   0443             ; DEC 123
0268   0443 102020402020.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0268   0449 1000
0269   044B 202020202020.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0269   0451 2000
0270   0453 402020102020.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0270   0459 4000
0271   045B 000050A00000.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0271   0461 0000
0272   0463 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0272   0469 0000
0273   046B             
0274   046B             
0275   046B             
0276   046B             
0277   046B             
0278   046B             
0279   046B             
0280   046B             
0281   046B             ; -----------------------------------------------------------------------------
0282   046B             ;   INICIO
0283   046B             ; -----------------------------------------------------------------------------
0284   046B             INICIO:
0285   046B 31 00 FD        LD  SP, SYSTEM
0286   046E             
0287   046E                 ; init serial
0288   046E CD D1 0C        CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0289   0471 21 6C 0C        LD    HL,TXDATA
0290   0474 22 AA FF        LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0291   0477 21 97 0C        LD    HL,RXDATA
0292   047A 22 AC FF        LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
0293   047D                 
0294   047D 21 1B 00        LD	HL,B4800
0295   0480 22 C0 FF    	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
0296   0483             
0297   0483 3E FF           LD A, $FF
0298   0485 D3 C0           OUT (SERIAL_TX_PORT), A
0299   0487             
0300   0487 21 BA 0E        LD HL, WELLCOME
0301   048A CD 52 0C        CALL SNDMSG
0302   048D             
0303   048D                 ; CALL INCH
0304   048D                 ; CALL OUTCH
0305   048D             
0306   048D                 ; Init LCD hardware
0307   048D CD 88 09        CALL INIT_LCD
0308   0490 CD 19 0B        call delay
0309   0493             
0310   0493 CD A0 0A        call cls_TXT
0311   0496 CD 19 0B        call delay
0312   0499             
0313   0499 CD 2A 0A        CALL enable_grafic
0314   049C CD 19 0B        call delay
0315   049F             
0316   049F CD A6 0A        call cls_GRAPHIC
0317   04A2 CD 19 0B        call delay
0318   04A5             
0319   04A5 CD 1C 0A        call lcd_clear
0320   04A8             
0321   04A8 21 00 E5        ld hl, DISPLAY
0322   04AB CD 43 0A        call print_image
0323   04AE             
0324   04AE CD 19 0B        call delay
0325   04B1             
0326   04B1                 ; Init LCD logical
0327   04B1 CD 75 07        call INIT_TXT_LCD ; set cursor X Y to 0
0328   04B4             
0329   04B4 21 D2 0E        LD HL, MSG_MONITOR
0330   04B7 CD 44 0C        CALL SNDLCDMSG
0331   04BA             
0332   04BA 3E 3E           LD A, '>'
0333   04BC CD 04 08        CALL PRINTCHAR
0334   04BF             
0335   04BF             KEY:
0336   04BF CD 3D 0B        CALL KEYREADINIT
0337   04C2             
0338   04C2 FE 48           CP 'H'
0339   04C4 CC 39 06        CALL Z, SHOWHELP
0340   04C7             
0341   04C7 FE 42           CP 'B'
0342   04C9 CA 00 60        JP Z, BASIC
0343   04CC             
0344   04CC FE 49           CP 'I'
0345   04CE CA 2D 06        JP Z, INTEL_HEX
0346   04D1             
0347   04D1 FE 31           CP '1'
0348   04D3 CC E7 0C        CALL Z, I2CLIST
0349   04D6             
0350   04D6 FE 32           CP '2'
0351   04D8 CC A2 05        CALL Z, I2CCPUTOMEM
0352   04DB             
0353   04DB FE 33           CP '3'
0354   04DD CC 7A 05        CALL Z, I2CMEMTOCPU
0355   04E0             
0356   04E0 FE 47           CP 'G'
0357   04E2 CC D1 06        CALL Z, GOJUMP
0358   04E5             
0359   04E5 FE 4D           CP 'M'
0360   04E7 CC 6F 06        CALL Z, MODIFY
0361   04EA             
0362   04EA FE 44           CP 'D'
0363   04EC CC FC 04        CALL Z, DSPLAY
0364   04EF             
0365   04EF 3E 0D           LD A, CR 
0366   04F1 CD 04 08        CALL PRINTCHAR
0367   04F4             
0368   04F4 3E 3E           LD A, '>' 
0369   04F6 CD 04 08        CALL PRINTCHAR
0370   04F9             
0371   04F9 C3 BF 04        JP  KEY
0372   04FC             
0373   04FC             
0374   04FC             ;--------------------------
0375   04FC             ; D DISPLAY MEMORY LOCATION
0376   04FC             ;--------------------------
0377   04FC 3E 44       DSPLAY: LD A, 'D'
0378   04FE CD 04 08            CALL PRINTCHAR
0379   0501 CD F9 06            CALL  OUTSP       ;A SPACE
0380   0504 CD 05 07           CALL  GETCHR
0381   0507 D8                 RET   C         
0382   0508 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0383   050B CD 05 07           CALL  GETCHR
0384   050E D8                 RET   C
0385   050F 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0386   0512             ;
0387   0512             ; WAIT FOR CR OR ESC
0388   0512             ;
0389   0512 CD 3D 0B    DPLAY1: CALL  KEYREADINIT
0390   0515 FE 1B              CP    ESC
0391   0517 C8                 RET   Z
0392   0518 FE 0D              CP    CR
0393   051A 20 F6              JR    NZ,DPLAY1          
0394   051C CD FF 06           CALL  TXCRLF      ;NEWLINE
0395   051F             ;
0396   051F             ; DISPLAY THE LINE
0397   051F             ;
0398   051F CD 34 05    DPLAY2: CALL  DPLINE
0399   0522 ED 53 B0 FE        LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
0400   0526             ;
0401   0526             ; DISPLAY MORE LINES OR EXIT
0402   0526             ;       
0403   0526 CD 3D 0B    DPLAY3: CALL  KEYREADINIT
0404   0529 38 FB              JR    C,DPLAY3   
0405   052B FE 0D              CP    CR        ;ENTER DISPLAYS THE NEXT LINE
0406   052D 28 F0              JR    Z,DPLAY2
0407   052F FE 1B              CP    ESC         ;ESC EXITS (SHIFT + C)
0408   0531 20 F3              JR    NZ,DPLAY3     
0409   0533 C9                 RET   
0410   0534             ;-------------------------
0411   0534             ; DISPLAY A LINE OF MEMORY
0412   0534             ;-------------------------      
0413   0534 ED 5B B0 FE DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
0414   0538 21 00 FE           LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
0415   053B             ;
0416   053B             ; DISPLAY THE ADDRESS
0417   053B             ;         
0418   053B CD 5C 07           CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
0419   053E CD 74 05           CALL  SPCBUF        
0420   0541             ;
0421   0541             ; DISPLAY 4 BYTES
0422   0541             ;
0423   0541 06 04              LD    B,4 ;16
0424   0543 1A          DLINE1: LD    A,(DE)
0425   0544 CD 61 07           CALL  BYTASC
0426   0547 CD 74 05           CALL  SPCBUF
0427   054A 13                 INC   DE        
0428   054B 10 F6              DJNZ  DLINE1
0429   054D                    ;CALL  SPCBUF
0430   054D             ;
0431   054D             ; NOW DISPLAY THE ASCII CHARACTER
0432   054D             ; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
0433   054D             ; BE DIFFERENT BETWEEN THE TWO PASSES!
0434   054D             ;
0435   054D ED 5B B0 FE        LD    DE,(ADDR)    
0436   0551 06 04              LD    B,4 ;16
0437   0553 1A          DLINE2: LD    A,(DE)   
0438   0554 FE 20              CP    20H
0439   0556 38 07              JR    C,DOT
0440   0558 FE 7F              CP    7FH
0441   055A 30 03              JR    NC,DOT
0442   055C C3 61 05           JP    NDOT
0443   055F 3E 2E       DOT:    LD    A,'.'
0444   0561 CD 76 05    NDOT:   CALL  INBUF
0445   0564 13                 INC   DE       
0446   0565 10 EC              DJNZ  DLINE2
0447   0567             ;         
0448   0567             ;TERMINATE AND DISPLAY STRING
0449   0567             ;       
0450   0567 CD 79 05           CALL  BCRLF
0451   056A 3E 00              LD    A,00H
0452   056C 77                 LD    (HL),A
0453   056D 21 00 FE           LD    HL,MSGBUF
0454   0570 CD 44 0C           CALL  SNDLCDMSG
0455   0573 C9                 RET
0456   0574             
0457   0574             
0458   0574             ;
0459   0574             ; PUT A SPACE IN THE BUFFER
0460   0574             ;
0461   0574 3E 08       SPCBUF: LD    A, 8 ;20H(32dec)
0462   0576 77          INBUF:  LD    (HL),A
0463   0577 23                 INC   HL
0464   0578 C9                 RET
0465   0579             ;
0466   0579             ; PUT A CR LF IN THE BUFFER
0467   0579             ;        
0468   0579             BCRLF:  ;LD    A,CR  
0469   0579                    ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
0470   0579 C9                 RET
0471   057A             
0472   057A             
0473   057A             
0474   057A             
0475   057A             
0476   057A             
0477   057A             I2CMEMTOCPU:
0478   057A                 ; Get parameters to copy a block from I2C memory to CPU memory
0479   057A             ;   On entry: DE = First address in I2C memory
0480   057A             ;             HL = First address in CPU memory
0481   057A             ;             BC = Number of bytes to be copied
0482   057A             ;             SCL = unknown, SDA = unknown
0483   057A             ;   On exit:  If successfully A = 0 and Z flagged
0484   057A             ;             If unsuccessfully A = Error and NZ flagged
0485   057A             ;             IX IY preserved
0486   057A             
0487   057A 21 85 0F        LD HL, MSG_MEM2CPU
0488   057D CD 44 0C        CALL SNDLCDMSG
0489   0580             
0490   0580 CD CA 05        CALL GET_FROM_TO_SIZE
0491   0583             
0492   0583             ;    DE = First address in I2C memory
0493   0583             ;    HL = First address in CPU memory
0494   0583             ;    BC = Number of bytes to be copied
0495   0583             
0496   0583 ED 5B B2 FE     LD DE, (ADDR_FROM)
0497   0587 2A B4 FE        LD HL, (ADDR_TO)
0498   058A ED 4B B6 FE     LD BC, (ADDR_SIZE)
0499   058E CD 11 0D        CALL I2C_MemRd  
0500   0591             
0501   0591 CA 9B 05        JP Z, I2CMEMTOCPU_OK
0502   0594 21 D6 0F        LD HL, MSG_COPYFAIL
0503   0597 CD 44 0C        CALL SNDLCDMSG
0504   059A C9              RET
0505   059B             I2CMEMTOCPU_OK:
0506   059B 21 CD 0F        LD HL, MSG_COPYOK
0507   059E CD 44 0C        CALL SNDLCDMSG
0508   05A1 C9              RET
0509   05A2             
0510   05A2             
0511   05A2             I2CCPUTOMEM:
0512   05A2             ; Get parameters to copy a block from CPU memory to I2C memory
0513   05A2             ;   On entry: DE = First address in I2C memory
0514   05A2             ;             HL = First address in CPU memory
0515   05A2             ;             BC = Number of bytes to be copied
0516   05A2             ;             SCL = unknown, SDA = unknown
0517   05A2             ;   On exit:  If successfully A = 0 and Z flagged
0518   05A2             ;             If unsuccessfully A = Error and NZ flagged
0519   05A2             ;             IX IY preserved
0520   05A2             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
0521   05A2             ; pages.
0522   05A2 21 9B 0F        LD HL, MSG_CPU2MEM
0523   05A5 CD 44 0C        CALL SNDLCDMSG
0524   05A8             
0525   05A8 CD CA 05        CALL GET_FROM_TO_SIZE
0526   05AB             
0527   05AB             ;    DE = First address in I2C memory
0528   05AB             ;    HL = First address in CPU memory
0529   05AB             ;    BC = Number of bytes to be copied
0530   05AB             
0531   05AB 2A B2 FE        LD HL, (ADDR_FROM)
0532   05AE ED 5B B4 FE     LD DE, (ADDR_TO)
0533   05B2 ED 4B B6 FE     LD BC, (ADDR_SIZE)
0534   05B6 CD 46 0D        CALL I2C_MemWr
0535   05B9                 
0536   05B9 CA C3 05        JP Z, I2CCPUTOMEM_OK
0537   05BC 21 D6 0F        LD HL, MSG_COPYFAIL
0538   05BF CD 44 0C        CALL SNDLCDMSG
0539   05C2 C9              RET
0540   05C3             I2CCPUTOMEM_OK:
0541   05C3 21 CD 0F        LD HL, MSG_COPYOK
0542   05C6 CD 44 0C        CALL SNDLCDMSG
0543   05C9 C9              RET
0544   05CA             
0545   05CA             
0546   05CA             
0547   05CA             
0548   05CA             
0549   05CA             
0550   05CA             GET_FROM_TO_SIZE:
0551   05CA                 ; FROM
0552   05CA 21 B1 0F        LD HL, MSG_FROM
0553   05CD CD 44 0C        CALL SNDLCDMSG
0554   05D0                 ;
0555   05D0                 ;GET THE ADDRESS  FROM
0556   05D0                 ;
0557   05D0 CD 05 07        CALL  GETCHR 
0558   05D3 D8              RET   C        
0559   05D4 32 B3 FE        LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
0560   05D7 CD 05 07        CALL  GETCHR
0561   05DA D8              RET   C
0562   05DB 32 B2 FE        LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW
0563   05DE             
0564   05DE CD 3D 0B        CALL  KEYREADINIT
0565   05E1 FE 1B           CP    ESC         ;ESC KEY?
0566   05E3 C8              RET   Z
0567   05E4 FE 0D           CP    CR
0568   05E6 28 08           JR Z, GET_FROM_TO_SIZE_TO
0569   05E8 3E 0D           LD A, CR
0570   05EA CD 04 08        CALL PRINTCHAR
0571   05ED C3 CA 05        JP GET_FROM_TO_SIZE
0572   05F0             
0573   05F0             GET_FROM_TO_SIZE_TO:
0574   05F0                 ; TO
0575   05F0 21 B8 0F        LD HL, MSG_TO
0576   05F3 CD 44 0C        CALL SNDLCDMSG
0577   05F6                 ;
0578   05F6                 ;GET THE ADDRESS  TO
0579   05F6                 ;
0580   05F6 CD 05 07        CALL  GETCHR 
0581   05F9 D8              RET   C        
0582   05FA 32 B5 FE        LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
0583   05FD CD 05 07        CALL  GETCHR
0584   0600 D8              RET   C
0585   0601 32 B4 FE        LD    (ADDR_TO),A    ;SAVE ADDRESS LOW
0586   0604             
0587   0604 CD 3D 0B        CALL  KEYREADINIT
0588   0607 FE 1B           CP    ESC         ;ESC KEY?
0589   0609 C8              RET   Z
0590   060A FE 0D           CP    CR
0591   060C 20 E2           JR NZ, GET_FROM_TO_SIZE_TO
0592   060E             
0593   060E             GET_FROM_TO_SIZE_SIZE:
0594   060E                 ; SIZE
0595   060E 21 BE 0F        LD HL, MSG_SIZE
0596   0611 CD 44 0C        CALL SNDLCDMSG
0597   0614                 ;
0598   0614                 ;GET THE SIZE
0599   0614                 ;
0600   0614 CD 05 07        CALL  GETCHR 
0601   0617 D8              RET   C        
0602   0618 32 B7 FE        LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
0603   061B CD 05 07        CALL  GETCHR
0604   061E D8              RET   C
0605   061F 32 B6 FE        LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW
0606   0622             
0607   0622 CD 3D 0B        CALL  KEYREADINIT
0608   0625 FE 1B           CP    ESC         ;ESC KEY?
0609   0627 C8              RET   Z
0610   0628 FE 0D           CP    CR
0611   062A 20 E2           JR NZ, GET_FROM_TO_SIZE_SIZE
0612   062C C9              RET
0613   062D             
0614   062D             
0615   062D             INTEL_HEX:
0616   062D CD 91 0B        CALL INTHEX
0617   0630 CD 19 0B        CALL delay
0618   0633 CD 19 0B        CALL delay
0619   0636 C3 6B 04        JP INICIO
0620   0639             
0621   0639             SHOWHELP:
0622   0639 3E 0C           LD A, $0C ; limpar tela
0623   063B CD 04 08        CALL PRINTCHAR
0624   063E             
0625   063E 21 E7 0E        LD HL, MSG_MENU1
0626   0641 CD 44 0C        CALL SNDLCDMSG
0627   0644             
0628   0644 21 FD 0E        LD HL, MSG_MENU2
0629   0647 CD 44 0C        CALL SNDLCDMSG
0630   064A             
0631   064A 21 08 0F        LD HL, MSG_MENU3
0632   064D CD 44 0C        CALL SNDLCDMSG
0633   0650             
0634   0650 21 1A 0F        LD HL, MSG_MENU4
0635   0653 CD 44 0C        CALL SNDLCDMSG
0636   0656             
0637   0656 21 2B 0F        LD HL, MSG_MENU5
0638   0659 CD 44 0C        CALL SNDLCDMSG
0639   065C             
0640   065C 21 3B 0F        LD HL, MSG_MENU6
0641   065F CD 44 0C        CALL SNDLCDMSG
0642   0662             
0643   0662 21 49 0F        LD HL, MSG_MENU7
0644   0665 CD 44 0C        CALL SNDLCDMSG
0645   0668             
0646   0668 21 5C 0F        LD HL, MSG_MENU8
0647   066B CD 44 0C        CALL SNDLCDMSG
0648   066E             
0649   066E C9              RET
0650   066F             
0651   066F             
0652   066F             ;----------------------------
0653   066F             ; M DISPLAY AND MODIFY MEMORY
0654   066F             ;----------------------------
0655   066F 3E 4D       MODIFY: LD A, 'M'
0656   0671 CD 04 08            CALL PRINTCHAR
0657   0674 CD F9 06         CALL  OUTSP
0658   0677             ;
0659   0677             ;GET THE ADDRESS        
0660   0677             ;
0661   0677 CD 05 07           CALL  GETCHR 
0662   067A D8                 RET   C        
0663   067B 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0664   067E CD 05 07           CALL  GETCHR
0665   0681 D8                 RET   C
0666   0682 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0667   0685             ;
0668   0685             ; DISPLAY ON A NEW LINE
0669   0685             ;       
0670   0685 CD FF 06    MDIFY1: CALL  TXCRLF       
0671   0688 ED 5B B0 FE        LD    DE,(ADDR)    
0672   068C 21 00 FE           LD    HL,MSGBUF   
0673   068F CD 5C 07           CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
0674   0692 21 00 FE           LD    HL,MSGBUF
0675   0695 CD 50 07           CALL  WRDOUT      ;OUTPUT THE ADDRESS
0676   0698 CD F9 06           CALL  OUTSP    
0677   069B             ;      
0678   069B             ;GET THE DATA AT THE ADDRESS        
0679   069B             ;
0680   069B 2A B0 FE            LD   HL,(ADDR)       
0681   069E 7E                  LD   A,(HL)
0682   069F             ;
0683   069F             ; DISPLAY THE DATA
0684   069F             ;        
0685   069F 21 00 FE           LD    HL,MSGBUF
0686   06A2 CD 61 07           CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
0687   06A5 21 00 FE           LD    HL,MSGBUF
0688   06A8 CD 53 07           CALL  BYTOUT      ;OUTPUT THE BYTE
0689   06AB CD F9 06           CALL  OUTSP
0690   06AE             ;
0691   06AE             ; GET NEW DATA,EXIT OR CONTINUE
0692   06AE             ;
0693   06AE CD 05 07           CALL  GETCHR
0694   06B1 D8                 RET   C
0695   06B2 47                 LD    B,A         ;SAVE IT FOR LATER
0696   06B3 2A B0 FE           LD    HL,(ADDR)
0697   06B6 77                 LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
0698   06B7 78                 LD    A,B
0699   06B8 BE                 CP    (HL)
0700   06B9 28 05              JR    Z,MDIFY2
0701   06BB 3E 3F              LD    A,'?'
0702   06BD CD 04 08           CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
0703   06C0             ;
0704   06C0             ; INCREMENT THE ADDRESS
0705   06C0             ;
0706   06C0 23          MDIFY2: INC   HL
0707   06C1 22 B0 FE           LD    (ADDR),HL
0708   06C4 C3 85 06           JP    MDIFY1
0709   06C7             
0710   06C7             
0711   06C7             
0712   06C7             ;------------------------------
0713   06C7             ; GO <ADDR>
0714   06C7             ; TRANSFERS EXECUTION TO <ADDR>
0715   06C7             ;------------------------------
0716   06C7             GOJUMP_new:
0717   06C7 3E 0D           LD A, CR
0718   06C9 CD 04 08        CALL PRINTCHAR
0719   06CC             
0720   06CC 3E 3E           LD A, '>'
0721   06CE CD 04 08        CALL PRINTCHAR
0722   06D1             
0723   06D1 3E 47       GOJUMP: LD A, 'G'
0724   06D3 CD 04 08            CALL PRINTCHAR
0725   06D6 CD F9 06           CALL  OUTSP       
0726   06D9 CD 05 07           CALL  GETCHR      ;GET ADDRESS HIGH BYTE
0727   06DC D8                 RET   C
0728   06DD 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0729   06E0 CD 05 07           CALL  GETCHR      ;GET ADDRESS LOW BYTE
0730   06E3 D8                 RET   C
0731   06E4 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0732   06E7             ;
0733   06E7             ; WAIT FOR A CR OR ESC
0734   06E7             ;       
0735   06E7 CD 3D 0B    GOJMP1: CALL  KEYREADINIT
0736   06EA FE 1B              CP    ESC         ;ESC KEY?
0737   06EC C8                 RET   Z
0738   06ED FE 0D              CP    CR
0739   06EF                    ;JR    NZ,GOJMP1
0740   06EF 20 D6              JR NZ, GOJUMP_new
0741   06F1 CD FF 06           CALL  TXCRLF
0742   06F4 E1                 POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
0743   06F5 2A B0 FE           LD    HL,(ADDR)
0744   06F8 E9                 JP    (HL)        ;GOOD LUCK WITH THAT!
0745   06F9             
0746   06F9             
0747   06F9             ;---------------
0748   06F9             ; OUTPUT A SPACE
0749   06F9             ;---------------
0750   06F9 3E 20       OUTSP:  LD    A, ' '
0751   06FB CD 04 08           CALL  PRINTCHAR
0752   06FE C9                 RET
0753   06FF             
0754   06FF             ;-------------      
0755   06FF             ; OUTPUT CRLF
0756   06FF             ;------------
0757   06FF 3E 0D       TXCRLF: LD   A,CR
0758   0701 CD 04 08           CALL PRINTCHAR   
0759   0704 C9                 RET
0760   0705             
0761   0705             ;-----------------------------
0762   0705             ; GET A BYTE FROM THE TERMINAL
0763   0705             ;-----------------------------
0764   0705 CD 3D 0B    GETCHR: CALL KEYREADINIT ; read key
0765   0708 FE 1B              CP    ESC
0766   070A 28 27              JR    Z,GETOUT
0767   070C 47                 LD    B,A                ;SAVE TO ECHO      
0768   070D CD 35 07           CALL  ASC2HEX
0769   0710 30 F3              JR    NC,GETCHR          ;REJECT NON HEX CHARS    
0770   0712 21 B8 FE           LD    HL,DATA
0771   0715 77                 LD    (HL),A 
0772   0716 78                 LD    A,B         
0773   0717 CD 04 08           CALL  PRINTCHAR             ;ECHO VALID HEX
0774   071A                    
0775   071A CD 3D 0B    GETNYB: CALL  KEYREADINIT
0776   071D FE 1B              CP    ESC
0777   071F 28 12              JR    Z,GETOUT
0778   0721 47                 LD    B,A               ;SAVE TO ECHO
0779   0722 CD 35 07           CALL  ASC2HEX
0780   0725 30 F3              JR    NC,GETNYB         ;REJECT NON HEX CHARS
0781   0727 ED 6F              RLD
0782   0729 78                 LD    A,B
0783   072A CD 04 08           CALL  PRINTCHAR             ;ECHO VALID HEX
0784   072D 7E                 LD    A,(HL)
0785   072E CD 33 07           CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
0786   0731 3F                 CCF                    ;AND THEN COMPLEMENTING IT
0787   0732 C9                 RET   
0788   0733 37          GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
0789   0734 C9                 RET
0790   0735             
0791   0735             
0792   0735             ;----------------------------------------
0793   0735             ; CONVERT ASCII CHARACTER INTO HEX NYBBLE
0794   0735             ;----------------------------------------
0795   0735             ; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
0796   0735             ; ENTRY OTHER THAN HEXADECIMAL KEYS
0797   0735             ;
0798   0735             ;CONVERTS ASCII 0-9,A-F INTO HEX LSN
0799   0735             ;ENTRY : A= ASCII 0-9,A-F
0800   0735             ;EXIT  : CARRY =  1
0801   0735             ;          A= HEX 0-F IN LSN    
0802   0735             ;      : CARRY = 0
0803   0735             ;          A= OUT OF RANGE CHARACTER & 7FH
0804   0735             ; A AND F REGISTERS MODIFIED
0805   0735             ;
0806   0735 E6 7F       ASC2HEX: AND   7FH        ;STRIP OUT PARITY
0807   0737 FE 30              CP    30H
0808   0739 38 12              JR    C,AC2HEX3    ;LESS THAN 0
0809   073B FE 3A              CP    3AH
0810   073D 30 02              JR    NC,AC2HEX2   ;MORE THAN 9
0811   073F 37          AC2HEX1: SCF               ;SET THE CARRY - IS HEX
0812   0740 C9                 RET
0813   0741             ;     
0814   0741 FE 41       AC2HEX2: CP    41H
0815   0743 38 08              JR    C,AC2HEX3    ;LESS THAN A
0816   0745 FE 47              CP    47H
0817   0747 30 04              JR    NC,AC2HEX3   ;MORE THAN F
0818   0749 D6 07              SUB   07H        ;CONVERT TO NYBBLE
0819   074B 18 F2              JR    AC2HEX1  
0820   074D E6 FF       AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
0821   074F C9                 RET
0822   0750             
0823   0750             
0824   0750             ;----------------------     
0825   0750             ; SEND ASCII HEX VALUES        
0826   0750             ;----------------------
0827   0750             ;
0828   0750             ; OUTPUT THE 4 BYTE, WRDOUT
0829   0750             ; THE 2 BYTE, BYTOUT
0830   0750             ; OR THE SINGLE BYTE, NYBOUT
0831   0750             ; ASCII STRING AT HL TO THE SERIAL PORT
0832   0750             ;
0833   0750 CD 53 07    WRDOUT: CALL  BYTOUT
0834   0753 CD 56 07    BYTOUT: CALL  NYBOUT
0835   0756 7E          NYBOUT: LD    A,(HL)
0836   0757 CD 04 08           CALL  PRINTCHAR
0837   075A 23                 INC   HL
0838   075B C9                 RET       
0839   075C             ;----------------
0840   075C             ;CONVERT TO ASCII 
0841   075C             ;----------------
0842   075C             ;
0843   075C             ; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
0844   075C             ;
0845   075C             ;         ENTRY :  A = BINARY TO CONVERT
0846   075C             ;                  HL = CHARACTER BUFFER ADDRESS   
0847   075C             ;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
0848   075C             ;   
0849   075C             ;        MODIFIES : DE
0850   075C             
0851   075C 7A          WRDASC: LD    A,D         ;CONVERT AND
0852   075D CD 61 07           CALL  BYTASC      ;OUTPUT D
0853   0760 7B                 LD    A,E         ;THEN E
0854   0761             ;
0855   0761             ;CONVERT A BYTE TO ASCII 
0856   0761             ;
0857   0761 F5          BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
0858   0762 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
0859   0763 0F                 RRCA
0860   0764 0F                 RRCA
0861   0765 0F                 RRCA
0862   0766 CD 6A 07           CALL NYBASC       ;CALL NYBBLE CONVERTER 
0863   0769 F1                 POP AF            ;RESTORE LOW NYBBLE
0864   076A             
0865   076A             ;           
0866   076A             ; CONVERT A NYBBLE TO ASCII
0867   076A             ;
0868   076A E6 0F       NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
0869   076C C6 90              ADD   A,90H       ;CONVERT TO
0870   076E 27                 DAA               ;ASCII
0871   076F CE 40              ADC   A,40H
0872   0771 27                 DAA
0873   0772             ;            
0874   0772             ; SAVE IN STRING
0875   0772             ;
0876   0772 77          INSBUF: LD    (HL),A
0877   0773 23                 INC   HL 
0878   0774 C9                 RET 
0879   0775             
0880   0775             
0881   0775             
0882   0775             INIT_TXT_LCD:
0883   0775 3E 00           ld a, 0
0884   0777 32 03 E0        ld (LCD_TXT_X), a
0885   077A 32 04 E0        ld (LCD_TXT_Y), a
0886   077D 32 0F E0        ld (LCD_DELETE_CHAR), a
0887   0780 32 10 E0        ld (LCD_AUTO_X), a
0888   0783 21 00 00        ld hl, 0
0889   0786 22 08 E0        ld (LCD_TXT_X_TMP), hl
0890   0789 23              inc hl
0891   078A 22 0A E0        ld (LCD_TXT_Y_TMP), hl
0892   078D C9              RET
0893   078E             
0894   078E             
0895   078E             DISPLAY_SCROLL_UP:
0896   078E                 ; cada linha tem 128 bytes
0897   078E                 ; temos 8 linhas
0898   078E                 ; total 1024 bytes
0899   078E             
0900   078E                 ; display lines 0 to 7
0901   078E                 ; move line 1 to 0
0902   078E 21 80 E5        ld hl, DISPLAY+128
0903   0791 11 00 E5        ld de, DISPLAY
0904   0794 01 7F 00        ld bc, 127
0905   0797 ED B0           ldir
0906   0799             
0907   0799                 ; move line 2 to 1
0908   0799 21 00 E6        ld hl, DISPLAY+256
0909   079C 11 80 E5        ld de, DISPLAY+128
0910   079F 01 7F 00        ld bc, 127
0911   07A2 ED B0           ldir
0912   07A4             
0913   07A4                 ; move line 3 to 2
0914   07A4 21 80 E6        ld hl, DISPLAY+384
0915   07A7 11 00 E6        ld de, DISPLAY+256
0916   07AA 01 7F 00        ld bc, 127
0917   07AD ED B0           ldir
0918   07AF             
0919   07AF                 ; move line 4 to 3
0920   07AF 21 00 E7        ld hl, DISPLAY+512
0921   07B2 11 80 E6        ld de, DISPLAY+384
0922   07B5 01 7F 00        ld bc, 127
0923   07B8 ED B0           ldir
0924   07BA             
0925   07BA                 ; move line 5 to 4
0926   07BA 21 80 E7        ld hl, DISPLAY+640
0927   07BD 11 00 E7        ld de, DISPLAY+512
0928   07C0 01 7F 00        ld bc, 127
0929   07C3 ED B0           ldir
0930   07C5             
0931   07C5                 ; move line 6 to 5
0932   07C5 21 00 E8        ld hl, DISPLAY+768
0933   07C8 11 80 E7        ld de, DISPLAY+640
0934   07CB 01 7F 00        ld bc, 127
0935   07CE ED B0           ldir
0936   07D0             
0937   07D0                 ; move line 7 to 6
0938   07D0 21 80 E8        ld hl, DISPLAY+896
0939   07D3 11 00 E8        ld de, DISPLAY+768
0940   07D6 01 7F 00        ld bc, 127
0941   07D9 ED B0           ldir
0942   07DB             
0943   07DB                 ; clear line 7
0944   07DB                 ; 896 to 1024
0945   07DB 21 80 E8        ld hl, DISPLAY+896
0946   07DE 5D              ld e,l
0947   07DF 54              ld d,h
0948   07E0 13              inc de
0949   07E1 36 00           ld (hl), 0
0950   07E3 01 7F 00        ld bc, 127
0951   07E6 ED B0           ldir
0952   07E8             
0953   07E8 C9              RET
0954   07E9             
0955   07E9             DELETE_CHAR:
0956   07E9 E1              POP HL ; retorno do call
0957   07EA 3E 00           LD A, 0
0958   07EC 32 0F E0        LD (LCD_DELETE_CHAR), A
0959   07EF 3A 03 E0        LD A, (LCD_TXT_X)
0960   07F2 3D              DEC A
0961   07F3 32 03 E0        LD (LCD_TXT_X), A
0962   07F6             
0963   07F6 3E FF           LD A, $FF
0964   07F8 32 10 E0        LD (LCD_AUTO_X), A
0965   07FB             
0966   07FB F1              POP AF
0967   07FC 3E 20           LD A, ' '
0968   07FE 32 00 E0        LD (LCD_CHAR), A
0969   0801 F5              PUSH AF
0970   0802 E5              PUSH HL ; call
0971   0803 C9              RET
0972   0804             
0973   0804             
0974   0804             ; char in A
0975   0804             PRINTCHAR:
0976   0804 32 00 E0        LD (LCD_CHAR), A ; save char to print
0977   0807             
0978   0807 F5              PUSH AF
0979   0808 C5              PUSH BC
0980   0809 D5              PUSH DE
0981   080A E5              PUSH HL
0982   080B             
0983   080B F5              PUSH AF
0984   080C 3E 00           LD A, $0
0985   080E 32 10 E0        LD (LCD_AUTO_X), A
0986   0811 F1              POP AF
0987   0812             
0988   0812             
0989   0812             ver_delete:
0990   0812 F5              PUSH AF
0991   0813 3A 0F E0        LD A, (LCD_DELETE_CHAR)
0992   0816 B7              or a
0993   0817 FE FF           CP $FF
0994   0819 CC E9 07        call z, DELETE_CHAR
0995   081C F1              POP AF
0996   081D B7              or a
0997   081E FE 00           CP $0
0998   0820 20 08           jr nz, ver_enter
0999   0822 3E FF           LD A, $FF ; delete proximo char
1000   0824 32 0F E0        LD (LCD_DELETE_CHAR), A
1001   0827 C3 67 09        jp print_char_fim
1002   082A             
1003   082A                 ; Verificar Enter, clear, etc... SEM PERDER O reg. A
1004   082A             ver_enter:       
1005   082A             
1006   082A                             ; trata dados para o lcd
1007   082A FE 0D                       CP      CR                     ; compara com ENTER
1008   082C 20 20                       jr      nz, ver_limpa
1009   082E             
1010   082E 3E 00                       LD A,0
1011   0830 32 03 E0                    LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
1012   0833             
1013   0833 3A 04 E0                    LD A, (LCD_TXT_Y)
1014   0836 3C                          inc a
1015   0837 FE 08                       cp 8
1016   0839 C2 48 08                    jp nz, ver_enter_incYOK
1017   083C                             
1018   083C CD 8E 07                    CALL DISPLAY_SCROLL_UP
1019   083F 21 00 E5                    ld hl, DISPLAY
1020   0842 CD 43 0A                    CALL print_image
1021   0845                             
1022   0845 C3 67 09                    jp print_char_fim
1023   0848             
1024   0848             ver_enter_incYOK:
1025   0848 32 04 E0                    ld (LCD_TXT_Y), a
1026   084B C3 67 09                    jp print_char_fim
1027   084E             
1028   084E             
1029   084E             ver_limpa:
1030   084E FE 0C                       CP      $0C                     ; compara com limpar tela
1031   0850 20 14                       jr      NZ, ver_line
1032   0852                             
1033   0852                             ;call    clear_lcd_screen
1034   0852                             ;call    show_lcd_screen
1035   0852 CD 1C 0A                    call lcd_clear
1036   0855 21 00 E5                    ld hl, DISPLAY
1037   0858 CD 43 0A                    call print_image
1038   085B 3E 00                       LD A, 0
1039   085D 32 03 E0                    LD (LCD_TXT_X), A
1040   0860 32 04 E0                    LD (LCD_TXT_Y), A
1041   0863             
1042   0863 C3 67 09                    JP print_char_fim
1043   0866             
1044   0866             ver_line:
1045   0866 FE 0A                       CP      LF                     ; retorna come√ßo da linha
1046   0868 20 03                       jr      NZ, print_lcd      
1047   086A             
1048   086A                                 ;----- verificar se precisa add algo aqui
1049   086A                             ;call    shift_lcd_up
1050   086A                             ;call    show_lcd_screen
1051   086A C3 67 09                    JP print_char_fim
1052   086D             
1053   086D             print_lcd:
1054   086D                 ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
1055   086D 26 00           ld H, 0
1056   086F 6F              ld L, A
1057   0870 29              ADD HL, HL ; hl x 8
1058   0871 29              ADD HL, HL
1059   0872 29              ADD HL, HL
1060   0873             
1061   0873 54              LD D, H
1062   0874 5D              LD E, L
1063   0875 21 6B 00        ld hl, TABLE
1064   0878 19              add hl, de
1065   0879 22 01 E0        ld (LCD_CHAR_POINT), HL ; table
1066   087C             
1067   087C             
1068   087C                 ; ajusta X
1069   087C 06 06           ld b, 6
1070   087E 3A 03 E0        ld a, (LCD_TXT_X)
1071   0881 B7              or A
1072   0882 CA 8C 08        jp z, ajustX
1073   0885 4F              ld c, a
1074   0886 CD 6C 09        call multiplication
1075   0889 C3 8F 08        jp ajustXOK
1076   088C                 
1077   088C             ajustX:
1078   088C 21 00 00        ld hl, 0
1079   088F             ajustXOK:
1080   088F 22 08 E0        ld (LCD_TXT_X_TMP), HL 
1081   0892             
1082   0892             
1083   0892             
1084   0892                 ; ajuste Y
1085   0892 16 04           ld d, 4
1086   0894 1E 00           ld e, 0 ; = 128x8 proxima linha
1087   0896 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1088   0899 3A 04 E0        ld a, (LCD_TXT_Y)
1089   089C B7              or a
1090   089D CA AD 08        JP Z, multYfim
1091   08A0 21 00 00        ld hl, 0
1092   08A3 47              ld b, a
1093   08A4             multY:
1094   08A4 19              add hl, de
1095   08A5 10 FD           DJNZ multY
1096   08A7             
1097   08A7 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1098   08AA C3 B3 08        jp multYfimok
1099   08AD             
1100   08AD             multYfim:
1101   08AD 21 00 00        ld hl, 0
1102   08B0 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1103   08B3             
1104   08B3             multYfimok:
1105   08B3             
1106   08B3 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1107   08B6 ED 5B 08 E0     ld de, (LCD_TXT_X_TMP)
1108   08BA             
1109   08BA 19              add hl, de  ; hl tem pos do pix 0-8191
1110   08BB             
1111   08BB 22 0E E0        ld (LCD_TMP_POINT), hl
1112   08BE             
1113   08BE             
1114   08BE 3E 08           ld a, 8 ; altura do caracter
1115   08C0 32 0C E0        ld (LCD_CHAR_H), a
1116   08C3             printchar_loopH:
1117   08C3 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1118   08C6 7E              ld a, (HL)
1119   08C7 32 10 E1        ld (LCD_TEMP), a
1120   08CA             
1121   08CA 3E 06           ld a, 6 ; largura do caracter
1122   08CC 32 0D E0        ld (LCD_CHAR_W), a
1123   08CF             printchar_loopW:
1124   08CF 3A 10 E1        ld a, (LCD_TEMP)
1125   08D2 E6 80           and 128
1126   08D4 FE 00           cp 0
1127   08D6 CA E2 08        jp z, printchar_loopWC
1128   08D9 2A 0E E0        ld hl, (LCD_TMP_POINT)
1129   08DC CD A7 09        call lcd_setPixel
1130   08DF C3 E8 08        JP printchar_loopWE
1131   08E2             
1132   08E2             printchar_loopWC:
1133   08E2 2A 0E E0        ld hl, (LCD_TMP_POINT)
1134   08E5 CD E0 09        call lcd_clearPixel
1135   08E8             
1136   08E8             printchar_loopWE:
1137   08E8 3A 10 E1        ld a, (LCD_TEMP)
1138   08EB CB 27           sla a
1139   08ED 32 10 E1        ld (LCD_TEMP), a
1140   08F0                 
1141   08F0 2A 0E E0        ld hl, (LCD_TMP_POINT)
1142   08F3 23              inc hl
1143   08F4 22 0E E0        ld (LCD_TMP_POINT), hl
1144   08F7             
1145   08F7 3A 0D E0        ld a, (LCD_CHAR_W)
1146   08FA 3D              dec A
1147   08FB 32 0D E0        ld (LCD_CHAR_W), a
1148   08FE FE 00           cp 0
1149   0900 C2 CF 08        JP NZ, printchar_loopW
1150   0903             
1151   0903             
1152   0903 2A 0E E0        ld hl, (LCD_TMP_POINT)
1153   0906 2B              dec hl
1154   0907 2B              dec hl
1155   0908 2B              dec hl
1156   0909 2B              dec hl
1157   090A 2B              dec hl
1158   090B 2B              dec hl
1159   090C             
1160   090C 16 00           ld d, 0
1161   090E 1E 80           ld e, 128
1162   0910 19              add hl, de
1163   0911 22 0E E0        ld (LCD_TMP_POINT), HL
1164   0914             
1165   0914 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1166   0917 23              inc hl
1167   0918 22 01 E0        ld (LCD_CHAR_POINT), hl
1168   091B             
1169   091B             
1170   091B 3A 0C E0        ld a, (LCD_CHAR_H)
1171   091E 3D              dec A
1172   091F 32 0C E0        ld (LCD_CHAR_H), a
1173   0922 FE 00           cp 0
1174   0924 C2 C3 08        jp NZ, printchar_loopH
1175   0927             
1176   0927 21 00 E5        ld hl, DISPLAY
1177   092A CD 43 0A        call print_image
1178   092D             
1179   092D             
1180   092D                 ; check auto x
1181   092D 3A 10 E0        LD A, (LCD_AUTO_X)
1182   0930 B7              OR A
1183   0931 FE FF           CP $FF
1184   0933 CA 67 09        JP Z, print_char_fim
1185   0936             
1186   0936                 ; increment X, Y
1187   0936 3A 03 E0        ld a, (LCD_TXT_X)
1188   0939 3C              inc a
1189   093A FE 15           cp 21
1190   093C C2 64 09        jp nz, incXOK
1191   093F 3E 00           ld a, 0
1192   0941 32 03 E0        ld (LCD_TXT_X), a
1193   0944 3A 04 E0        ld a, (LCD_TXT_Y)
1194   0947 3C              inc a
1195   0948 FE 08           cp 8
1196   094A C2 5E 09        jp nz, incYOK
1197   094D CD 8E 07        CALL DISPLAY_SCROLL_UP
1198   0950 21 00 E5        ld hl, DISPLAY
1199   0953 CD 43 0A        CALL print_image
1200   0956 3E 00           ld a, 0
1201   0958 32 03 E0        ld (LCD_TXT_X), a
1202   095B C3 67 09        jp print_char_fim
1203   095E             
1204   095E             incYOK:
1205   095E 32 04 E0        ld (LCD_TXT_Y), a
1206   0961 C3 67 09        jp print_char_fim
1207   0964             
1208   0964             incXOK:
1209   0964 32 03 E0        ld (LCD_TXT_X), a
1210   0967             
1211   0967             print_char_fim:
1212   0967 E1              POP HL
1213   0968 D1              POP DE
1214   0969 C1              POP BC
1215   096A F1              POP AF
1216   096B C9              RET
1217   096C             ;-------- FIM PRINTCHAR ------------------
1218   096C             
1219   096C             
1220   096C             
1221   096C             ; ----------------------------------
1222   096C             
1223   096C             ; INPUT: THE VALUES IN REGISTER B EN C
1224   096C             ; OUTPUT: HL = B * C
1225   096C             ; CHANGES: AF,DE,HL,B
1226   096C             ;
1227   096C             multiplication:
1228   096C 21 00 00    	LD HL,0
1229   096F 78          	LD A,B
1230   0970 B7          	OR A
1231   0971 C8          	RET Z
1232   0972 16 00       	LD D,0
1233   0974 59          	LD E,C
1234   0975 19          multiplicationLOOP:	ADD HL,DE
1235   0976 10 FD       	DJNZ multiplicationLOOP
1236   0978 C9          	RET 
1237   0979             
1238   0979             ;-----------------------------------
1239   0979             
1240   0979             Div_HL_D:
1241   0979             ;Inputs:
1242   0979             ;   HL and D
1243   0979             ;Outputs:
1244   0979             ;   HL is the quotient (HL/D)
1245   0979             ;   A is the remainder
1246   0979             ;   B is 0
1247   0979             ;   C,D,E are preserved
1248   0979 AF              xor a         ; Clear upper eight bits of AHL
1249   097A 06 10           ld b,16       ; Sixteen bits in dividend
1250   097C             _loop:
1251   097C 29              add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
1252   097D 17              rla           ; This moves the upper bits of the dividend into A
1253   097E 38 03           jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
1254   0980 BA              cp d          ; Check if we can subtract the divisor
1255   0981 38 02           jr c,_skip    ; Carry means A < D
1256   0983             _overflow:
1257   0983 92              sub d         ; Do subtraction for real this time
1258   0984 2C              inc l         ; Set the next bit of the quotient (currently bit 0)
1259   0985             _skip:
1260   0985 10 F5           djnz _loop
1261   0987 C9              ret
1262   0988             
1263   0988             
1264   0988             ; -----------------------------------------------------------------------------
1265   0988             ;   LCD DRIVER
1266   0988             ; -----------------------------------------------------------------------------
1267   0988             ; INIT_LCD - Inicia o lcd em mode texto
1268   0988             ; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
1269   0988             ; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
1270   0988             ; lcd_clear - Limpa buffer do lcd
1271   0988             ; enable_grafic - Coloca o LCD em modo grafico
1272   0988             ; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
1273   0988             ; cls_TXT - Limpa LCD mode text
1274   0988             ; cls_GRAPHIC - Limpa LCD modo grafico
1275   0988             
1276   0988             INIT_LCD:
1277   0988                 ;Initialisation
1278   0988 3E 30       	ld a, 30H
1279   098A CD CC 0A    	call lcd_send_command
1280   098D             
1281   098D 3E A0       	ld a, 0b00100000
1282   098F CD CC 0A    	call lcd_send_command
1283   0992             
1284   0992 3E 30       	ld a, 30H
1285   0994 CD CC 0A    	call lcd_send_command
1286   0997             
1287   0997 3E 0C       	ld a, 0CH
1288   0999 CD CC 0A    	call lcd_send_command
1289   099C             
1290   099C 3E 01       	ld a, 01H
1291   099E CD D6 0A    	call lcd_send_command_clear ;; clear
1292   09A1             
1293   09A1 3E 02       	ld a, 02H
1294   09A3 CD CC 0A    	call lcd_send_command
1295   09A6 C9              RET
1296   09A7             
1297   09A7             
1298   09A7             ; pixel index in HL
1299   09A7             lcd_setPixel:
1300   09A7 E5              push hl
1301   09A8 C5              push bc
1302   09A9 D5              push de
1303   09AA F5              push af
1304   09AB AF              xor A
1305   09AC 32 07 E0        ld (LCD_BIT_INDEX), A
1306   09AF 32 05 E0        ld (LCD_BYTE_INDEX), A
1307   09B2             
1308   09B2 16 08           ld d, 8
1309   09B4 CD 79 09        call Div_HL_D
1310   09B7 32 07 E0        ld (LCD_BIT_INDEX), A
1311   09BA 22 05 E0        ld (LCD_BYTE_INDEX), HL
1312   09BD ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1313   09C1 21 00 E5        ld hl, DISPLAY
1314   09C4 09              add hl, bc
1315   09C5                 
1316   09C5 06 80           ld b, 128 ; 1000 0000
1317   09C7 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1318   09CA FE 00           cp 0
1319   09CC CA D8 09        jp z, lcd_setPixel_fim
1320   09CF             lcd_setPixel_bit:
1321   09CF CB 38           srl B
1322   09D1 3D              dec A
1323   09D2 CA D8 09        jp z, lcd_setPixel_fim
1324   09D5                 
1325   09D5 C3 CF 09        jp lcd_setPixel_bit
1326   09D8             lcd_setPixel_fim
1327   09D8 7E              ld a, (hl)
1328   09D9 B0              or b
1329   09DA 77              ld (hl), a
1330   09DB             
1331   09DB F1              pop af
1332   09DC C1              pop bc
1333   09DD D1              pop de
1334   09DE E1              pop hl
1335   09DF C9              ret
1336   09E0             
1337   09E0             ;===============================
1338   09E0             ; pixel index in HL
1339   09E0             lcd_clearPixel:
1340   09E0 E5              push hl
1341   09E1 C5              push bc
1342   09E2 D5              push de
1343   09E3 F5              push af
1344   09E4 AF              xor A
1345   09E5 32 07 E0        ld (LCD_BIT_INDEX), A
1346   09E8 32 05 E0        ld (LCD_BYTE_INDEX), A
1347   09EB 16 08           ld d, 8
1348   09ED CD 79 09        call Div_HL_D
1349   09F0 32 07 E0        ld (LCD_BIT_INDEX), A
1350   09F3 22 05 E0        ld (LCD_BYTE_INDEX), HL
1351   09F6 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1352   09FA 21 00 E5        ld hl, DISPLAY
1353   09FD 09              add hl, bc
1354   09FE                 
1355   09FE 06 80           ld b, 128 ; 1000 0000
1356   0A00 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1357   0A03 FE 00           cp 0
1358   0A05 CA 11 0A        jp z, lcd_clearPixel_fim
1359   0A08             lcd_clearPixel_bit:
1360   0A08 CB 38           srl B
1361   0A0A 3D              dec A
1362   0A0B CA 11 0A        jp z, lcd_clearPixel_fim
1363   0A0E                 
1364   0A0E C3 08 0A        jp lcd_clearPixel_bit
1365   0A11             lcd_clearPixel_fim
1366   0A11 78              ld a, b
1367   0A12 2F              cpl     ; NOT B
1368   0A13 47              ld b, a
1369   0A14             
1370   0A14 7E              ld a, (hl)
1371   0A15 A0              and b
1372   0A16 77              ld (hl), a
1373   0A17             
1374   0A17 F1              pop af
1375   0A18 C1              pop bc
1376   0A19 D1              pop de
1377   0A1A E1              pop hl
1378   0A1B C9              ret
1379   0A1C             
1380   0A1C             
1381   0A1C             ;;--------------------------------------------------
1382   0A1C             lcd_clear:
1383   0A1C                 ;; HL = start address of block
1384   0A1C 21 00 E5        ld hl, DISPLAY
1385   0A1F             
1386   0A1F                 ;; DE = HL + 1
1387   0A1F 5D              ld e,l
1388   0A20 54              ld d,h
1389   0A21 13              inc de
1390   0A22             
1391   0A22                 ;; initialise first byte of block
1392   0A22                 ;; with data byte (&00)
1393   0A22 36 00           ld (hl), 0
1394   0A24                     
1395   0A24                 ;; BC = length of block in bytes
1396   0A24                 ;; HL+BC-1 = end address of block
1397   0A24             
1398   0A24 01 00 04        ld bc, 1024
1399   0A27             
1400   0A27                 ;; fill memory
1401   0A27 ED B0           ldir
1402   0A29 C9              ret
1403   0A2A             
1404   0A2A             
1405   0A2A             ;===================
1406   0A2A             
1407   0A2A             ; grafic mode - enable
1408   0A2A             enable_grafic:
1409   0A2A 3E 30       	ld a, 30H
1410   0A2C CD CC 0A    	call lcd_send_command
1411   0A2F CD 01 0B    	call delayLCD
1412   0A32             	
1413   0A32 3E 34       	ld a, 34H
1414   0A34 CD CC 0A    	call lcd_send_command
1415   0A37 CD 01 0B    	call delayLCD
1416   0A3A             	
1417   0A3A 3E 36       	ld a, 36H
1418   0A3C CD CC 0A    	call lcd_send_command
1419   0A3F CD 01 0B    	call delayLCD
1420   0A42 C9              ret
1421   0A43             
1422   0A43             
1423   0A43             ;==========================
1424   0A43             
1425   0A43             print_image:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
1426   0A43             									; HL content the data address
1427   0A43 F5              push af
1428   0A44 D5          	push de
1429   0A45 C5          	push bc
1430   0A46             
1431   0A46             
1432   0A46             ; premiere partie : X de 0 √† 127 / Y de 0 √† 32
1433   0A46             
1434   0A46 3E 20       	ld a,32
1435   0A48 57          	ld d,a							; boucle Y
1436   0A49 3E 00       	ld a,0
1437   0A4B 5F          	ld e,a
1438   0A4C             	
1439   0A4C             boucle_colonne:
1440   0A4C 3E 80       		ld a,$80					; coordonn√©e Y (0)
1441   0A4E 83          		add a,e
1442   0A4F CD CC 0A    		call lcd_send_command
1443   0A52             		
1444   0A52 3E 80       		ld a,$80					; coordonn√©e X (0)		
1445   0A54 CD CC 0A    		call lcd_send_command
1446   0A57             		
1447   0A57 3E 08       		ld a,8
1448   0A59 47          		ld b,a						; boucle X
1449   0A5A             		
1450   0A5A             boucle_ligne:	
1451   0A5A 7E          			ld a,(hl)
1452   0A5B CD E0 0A    			call lcd_send_data
1453   0A5E 23          			inc hl
1454   0A5F 7E          			ld a,(hl)
1455   0A60 CD E0 0A    			call lcd_send_data		; auto-increment on screen address
1456   0A63 23          			inc hl
1457   0A64 05          			dec b
1458   0A65 AF          			XOR a
1459   0A66 B0          			OR b
1460   0A67 C2 5A 0A    			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
1461   0A6A             		
1462   0A6A 15          		dec d
1463   0A6B 1C          		inc e
1464   0A6C AF          		XOR a
1465   0A6D B2          		OR d
1466   0A6E C2 4C 0A    		jp nz,boucle_colonne
1467   0A71             		
1468   0A71             
1469   0A71             ; seconde partie : X de 128 √† 255 / Y de 0 √† 32
1470   0A71             
1471   0A71 3E 20       	ld a,32
1472   0A73 57          	ld d,a							; boucle Y
1473   0A74 3E 00       	ld a,0
1474   0A76 5F          	ld e,a
1475   0A77             	
1476   0A77             boucle_colonne2:
1477   0A77 3E 80       		ld a,$80					; coordonn√©e Y (0)
1478   0A79 83          		add a, e
1479   0A7A CD CC 0A    		call lcd_send_command
1480   0A7D             		
1481   0A7D 3E 88       		ld a,$88					; coordonn√©e X (8)		
1482   0A7F CD CC 0A    		call lcd_send_command
1483   0A82             		
1484   0A82 3E 08       		ld a,8
1485   0A84 47          		ld b,a						; boucle X
1486   0A85             		
1487   0A85             boucle_ligne2:	
1488   0A85 7E          			ld a,(hl)
1489   0A86 CD E0 0A    			call lcd_send_data
1490   0A89 23          			inc hl
1491   0A8A 7E          			ld a,(hl)
1492   0A8B CD E0 0A    			call lcd_send_data		; auto-increment on screen address
1493   0A8E 23          			inc hl
1494   0A8F 05          			dec b
1495   0A90 AF          			XOR a
1496   0A91 B0          			OR b
1497   0A92 C2 85 0A    			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
1498   0A95             		
1499   0A95 15          		dec d
1500   0A96 1C          		inc e
1501   0A97 AF          		XOR a
1502   0A98 B2          		OR d
1503   0A99 C2 77 0A    		jp nz,boucle_colonne2
1504   0A9C             
1505   0A9C C1          	pop bc
1506   0A9D D1          	pop de
1507   0A9E F1              pop af
1508   0A9F             
1509   0A9F C9              ret
1510   0AA0             
1511   0AA0             
1512   0AA0             
1513   0AA0             ; ======================
1514   0AA0             cls_TXT:
1515   0AA0             	; # CLEAR DISPLAY IN TEXT MODE # 
1516   0AA0 3E 01       	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
1517   0AA2 CD D6 0A    	call lcd_send_command_clear		; CLEAR DISPLAY	
1518   0AA5 C9              ret
1519   0AA6             
1520   0AA6             ; ========================
1521   0AA6             
1522   0AA6             cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
1523   0AA6             					;	Graphic RAM (GDRAM) use :
1524   0AA6             					;	1. Set vertical address (Y) for GDRAM
1525   0AA6             					;	2. Set horizontal address (X) for GDRAM
1526   0AA6             					;	3. Write D15~D8 to GDRAM (first byte)
1527   0AA6             					;	4. Write D7~D0 to GDRAM (second byte)
1528   0AA6 C5          	push bc
1529   0AA7 D5          	push de
1530   0AA8             
1531   0AA8 1E 20       	ld e,$20						; e = 32 
1532   0AAA 16 00       	ld d,$0							; d = 0
1533   0AAC             Boucle32X:
1534   0AAC 7A          		ld a,d
1535   0AAD F6 80       		OR $80
1536   0AAF CD CC 0A    		call lcd_send_command
1537   0AB2             		
1538   0AB2 3E 80       		ld a,$80					; Set horizontal addressÔºàXÔºâ for GDRAM = 0 ($80)
1539   0AB4 CD CC 0A    		call lcd_send_command
1540   0AB7             		
1541   0AB7 AF          		xor a							 	
1542   0AB8 06 10       		ld b,$10							; b = 17
1543   0ABA             		
1544   0ABA             Boucle16X:	 
1545   0ABA CD E0 0A    			call lcd_send_data 			; Write D15„ÄúD8 to GDRAM (first byte)
1546   0ABD CD E0 0A    			call lcd_send_data 			; Write D7„ÄúD0 to GDRAM (second byte)
1547   0AC0             											; Address counter will automatically increase by one for the next two-byte data												
1548   0AC0 10 F8       			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
1549   0AC2             		
1550   0AC2 1D          		dec e 
1551   0AC3 14          		inc d
1552   0AC4 AF          		xor a							; a = 0
1553   0AC5 B3          		or e
1554   0AC6 C2 AC 0A    		jp nz,Boucle32X
1555   0AC9             
1556   0AC9 D1          	pop de
1557   0ACA C1          	pop bc
1558   0ACB             	
1559   0ACB C9              ret
1560   0ACC             
1561   0ACC             
1562   0ACC             
1563   0ACC             ;******************
1564   0ACC             ;Send a command byte to the LCD
1565   0ACC             ;Entry: A= command byte
1566   0ACC             ;Exit: All preserved
1567   0ACC             ;******************
1568   0ACC             lcd_send_command:
1569   0ACC C5          	push bc				;Preserve
1570   0ACD 0E 70       	ld c, LCDCTRL   	;Command port
1571   0ACF             	
1572   0ACF CD 01 0B    	call delayLCD
1573   0AD2             	
1574   0AD2 ED 79       	out (c),a			;Send command
1575   0AD4 C1          	pop bc				;Restore
1576   0AD5 C9          	ret
1577   0AD6             
1578   0AD6             
1579   0AD6             ;******************
1580   0AD6             ;Send a command byte to the LCD
1581   0AD6             ;Entry: A= command byte
1582   0AD6             ;Exit: All preserved
1583   0AD6             ;******************
1584   0AD6             lcd_send_command_clear:
1585   0AD6 C5          	push bc				;Preserve
1586   0AD7 0E 70       	ld c, LCDCTRL   	;Command port
1587   0AD9             	
1588   0AD9 CD 0B 0B    	call delayLCDclear
1589   0ADC             	
1590   0ADC ED 79       	out (c),a			;Send command
1591   0ADE C1          	pop bc				;Restore
1592   0ADF C9          	ret
1593   0AE0             	
1594   0AE0             ;******************
1595   0AE0             ;Send a data byte to the LCD
1596   0AE0             ;Entry: A= data byte
1597   0AE0             ;Exit: All preserved
1598   0AE0             ;******************
1599   0AE0             lcd_send_data:
1600   0AE0 C5          	push bc				;Preserve
1601   0AE1 0E 70       	ld c, LCDCTRL	    ;Command port
1602   0AE3             	
1603   0AE3                 ;Busy wait
1604   0AE3 CD 01 0B    	call delayLCD
1605   0AE6             	
1606   0AE6 0E 71       	ld c, LCDDATA	;Data port
1607   0AE8 ED 79       	out (c),a			;Send data
1608   0AEA C1          	pop bc				;Restore
1609   0AEB C9          	ret
1610   0AEC             
1611   0AEC             ;******************
1612   0AEC             ;Send an asciiz string to the LCD
1613   0AEC             ;Entry: HL=address of string
1614   0AEC             ;Exit: HL=address of ending zero of the string. All others preserved
1615   0AEC             ;******************
1616   0AEC             lcd_send_asciiz:
1617   0AEC F5          	push af
1618   0AED C5          	push bc				;Preserve
1619   0AEE             lcd_asciiz_char_loop:
1620   0AEE 0E 70       	ld c, LCDCTRL   	;Command port
1621   0AF0             	
1622   0AF0             lcd_asciiz_wait_loop:	;Busy wait
1623   0AF0 CD 01 0B    	call delayLCD
1624   0AF3             	
1625   0AF3 7E          	ld a,(hl)			;Get character
1626   0AF4 A7          	and a				;Is it zero?
1627   0AF5 28 07       	jr z,lcd_asciiz_done	;If so, we're done
1628   0AF7             	
1629   0AF7 0E 71       	ld c, LCDDATA	;Data port
1630   0AF9 ED 79       	out (c),a			;Send data
1631   0AFB 23          	inc hl				;Next char
1632   0AFC 18 F0       	jr lcd_asciiz_char_loop
1633   0AFE             	
1634   0AFE             lcd_asciiz_done:
1635   0AFE C1          	pop bc				;Restore
1636   0AFF F1          	pop af
1637   0B00 C9          	ret
1638   0B01             
1639   0B01             ; =========================================================
1640   0B01             ; Delay LCD
1641   0B01             ; =========================================================
1642   0B01             delayLCD:
1643   0B01 00          	NOP
1644   0B02 00          	NOP
1645   0B03 00          	NOP
1646   0B04 00          	NOP
1647   0B05 00          	NOP
1648   0B06 00          	NOP
1649   0B07 00          	NOP
1650   0B08 00          	NOP
1651   0B09 00              NOP
1652   0B0A C9              ret
1653   0B0B             
1654   0B0B             delayLCDclear:
1655   0B0B 00          	NOP
1656   0B0C 00          	NOP
1657   0B0D 00          	NOP
1658   0B0E 00          	NOP
1659   0B0F 00          	NOP
1660   0B10 00          	NOP
1661   0B11 00          	NOP
1662   0B12 00          	NOP
1663   0B13 00          	NOP
1664   0B14 00          	NOP
1665   0B15 00          	NOP
1666   0B16 00          	NOP
1667   0B17 00              NOP
1668   0B18 C9              ret
1669   0B19             
1670   0B19             	
1671   0B19             ; =========================================================
1672   0B19             ; Delay
1673   0B19             ; =========================================================
1674   0B19             delay:
1675   0B19 C5          	push bc                       ; 2.75 us
1676   0B1A 06 01           ld b, 1                     ; 1.75 us
1677   0B1C             delay_loop_b:
1678   0B1C 0E FF       	ld c, 255                     ; 1.75 us
1679   0B1E             delay_loop:
1680   0B1E 0D          	dec c                         ; 1 us
1681   0B1F C2 1E 0B        jp nz, delay_loop             ; true = 3 us, false 1.75 us
1682   0B22 05              dec b                         ; 1 us
1683   0B23 C2 1C 0B        jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
1684   0B26 C1              pop bc                        ; 2.50 us
1685   0B27 C9              ret   
1686   0B28             
1687   0B28             
1688   0B28             ; Check break key
1689   0B28 3E 40       CHKKEY: LD  A, $40
1690   0B2A D3 40       	OUT (KEY_OUT), A ; line 4
1691   0B2C DB 40       	IN  A, (KEY_IN)
1692   0B2E FE 01       	CP  1
1693   0B30 C2 38 0B    	JP  NZ, GRET
1694   0B33 3E 03       	LD  A, CTRLC
1695   0B35 FE 00       	CP	0
1696   0B37 C9          	RET
1697   0B38             GRET:
1698   0B38 3E 00       	LD  A, 0
1699   0B3A FE 00       	CP 0
1700   0B3C C9          	RET
1701   0B3D             
1702   0B3D             
1703   0B3D             
1704   0B3D             
1705   0B3D             ; -----------------------------------------------------------------------------
1706   0B3D             ;   KEYREAD - KEY In A
1707   0B3D             ; -----------------------------------------------------------------------------
1708   0B3D             KEYREADINIT:
1709   0B3D C5              PUSH    BC
1710   0B3E D5          	PUSH	DE
1711   0B3F E5          	PUSH    HL
1712   0B40 1E 00       	LD      E, 0                    ; E will be the last pressed key
1713   0B42             READKEY:        
1714   0B42 26 01           LD      H, 1                    ; H is the line register, start with second
1715   0B44 06 00       	LD      B, 0                    ; Count lines for later multiplication	
1716   0B46 16 00       	LD      D, 0                    ; DE will be the adress for mask
1717   0B48             						
1718   0B48             NEXTKEY:        
1719   0B48 7C              LD      A, H						
1720   0B49 FE 00           CP      0                       ; All lines tried? 
1721   0B4B CA 86 0B        JP      Z, KEYOUT               ; Then check if there was a key pressed
1722   0B4E D3 40       	OUT     (KEY_OUT), A		    ; Put current line to register
1723   0B50 DB 40       	IN      A, (KEY_IN)		        ; Input Keys
1724   0B52 E6 1F       	AND     $1F                     ; only 5 bits
1725   0B54 CB 24       	SLA     H                       ; Next line
1726   0B56 04              INC     B
1727   0B57 FE 00           CP      0                       ; Was key zero?
1728   0B59 CA 48 0B        JP      Z, NEXTKEY              ; Then try again with next lines
1729   0B5C 16 00           LD      D, 0                    ; In D will be the number of the key
1730   0B5E             LOGARITHM:      
1731   0B5E 14              INC     D	                    ; Add one per shift
1732   0B5F CB 3F           SRL     A                       ; Shift key right
1733   0B61 C2 5E 0B        JP      NZ, LOGARITHM		    ; If not zero shift again
1734   0B64 15              DEC     D                       ; Was too much
1735   0B65 DB 40       	IN      A, (KEY_IN)
1736   0B67 E6 80           AND     $80                     ; Check if first bit set (shift key pressed)
1737   0B69 C2 72 0B        JP      NZ, LOADSHIFT		    ; Then jump to read with shift
1738   0B6C 7A              LD      A, D                    ; Put read key into accu
1739   0B6D C6 1B           ADD     A, KEYMAP               ; Add base of key map array
1740   0B6F C3 75 0B        JP      ADDOFFSET               ; Jump to load key
1741   0B72             LOADSHIFT:
1742   0B72 7A              LD      A, D
1743   0B73 C6 43           ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
1744   0B75             ADDOFFSET:
1745   0B75 C6 05           ADD     A, 5                    ; Add 5 for every line
1746   0B77 10 FC           DJNZ    ADDOFFSET               ; Jump back (do while loop)
1747   0B79 D6 05       	SUB     5                       ; Since do while is one too much
1748   0B7B             TRANSKEY:
1749   0B7B A8              XOR     B                       ; Empty B
1750   0B7C 4F          	LD      C, A                    ; A will be address in BC
1751   0B7D 0A          	LD      A, (BC)	                ; Load key
1752   0B7E BB          	CP      E                       ; Same key?
1753   0B7F CA 42 0B    	JP      Z, READKEY              ; Then from beginning
1754   0B82 5F          	LD      E, A                    ; Otherwise save new key
1755   0B83 C3 42 0B    	JP      READKEY	                ; And restart
1756   0B86             KEYOUT:
1757   0B86 7B              LD      A, E
1758   0B87 1E 00           LD      E, 0                    ; empty it
1759   0B89 B7              OR      A	                    ; Was a key read?
1760   0B8A CA 42 0B        JP      Z, READKEY              ; If not restart
1761   0B8D E1              POP     HL
1762   0B8E D1              POP     DE
1763   0B8F C1              POP     BC
1764   0B90 C9              RET
1765   0B91             
1766   0B91             
1767   0B91             ;-----------------------
1768   0B91             ; RECEIVE INTEL HEX FILE
1769   0B91             ;-----------------------       
1770   0B91             INTHEX: 
1771   0B91 21 E1 0F           LD HL, MSG_ILOAD
1772   0B94 CD 44 0C           CALL  SNDLCDMSG
1773   0B97             
1774   0B97 21 E1 0F           LD HL, MSG_ILOAD
1775   0B9A CD 52 0C           CALL  SNDMSG
1776   0B9D                    
1777   0B9D             
1778   0B9D CD BC 0B           CALL  INTELH
1779   0BA0 20 0D              JR    NZ,ITHEX1      
1780   0BA2             
1781   0BA2 21 F7 0F           LD    HL,FILEOK
1782   0BA5 CD 44 0C           CALL  SNDLCDMSG   ;GOT FILE OK LCD
1783   0BA8 21 F7 0F           LD    HL,FILEOK
1784   0BAB CD 52 0C           CALL  SNDMSG      ;GOT FILE OK Serial
1785   0BAE                    
1786   0BAE C9                 RET
1787   0BAF 21 09 10    ITHEX1: LD    HL,CSUMERR
1788   0BB2 CD 44 0C           CALL  SNDLCDMSG
1789   0BB5             
1790   0BB5 21 09 10           LD    HL,CSUMERR
1791   0BB8 CD 52 0C           CALL  SNDMSG      ;CHECKSUM ERROR
1792   0BBB                    
1793   0BBB C9                 RET  
1794   0BBC             
1795   0BBC             
1796   0BBC             
1797   0BBC             
1798   0BBC             
1799   0BBC             ;-----------------------
1800   0BBC             ; RECEIVE INTEL HEX FILE
1801   0BBC             ;-----------------------
1802   0BBC DD 21 00 FD INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
1803   0BC0             ;
1804   0BC0             ; WAIT FOR RECORD MARK
1805   0BC0             ;
1806   0BC0 AF          INTEL1:	XOR	A
1807   0BC1 DD 77 03    	LD	(IX+3),A	;CLEAR CHECKSUM
1808   0BC4 CD 97 0C    	CALL	RXDATA	;WAIT FOR THE RECORD MARK
1809   0BC7 FE 3A       	CP	':'	;TO BE TRANSMITTED
1810   0BC9 20 F5       	JR	NZ,INTEL1	;NOT RECORD MARK
1811   0BCB             ;
1812   0BCB             ; GET RECORD LENGTH
1813   0BCB             ;
1814   0BCB CD 18 0C    	CALL	GETBYT
1815   0BCE DD 77 00    	LD	(IX+0),A	;NUMBER OF DATA BYTES
1816   0BD1             ;
1817   0BD1             ; GET ADDRESS FIELD
1818   0BD1             ;
1819   0BD1 CD 18 0C    	CALL	GETBYT
1820   0BD4 DD 77 02    	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
1821   0BD7 CD 18 0C    	CALL	GETBYT
1822   0BDA DD 77 01    	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
1823   0BDD             ;
1824   0BDD             ; GET RECORD TYPE
1825   0BDD             ;
1826   0BDD CD 18 0C    	CALL	GETBYT
1827   0BE0 20 24       	JR	NZ,INTEL4	;END OF FILE RECORD
1828   0BE2             ;
1829   0BE2             ; READ IN THE DATA
1830   0BE2             ;
1831   0BE2 DD 46 00    	LD	B,(IX+0)	;NUMBER OF DATA BYTES
1832   0BE5 DD 66 02    	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
1833   0BE8 DD 6E 01    	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
1834   0BEB             
1835   0BEB CD 18 0C    INTEL2:	CALL	GETBYT	;GET DATA BYTE
1836   0BEE 77          	LD	(HL),A	;STORE DATA BYTE
1837   0BEF 23          	INC	HL
1838   0BF0 10 F9       	DJNZ	INTEL2	;LOAD MORE BYTES
1839   0BF2             ;
1840   0BF2             ; GET CHECKSUM AND COMPARE
1841   0BF2             ;
1842   0BF2 DD 7E 03    	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1843   0BF5 ED 44       	NEG		;TWO'S COMPLEMENT
1844   0BF7 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
1845   0BFA CD 18 0C    	CALL	GETBYT
1846   0BFD DD 77 03    	LD	(IX+3),A	;SAVE RECORD CHECKSUM
1847   0C00 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
1848   0C03 28 BB       	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
1849   0C05 C9              RET             ;NZ=CHECKSUM ERROR
1850   0C06             ;
1851   0C06             ; END OF FILE RECORD
1852   0C06             ;
1853   0C06 DD 7E 03    INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1854   0C09 ED 44       	NEG		;TWO'S COMPLEMENT
1855   0C0B DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
1856   0C0E CD 18 0C    	CALL	GETBYT
1857   0C11 DD 77 03    	LD	(IX+3),A	;SAVE EOF CHECKSUM
1858   0C14 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
1859   0C17 C9          	RET  	    ;NZ=CHECKSUM ERROR
1860   0C18             ;--------------------------
1861   0C18             ; GET BYTE FROM SERIAL PORT
1862   0C18             ;--------------------------
1863   0C18 C5          GETBYT:	PUSH	BC
1864   0C19 CD 97 0C    	CALL	RXDATA
1865   0C1C CB 77       	BIT	6,A
1866   0C1E 28 02       	JR	Z,GETBT1
1867   0C20 C6 09       	ADD	A,09H
1868   0C22 E6 0F       GETBT1:	AND	0FH
1869   0C24 CB 27       	SLA 	A
1870   0C26 CB 27       	SLA	A
1871   0C28 CB 27       	SLA	A
1872   0C2A CB 27       	SLA	A
1873   0C2C 4F          	LD	C,A
1874   0C2D             ;
1875   0C2D             ; GET LOW NYBBLE
1876   0C2D             ;
1877   0C2D CD 97 0C    	CALL	RXDATA
1878   0C30 CB 77       	BIT	6,A
1879   0C32 28 02       	JR	Z,GETBT2
1880   0C34 C6 09       	ADD	A,09H
1881   0C36 E6 0F       GETBT2:	AND	0FH
1882   0C38 B1          	OR	C
1883   0C39 47          	LD	B,A
1884   0C3A DD 86 03    	ADD	A,(IX+3)
1885   0C3D DD 77 03    	LD	(IX+3),A	;ADD TO CHECKSUM
1886   0C40 78          	LD	A,B
1887   0C41 A7          	AND	A	;CLEAR CARRY
1888   0C42 C1              POP	BC
1889   0C43 C9          	RET
1890   0C44             
1891   0C44             ;-----------------------------------------
1892   0C44             ; SEND AN ASCII STRING OUT LCD
1893   0C44             ;-----------------------------------------
1894   0C44             ; 
1895   0C44             ; SENDS A ZERO TERMINATED STRING OR 
1896   0C44             ; 128 CHARACTERS MAX. OUT LCD
1897   0C44             ;
1898   0C44             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
1899   0C44             ;      EXIT  : NONE
1900   0C44             ;
1901   0C44             ;       MODIFIES : A,B,C
1902   0C44             ;          
1903   0C44 06 80       SNDLCDMSG: LD    B,128         ;128 CHARS MAX
1904   0C46 7E          SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
1905   0C47 FE 00              CP    00H          ;ZERO TERMINATOR?
1906   0C49 28 06              JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
1907   0C4B CD 04 08           CALL PRINTCHAR         ;TRANSMIT THE CHAR
1908   0C4E 23                 INC   HL
1909   0C4F 10 F5              DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
1910   0C51 C9          SDLCDMSG2: RET
1911   0C52             
1912   0C52             
1913   0C52             ;-----------------------------------------
1914   0C52             ; SEND AN ASCII STRING OUT THE SERIAL PORT
1915   0C52             ;-----------------------------------------
1916   0C52             ; 
1917   0C52             ; SENDS A ZERO TERMINATED STRING OR 
1918   0C52             ; 128 CHARACTERS MAX. OUT THE SERIAL PORT
1919   0C52             ;
1920   0C52             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
1921   0C52             ;      EXIT  : NONE
1922   0C52             ;
1923   0C52             ;       MODIFIES : A,B,C
1924   0C52             ;          
1925   0C52 06 80       SNDMSG: LD    B,128         ;128 CHARS MAX
1926   0C54 7E          SDMSG1: LD    A,(HL)        ;GET THE CHAR
1927   0C55 FE 00              CP    00H          ;ZERO TERMINATOR?
1928   0C57 28 06              JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
1929   0C59 CD 60 0C           CALL  OUTCH         ;TRANSMIT THE CHAR
1930   0C5C 23                 INC   HL
1931   0C5D 10 F5              DJNZ  SDMSG1        ;128 CHARS MAX!    
1932   0C5F C9          SDMSG2: RET
1933   0C60             
1934   0C60             
1935   0C60             
1936   0C60             ;-----------------------------------
1937   0C60             ; OUTPUT A CHARACTER TO THE TERMINAL
1938   0C60             ;-----------------------------------       
1939   0C60 DD 2A AA FF OUTCH:  LD   IX,(PUTCH)
1940   0C64 DD E9              JP   (IX)
1941   0C66             ;------------------------------------
1942   0C66             ; INPUT A CHARACTER FROM THE TERMINAL
1943   0C66             ;------------------------------------
1944   0C66 DD 2A AC FF INCH:  LD   IX,(GETCH)
1945   0C6A DD E9             JP   (IX)
1946   0C6C             
1947   0C6C             
1948   0C6C             
1949   0C6C             ;------------------------
1950   0C6C             ; SERIAL TRANSMIT ROUTINE
1951   0C6C             ;------------------------
1952   0C6C             ;TRANSMIT BYTE SERIALLY ON DOUT
1953   0C6C             ;
1954   0C6C             ; ENTRY : A = BYTE TO TRANSMIT
1955   0C6C             ;  EXIT : NO REGISTERS MODIFIED
1956   0C6C             ;
1957   0C6C F5          TXDATA:	PUSH	AF
1958   0C6D C5          	PUSH	BC
1959   0C6E E5          	PUSH	HL
1960   0C6F 2A C0 FF    	LD	HL,(BAUD)
1961   0C72 4F          	LD	C,A
1962   0C73             ;
1963   0C73             ; TRANSMIT START BIT
1964   0C73             ;
1965   0C73 AF          	XOR	A
1966   0C74 D3 C0       	OUT	(SERIAL_TX_PORT),A
1967   0C76 CD C4 0C    	CALL	BITIME
1968   0C79             ;
1969   0C79             ; TRANSMIT DATA
1970   0C79             ;
1971   0C79 06 08       	LD	B,08H
1972   0C7B CB 09       	RRC	C
1973   0C7D CB 09       NXTBIT:	RRC	C	;SHIFT BITS TO D6,
1974   0C7F 79          	LD	A,C	;LSB FIRST AND OUTPUT
1975   0C80 E6 40       	AND	40H	;THEM FOR ONE BIT TIME.
1976   0C82 D3 C0       	OUT	(SERIAL_TX_PORT),A
1977   0C84 CD C4 0C    	CALL	BITIME
1978   0C87 10 F4       	DJNZ	NXTBIT
1979   0C89             ;
1980   0C89             ; SEND STOP BITS
1981   0C89             ;
1982   0C89 3E 40       	LD	A,40H
1983   0C8B D3 C0       	OUT	(SERIAL_TX_PORT),A
1984   0C8D CD C4 0C    	CALL	BITIME
1985   0C90 CD C4 0C    	CALL	BITIME
1986   0C93 E1          	POP	HL
1987   0C94 C1          	POP	BC
1988   0C95 F1          	POP	AF
1989   0C96 C9          	RET
1990   0C97             ;-----------------------
1991   0C97             ; SERIAL RECEIVE ROUTINE
1992   0C97             ;-----------------------
1993   0C97             ;RECEIVE SERIAL BYTE FROM DIN
1994   0C97             ;
1995   0C97             ; ENTRY : NONE
1996   0C97             ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
1997   0C97             ;
1998   0C97             ; REGISTERS MODIFIED A AND F
1999   0C97             ;
2000   0C97 C5          RXDATA:	PUSH	BC
2001   0C98 E5          	PUSH	HL
2002   0C99             ;
2003   0C99             ; WAIT FOR START BIT 
2004   0C99             ;
2005   0C99 DB C0       RXDAT1: IN	A,(SERIAL_RX_PORT)
2006   0C9B CB 7F       	    BIT	7,A
2007   0C9D 20 FA       	    JR	NZ,RXDAT1	;NO START BIT
2008   0C9F             ;
2009   0C9F             ; DETECTED START BIT
2010   0C9F             ;
2011   0C9F 2A C0 FF    	LD	HL,(BAUD)
2012   0CA2 CB 3C       	SRL	H
2013   0CA4 CB 1D       	RR	L 	;DELAY FOR HALF BIT TIME
2014   0CA6 CD C4 0C    	CALL 	BITIME
2015   0CA9 DB C0       	IN	A,(SERIAL_RX_PORT)
2016   0CAB CB 7F       	BIT	7,A
2017   0CAD 20 EA       	JR	NZ,RXDAT1	;START BIT NOT VALID
2018   0CAF             ;
2019   0CAF             ; DETECTED VALID START BIT,READ IN DATA
2020   0CAF             ;
2021   0CAF 06 08       	LD	B,08H
2022   0CB1 2A C0 FF    RXDAT2:	LD	HL,(BAUD)
2023   0CB4 CD C4 0C    	CALL	BITIME	;DELAY ONE BIT TIME
2024   0CB7 DB C0       	IN	A,(SERIAL_RX_PORT)
2025   0CB9 CB 17       	RL	A
2026   0CBB CB 19       	RR	C	;SHIFT BIT INTO DATA REG
2027   0CBD 10 F2       	DJNZ	RXDAT2
2028   0CBF 79          	LD	A,C
2029   0CC0 B7          	OR	A	;CLEAR CARRY FLAG
2030   0CC1 E1              POP	HL
2031   0CC2 C1          	POP	BC
2032   0CC3 C9          	RET
2033   0CC4             ;---------------
2034   0CC4             ; BIT TIME DELAY
2035   0CC4             ;---------------
2036   0CC4             ;DELAY FOR ONE SERIAL BIT TIME
2037   0CC4             ;ENTRY : HL = DELAY TIME
2038   0CC4             ; NO REGISTERS MODIFIED
2039   0CC4             ;
2040   0CC4 E5          BITIME:	PUSH	HL
2041   0CC5 D5          	PUSH	DE
2042   0CC6 11 01 00    	LD	DE,0001H
2043   0CC9 ED 52       BITIM1:	SBC	HL,DE
2044   0CCB D2 C9 0C    	JP	NC,BITIM1
2045   0CCE D1          	POP	DE
2046   0CCF E1          	POP	HL
2047   0CD0 C9          	RET
2048   0CD1             
2049   0CD1             
2050   0CD1             ;-----------------
2051   0CD1             ; ONE SECOND DELAY
2052   0CD1             ;-----------------
2053   0CD1             ;
2054   0CD1             ; ENTRY : NONE
2055   0CD1             ; EXIT : FLAG REGISTER MODIFIED
2056   0CD1             ;
2057   0CD1 C5          DELONE:	PUSH	BC
2058   0CD2 D5          	PUSH	DE
2059   0CD3 E5          	PUSH	HL
2060   0CD4 11 01 00    	LD	DE,0001H
2061   0CD7 21 70 08    	LD	HL,0870H
2062   0CDA 06 92       DELON1:	LD	B,92H
2063   0CDC 10 FE       DELON2:	DJNZ	DELON2	;INNER LOOP
2064   0CDE ED 52       	SBC	HL,DE
2065   0CE0 D2 DA 0C    	JP	NC,DELON1	;OUTER LOOP
2066   0CE3 E1          	POP	HL
2067   0CE4 D1          	POP	DE
2068   0CE5 C1          	POP	BC
2069   0CE6 C9          	RET
2070   0CE7             
2071   0CE7             
2072   0CE7             
2073   0CE7             
2074   0CE7             
2075   0CE7             
2076   0CE7             
2077   0CE7             ; **********************************************************************
2078   0CE7             ; List devices found on the I2C bus
2079   0CE7             ;
2080   0CE7             ; Test each I2C device address and reports any that acknowledge
2081   0CE7             
2082   0CE7 11 6E 0F    I2CLIST:       LD   DE,LISTMsg        ;Address of message string
2083   0CEA CD 8A 0D                CALL StrOut         ;Output string
2084   0CED 16 00                   LD   D,0            ;First I2C device address to test
2085   0CEF D5          LISTLOOP:      PUSH DE             ;Preserve DE
2086   0CF0 7A                      LD   A,D            ;Get device address to be tested
2087   0CF1 CD 08 0D                CALL LISTTEST          ;Test if device is present
2088   0CF4 D1                      POP  DE             ;Restore DE
2089   0CF5 20 07                   JR   NZ,LISTNEXT       ;Skip if no acknowledge
2090   0CF7 7A                      LD   A,D            ;Get address of device tested
2091   0CF8 CD B9 0D                CALL HexOut         ;Output as two character hex 
2092   0CFB CD 85 0D                CALL SpaceOut       ;Output space character
2093   0CFE 14          LISTNEXT:      INC  D              ;Get next write address
2094   0CFF 14                      INC  D
2095   0D00 7A                      LD   A,D            ;Address of next device to test
2096   0D01 B7                      OR   A              ;Have we tested all addresses?
2097   0D02 20 EB                   JR   NZ,LISTLOOP       ;No, so loop again
2098   0D04 CD 82 0D                CALL LineOut        ;Output new line
2099   0D07 C9                      RET
2100   0D08             
2101   0D08             ; Test if device at I2C address A acknowledges
2102   0D08             ;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
2103   0D08             ;   On exit:  Z flagged if device acknowledges
2104   0D08             ;             NZ flagged if devices does not acknowledge
2105   0D08 CD FA 0D    LISTTEST:      CALL I2C_Open       ;Open I2C device for write
2106   0D0B C0                      RET  NZ             ;Abort if failed to open
2107   0D0C CD 01 0E                CALL I2C_Close      ;Close I2C device 
2108   0D0F AF                      XOR  A              ;Return with Z flagged
2109   0D10 C9                      RET
2110   0D11             
2111   0D11             
2112   0D11             
2113   0D11             
2114   0D11             ; Copy a block from I2C memory to CPU memory
2115   0D11             ;   On entry: DE = First address in I2C memory
2116   0D11             ;             HL = First address in CPU memory
2117   0D11             ;             BC = Number of bytes to be copied
2118   0D11             ;             SCL = unknown, SDA = unknown
2119   0D11             ;   On exit:  If successfully A = 0 and Z flagged
2120   0D11             ;             If unsuccessfully A = Error and NZ flagged
2121   0D11             ;             IX IY preserved
2122   0D11 C5          I2C_MemRd:  PUSH BC
2123   0D12 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2124   0D15 3E AE       I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2125   0D17 CD FA 0D                CALL I2C_Open       ;Open for write
2126   0D1A 28 0A                   JR   Z,I2C_MemRdReady       ;If open okay then skip on
2127   0D1C 0B                      DEC  BC
2128   0D1D 78                      LD   A,B
2129   0D1E B1                      OR   C              ;Timeout?
2130   0D1F 20 F4                   JR   NZ,I2C_MemRdRepeat     ;No, so go try again
2131   0D21 C1                      POP  BC
2132   0D22 3E 03                   LD   A,ERR_TOUT     ;Error code
2133   0D24 B7                      OR   A              ;Error, so NZ flagged
2134   0D25 C9                      RET                 ;Return with error
2135   0D26             ; Device opened okay
2136   0D26 C1          I2C_MemRdReady:     POP  BC             ;Restore byte counter
2137   0D27 7A                      LD   A,D            ;Address (hi) in I2C memory
2138   0D28 CD 04 0E                CALL I2C_Write      ;Write address
2139   0D2B 7B                      LD   A,E            ;Address (lo) in I2C memory
2140   0D2C CD 04 0E                CALL I2C_Write      ;Write address
2141   0D2F 3E AF                   LD   A,I2CA_BLOCK+1 ;I2C device to be read from
2142   0D31 CD FA 0D                CALL I2C_Open       ;Open for read
2143   0D34 C0                      RET  NZ             ;Abort if error
2144   0D35 0B          I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
2145   0D36 78                      LD   A,B
2146   0D37 B1                      OR   C              ;Last byte to be read?
2147   0D38 CD 41 0E                CALL I2C_Read       ;Read byte with no ack on last byte
2148   0D3B 77                      LD   (HL),A         ;Write byte in CPU memory
2149   0D3C 23                      INC  HL             ;Increment CPU memory pointer
2150   0D3D 78                      LD   A,B
2151   0D3E B1                      OR   C              ;Finished?
2152   0D3F 20 F4                   JR   NZ,I2C_MemRdRead       ;No, so go read next byte
2153   0D41 CD 79 0E                CALL I2C_Stop       ;Generate I2C stop
2154   0D44 AF                      XOR  A              ;Return with success (Z flagged)
2155   0D45 C9                      RET
2156   0D46             
2157   0D46             
2158   0D46             ; Copy a block from CPU memory to I2C memory
2159   0D46             ;   On entry: DE = First address in I2C memory
2160   0D46             ;             HL = First address in CPU memory
2161   0D46             ;             BC = Number of bytes to be copied
2162   0D46             ;             SCL = unknown, SDA = unknown
2163   0D46             ;   On exit:  If successfully A = 0 and Z flagged
2164   0D46             ;             If unsuccessfully A = Error and NZ flagged
2165   0D46             ;             IX IY preserved
2166   0D46             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
2167   0D46             ; pages.
2168   0D46 C5          I2C_MemWr:  PUSH BC
2169   0D47 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2170   0D4A 3E AE       I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2171   0D4C CD FA 0D                CALL I2C_Open       ;Open for write
2172   0D4F 28 0A                   JR   Z,I2C_MemWrReady       ;If open okay then skip on
2173   0D51 0B                      DEC  BC
2174   0D52 78                      LD   A,B
2175   0D53 B1                      OR   C              ;Timeout?
2176   0D54 20 F4                   JR   NZ,I2C_MemWrRepeat     ;No, so go try again
2177   0D56 C1                      POP  BC
2178   0D57 3E 03                   LD   A,ERR_TOUT     ;Error code
2179   0D59 B7                      OR   A              ;Error, so NZ flagged
2180   0D5A C9                      RET                 ;Return with error
2181   0D5B             ; Device opened okay
2182   0D5B C1          I2C_MemWrReady:     POP  BC             ;Restore byte counter
2183   0D5C 7A          I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
2184   0D5D CD 04 0E                CALL I2C_Write      ;Write address
2185   0D60 7B                      LD   A,E            ;Address (lo) in I2C memory
2186   0D61 CD 04 0E                CALL I2C_Write      ;Write address
2187   0D64 7E          I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
2188   0D65 CD 04 0E                CALL I2C_Write      ;Read byte from I2C memory
2189   0D68 23                      INC  HL             ;Increment CPU memory pointer
2190   0D69 13                      INC  DE             ;Increment I2C memory pointer
2191   0D6A 0B                      DEC  BC             ;Decrement byte counter
2192   0D6B 78                      LD   A,B
2193   0D6C B1                      OR   C              ;Finished?
2194   0D6D 28 05                   JR   Z,I2C_MemWrStore       ;Yes, so go store this page
2195   0D6F 7B                      LD   A,E            ;Get address in I2C memory (lo byte)
2196   0D70 E6 3F                   AND  63             ;64 byte page boundary?
2197   0D72 20 F0                   JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
2198   0D74 CD 79 0E    I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
2199   0D77 78                      LD   A,B
2200   0D78 B1                      OR   C              ;Finished?
2201   0D79 20 CB                   JR   NZ,I2C_MemWr   ;No, so go write some more
2202   0D7B C9                      RET   
2203   0D7C             
2204   0D7C             
2205   0D7C             
2206   0D7C             
2207   0D7C             
2208   0D7C             
2209   0D7C             
2210   0D7C             
2211   0D7C             
2212   0D7C             
2213   0D7C             ; Display test result
2214   0D7C             ;   On entry: DE = Address of null terminated string
2215   0D7C             ;             H = First value ($H)
2216   0D7C             ;             L = Second value ($L)
2217   0D7C             ;   On exit:  HL IX IY preserved
2218   0D7C             Result:     
2219   0D7C C3 D1 0D                JP   String         ;Output result string to console
2220   0D7F             
2221   0D7F             
2222   0D7F             ; Character output to console
2223   0D7F             ;   On entry: A = Character to be output
2224   0D7F             ;   On exit:  BC DE HL IX IY preserved
2225   0D7F C3 97 0D    CharOut:    JP   API_Cout
2226   0D82             
2227   0D82             ; New line output to console
2228   0D82             ;   On entry: No parameters required
2229   0D82             ;   On exit:  BC DE HL IX IY preserved
2230   0D82 C3 A1 0D    LineOut:    JP   API_Lout
2231   0D85             
2232   0D85             ; Space character ouput to console
2233   0D85             ;   On entry: No parameters required
2234   0D85             ;   On exit:  BC DE HL IX IY preserved
2235   0D85 3E 20       SpaceOut:   LD   A,$20
2236   0D87 C3 97 0D                JP   API_Cout
2237   0D8A             
2238   0D8A             ; String output to console
2239   0D8A             ;   On entry: DE = Address of string
2240   0D8A             ;   On exit:  BC DE HL IX IY preserved
2241   0D8A C3 AD 0D    StrOut:     JP   API_Sout
2242   0D8D             
2243   0D8D             
2244   0D8D             ; Delay by DE milliseconds (approx)
2245   0D8D             ;   On entry: DE = Delay time in milliseconds
2246   0D8D             ;   On exit:  BC DE HL IX IY preserved
2247   0D8D C5          API_Delay:  PUSH BC             ;Preserve registers
2248   0D8E D5                      PUSH DE
2249   0D8F E5                      PUSH HL
2250   0D90 CD 19 0B                CALL delay
2251   0D93 E1                      POP  HL             ;Restore registers
2252   0D94 D1                      POP  DE
2253   0D95 C1                      POP  BC
2254   0D96 C9                      RET
2255   0D97             
2256   0D97             
2257   0D97             ; Character output to console device
2258   0D97             ;   On entry: A = Character to be output
2259   0D97             ;   On exit:  BC DE HL IX IY preserved
2260   0D97 C5          API_Cout:   PUSH BC             ;Preserve registers
2261   0D98 D5                      PUSH DE
2262   0D99 E5                      PUSH HL
2263   0D9A CD 08 00                CALL $0008
2264   0D9D E1                      POP  HL             ;Restore registers
2265   0D9E D1                      POP  DE
2266   0D9F C1                      POP  BC
2267   0DA0 C9                      RET
2268   0DA1             
2269   0DA1             
2270   0DA1             ; New line output to console device
2271   0DA1             ;   On entry: No parameters required
2272   0DA1             ;   On exit:  BC DE HL IX IY preserved
2273   0DA1 C5          API_Lout:   PUSH BC             ;Preserve registers
2274   0DA2 D5                      PUSH DE
2275   0DA3 E5                      PUSH HL
2276   0DA4 3E 0D                   LD A, CR ; enter char
2277   0DA6 CD 08 00                CALL $0008
2278   0DA9 E1                      POP  HL             ;Restore registers
2279   0DAA D1                      POP  DE
2280   0DAB C1                      POP  BC
2281   0DAC C9                      RET
2282   0DAD             
2283   0DAD             
2284   0DAD             ; String output to console device
2285   0DAD             ;   On entry: DE = Address of string
2286   0DAD             ;   On exit:  BC DE HL IX IY preserved
2287   0DAD C5          API_Sout:   PUSH BC             ;Preserve registers
2288   0DAE D5                      PUSH DE
2289   0DAF E5                      PUSH HL
2290   0DB0 62                      LD H, D
2291   0DB1 6B                      LD L, E
2292   0DB2 CD 44 0C                CALL SNDLCDMSG
2293   0DB5 E1                      POP  HL             ;Restore registers
2294   0DB6 D1                      POP  DE
2295   0DB7 C1                      POP  BC
2296   0DB8 C9                      RET
2297   0DB9             
2298   0DB9             
2299   0DB9             ; Hex byte output to console
2300   0DB9             ;   On entry: A = Byte to be output in hex
2301   0DB9             ;   On exit:  BC DE HL IX IY preserved
2302   0DB9 F5          HexOut:     PUSH AF             ;Preserve byte to be output
2303   0DBA 1F                      RRA                 ;Shift top nibble to
2304   0DBB 1F                      RRA                 ;  botom four bits..
2305   0DBC 1F                      RRA
2306   0DBD 1F                      RRA
2307   0DBE E6 0F                   AND  $0F           ;Mask off unwanted bits
2308   0DC0 CD C6 0D                CALL HexOutHex           ;Output hi nibble
2309   0DC3 F1                      POP  AF             ;Restore byte to be output
2310   0DC4 E6 0F                   AND  $0F           ;Mask off unwanted bits
2311   0DC6             ; Output nibble as ascii character
2312   0DC6 FE 0A       HexOutHex:       CP   $0A           ;Nibble > 10 ?
2313   0DC8 38 02                   JR   C,HexOutSkip        ;No, so skip
2314   0DCA C6 07                   ADD  A,7            ;Yes, so add 7
2315   0DCC C6 30       HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
2316   0DCE C3 97 0D                JP   API_Cout       ;Write character
2317   0DD1             
2318   0DD1             
2319   0DD1             ; Output string at DE with substitutions
2320   0DD1             ;   On entry: A = Address of device on I2C bus (write address)
2321   0DD1             ;             DE = Address of null terminated string
2322   0DD1             ;             H = Value to substitute for $H
2323   0DD1             ;             L = Value to substitute for $L
2324   0DD1             ;             B = Value to substitute for $B
2325   0DD1             ;   On exit:  DE = Address of next location after this string
2326   0DD1             ;             IX IY preserved
2327   0DD1 1A          String:     LD   A,(DE)         ;Get character from string
2328   0DD2 13                      INC  DE             ;Point to next character in string
2329   0DD3 B7                      OR   A              ;Null ?
2330   0DD4 C8                      RET  Z              ;Yes, so we're done
2331   0DD5 FE 24                   CP   '$'            ;Substitue value?
2332   0DD7 28 05                   JR   Z,StringSubst       ;Yes, so go handle substitution
2333   0DD9 CD 7F 0D                CALL CharOut        ;Output character to console
2334   0DDC 18 F3                   JR   String         ;Go get next character from string
2335   0DDE 1A          StringSubst:     LD   A,(DE)         ;Get character from string
2336   0DDF 13                      INC  DE             ;Point to next character in string
2337   0DE0 B7                      OR   A              ;Null ?
2338   0DE1 C8                      RET  Z              ;Yes, so we're done
2339   0DE2 FE 48                   CP   'H'            ;Register H
2340   0DE4 20 03                   JR   NZ,StringNotH       ;No, so skip
2341   0DE6 7C                      LD   A,H            ;Get value 'H'
2342   0DE7 18 0C                   JR   StringGotIt         ;Go output it in hex
2343   0DE9 FE 4C       StringNotH:      CP   'L'            ;Register L
2344   0DEB 20 03                   JR   NZ,StringNotL       ;No, so skip
2345   0DED 7D                      LD   A,L            ;Get value 'L'
2346   0DEE 18 05                   JR   StringGotIt         ;Go output it in hex
2347   0DF0 FE 42       StringNotL:      CP   'B'            ;Register B
2348   0DF2 20 04                   JR   NZ,StringNotB       ;No, so skip
2349   0DF4 78                      LD   A,B            ;Get value 'L'
2350   0DF5                         ;JR   @GotIt        ;Go output it in hex
2351   0DF5 CD B9 0D    StringGotIt:     CALL HexOut         ;Output write address in hex
2352   0DF8 18 D7       StringNotB:      JR   String         ;Go get next character from string
2353   0DFA             
2354   0DFA             
2355   0DFA             ; **********************************************************************
2356   0DFA             ; I2C support functions
2357   0DFA             
2358   0DFA             ; I2C bus open device
2359   0DFA             ;   On entry: A = Device address (bit zero is read flag)
2360   0DFA             ;             SCL = unknown, SDA = unknown
2361   0DFA             ;   On exit:  If successfully A = 0 and Z flagged
2362   0DFA             ;             If unsuccessfully A = Error and NZ flagged
2363   0DFA             ;             BC DE HL IX IY preserved
2364   0DFA F5          I2C_Open:   PUSH AF
2365   0DFB CD 6E 0E                CALL I2C_Start      ;Output start condition
2366   0DFE F1                      POP  AF
2367   0DFF 18 03                   JR   I2C_Write      ;Write data byte
2368   0E01             
2369   0E01             
2370   0E01             ; I2C bus close device
2371   0E01             ;   On entry: SCL = unknown, SDA = unknown
2372   0E01             ;   On exit:  If successfully A=0 and Z flagged
2373   0E01             ;             If unsuccessfully A=Error and NZ flagged
2374   0E01             ;             SCL = hi, SDA = hi
2375   0E01             ;             BC DE HL IX IY preserved
2376   0E01 C3 79 0E    I2C_Close:  JP   I2C_Stop       ;Output stop condition
2377   0E04             
2378   0E04             
2379   0E04             ; **********************************************************************
2380   0E04             ; **********************************************************************
2381   0E04             ; I2C bus master driver
2382   0E04             ; **********************************************************************
2383   0E04             ; **********************************************************************
2384   0E04             
2385   0E04             ; Functions provided are:
2386   0E04             ;     I2C_Start
2387   0E04             ;     I2C_Stop
2388   0E04             ;     I2C_Read
2389   0E04             ;     I2C_Write
2390   0E04             ;
2391   0E04             ; This code has delays between all I/O operations to ensure it works
2392   0E04             ; with the slowest I2C devices
2393   0E04             ;
2394   0E04             ; I2C transfer sequence
2395   0E04             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2396   0E04             ;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
2397   0E04             ;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
2398   0E04             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2399   0E04             ;
2400   0E04             ;
2401   0E04             ; Start condition                     Stop condition
2402   0E04             ; Output by master device             Output by master device
2403   0E04             ;       ----+                                      +----
2404   0E04             ; SDA       |                         SDA          |
2405   0E04             ;           +-------                        -------+
2406   0E04             ;       -------+                                +-------
2407   0E04             ; SCL          |                      SCL       |
2408   0E04             ;              +----                        ----+
2409   0E04             ;
2410   0E04             ;
2411   0E04             ; Address frame
2412   0E04             ; Clock and data output from master device
2413   0E04             ; Receiving device outputs acknowledge 
2414   0E04             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2415   0E04             ; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
2416   0E04             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2417   0E04             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2418   0E04             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2419   0E04             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2420   0E04             ;
2421   0E04             ;
2422   0E04             ; Data frame 
2423   0E04             ; Clock output by master device
2424   0E04             ; Data output by transmitting device
2425   0E04             ; Receiving device outputs acknowledge 
2426   0E04             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2427   0E04             ; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
2428   0E04             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2429   0E04             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2430   0E04             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2431   0E04             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2432   0E04             ;
2433   0E04             
2434   0E04             
2435   0E04             ; **********************************************************************
2436   0E04             ; I2C constants
2437   0E04             
2438   0E04             
2439   0E04             ; I2C bus master interface
2440   0E04             ; The default device option is for SC126 or compatible
2441   0E04             
2442   0E04             I2C_PORT:   .EQU $20           ;Host I2C port address
2443   0E04             I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
2444   0E04             I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
2445   0E04             I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
2446   0E04             I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
2447   0E04             I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
2448   0E04             
2449   0E04             
2450   0E04             ; I2C support constants
2451   0E04             ERR_NONE:   .EQU 0              ;Error = None
2452   0E04             ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
2453   0E04             ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
2454   0E04             ERR_TOUT:   .EQU 3              ;Error = Timeout
2455   0E04             
2456   0E04             
2457   0E04             ; **********************************************************************
2458   0E04             ; Hardware dependent I2C bus functions
2459   0E04             
2460   0E04             
2461   0E04             ; I2C bus transmit frame (address or data)
2462   0E04             ;   On entry: A = Data byte, or
2463   0E04             ;                 Address byte (bit zero is read flag)
2464   0E04             ;             SCL = low, SDA = low
2465   0E04             ;   On exit:  If successful A=0 and Z flagged
2466   0E04             ;                SCL = lo, SDA = lo
2467   0E04             ;             If unsuccessful A=Error and NZ flagged
2468   0E04             ;                SCL = high, SDA = high, I2C closed
2469   0E04             ;             BC DE HL IX IY preserved
2470   0E04 C5          I2C_Write:  PUSH BC             ;Preserve registers
2471   0E05 D5                      PUSH DE
2472   0E06 57                      LD   D,A            ;Store byte to be written
2473   0E07 06 08                   LD   B,8            ;8 data bits, bit 7 first
2474   0E09 CB 12       I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
2475   0E0B 38 05                   JR   C,I2C_WriteBit_Hi      ;High, so skip
2476   0E0D CD A0 0E                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
2477   0E10 18 03                   JR   I2C_WriteBit_Clk
2478   0E12 CD 99 0E    I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
2479   0E15 CD 8B 0E    I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
2480   0E18 CD 92 0E                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
2481   0E1B 10 EC                   DJNZ I2C_WriteWr_Loop
2482   0E1D             ; Test for acknowledge from slave (receiver)
2483   0E1D             ; On arriving here, SCL = lo, SDA = data bit
2484   0E1D CD 99 0E                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
2485   0E20 CD 8B 0E                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
2486   0E23 CD B1 0E                CALL I2C_RdPort     ;Read SDA input
2487   0E26 47                      LD   B,A
2488   0E27 CD 92 0E                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
2489   0E2A CB 78                   BIT  I2C_SDA_RD,B
2490   0E2C 20 04                   JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
2491   0E2E D1                      POP  DE             ;Restore registers
2492   0E2F C1                      POP  BC
2493   0E30 AF                      XOR  A              ;Return success A=0 and Z flagged
2494   0E31 C9                      RET
2495   0E32             ; I2C STOP required as no acknowledge
2496   0E32             ; On arriving here, SCL = lo, SDA = hi
2497   0E32 CD A0 0E    I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
2498   0E35 CD 8B 0E                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
2499   0E38 CD 99 0E                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
2500   0E3B D1                      POP  DE             ;Restore registers
2501   0E3C C1                      POP  BC
2502   0E3D 3E 02                   LD   A,ERR_NOACK    ;Return error = No Acknowledge
2503   0E3F B7                      OR   A              ;  and NZ flagged
2504   0E40 C9                      RET
2505   0E41             
2506   0E41             
2507   0E41             ; I2C bus receive frame (data)
2508   0E41             ;   On entry: A = Acknowledge flag
2509   0E41             ;               If A != 0 the read is acknowledged
2510   0E41             ;             SCL low, SDA low
2511   0E41             ;   On exit:  If successful A = data byte and Z flagged
2512   0E41             ;               SCL = low, SDA = low
2513   0E41             ;             If unsuccessul* A = Error and NZ flagged
2514   0E41             ;               SCL = low, SDA = low
2515   0E41             ;             BC DE HL IX IY preserved
2516   0E41             ; *This function always returns successful
2517   0E41 C5          I2C_Read:   PUSH BC             ;Preserve registers
2518   0E42 D5                      PUSH DE
2519   0E43 5F                      LD   E,A            ;Store acknowledge flag
2520   0E44 06 08                   LD   B,8            ;8 data bits, 7 first
2521   0E46 CD 99 0E                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
2522   0E49 CD 8B 0E    I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
2523   0E4C CD B1 0E                CALL I2C_RdPort     ;Read SDA input bit
2524   0E4F 37                      SCF                 ;Set carry flag
2525   0E50 CB 7F                   BIT  I2C_SDA_RD,A   ;SDA input high?
2526   0E52 20 01                   JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
2527   0E54 3F                      CCF                 ;Clear carry flag
2528   0E55 CB 12       I2C_ReadRotate:    RL   D              ;Rotate result into D
2529   0E57 CD 92 0E                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
2530   0E5A 10 ED                   DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
2531   0E5C             ; Acknowledge input byte
2532   0E5C             ; On arriving here, SCL = lo, SDA = hi/input
2533   0E5C 7B                      LD   A,E            ;Get acknowledge flag
2534   0E5D B7                      OR   A              ;A = 0? (indicates no acknowledge)
2535   0E5E 28 03                   JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
2536   0E60 CD A0 0E                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
2537   0E63 CD 8B 0E    I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
2538   0E66 CD 92 0E                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2539   0E69 7A                      LD   A,D            ;Get data byte received
2540   0E6A D1                      POP  DE             ;Restore registers
2541   0E6B C1                      POP  BC
2542   0E6C BF                      CP   A              ;Return success Z flagged
2543   0E6D C9                      RET
2544   0E6E             
2545   0E6E             
2546   0E6E             ; I2C bus start
2547   0E6E             ;   On entry: SCL = unknown, SDA = unknown
2548   0E6E             ;   On exit:  SCL = low, SDA = low
2549   0E6E             ;             A = 0 and Z flagged as we always succeed
2550   0E6E             ;             BC DE HL IX IY preserved
2551   0E6E             ; First ensure SDA and SCL are high
2552   0E6E CD 87 0E    I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
2553   0E71             ;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
2554   0E71             ;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
2555   0E71             ; Generate I2C start condition
2556   0E71 CD A0 0E                CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2557   0E74 CD 92 0E                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2558   0E77 AF                      XOR  A              ;Return success A=0 and Z flagged
2559   0E78 C9                      RET
2560   0E79             
2561   0E79             
2562   0E79             ; I2C bus stop 
2563   0E79             ;   On entry: SCL = unknown, SDA = unknown
2564   0E79             ;   On exit:  SCL = high, SDA = high
2565   0E79             ;             A = 0 and Z flagged as we always succeed
2566   0E79             ;             BC DE HL IX IY preserved
2567   0E79             ; First ensure SDA and SCL are low
2568   0E79 CD A0 0E    I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2569   0E7C CD 92 0E                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2570   0E7F             ; Generate stop condition
2571   0E7F CD 8B 0E                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
2572   0E82 CD 99 0E                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
2573   0E85 AF                      XOR  A              ;Return success A=0 and Z flagged
2574   0E86 C9                      RET
2575   0E87             
2576   0E87             
2577   0E87             ; **********************************************************************
2578   0E87             ; I2C bus simple I/O functions
2579   0E87             ;   On entry: No parameters required
2580   0E87             ;   On exit:  BC DE HL IX IY preserved
2581   0E87             
2582   0E87 3E 81       I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
2583   0E89 18 1A                   JR   I2C_WrPort
2584   0E8B             
2585   0E8B 3A 00 D0    I2C_SCL_HI: LD   A,(I2C_RAMCPY)
2586   0E8E CB C7                   SET  I2C_SCL_WR,A
2587   0E90 18 13                   JR   I2C_WrPort
2588   0E92             
2589   0E92 3A 00 D0    I2C_SCL_LO: LD   A,(I2C_RAMCPY)
2590   0E95 CB 87                   RES  I2C_SCL_WR,A
2591   0E97 18 0C                   JR   I2C_WrPort
2592   0E99             
2593   0E99 3A 00 D0    I2C_SDA_HI: LD   A,(I2C_RAMCPY)
2594   0E9C CB FF                   SET  I2C_SDA_WR,A
2595   0E9E 18 05                   JR   I2C_WrPort
2596   0EA0             
2597   0EA0 3A 00 D0    I2C_SDA_LO: LD   A,(I2C_RAMCPY)
2598   0EA3 CB BF                   RES  I2C_SDA_WR,A
2599   0EA5                         ;JR   I2C_WrPort
2600   0EA5             
2601   0EA5 C5          I2C_WrPort: PUSH BC             ;Preserve registers
2602   0EA6 06 00                   LD   B,0            ;Set up BC for 16-bit
2603   0EA8 0E 20                   LD   C,I2C_PORT     ;  I/O address of I2C port
2604   0EAA ED 79                   OUT  (C),A          ;Write A to I2C I/O port
2605   0EAC 32 00 D0                LD   (I2C_RAMCPY),A ;Write A to RAM copy
2606   0EAF C1                      POP  BC             ;Restore registers
2607   0EB0 C9                      RET
2608   0EB1             
2609   0EB1 C5          I2C_RdPort: PUSH BC             ;Preserve registers
2610   0EB2 06 00                   LD   B,0            ;Set up BC for 16-bit
2611   0EB4 0E 20                   LD   C,I2C_PORT     ;  I/O address of I2C port
2612   0EB6 ED 78                   IN   A,(C)          ;Read A from I/O port
2613   0EB8 C1                      POP  BC             ;Restore registers
2614   0EB9 C9                      RET
2615   0EBA             
2616   0EBA             
2617   0EBA             
2618   0EBA 0C0D0D0A5A38WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
2618   0EC0 30204D696E6920496E69636961646F0D0A00
2619   0ED2 5A3830204D49MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H
2619   0ED8 4E492C204820544F2048454C500D00
2620   0EE7             
2621   0EE7 49202D20496EMSG_MENU1 .db "I - Intel hex loader",CR, 00H
2621   0EED 74656C20686578206C6F616465720D00
2622   0EFD 42202D204261MSG_MENU2 .db "B - Basic",CR, 00H
2622   0F03 7369630D00
2623   0F08 442041414141MSG_MENU3 .db "D AAAA - DISPLAY",CR,00H
2623   0F0E 202D20444953504C41590D00
2624   0F1A 4D2041414141MSG_MENU4 .db "M AAAA - MODIFY",CR,00H
2624   0F20 202D204D4F444946590D00
2625   0F2B 472041414141MSG_MENU5 .db "G AAAA - GO TO",CR, 00H
2625   0F31 202D20474F20544F0D00
2626   0F3B 31202D204932MSG_MENU6 .db "1 - I2C Scan",CR, 00H
2626   0F41 43205363616E0D00
2627   0F49 32202D204932MSG_MENU7 .db "2 - I2C PC -> MEM",CR, 00H
2627   0F4F 43205043202D3E204D454D0D00
2628   0F5C 33202D204932MSG_MENU8 .db "3 - I2C MEM -> PC", 00H
2628   0F62 43204D454D202D3E20504300
2629   0F6E             
2630   0F6E 0C4932432064LISTMsg:    .DB  CS,"I2C device found at:",CR,0
2630   0F74 657669636520666F756E642061743A0D00
2631   0F85 0C434F505920MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
2631   0F8B 493243204D454D20544F204350550D00
2632   0F9B 0C434F505920MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H
2632   0FA1 43505520544F20493243204D454D0D00
2633   0FB1 46524F4D3A20MSG_FROM    .db "FROM: ", 00H
2633   0FB7 00
2634   0FB8 0D544F3A2000MSG_TO      .db CR,"TO: ", 00H
2635   0FBE 0D53495A4528MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
2635   0FC4 4259544553293A2000
2636   0FCD 0D434F505920MSG_COPYOK  .db CR,"COPY OK", 00H
2636   0FD3 4F4B00
2637   0FD6 0D434F505920MSG_COPYFAIL  .db CR,"COPY FAIL", 00H
2637   0FDC 4641494C00
2638   0FE1             
2639   0FE1             
2640   0FE1 0C496E74656CMSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
2640   0FE7 20484558206C6F616465722E2E2E0D00
2641   0FF7 46494C452052FILEOK    .DB      "FILE RECEIVED OK",CR,00H
2641   0FFD 45434549564544204F4B0D00
2642   1009 434845434B53CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
2642   100F 554D204552524F520D00
2643   1019             
2644   1019             
2645   1019             
2646   1019             ; **********************************************************************
2647   1019             ; I2C workspace / variables in RAM
2648   1019             
2649   D000                         .ORG  I2CDATA
2650   D000             
2651   D000 00          I2C_RAMCPY: .DB  0              ;RAM copy of output port
2652   D001             
2653   D001 00          RESULTS:    .DB  0              ;Large block of results can start here
2654   D002             
2655   D002             .end
tasm: Number of errors = 0
