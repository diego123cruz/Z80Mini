0001   0000             ; Diego Cruz - Nov 2022
0002   0000             ; 
0003   0000             ; bootV2: 
0004   0000             ;         - CPU Z80@4Mhz
0005   0000             ;         - Lcd Grafico 128x64
0006   0000             ;         - Keyboard 40 keys + Shift
0007   0000             ;         - Rom 32k 0000h - 7FFFh
0008   0000             ;         - Ram 32k 8000h - FFFFh
0009   0000             ;         
0010   0000             ;
0011   0000             ;         - Ports:
0012   0000             ;               - Keyboard: 40H
0013   0000             ;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
0014   0000             ;               - User IN/OUT: C0H
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------
0017   0000             LCDCTRL	    .EQU    70H
0018   0000             LCDDATA     .EQU    71H
0019   0000             KEY_IN      .EQU    40H
0020   0000             KEY_OUT     .EQU    40H
0021   0000             
0022   0000             CTRLC       .EQU    03H             ; Control "C"
0023   0000             CTRLG       .EQU    07H             ; Control "G"
0024   0000             BKSP        .EQU    08H             ; Back space
0025   0000             LF          .EQU    0AH             ; Line feed
0026   0000             VT          .equ    0BH             ; 
0027   0000             CS          .EQU    0CH             ; Clear screen
0028   0000             CR          .EQU    0DH             ; Carriage return [Enter]
0029   0000             CTRLO       .EQU    0FH             ; Control "O"
0030   0000             CTRLQ	    .EQU	11H		        ; Control "Q"
0031   0000             CTRLR       .EQU    12H             ; Control "R"
0032   0000             CTRLS       .EQU    13H             ; Control "S"
0033   0000             CTRLU       .EQU    15H             ; Control "U"
0034   0000             ESC         .EQU    1BH             ; Escape
0035   0000             DEL         .EQU    7FH             ; Delete
0036   0000             
0037   0000             BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
0038   0000             ;
0039   0000             ; BAUD RATE CONSTANTS
0040   0000             ;
0041   0000             B300:	.EQU	0220H	;300 BAUD
0042   0000             B1200:	.EQU	0080H	;1200 BAUD
0043   0000             B2400:	.EQU	003FH	;2400 BAUD
0044   0000             B4800:	.EQU	001BH	;4800 BAUD
0045   0000             B9600:	.EQU	000BH	;9600 BAUD
0046   0000             
0047   0000             SYSTEM:	.EQU 	0FD00H	;INITIAL STACK POINTER
0048   0000             I2CDATA .EQU    0D000H 
0049   0000             
0050   0000             ADDR:    .EQU 0FEB0H   ;THE ADDRESS  
0051   0000             DATA:    .EQU 0FEB2H   ;THE DATA
0052   0000             MSGBUF:  .EQU 0FE00H   ;STRING HANDLING AREA
0053   0000             
0054   0000             BAUD:	 .EQU	0FFC0H	 ;BAUD RATE
0055   0000             PUTCH:   .EQU   0FFAAH   ;OUTPUT A CHARACTER TO SERIAL
0056   0000             GETCH:   .EQU   0FFACH   ;WAIT FOR A CHARACTER FROM SERIAL
0057   0000             
0058   0000             SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
0059   0000             SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
0060   0000             
0061   0000             
0062   0000             ; LCD TEXT MODE
0063   0000             LCD_LINE1   .EQU    80H
0064   0000             LCD_LINE2   .EQU    90H
0065   0000             LCD_LINE3   .EQU    88H
0066   0000             LCD_LINE4   .EQU    98H
0067   0000             
0068   0000             
0069   0000             ; RAM MAP
0070   0000             
0071   0000             
0072   0000             
0073   0000             LCD_CHAR            .EQU    $E000   ; 1 byte char ex: 'A'
0074   0000             LCD_CHAR_POINT      .EQU    $E001   ; 2 bytes ponteiro para o mapa de caracteres
0075   0000             LCD_TXT_X           .EQU    $E003   ; 1 byte  0-20 (21 col)
0076   0000             LCD_TXT_Y           .EQU    $E004   ; 1 byte  0-7  (8 row)
0077   0000             LCD_BYTE_INDEX      .EQU    $E005   ; 2 bytes pointer pixel(8)
0078   0000             LCD_BIT_INDEX       .EQU    $E007   ; 1 byte pointer pixel(1)
0079   0000             LCD_TXT_X_TMP       .EQU    $E008   ; 2 bytes = LCD_TXT_X * 6
0080   0000             LCD_TXT_Y_TMP       .EQU    $E00A   ; 2 bytes = LCD_TXT_Y * 128
0081   0000             LCD_CHAR_H          .EQU    $E00C   ; 1 byte altura do char
0082   0000             LCD_CHAR_W          .EQU    $E00D   ; 1 byte largura do char
0083   0000             LCD_TMP_POINT       .EQU    $E00E   ; 2 bytes ponteiro do pixel altural do print
0084   0000             LCD_DELETE_CHAR     .EQU    $E00F   ; 1 byte, 0 não, ff delete proximo char
0085   0000             LCD_AUTO_X          .EQU    $E010   ; 1 byte, 0 sim, ff nao
0086   0000             
0087   0000             DISPLAY             .EQU    $E500
0088   0000             
0089   0000             LCD_TEMP        .EQU    $E110
0090   0000             LCD_COOX        .EQU    $E102 ; 1 byte, local onde vai printar
0091   0000             LCD_COOY        .EQU    $E103 ; 1 byte
0092   0000             LCD_PRINT_H     .EQU    $E104 ; 1 byte, tamanho do que vai printar
0093   0000             LCD_PRINT_W     .EQU    $E105 ; 1 byte
0094   0000             LCD_PRINT_IMAGE .EQU    $E106 ; 2 bytes
0095   0000             
0096   0000             
0097   0000                     .ORG 0
0098   0000 F3          RST00	DI
0099   0001 C3 6B 04            JP  INICIO
0100   0004             						
0101   0008                     .ORG     0008H
0102   0008 C3 C0 06    RST08   JP  PRINTCHAR
0103   000B             
0104   0010                     .ORG 0010H
0105   0010 C3 E5 09    RST10   JP KEYREADINIT
0106   0013             
0107   0018                     .ORG 0018H ; check break
0108   0018             RST18   ;LD	A, 0
0109   0018                     ;CP	0
0110   0018                     ;RET
0111   0018 C3 D0 09    	JP CHKKEY
0112   001B             
0113   001B             KEYMAP:
0114   001B 313233343536.BYTE   "1234567890"
0114   0021 37383930
0115   0025 515745525459.BYTE   "QWERTYUIOP"
0115   002B 55494F50
0116   002F 415344464748.BYTE   "ASDFGHJKL", CR
0116   0035 4A4B4C0D
0117   0039 035A58435642.BYTE   CTRLC, "ZXCVBNM ", DEL
0117   003F 4E4D207F
0118   0043             
0119   0043             SHIFTKEYMAP:
0120   0043 21402324255E.BYTE   "!@#$%^&*()"
0120   0049 262A2829
0121   004D 607E2D5F3D2B.BYTE   "`~-_=+;:'"
0121   0053 3B3A27
0122   0056 22          .BYTE   22h
0123   0057 7B7D5B5D7C5C.BYTE   "{}[]|",$5C,"<>?/"
0123   005D 3C3E3F2F
0124   0061 032C2E1B2020.BYTE   CTRLC,",.",ESC,"    ", VT, LF
0124   0067 20200B0A
0125   006B             
0126   006B             
0127   006B             
0128   006B             TABLE:
0129   006B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
0129   0071 0000
0130   0073 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
0130   0079 0000
0131   007B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
0131   0081 0000
0132   0083 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
0132   0089 0000
0133   008B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
0133   0091 0000
0134   0093 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
0134   0099 0000
0135   009B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
0135   00A1 0000
0136   00A3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
0136   00A9 0000
0137   00AB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
0137   00B1 0000
0138   00B3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
0138   00B9 0000
0139   00BB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0139   00C1 0000
0140   00C3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
0140   00C9 0000
0141   00CB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0141   00D1 0000
0142   00D3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
0142   00D9 0000
0143   00DB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0143   00E1 0000
0144   00E3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
0144   00E9 0000
0145   00EB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0145   00F1 0000
0146   00F3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
0146   00F9 0000
0147   00FB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0147   0101 0000
0148   0103 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
0148   0109 0000
0149   010B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0149   0111 0000
0150   0113 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
0150   0119 0000
0151   011B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0151   0121 0000
0152   0123 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
0152   0129 0000
0153   012B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0153   0131 0000
0154   0133 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
0154   0139 0000
0155   013B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0155   0141 0000
0156   0143 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
0156   0149 0000
0157   014B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0157   0151 0000
0158   0153 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
0158   0159 0000
0159   015B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
0159   0161 0000
0160   0163 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
0160   0169 0000
0161   016B             
0162   016B             ; DEC 32
0163   016B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
0163   0171 0000
0164   0173 202020202000.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
0164   0179 2000
0165   017B 505050000000.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
0165   0181 0000
0166   0183 5050F850F850.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
0166   0189 5000
0167   018B 2078A07028F0.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
0167   0191 2000
0168   0193 C0C810204098.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
0168   0199 1800
0169   019B 6090A040A890.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
0169   01A1 6800
0170   01A3 202020000000.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
0170   01A9 0000
0171   01AB 102040404020.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
0171   01B1 1000
0172   01B3 402010101020.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
0172   01B9 4000
0173   01BB 0020A870A820.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0173   01C1 0000
0174   01C3 002020F82020.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
0174   01C9 0000
0175   01CB 000000006020.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0175   01D1 4000
0176   01D3 000000F80000.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
0176   01D9 0000
0177   01DB 000000000060.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0177   01E1 6000
0178   01E3 000008102040.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
0178   01E9 8000
0179   01EB 708898A8C888.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0179   01F1 7000
0180   01F3 206020202020.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
0180   01F9 7000
0181   01FB 708808102040.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0181   0201 F800
0182   0203 F81020100888.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
0182   0209 7000
0183   020B 10305090F810.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0183   0211 1000
0184   0213 F880F0080888.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
0184   0219 7000
0185   021B 304080F08888.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0185   0221 7000
0186   0223 F80810204040.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
0186   0229 4000
0187   022B 708888708888.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0187   0231 7000
0188   0233 708888780810.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
0188   0239 6000
0189   023B 000030300030.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0189   0241 3000
0190   0243 003030003010.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
0190   0249 2000
0191   024B 102040804020.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0191   0251 1000
0192   0253 0000F800F800.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
0192   0259 0000
0193   025B 402010081020.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
0193   0261 4000
0194   0263 304808102000.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
0194   0269 2000
0195   026B 70880868A8A8.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
0195   0271 7000
0196   0273             
0197   0273             ; DEC 65 Maiusculas
0198   0273 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0198   0279 8800
0199   027B F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0199   0281 F000
0200   0283 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0200   0289 7000
0201   028B E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0201   0291 E000
0202   0293 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0202   0299 F800
0203   029B F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0203   02A1 8000
0204   02A3 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0204   02A9 7000
0205   02AB 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0205   02B1 8800
0206   02B3 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0206   02B9 7000
0207   02BB 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0207   02C1 7000
0208   02C3 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0208   02C9 8800
0209   02CB 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0209   02D1 F800
0210   02D3 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0210   02D9 8800
0211   02DB 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0211   02E1 8800
0212   02E3 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0212   02E9 7000
0213   02EB F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0213   02F1 8000
0214   02F3 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0214   02F9 7000
0215   02FB F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0215   0301 8800
0216   0303 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0216   0309 7000
0217   030B F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0217   0311 2000
0218   0313 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0218   0319 7000
0219   031B 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0219   0321 2000
0220   0323 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0220   0329 8800
0221   032B 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0221   0331 8800
0222   0333 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0222   0339 2000
0223   033B F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0223   0341 F800
0224   0343             
0225   0343             ; DEC 91
0226   0343 302020202020.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
0226   0349 3000
0227   034B 008040201008.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0227   0351 0000
0228   0353 602020202020.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
0228   0359 6000
0229   035B 205088000000.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
0229   0361 0000
0230   0363 000000000000.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
0230   0369 F800
0231   036B 402010000000.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
0231   0371 0000
0232   0373             
0233   0373             ; DEC 97 "Minusculas"
0234   0373 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0234   0379 8800
0235   037B F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0235   0381 F000
0236   0383 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0236   0389 7000
0237   038B E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0237   0391 E000
0238   0393 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0238   0399 F800
0239   039B F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0239   03A1 8000
0240   03A3 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0240   03A9 7000
0241   03AB 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0241   03B1 8800
0242   03B3 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0242   03B9 7000
0243   03BB 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0243   03C1 7000
0244   03C3 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0244   03C9 8800
0245   03CB 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0245   03D1 F800
0246   03D3 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0246   03D9 8800
0247   03DB 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0247   03E1 8800
0248   03E3 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0248   03E9 7000
0249   03EB F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0249   03F1 8000
0250   03F3 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0250   03F9 7000
0251   03FB F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0251   0401 8800
0252   0403 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0252   0409 7000
0253   040B F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0253   0411 2000
0254   0413 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0254   0419 7000
0255   041B 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0255   0421 2000
0256   0423 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0256   0429 8800
0257   042B 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0257   0431 8800
0258   0433 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0258   0439 2000
0259   043B F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0259   0441 F800
0260   0443             
0261   0443             ; DEC 123
0262   0443 102020402020.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0262   0449 1000
0263   044B 202020202020.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0263   0451 2000
0264   0453 402020102020.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0264   0459 4000
0265   045B 000050A00000.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0265   0461 0000
0266   0463 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0266   0469 0000
0267   046B             
0268   046B             
0269   046B             
0270   046B             
0271   046B             
0272   046B             
0273   046B             
0274   046B             
0275   046B             ; -----------------------------------------------------------------------------
0276   046B             ;   INICIO
0277   046B             ; -----------------------------------------------------------------------------
0278   046B             INICIO:
0279   046B 31 00 FD        LD  SP, SYSTEM
0280   046E             
0281   046E                 ; init serial
0282   046E CD 79 0B        CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0283   0471 21 14 0B        LD    HL,TXDATA
0284   0474 22 AA FF        LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0285   0477 21 3F 0B        LD    HL,RXDATA
0286   047A 22 AC FF        LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
0287   047D                 
0288   047D 21 1B 00        LD	HL,B4800
0289   0480 22 C0 FF    	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
0290   0483             
0291   0483 3E FF           LD A, $FF
0292   0485 D3 C0           OUT (SERIAL_TX_PORT), A
0293   0487             
0294   0487 21 0D 0D        LD HL, WELLCOME
0295   048A CD FA 0A        CALL SNDMSG
0296   048D             
0297   048D                 ; CALL INCH
0298   048D                 ; CALL OUTCH
0299   048D             
0300   048D                 ; Init LCD hardware
0301   048D CD 44 08        CALL INIT_LCD
0302   0490 CD C1 09        call delay
0303   0493             
0304   0493 CD 5C 09        call cls_TXT
0305   0496 CD C1 09        call delay
0306   0499             
0307   0499 CD E6 08        CALL enable_grafic
0308   049C CD C1 09        call delay
0309   049F             
0310   049F CD 62 09        call cls_GRAPHIC
0311   04A2 CD C1 09        call delay
0312   04A5             
0313   04A5 CD D8 08        call lcd_clear
0314   04A8             
0315   04A8 21 00 E5        ld hl, DISPLAY
0316   04AB CD FF 08        call print_image
0317   04AE             
0318   04AE CD C1 09        call delay
0319   04B1             
0320   04B1                 ; Init LCD logical
0321   04B1 CD 31 06        call INIT_TXT_LCD ; set cursor X Y to 0
0322   04B4             
0323   04B4 21 25 0D        LD HL, MSG_MONITOR
0324   04B7 CD EC 0A        CALL SNDLCDMSG
0325   04BA             
0326   04BA 3E 3E           LD A, '>'
0327   04BC CD C0 06        CALL PRINTCHAR
0328   04BF             
0329   04BF             KEY:
0330   04BF CD E5 09        CALL KEYREADINIT
0331   04C2             
0332   04C2 FE 48           CP 'H'
0333   04C4 CC 0B 05        CALL Z, SHOWHELP
0334   04C7             
0335   04C7 FE 42           CP 'B'
0336   04C9 CA 00 60        JP Z, BASIC
0337   04CC             
0338   04CC FE 49           CP 'I'
0339   04CE CA FF 04        JP Z, INTEL_HEX
0340   04D1             
0341   04D1 FE 52           CP 'R'
0342   04D3 CA 00 80        JP Z, $8000
0343   04D6             
0344   04D6 FE 31           CP '1'
0345   04D8 CC 8F 0B        CALL Z, I2CLIST
0346   04DB             
0347   04DB FE 47           CP 'G'
0348   04DD CC 8D 05        CALL Z, GOJUMP
0349   04E0             
0350   04E0 FE 4D           CP 'M'
0351   04E2 CC 35 05        CALL Z, MODIFY
0352   04E5             
0353   04E5 3E 0D           LD A, CR 
0354   04E7 CD C0 06        CALL PRINTCHAR
0355   04EA             
0356   04EA 3E 3E           LD A, '>' 
0357   04EC CD C0 06        CALL PRINTCHAR
0358   04EF             
0359   04EF C3 BF 04        JP  KEY
0360   04F2             
0361   04F2             RESETW:
0362   04F2 3E 0D           LD A, CR
0363   04F4 CD C0 06        CALL PRINTCHAR
0364   04F7             
0365   04F7 3E 3E           LD A, '>'
0366   04F9 CD C0 06        CALL PRINTCHAR
0367   04FC C3 BF 04        JP KEY
0368   04FF             
0369   04FF             INTEL_HEX:
0370   04FF CD 39 0A        CALL INTHEX
0371   0502 CD C1 09        CALL delay
0372   0505 CD C1 09        CALL delay
0373   0508 C3 6B 04        JP INICIO
0374   050B             
0375   050B             SHOWHELP:
0376   050B 3E 0C           LD A, $0C ; limpar tela
0377   050D CD C0 06        CALL PRINTCHAR
0378   0510             
0379   0510 21 3A 0D        LD HL, MSG_MENU1
0380   0513 CD EC 0A        CALL SNDLCDMSG
0381   0516             
0382   0516 21 45 0D        LD HL, MSG_MENU2
0383   0519 CD EC 0A        CALL SNDLCDMSG
0384   051C             
0385   051C 21 5B 0D        LD HL, MSG_MENU3
0386   051F CD EC 0A        CALL SNDLCDMSG
0387   0522             
0388   0522 21 6F 0D        LD HL, MSG_MENU4
0389   0525 CD EC 0A        CALL SNDLCDMSG
0390   0528             
0391   0528 21 7D 0D        LD HL, MSG_MENU5
0392   052B CD EC 0A        CALL SNDLCDMSG
0393   052E             
0394   052E 21 92 0D        LD HL, MSG_MENU6
0395   0531 CD EC 0A        CALL SNDLCDMSG
0396   0534             
0397   0534 C9              RET
0398   0535             
0399   0535             
0400   0535             ;----------------------------
0401   0535             ; M DISPLAY AND MODIFY MEMORY
0402   0535             ;----------------------------
0403   0535 3E 4D       MODIFY: LD A, 'M'
0404   0537 CD C0 06            CALL PRINTCHAR
0405   053A CD B5 05         CALL  OUTSP
0406   053D             ;
0407   053D             ;GET THE ADDRESS        
0408   053D             ;
0409   053D CD C1 05           CALL  GETCHR 
0410   0540 D8                 RET   C        
0411   0541 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0412   0544 CD C1 05           CALL  GETCHR
0413   0547 D8                 RET   C
0414   0548 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0415   054B             ;
0416   054B             ; DISPLAY ON A NEW LINE
0417   054B             ;       
0418   054B CD BB 05    MDIFY1: CALL  TXCRLF       
0419   054E ED 5B B0 FE        LD    DE,(ADDR)    
0420   0552 21 00 FE           LD    HL,MSGBUF   
0421   0555 CD 18 06           CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
0422   0558 21 00 FE           LD    HL,MSGBUF
0423   055B CD 0C 06           CALL  WRDOUT      ;OUTPUT THE ADDRESS
0424   055E CD B5 05           CALL  OUTSP    
0425   0561             ;      
0426   0561             ;GET THE DATA AT THE ADDRESS        
0427   0561             ;
0428   0561 2A B0 FE            LD   HL,(ADDR)       
0429   0564 7E                  LD   A,(HL)
0430   0565             ;
0431   0565             ; DISPLAY THE DATA
0432   0565             ;        
0433   0565 21 00 FE           LD    HL,MSGBUF
0434   0568 CD 1D 06           CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
0435   056B 21 00 FE           LD    HL,MSGBUF
0436   056E CD 0F 06           CALL  BYTOUT      ;OUTPUT THE BYTE
0437   0571 CD B5 05           CALL  OUTSP
0438   0574             ;
0439   0574             ; GET NEW DATA,EXIT OR CONTINUE
0440   0574             ;
0441   0574 CD C1 05           CALL  GETCHR
0442   0577 D8                 RET   C
0443   0578 47                 LD    B,A         ;SAVE IT FOR LATER
0444   0579 2A B0 FE           LD    HL,(ADDR)
0445   057C 77                 LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
0446   057D 78                 LD    A,B
0447   057E BE                 CP    (HL)
0448   057F 28 05              JR    Z,MDIFY2
0449   0581 3E 3F              LD    A,'?'
0450   0583 CD C0 06           CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
0451   0586             ;
0452   0586             ; INCREMENT THE ADDRESS
0453   0586             ;
0454   0586 23          MDIFY2: INC   HL
0455   0587 22 B0 FE           LD    (ADDR),HL
0456   058A C3 4B 05           JP    MDIFY1
0457   058D             
0458   058D             
0459   058D             
0460   058D             ;------------------------------
0461   058D             ; GO <ADDR>
0462   058D             ; TRANSFERS EXECUTION TO <ADDR>
0463   058D             ;------------------------------
0464   058D 3E 47       GOJUMP: LD A, 'G'
0465   058F CD C0 06            CALL PRINTCHAR
0466   0592 CD B5 05           CALL  OUTSP       
0467   0595 CD C1 05           CALL  GETCHR      ;GET ADDRESS HIGH BYTE
0468   0598 D8                 RET   C
0469   0599 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0470   059C CD C1 05           CALL  GETCHR      ;GET ADDRESS LOW BYTE
0471   059F D8                 RET   C
0472   05A0 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0473   05A3             ;
0474   05A3             ; WAIT FOR A CR OR ESC
0475   05A3             ;       
0476   05A3 CD E5 09    GOJMP1: CALL  KEYREADINIT
0477   05A6 FE 1B              CP    ESC         ;ESC KEY?
0478   05A8 C8                 RET   Z
0479   05A9 FE 0D              CP    CR
0480   05AB 20 F6              JR    NZ,GOJMP1
0481   05AD CD BB 05           CALL  TXCRLF
0482   05B0 E1                 POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
0483   05B1 2A B0 FE           LD    HL,(ADDR)
0484   05B4 E9                 JP    (HL)        ;GOOD LUCK WITH THAT!
0485   05B5             
0486   05B5             
0487   05B5             ;---------------
0488   05B5             ; OUTPUT A SPACE
0489   05B5             ;---------------
0490   05B5 3E 20       OUTSP:  LD    A,20H
0491   05B7 CD C0 06           CALL  PRINTCHAR
0492   05BA C9                 RET
0493   05BB             
0494   05BB             ;-------------      
0495   05BB             ; OUTPUT CRLF
0496   05BB             ;------------
0497   05BB 3E 0D       TXCRLF: LD   A,CR
0498   05BD CD C0 06           CALL PRINTCHAR   
0499   05C0 C9                 RET
0500   05C1             
0501   05C1             ;-----------------------------
0502   05C1             ; GET A BYTE FROM THE TERMINAL
0503   05C1             ;-----------------------------
0504   05C1 CD E5 09    GETCHR: CALL KEYREADINIT ; read key
0505   05C4 FE 1B              CP    ESC
0506   05C6 28 27              JR    Z,GETOUT
0507   05C8 47                 LD    B,A                ;SAVE TO ECHO      
0508   05C9 CD F1 05           CALL  ASC2HEX
0509   05CC 30 F3              JR    NC,GETCHR          ;REJECT NON HEX CHARS    
0510   05CE 21 B2 FE           LD    HL,DATA
0511   05D1 77                 LD    (HL),A 
0512   05D2 78                 LD    A,B         
0513   05D3 CD C0 06           CALL  PRINTCHAR             ;ECHO VALID HEX
0514   05D6                    
0515   05D6 CD E5 09    GETNYB: CALL  KEYREADINIT
0516   05D9 FE 1B              CP    ESC
0517   05DB 28 12              JR    Z,GETOUT
0518   05DD 47                 LD    B,A               ;SAVE TO ECHO
0519   05DE CD F1 05           CALL  ASC2HEX
0520   05E1 30 F3              JR    NC,GETNYB         ;REJECT NON HEX CHARS
0521   05E3 ED 6F              RLD
0522   05E5 78                 LD    A,B
0523   05E6 CD C0 06           CALL  PRINTCHAR             ;ECHO VALID HEX
0524   05E9 7E                 LD    A,(HL)
0525   05EA CD EF 05           CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
0526   05ED 3F                 CCF                    ;AND THEN COMPLEMENTING IT
0527   05EE C9                 RET   
0528   05EF 37          GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
0529   05F0 C9                 RET
0530   05F1             
0531   05F1             
0532   05F1             ;----------------------------------------
0533   05F1             ; CONVERT ASCII CHARACTER INTO HEX NYBBLE
0534   05F1             ;----------------------------------------
0535   05F1             ; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
0536   05F1             ; ENTRY OTHER THAN HEXADECIMAL KEYS
0537   05F1             ;
0538   05F1             ;CONVERTS ASCII 0-9,A-F INTO HEX LSN
0539   05F1             ;ENTRY : A= ASCII 0-9,A-F
0540   05F1             ;EXIT  : CARRY =  1
0541   05F1             ;          A= HEX 0-F IN LSN    
0542   05F1             ;      : CARRY = 0
0543   05F1             ;          A= OUT OF RANGE CHARACTER & 7FH
0544   05F1             ; A AND F REGISTERS MODIFIED
0545   05F1             ;
0546   05F1 E6 7F       ASC2HEX: AND   7FH        ;STRIP OUT PARITY
0547   05F3 FE 30              CP    30H
0548   05F5 38 12              JR    C,AC2HEX3    ;LESS THAN 0
0549   05F7 FE 3A              CP    3AH
0550   05F9 30 02              JR    NC,AC2HEX2   ;MORE THAN 9
0551   05FB 37          AC2HEX1: SCF               ;SET THE CARRY - IS HEX
0552   05FC C9                 RET
0553   05FD             ;     
0554   05FD FE 41       AC2HEX2: CP    41H
0555   05FF 38 08              JR    C,AC2HEX3    ;LESS THAN A
0556   0601 FE 47              CP    47H
0557   0603 30 04              JR    NC,AC2HEX3   ;MORE THAN F
0558   0605 D6 07              SUB   07H        ;CONVERT TO NYBBLE
0559   0607 18 F2              JR    AC2HEX1  
0560   0609 E6 FF       AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
0561   060B C9                 RET
0562   060C             
0563   060C             
0564   060C             ;----------------------     
0565   060C             ; SEND ASCII HEX VALUES        
0566   060C             ;----------------------
0567   060C             ;
0568   060C             ; OUTPUT THE 4 BYTE, WRDOUT
0569   060C             ; THE 2 BYTE, BYTOUT
0570   060C             ; OR THE SINGLE BYTE, NYBOUT
0571   060C             ; ASCII STRING AT HL TO THE SERIAL PORT
0572   060C             ;
0573   060C CD 0F 06    WRDOUT: CALL  BYTOUT
0574   060F CD 12 06    BYTOUT: CALL  NYBOUT
0575   0612 7E          NYBOUT: LD    A,(HL)
0576   0613 CD C0 06           CALL  PRINTCHAR
0577   0616 23                 INC   HL
0578   0617 C9                 RET       
0579   0618             ;----------------
0580   0618             ;CONVERT TO ASCII 
0581   0618             ;----------------
0582   0618             ;
0583   0618             ; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
0584   0618             ;
0585   0618             ;         ENTRY :  A = BINARY TO CONVERT
0586   0618             ;                  HL = CHARACTER BUFFER ADDRESS   
0587   0618             ;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
0588   0618             ;   
0589   0618             ;        MODIFIES : DE
0590   0618             
0591   0618 7A          WRDASC: LD    A,D         ;CONVERT AND
0592   0619 CD 1D 06           CALL  BYTASC      ;OUTPUT D
0593   061C 7B                 LD    A,E         ;THEN E
0594   061D             ;
0595   061D             ;CONVERT A BYTE TO ASCII 
0596   061D             ;
0597   061D F5          BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
0598   061E 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
0599   061F 0F                 RRCA
0600   0620 0F                 RRCA
0601   0621 0F                 RRCA
0602   0622 CD 26 06           CALL NYBASC       ;CALL NYBBLE CONVERTER 
0603   0625 F1                 POP AF            ;RESTORE LOW NYBBLE
0604   0626             
0605   0626             ;           
0606   0626             ; CONVERT A NYBBLE TO ASCII
0607   0626             ;
0608   0626 E6 0F       NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
0609   0628 C6 90              ADD   A,90H       ;CONVERT TO
0610   062A 27                 DAA               ;ASCII
0611   062B CE 40              ADC   A,40H
0612   062D 27                 DAA
0613   062E             ;            
0614   062E             ; SAVE IN STRING
0615   062E             ;
0616   062E 77          INSBUF: LD    (HL),A
0617   062F 23                 INC   HL 
0618   0630 C9                 RET 
0619   0631             
0620   0631             
0621   0631             
0622   0631             INIT_TXT_LCD:
0623   0631 3E 00           ld a, 0
0624   0633 32 03 E0        ld (LCD_TXT_X), a
0625   0636 32 04 E0        ld (LCD_TXT_Y), a
0626   0639 32 0F E0        ld (LCD_DELETE_CHAR), a
0627   063C 32 10 E0        ld (LCD_AUTO_X), a
0628   063F 21 00 00        ld hl, 0
0629   0642 22 08 E0        ld (LCD_TXT_X_TMP), hl
0630   0645 23              inc hl
0631   0646 22 0A E0        ld (LCD_TXT_Y_TMP), hl
0632   0649 C9              RET
0633   064A             
0634   064A             
0635   064A             DISPLAY_SCROLL_UP:
0636   064A                 ; cada linha tem 128 bytes
0637   064A                 ; temos 8 linhas
0638   064A                 ; total 1024 bytes
0639   064A             
0640   064A                 ; display lines 0 to 7
0641   064A                 ; move line 1 to 0
0642   064A 21 80 E5        ld hl, DISPLAY+128
0643   064D 11 00 E5        ld de, DISPLAY
0644   0650 01 7F 00        ld bc, 127
0645   0653 ED B0           ldir
0646   0655             
0647   0655                 ; move line 2 to 1
0648   0655 21 00 E6        ld hl, DISPLAY+256
0649   0658 11 80 E5        ld de, DISPLAY+128
0650   065B 01 7F 00        ld bc, 127
0651   065E ED B0           ldir
0652   0660             
0653   0660                 ; move line 3 to 2
0654   0660 21 80 E6        ld hl, DISPLAY+384
0655   0663 11 00 E6        ld de, DISPLAY+256
0656   0666 01 7F 00        ld bc, 127
0657   0669 ED B0           ldir
0658   066B             
0659   066B                 ; move line 4 to 3
0660   066B 21 00 E7        ld hl, DISPLAY+512
0661   066E 11 80 E6        ld de, DISPLAY+384
0662   0671 01 7F 00        ld bc, 127
0663   0674 ED B0           ldir
0664   0676             
0665   0676                 ; move line 5 to 4
0666   0676 21 80 E7        ld hl, DISPLAY+640
0667   0679 11 00 E7        ld de, DISPLAY+512
0668   067C 01 7F 00        ld bc, 127
0669   067F ED B0           ldir
0670   0681             
0671   0681                 ; move line 6 to 5
0672   0681 21 00 E8        ld hl, DISPLAY+768
0673   0684 11 80 E7        ld de, DISPLAY+640
0674   0687 01 7F 00        ld bc, 127
0675   068A ED B0           ldir
0676   068C             
0677   068C                 ; move line 7 to 6
0678   068C 21 80 E8        ld hl, DISPLAY+896
0679   068F 11 00 E8        ld de, DISPLAY+768
0680   0692 01 7F 00        ld bc, 127
0681   0695 ED B0           ldir
0682   0697             
0683   0697                 ; clear line 7
0684   0697                 ; 896 to 1024
0685   0697 21 80 E8        ld hl, DISPLAY+896
0686   069A 5D              ld e,l
0687   069B 54              ld d,h
0688   069C 13              inc de
0689   069D 36 00           ld (hl), 0
0690   069F 01 7F 00        ld bc, 127
0691   06A2 ED B0           ldir
0692   06A4             
0693   06A4 C9              RET
0694   06A5             
0695   06A5             DELETE_CHAR:
0696   06A5 E1              POP HL ; retorno do call
0697   06A6 3E 00           LD A, 0
0698   06A8 32 0F E0        LD (LCD_DELETE_CHAR), A
0699   06AB 3A 03 E0        LD A, (LCD_TXT_X)
0700   06AE 3D              DEC A
0701   06AF 32 03 E0        LD (LCD_TXT_X), A
0702   06B2             
0703   06B2 3E FF           LD A, $FF
0704   06B4 32 10 E0        LD (LCD_AUTO_X), A
0705   06B7             
0706   06B7 F1              POP AF
0707   06B8 3E 20           LD A, ' '
0708   06BA 32 00 E0        LD (LCD_CHAR), A
0709   06BD F5              PUSH AF
0710   06BE E5              PUSH HL ; call
0711   06BF C9              RET
0712   06C0             
0713   06C0             
0714   06C0             ; char in A
0715   06C0             PRINTCHAR:
0716   06C0 32 00 E0        LD (LCD_CHAR), A ; save char to print
0717   06C3             
0718   06C3 F5              PUSH AF
0719   06C4 C5              PUSH BC
0720   06C5 D5              PUSH DE
0721   06C6 E5              PUSH HL
0722   06C7             
0723   06C7 F5              PUSH AF
0724   06C8 3E 00           LD A, $0
0725   06CA 32 10 E0        LD (LCD_AUTO_X), A
0726   06CD F1              POP AF
0727   06CE             
0728   06CE             
0729   06CE             ver_delete:
0730   06CE F5              PUSH AF
0731   06CF 3A 0F E0        LD A, (LCD_DELETE_CHAR)
0732   06D2 B7              or a
0733   06D3 FE FF           CP $FF
0734   06D5 CC A5 06        call z, DELETE_CHAR
0735   06D8 F1              POP AF
0736   06D9 B7              or a
0737   06DA FE 00           CP $0
0738   06DC 20 08           jr nz, ver_enter
0739   06DE 3E FF           LD A, $FF ; delete proximo char
0740   06E0 32 0F E0        LD (LCD_DELETE_CHAR), A
0741   06E3 C3 23 08        jp print_char_fim
0742   06E6             
0743   06E6                 ; Verificar Enter, clear, etc... SEM PERDER O reg. A
0744   06E6             ver_enter:       
0745   06E6             
0746   06E6                             ; trata dados para o lcd
0747   06E6 FE 0D                       CP      CR                     ; compara com ENTER
0748   06E8 20 20                       jr      nz, ver_limpa
0749   06EA             
0750   06EA 3E 00                       LD A,0
0751   06EC 32 03 E0                    LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
0752   06EF             
0753   06EF 3A 04 E0                    LD A, (LCD_TXT_Y)
0754   06F2 3C                          inc a
0755   06F3 FE 08                       cp 8
0756   06F5 C2 04 07                    jp nz, ver_enter_incYOK
0757   06F8                             
0758   06F8 CD 4A 06                    CALL DISPLAY_SCROLL_UP
0759   06FB 21 00 E5                    ld hl, DISPLAY
0760   06FE CD FF 08                    CALL print_image
0761   0701                             
0762   0701 C3 23 08                    jp print_char_fim
0763   0704             
0764   0704             ver_enter_incYOK:
0765   0704 32 04 E0                    ld (LCD_TXT_Y), a
0766   0707 C3 23 08                    jp print_char_fim
0767   070A             
0768   070A             
0769   070A             ver_limpa:
0770   070A FE 0C                       CP      $0C                     ; compara com limpar tela
0771   070C 20 14                       jr      NZ, ver_line
0772   070E                             
0773   070E                             ;call    clear_lcd_screen
0774   070E                             ;call    show_lcd_screen
0775   070E CD D8 08                    call lcd_clear
0776   0711 21 00 E5                    ld hl, DISPLAY
0777   0714 CD FF 08                    call print_image
0778   0717 3E 00                       LD A, 0
0779   0719 32 03 E0                    LD (LCD_TXT_X), A
0780   071C 32 04 E0                    LD (LCD_TXT_Y), A
0781   071F             
0782   071F C3 23 08                    JP print_char_fim
0783   0722             
0784   0722             ver_line:
0785   0722 FE 0A                       CP      LF                     ; retorna começo da linha
0786   0724 20 03                       jr      NZ, print_lcd      
0787   0726             
0788   0726                                 ;----- verificar se precisa add algo aqui
0789   0726                             ;call    shift_lcd_up
0790   0726                             ;call    show_lcd_screen
0791   0726 C3 23 08                    JP print_char_fim
0792   0729             
0793   0729             print_lcd:
0794   0729                 ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
0795   0729 26 00           ld H, 0
0796   072B 6F              ld L, A
0797   072C 29              ADD HL, HL ; hl x 8
0798   072D 29              ADD HL, HL
0799   072E 29              ADD HL, HL
0800   072F             
0801   072F 54              LD D, H
0802   0730 5D              LD E, L
0803   0731 21 6B 00        ld hl, TABLE
0804   0734 19              add hl, de
0805   0735 22 01 E0        ld (LCD_CHAR_POINT), HL ; table
0806   0738             
0807   0738             
0808   0738                 ; ajusta X
0809   0738 06 06           ld b, 6
0810   073A 3A 03 E0        ld a, (LCD_TXT_X)
0811   073D B7              or A
0812   073E CA 48 07        jp z, ajustX
0813   0741 4F              ld c, a
0814   0742 CD 28 08        call multiplication
0815   0745 C3 4B 07        jp ajustXOK
0816   0748                 
0817   0748             ajustX:
0818   0748 21 00 00        ld hl, 0
0819   074B             ajustXOK:
0820   074B 22 08 E0        ld (LCD_TXT_X_TMP), HL 
0821   074E             
0822   074E             
0823   074E             
0824   074E                 ; ajuste Y
0825   074E 16 04           ld d, 4
0826   0750 1E 00           ld e, 0 ; = 128x8 proxima linha
0827   0752 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
0828   0755 3A 04 E0        ld a, (LCD_TXT_Y)
0829   0758 B7              or a
0830   0759 CA 69 07        JP Z, multYfim
0831   075C 21 00 00        ld hl, 0
0832   075F 47              ld b, a
0833   0760             multY:
0834   0760 19              add hl, de
0835   0761 10 FD           DJNZ multY
0836   0763             
0837   0763 22 0A E0        ld (LCD_TXT_Y_TMP), HL
0838   0766 C3 6F 07        jp multYfimok
0839   0769             
0840   0769             multYfim:
0841   0769 21 00 00        ld hl, 0
0842   076C 22 0A E0        ld (LCD_TXT_Y_TMP), HL
0843   076F             
0844   076F             multYfimok:
0845   076F             
0846   076F 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
0847   0772 ED 5B 08 E0     ld de, (LCD_TXT_X_TMP)
0848   0776             
0849   0776 19              add hl, de  ; hl tem pos do pix 0-8191
0850   0777             
0851   0777 22 0E E0        ld (LCD_TMP_POINT), hl
0852   077A             
0853   077A             
0854   077A 3E 08           ld a, 8 ; altura do caracter
0855   077C 32 0C E0        ld (LCD_CHAR_H), a
0856   077F             printchar_loopH:
0857   077F 2A 01 E0        ld hl, (LCD_CHAR_POINT)
0858   0782 7E              ld a, (HL)
0859   0783 32 10 E1        ld (LCD_TEMP), a
0860   0786             
0861   0786 3E 06           ld a, 6 ; largura do caracter
0862   0788 32 0D E0        ld (LCD_CHAR_W), a
0863   078B             printchar_loopW:
0864   078B 3A 10 E1        ld a, (LCD_TEMP)
0865   078E E6 80           and 128
0866   0790 FE 00           cp 0
0867   0792 CA 9E 07        jp z, printchar_loopWC
0868   0795 2A 0E E0        ld hl, (LCD_TMP_POINT)
0869   0798 CD 63 08        call lcd_setPixel
0870   079B C3 A4 07        JP printchar_loopWE
0871   079E             
0872   079E             printchar_loopWC:
0873   079E 2A 0E E0        ld hl, (LCD_TMP_POINT)
0874   07A1 CD 9C 08        call lcd_clearPixel
0875   07A4             
0876   07A4             printchar_loopWE:
0877   07A4 3A 10 E1        ld a, (LCD_TEMP)
0878   07A7 CB 27           sla a
0879   07A9 32 10 E1        ld (LCD_TEMP), a
0880   07AC                 
0881   07AC 2A 0E E0        ld hl, (LCD_TMP_POINT)
0882   07AF 23              inc hl
0883   07B0 22 0E E0        ld (LCD_TMP_POINT), hl
0884   07B3             
0885   07B3 3A 0D E0        ld a, (LCD_CHAR_W)
0886   07B6 3D              dec A
0887   07B7 32 0D E0        ld (LCD_CHAR_W), a
0888   07BA FE 00           cp 0
0889   07BC C2 8B 07        JP NZ, printchar_loopW
0890   07BF             
0891   07BF             
0892   07BF 2A 0E E0        ld hl, (LCD_TMP_POINT)
0893   07C2 2B              dec hl
0894   07C3 2B              dec hl
0895   07C4 2B              dec hl
0896   07C5 2B              dec hl
0897   07C6 2B              dec hl
0898   07C7 2B              dec hl
0899   07C8             
0900   07C8 16 00           ld d, 0
0901   07CA 1E 80           ld e, 128
0902   07CC 19              add hl, de
0903   07CD 22 0E E0        ld (LCD_TMP_POINT), HL
0904   07D0             
0905   07D0 2A 01 E0        ld hl, (LCD_CHAR_POINT)
0906   07D3 23              inc hl
0907   07D4 22 01 E0        ld (LCD_CHAR_POINT), hl
0908   07D7             
0909   07D7             
0910   07D7 3A 0C E0        ld a, (LCD_CHAR_H)
0911   07DA 3D              dec A
0912   07DB 32 0C E0        ld (LCD_CHAR_H), a
0913   07DE FE 00           cp 0
0914   07E0 C2 7F 07        jp NZ, printchar_loopH
0915   07E3             
0916   07E3 21 00 E5        ld hl, DISPLAY
0917   07E6 CD FF 08        call print_image
0918   07E9             
0919   07E9             
0920   07E9                 ; check auto x
0921   07E9 3A 10 E0        LD A, (LCD_AUTO_X)
0922   07EC B7              OR A
0923   07ED FE FF           CP $FF
0924   07EF CA 23 08        JP Z, print_char_fim
0925   07F2             
0926   07F2                 ; increment X, Y
0927   07F2 3A 03 E0        ld a, (LCD_TXT_X)
0928   07F5 3C              inc a
0929   07F6 FE 15           cp 21
0930   07F8 C2 20 08        jp nz, incXOK
0931   07FB 3E 00           ld a, 0
0932   07FD 32 03 E0        ld (LCD_TXT_X), a
0933   0800 3A 04 E0        ld a, (LCD_TXT_Y)
0934   0803 3C              inc a
0935   0804 FE 08           cp 8
0936   0806 C2 1A 08        jp nz, incYOK
0937   0809 CD 4A 06        CALL DISPLAY_SCROLL_UP
0938   080C 21 00 E5        ld hl, DISPLAY
0939   080F CD FF 08        CALL print_image
0940   0812 3E 00           ld a, 0
0941   0814 32 03 E0        ld (LCD_TXT_X), a
0942   0817 C3 23 08        jp print_char_fim
0943   081A             
0944   081A             incYOK:
0945   081A 32 04 E0        ld (LCD_TXT_Y), a
0946   081D C3 23 08        jp print_char_fim
0947   0820             
0948   0820             incXOK:
0949   0820 32 03 E0        ld (LCD_TXT_X), a
0950   0823             
0951   0823             print_char_fim:
0952   0823 E1              POP HL
0953   0824 D1              POP DE
0954   0825 C1              POP BC
0955   0826 F1              POP AF
0956   0827 C9              RET
0957   0828             ;-------- FIM PRINTCHAR ------------------
0958   0828             
0959   0828             
0960   0828             
0961   0828             ; ----------------------------------
0962   0828             
0963   0828             ; INPUT: THE VALUES IN REGISTER B EN C
0964   0828             ; OUTPUT: HL = B * C
0965   0828             ; CHANGES: AF,DE,HL,B
0966   0828             ;
0967   0828             multiplication:
0968   0828 21 00 00    	LD HL,0
0969   082B 78          	LD A,B
0970   082C B7          	OR A
0971   082D C8          	RET Z
0972   082E 16 00       	LD D,0
0973   0830 59          	LD E,C
0974   0831 19          multiplicationLOOP:	ADD HL,DE
0975   0832 10 FD       	DJNZ multiplicationLOOP
0976   0834 C9          	RET 
0977   0835             
0978   0835             ;-----------------------------------
0979   0835             
0980   0835             Div_HL_D:
0981   0835             ;Inputs:
0982   0835             ;   HL and D
0983   0835             ;Outputs:
0984   0835             ;   HL is the quotient (HL/D)
0985   0835             ;   A is the remainder
0986   0835             ;   B is 0
0987   0835             ;   C,D,E are preserved
0988   0835 AF              xor a         ; Clear upper eight bits of AHL
0989   0836 06 10           ld b,16       ; Sixteen bits in dividend
0990   0838             _loop:
0991   0838 29              add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
0992   0839 17              rla           ; This moves the upper bits of the dividend into A
0993   083A 38 03           jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
0994   083C BA              cp d          ; Check if we can subtract the divisor
0995   083D 38 02           jr c,_skip    ; Carry means A < D
0996   083F             _overflow:
0997   083F 92              sub d         ; Do subtraction for real this time
0998   0840 2C              inc l         ; Set the next bit of the quotient (currently bit 0)
0999   0841             _skip:
1000   0841 10 F5           djnz _loop
1001   0843 C9              ret
1002   0844             
1003   0844             
1004   0844             ; -----------------------------------------------------------------------------
1005   0844             ;   LCD DRIVER
1006   0844             ; -----------------------------------------------------------------------------
1007   0844             ; INIT_LCD - Inicia o lcd em mode texto
1008   0844             ; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
1009   0844             ; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
1010   0844             ; lcd_clear - Limpa buffer do lcd
1011   0844             ; enable_grafic - Coloca o LCD em modo grafico
1012   0844             ; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
1013   0844             ; cls_TXT - Limpa LCD mode text
1014   0844             ; cls_GRAPHIC - Limpa LCD modo grafico
1015   0844             
1016   0844             INIT_LCD:
1017   0844                 ;Initialisation
1018   0844 3E 30       	ld a, 30H
1019   0846 CD 88 09    	call lcd_send_command
1020   0849             
1021   0849 3E A0       	ld a, 0b00100000
1022   084B CD 88 09    	call lcd_send_command
1023   084E             
1024   084E 3E 30       	ld a, 30H
1025   0850 CD 88 09    	call lcd_send_command
1026   0853             
1027   0853 3E 0C       	ld a, 0CH
1028   0855 CD 88 09    	call lcd_send_command
1029   0858             
1030   0858 3E 01       	ld a, 01H
1031   085A CD 88 09    	call lcd_send_command
1032   085D             
1033   085D 3E 02       	ld a, 02H
1034   085F CD 88 09    	call lcd_send_command
1035   0862 C9              RET
1036   0863             
1037   0863             
1038   0863             ; pixel index in HL
1039   0863             lcd_setPixel:
1040   0863 E5              push hl
1041   0864 C5              push bc
1042   0865 D5              push de
1043   0866 F5              push af
1044   0867 AF              xor A
1045   0868 32 07 E0        ld (LCD_BIT_INDEX), A
1046   086B 32 05 E0        ld (LCD_BYTE_INDEX), A
1047   086E             
1048   086E 16 08           ld d, 8
1049   0870 CD 35 08        call Div_HL_D
1050   0873 32 07 E0        ld (LCD_BIT_INDEX), A
1051   0876 22 05 E0        ld (LCD_BYTE_INDEX), HL
1052   0879 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1053   087D 21 00 E5        ld hl, DISPLAY
1054   0880 09              add hl, bc
1055   0881                 
1056   0881 06 80           ld b, 128 ; 1000 0000
1057   0883 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1058   0886 FE 00           cp 0
1059   0888 CA 94 08        jp z, lcd_setPixel_fim
1060   088B             lcd_setPixel_bit:
1061   088B CB 38           srl B
1062   088D 3D              dec A
1063   088E CA 94 08        jp z, lcd_setPixel_fim
1064   0891                 
1065   0891 C3 8B 08        jp lcd_setPixel_bit
1066   0894             lcd_setPixel_fim
1067   0894 7E              ld a, (hl)
1068   0895 B0              or b
1069   0896 77              ld (hl), a
1070   0897             
1071   0897 F1              pop af
1072   0898 C1              pop bc
1073   0899 D1              pop de
1074   089A E1              pop hl
1075   089B C9              ret
1076   089C             
1077   089C             ;===============================
1078   089C             ; pixel index in HL
1079   089C             lcd_clearPixel:
1080   089C E5              push hl
1081   089D C5              push bc
1082   089E D5              push de
1083   089F F5              push af
1084   08A0 AF              xor A
1085   08A1 32 07 E0        ld (LCD_BIT_INDEX), A
1086   08A4 32 05 E0        ld (LCD_BYTE_INDEX), A
1087   08A7 16 08           ld d, 8
1088   08A9 CD 35 08        call Div_HL_D
1089   08AC 32 07 E0        ld (LCD_BIT_INDEX), A
1090   08AF 22 05 E0        ld (LCD_BYTE_INDEX), HL
1091   08B2 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1092   08B6 21 00 E5        ld hl, DISPLAY
1093   08B9 09              add hl, bc
1094   08BA                 
1095   08BA 06 80           ld b, 128 ; 1000 0000
1096   08BC 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1097   08BF FE 00           cp 0
1098   08C1 CA CD 08        jp z, lcd_clearPixel_fim
1099   08C4             lcd_clearPixel_bit:
1100   08C4 CB 38           srl B
1101   08C6 3D              dec A
1102   08C7 CA CD 08        jp z, lcd_clearPixel_fim
1103   08CA                 
1104   08CA C3 C4 08        jp lcd_clearPixel_bit
1105   08CD             lcd_clearPixel_fim
1106   08CD 78              ld a, b
1107   08CE 2F              cpl     ; NOT B
1108   08CF 47              ld b, a
1109   08D0             
1110   08D0 7E              ld a, (hl)
1111   08D1 A0              and b
1112   08D2 77              ld (hl), a
1113   08D3             
1114   08D3 F1              pop af
1115   08D4 C1              pop bc
1116   08D5 D1              pop de
1117   08D6 E1              pop hl
1118   08D7 C9              ret
1119   08D8             
1120   08D8             
1121   08D8             ;;--------------------------------------------------
1122   08D8             lcd_clear:
1123   08D8                 ;; HL = start address of block
1124   08D8 21 00 E5        ld hl, DISPLAY
1125   08DB             
1126   08DB                 ;; DE = HL + 1
1127   08DB 5D              ld e,l
1128   08DC 54              ld d,h
1129   08DD 13              inc de
1130   08DE             
1131   08DE                 ;; initialise first byte of block
1132   08DE                 ;; with data byte (&00)
1133   08DE 36 00           ld (hl), 0
1134   08E0                     
1135   08E0                 ;; BC = length of block in bytes
1136   08E0                 ;; HL+BC-1 = end address of block
1137   08E0             
1138   08E0 01 00 04        ld bc, 1024
1139   08E3             
1140   08E3                 ;; fill memory
1141   08E3 ED B0           ldir
1142   08E5 C9              ret
1143   08E6             
1144   08E6             
1145   08E6             ;===================
1146   08E6             
1147   08E6             ; grafic mode - enable
1148   08E6             enable_grafic:
1149   08E6 3E 30       	ld a, 30H
1150   08E8 CD 88 09    	call lcd_send_command
1151   08EB CD B3 09    	call delayLCD
1152   08EE             	
1153   08EE 3E 34       	ld a, 34H
1154   08F0 CD 88 09    	call lcd_send_command
1155   08F3 CD B3 09    	call delayLCD
1156   08F6             	
1157   08F6 3E 36       	ld a, 36H
1158   08F8 CD 88 09    	call lcd_send_command
1159   08FB CD B3 09    	call delayLCD
1160   08FE C9              ret
1161   08FF             
1162   08FF             
1163   08FF             ;==========================
1164   08FF             
1165   08FF             print_image:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
1166   08FF             									; HL content the data address
1167   08FF F5              push af
1168   0900 D5          	push de
1169   0901 C5          	push bc
1170   0902             
1171   0902             
1172   0902             ; premiere partie : X de 0 à 127 / Y de 0 à 32
1173   0902             
1174   0902 3E 20       	ld a,32
1175   0904 57          	ld d,a							; boucle Y
1176   0905 3E 00       	ld a,0
1177   0907 5F          	ld e,a
1178   0908             	
1179   0908             boucle_colonne:
1180   0908 3E 80       		ld a,$80					; coordonnée Y (0)
1181   090A 83          		add a,e
1182   090B CD 88 09    		call lcd_send_command
1183   090E             		
1184   090E 3E 80       		ld a,$80					; coordonnée X (0)		
1185   0910 CD 88 09    		call lcd_send_command
1186   0913             		
1187   0913 3E 08       		ld a,8
1188   0915 47          		ld b,a						; boucle X
1189   0916             		
1190   0916             boucle_ligne:	
1191   0916 7E          			ld a,(hl)
1192   0917 CD 92 09    			call lcd_send_data
1193   091A 23          			inc hl
1194   091B 7E          			ld a,(hl)
1195   091C CD 92 09    			call lcd_send_data		; auto-increment on screen address
1196   091F 23          			inc hl
1197   0920 05          			dec b
1198   0921 AF          			XOR a
1199   0922 B0          			OR b
1200   0923 C2 16 09    			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
1201   0926             		
1202   0926 15          		dec d
1203   0927 1C          		inc e
1204   0928 AF          		XOR a
1205   0929 B2          		OR d
1206   092A C2 08 09    		jp nz,boucle_colonne
1207   092D             		
1208   092D             
1209   092D             ; seconde partie : X de 128 à 255 / Y de 0 à 32
1210   092D             
1211   092D 3E 20       	ld a,32
1212   092F 57          	ld d,a							; boucle Y
1213   0930 3E 00       	ld a,0
1214   0932 5F          	ld e,a
1215   0933             	
1216   0933             boucle_colonne2:
1217   0933 3E 80       		ld a,$80					; coordonnée Y (0)
1218   0935 83          		add a, e
1219   0936 CD 88 09    		call lcd_send_command
1220   0939             		
1221   0939 3E 88       		ld a,$88					; coordonnée X (8)		
1222   093B CD 88 09    		call lcd_send_command
1223   093E             		
1224   093E 3E 08       		ld a,8
1225   0940 47          		ld b,a						; boucle X
1226   0941             		
1227   0941             boucle_ligne2:	
1228   0941 7E          			ld a,(hl)
1229   0942 CD 92 09    			call lcd_send_data
1230   0945 23          			inc hl
1231   0946 7E          			ld a,(hl)
1232   0947 CD 92 09    			call lcd_send_data		; auto-increment on screen address
1233   094A 23          			inc hl
1234   094B 05          			dec b
1235   094C AF          			XOR a
1236   094D B0          			OR b
1237   094E C2 41 09    			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
1238   0951             		
1239   0951 15          		dec d
1240   0952 1C          		inc e
1241   0953 AF          		XOR a
1242   0954 B2          		OR d
1243   0955 C2 33 09    		jp nz,boucle_colonne2
1244   0958             
1245   0958 C1          	pop bc
1246   0959 D1          	pop de
1247   095A F1              pop af
1248   095B             
1249   095B C9              ret
1250   095C             
1251   095C             
1252   095C             
1253   095C             ; ======================
1254   095C             cls_TXT:
1255   095C             	; # CLEAR DISPLAY IN TEXT MODE # 
1256   095C 3E 01       	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
1257   095E CD 88 09    	call lcd_send_command		; CLEAR DISPLAY	
1258   0961 C9              ret
1259   0962             
1260   0962             ; ========================
1261   0962             
1262   0962             cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
1263   0962             					;	Graphic RAM (GDRAM) use :
1264   0962             					;	1. Set vertical address (Y) for GDRAM
1265   0962             					;	2. Set horizontal address (X) for GDRAM
1266   0962             					;	3. Write D15~D8 to GDRAM (first byte)
1267   0962             					;	4. Write D7~D0 to GDRAM (second byte)
1268   0962 C5          	push bc
1269   0963 D5          	push de
1270   0964             
1271   0964 1E 20       	ld e,$20						; e = 32 
1272   0966 16 00       	ld d,$0							; d = 0
1273   0968             Boucle32X:
1274   0968 7A          		ld a,d
1275   0969 F6 80       		OR $80
1276   096B CD 88 09    		call lcd_send_command
1277   096E             		
1278   096E 3E 80       		ld a,$80					; Set horizontal address（X） for GDRAM = 0 ($80)
1279   0970 CD 88 09    		call lcd_send_command
1280   0973             		
1281   0973 AF          		xor a							 	
1282   0974 06 10       		ld b,$10							; b = 17
1283   0976             		
1284   0976             Boucle16X:	 
1285   0976 CD 92 09    			call lcd_send_data 			; Write D15〜D8 to GDRAM (first byte)
1286   0979 CD 92 09    			call lcd_send_data 			; Write D7〜D0 to GDRAM (second byte)
1287   097C             											; Address counter will automatically increase by one for the next two-byte data												
1288   097C 10 F8       			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
1289   097E             		
1290   097E 1D          		dec e 
1291   097F 14          		inc d
1292   0980 AF          		xor a							; a = 0
1293   0981 B3          		or e
1294   0982 C2 68 09    		jp nz,Boucle32X
1295   0985             
1296   0985 D1          	pop de
1297   0986 C1          	pop bc
1298   0987             	
1299   0987 C9              ret
1300   0988             
1301   0988             
1302   0988             
1303   0988             
1304   0988             ;******************
1305   0988             ;Send a command byte to the LCD
1306   0988             ;Entry: A= command byte
1307   0988             ;Exit: All preserved
1308   0988             ;******************
1309   0988             lcd_send_command:
1310   0988 C5          	push bc				;Preserve
1311   0989 0E 70       	ld c, LCDCTRL   	;Command port
1312   098B             	
1313   098B             lcd_command_wait_loop:	;Busy wait
1314   098B CD B3 09    	call delayLCD
1315   098E             	
1316   098E ED 79       	out (c),a			;Send command
1317   0990 C1          	pop bc				;Restore
1318   0991 C9          	ret
1319   0992             	
1320   0992             ;******************
1321   0992             ;Send a data byte to the LCD
1322   0992             ;Entry: A= data byte
1323   0992             ;Exit: All preserved
1324   0992             ;******************
1325   0992             lcd_send_data:
1326   0992 C5          	push bc				;Preserve
1327   0993 0E 70       	ld c, LCDCTRL	    ;Command port
1328   0995             	
1329   0995                 ;Busy wait
1330   0995 CD B3 09    	call delayLCD
1331   0998             	
1332   0998 0E 71       	ld c, LCDDATA	;Data port
1333   099A ED 79       	out (c),a			;Send data
1334   099C C1          	pop bc				;Restore
1335   099D C9          	ret
1336   099E             
1337   099E             ;******************
1338   099E             ;Send an asciiz string to the LCD
1339   099E             ;Entry: HL=address of string
1340   099E             ;Exit: HL=address of ending zero of the string. All others preserved
1341   099E             ;******************
1342   099E             lcd_send_asciiz:
1343   099E F5          	push af
1344   099F C5          	push bc				;Preserve
1345   09A0             lcd_asciiz_char_loop:
1346   09A0 0E 70       	ld c, LCDCTRL   	;Command port
1347   09A2             	
1348   09A2             lcd_asciiz_wait_loop:	;Busy wait
1349   09A2 CD B3 09    	call delayLCD
1350   09A5             	
1351   09A5 7E          	ld a,(hl)			;Get character
1352   09A6 A7          	and a				;Is it zero?
1353   09A7 28 07       	jr z,lcd_asciiz_done	;If so, we're done
1354   09A9             	
1355   09A9 0E 71       	ld c, LCDDATA	;Data port
1356   09AB ED 79       	out (c),a			;Send data
1357   09AD 23          	inc hl				;Next char
1358   09AE 18 F0       	jr lcd_asciiz_char_loop
1359   09B0             	
1360   09B0             lcd_asciiz_done:
1361   09B0 C1          	pop bc				;Restore
1362   09B1 F1          	pop af
1363   09B2 C9          	ret
1364   09B3             
1365   09B3             ; =========================================================
1366   09B3             ; Delay LCD
1367   09B3             ; =========================================================
1368   09B3             delayLCD:
1369   09B3             
1370   09B3 00          	NOP
1371   09B4 00          	NOP
1372   09B5 00          	NOP
1373   09B6 00          	NOP
1374   09B7 00          	NOP
1375   09B8 00          	NOP
1376   09B9 00          	NOP
1377   09BA 00          	NOP
1378   09BB 00          	NOP
1379   09BC 00          	NOP
1380   09BD 00          	NOP ; KO
1381   09BE 00          	NOP
1382   09BF 00              NOP
1383   09C0 C9              ret
1384   09C1             
1385   09C1             	
1386   09C1             ; =========================================================
1387   09C1             ; Delay
1388   09C1             ; =========================================================
1389   09C1             delay:
1390   09C1 C5          	push bc                       ; 2.75 us
1391   09C2 06 FF           ld b, 255                     ; 1.75 us
1392   09C4             delay_loop_b:
1393   09C4 0E FF       	ld c, 255                     ; 1.75 us
1394   09C6             delay_loop:
1395   09C6 0D          	dec c                         ; 1 us
1396   09C7 C2 C6 09        jp nz, delay_loop             ; true = 3 us, false 1.75 us
1397   09CA 05              dec b                         ; 1 us
1398   09CB C2 C4 09        jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
1399   09CE C1              pop bc                        ; 2.50 us
1400   09CF C9              ret   
1401   09D0             
1402   09D0             
1403   09D0             ; Check break key
1404   09D0 3E 40       CHKKEY: LD  A, $40
1405   09D2 D3 40       	OUT (KEY_OUT), A ; line 4
1406   09D4 DB 40       	IN  A, (KEY_IN)
1407   09D6 FE 01       	CP  1
1408   09D8 C2 E0 09    	JP  NZ, GRET
1409   09DB 3E 03       	LD  A, CTRLC
1410   09DD FE 00       	CP	0
1411   09DF C9          	RET
1412   09E0             GRET:
1413   09E0 3E 00       	LD  A, 0
1414   09E2 FE 00       	CP 0
1415   09E4 C9          	RET
1416   09E5             
1417   09E5             
1418   09E5             
1419   09E5             
1420   09E5             ; -----------------------------------------------------------------------------
1421   09E5             ;   KEYREAD - KEY In A
1422   09E5             ; -----------------------------------------------------------------------------
1423   09E5             KEYREADINIT:
1424   09E5 C5              PUSH    BC
1425   09E6 D5          	PUSH	DE
1426   09E7 E5          	PUSH    HL
1427   09E8 1E 00       	LD      E, 0                    ; E will be the last pressed key
1428   09EA             READKEY:        
1429   09EA 26 01           LD      H, 1                    ; H is the line register, start with second
1430   09EC 06 00       	LD      B, 0                    ; Count lines for later multiplication	
1431   09EE 16 00       	LD      D, 0                    ; DE will be the adress for mask
1432   09F0             						
1433   09F0             NEXTKEY:        
1434   09F0 7C              LD      A, H						
1435   09F1 FE 00           CP      0                       ; All lines tried? 
1436   09F3 CA 2E 0A        JP      Z, KEYOUT               ; Then check if there was a key pressed
1437   09F6 D3 40       	OUT     (KEY_OUT), A		    ; Put current line to register
1438   09F8 DB 40       	IN      A, (KEY_IN)		        ; Input Keys
1439   09FA E6 1F       	AND     $1F                     ; only 5 bits
1440   09FC CB 24       	SLA     H                       ; Next line
1441   09FE 04              INC     B
1442   09FF FE 00           CP      0                       ; Was key zero?
1443   0A01 CA F0 09        JP      Z, NEXTKEY              ; Then try again with next lines
1444   0A04 16 00           LD      D, 0                    ; In D will be the number of the key
1445   0A06             LOGARITHM:      
1446   0A06 14              INC     D	                    ; Add one per shift
1447   0A07 CB 3F           SRL     A                       ; Shift key right
1448   0A09 C2 06 0A        JP      NZ, LOGARITHM		    ; If not zero shift again
1449   0A0C 15              DEC     D                       ; Was too much
1450   0A0D DB 40       	IN      A, (KEY_IN)
1451   0A0F E6 80           AND     $80                     ; Check if first bit set (shift key pressed)
1452   0A11 C2 1A 0A        JP      NZ, LOADSHIFT		    ; Then jump to read with shift
1453   0A14 7A              LD      A, D                    ; Put read key into accu
1454   0A15 C6 1B           ADD     A, KEYMAP               ; Add base of key map array
1455   0A17 C3 1D 0A        JP      ADDOFFSET               ; Jump to load key
1456   0A1A             LOADSHIFT:
1457   0A1A 7A              LD      A, D
1458   0A1B C6 43           ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
1459   0A1D             ADDOFFSET:
1460   0A1D C6 05           ADD     A, 5                    ; Add 5 for every line
1461   0A1F 10 FC           DJNZ    ADDOFFSET               ; Jump back (do while loop)
1462   0A21 D6 05       	SUB     5                       ; Since do while is one too much
1463   0A23             TRANSKEY:
1464   0A23 A8              XOR     B                       ; Empty B
1465   0A24 4F          	LD      C, A                    ; A will be address in BC
1466   0A25 0A          	LD      A, (BC)	                ; Load key
1467   0A26 BB          	CP      E                       ; Same key?
1468   0A27 CA EA 09    	JP      Z, READKEY              ; Then from beginning
1469   0A2A 5F          	LD      E, A                    ; Otherwise save new key
1470   0A2B C3 EA 09    	JP      READKEY	                ; And restart
1471   0A2E             KEYOUT:
1472   0A2E 7B              LD      A, E
1473   0A2F 1E 00           LD      E, 0                    ; empty it
1474   0A31 B7              OR      A	                    ; Was a key read?
1475   0A32 CA EA 09        JP      Z, READKEY              ; If not restart
1476   0A35 E1              POP     HL
1477   0A36 D1              POP     DE
1478   0A37 C1              POP     BC
1479   0A38 C9              RET
1480   0A39             
1481   0A39             
1482   0A39             ;-----------------------
1483   0A39             ; RECEIVE INTEL HEX FILE
1484   0A39             ;-----------------------       
1485   0A39             INTHEX: 
1486   0A39 21 A8 0D           LD HL, MSG_ILOAD
1487   0A3C CD EC 0A           CALL  SNDLCDMSG
1488   0A3F             
1489   0A3F 21 A8 0D           LD HL, MSG_ILOAD
1490   0A42 CD FA 0A           CALL  SNDMSG
1491   0A45                    
1492   0A45             
1493   0A45 CD 64 0A           CALL  INTELH
1494   0A48 20 0D              JR    NZ,ITHEX1      
1495   0A4A             
1496   0A4A 21 BE 0D           LD    HL,FILEOK
1497   0A4D CD EC 0A           CALL  SNDLCDMSG   ;GOT FILE OK LCD
1498   0A50 21 BE 0D           LD    HL,FILEOK
1499   0A53 CD FA 0A           CALL  SNDMSG      ;GOT FILE OK Serial
1500   0A56                    
1501   0A56 C9                 RET
1502   0A57 21 D0 0D    ITHEX1: LD    HL,CSUMERR
1503   0A5A CD EC 0A           CALL  SNDLCDMSG
1504   0A5D             
1505   0A5D 21 D0 0D           LD    HL,CSUMERR
1506   0A60 CD FA 0A           CALL  SNDMSG      ;CHECKSUM ERROR
1507   0A63                    
1508   0A63 C9                 RET  
1509   0A64             
1510   0A64             
1511   0A64             
1512   0A64             
1513   0A64             
1514   0A64             ;-----------------------
1515   0A64             ; RECEIVE INTEL HEX FILE
1516   0A64             ;-----------------------
1517   0A64 DD 21 00 FD INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
1518   0A68             ;
1519   0A68             ; WAIT FOR RECORD MARK
1520   0A68             ;
1521   0A68 AF          INTEL1:	XOR	A
1522   0A69 DD 77 03    	LD	(IX+3),A	;CLEAR CHECKSUM
1523   0A6C CD 3F 0B    	CALL	RXDATA	;WAIT FOR THE RECORD MARK
1524   0A6F FE 3A       	CP	':'	;TO BE TRANSMITTED
1525   0A71 20 F5       	JR	NZ,INTEL1	;NOT RECORD MARK
1526   0A73             ;
1527   0A73             ; GET RECORD LENGTH
1528   0A73             ;
1529   0A73 CD C0 0A    	CALL	GETBYT
1530   0A76 DD 77 00    	LD	(IX+0),A	;NUMBER OF DATA BYTES
1531   0A79             ;
1532   0A79             ; GET ADDRESS FIELD
1533   0A79             ;
1534   0A79 CD C0 0A    	CALL	GETBYT
1535   0A7C DD 77 02    	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
1536   0A7F CD C0 0A    	CALL	GETBYT
1537   0A82 DD 77 01    	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
1538   0A85             ;
1539   0A85             ; GET RECORD TYPE
1540   0A85             ;
1541   0A85 CD C0 0A    	CALL	GETBYT
1542   0A88 20 24       	JR	NZ,INTEL4	;END OF FILE RECORD
1543   0A8A             ;
1544   0A8A             ; READ IN THE DATA
1545   0A8A             ;
1546   0A8A DD 46 00    	LD	B,(IX+0)	;NUMBER OF DATA BYTES
1547   0A8D DD 66 02    	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
1548   0A90 DD 6E 01    	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
1549   0A93             
1550   0A93 CD C0 0A    INTEL2:	CALL	GETBYT	;GET DATA BYTE
1551   0A96 77          	LD	(HL),A	;STORE DATA BYTE
1552   0A97 23          	INC	HL
1553   0A98 10 F9       	DJNZ	INTEL2	;LOAD MORE BYTES
1554   0A9A             ;
1555   0A9A             ; GET CHECKSUM AND COMPARE
1556   0A9A             ;
1557   0A9A DD 7E 03    	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1558   0A9D ED 44       	NEG		;TWO'S COMPLEMENT
1559   0A9F DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
1560   0AA2 CD C0 0A    	CALL	GETBYT
1561   0AA5 DD 77 03    	LD	(IX+3),A	;SAVE RECORD CHECKSUM
1562   0AA8 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
1563   0AAB 28 BB       	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
1564   0AAD C9              RET             ;NZ=CHECKSUM ERROR
1565   0AAE             ;
1566   0AAE             ; END OF FILE RECORD
1567   0AAE             ;
1568   0AAE DD 7E 03    INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
1569   0AB1 ED 44       	NEG		;TWO'S COMPLEMENT
1570   0AB3 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
1571   0AB6 CD C0 0A    	CALL	GETBYT
1572   0AB9 DD 77 03    	LD	(IX+3),A	;SAVE EOF CHECKSUM
1573   0ABC DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
1574   0ABF C9          	RET  	    ;NZ=CHECKSUM ERROR
1575   0AC0             ;--------------------------
1576   0AC0             ; GET BYTE FROM SERIAL PORT
1577   0AC0             ;--------------------------
1578   0AC0 C5          GETBYT:	PUSH	BC
1579   0AC1 CD 3F 0B    	CALL	RXDATA
1580   0AC4 CB 77       	BIT	6,A
1581   0AC6 28 02       	JR	Z,GETBT1
1582   0AC8 C6 09       	ADD	A,09H
1583   0ACA E6 0F       GETBT1:	AND	0FH
1584   0ACC CB 27       	SLA 	A
1585   0ACE CB 27       	SLA	A
1586   0AD0 CB 27       	SLA	A
1587   0AD2 CB 27       	SLA	A
1588   0AD4 4F          	LD	C,A
1589   0AD5             ;
1590   0AD5             ; GET LOW NYBBLE
1591   0AD5             ;
1592   0AD5 CD 3F 0B    	CALL	RXDATA
1593   0AD8 CB 77       	BIT	6,A
1594   0ADA 28 02       	JR	Z,GETBT2
1595   0ADC C6 09       	ADD	A,09H
1596   0ADE E6 0F       GETBT2:	AND	0FH
1597   0AE0 B1          	OR	C
1598   0AE1 47          	LD	B,A
1599   0AE2 DD 86 03    	ADD	A,(IX+3)
1600   0AE5 DD 77 03    	LD	(IX+3),A	;ADD TO CHECKSUM
1601   0AE8 78          	LD	A,B
1602   0AE9 A7          	AND	A	;CLEAR CARRY
1603   0AEA C1              POP	BC
1604   0AEB C9          	RET
1605   0AEC             
1606   0AEC             ;-----------------------------------------
1607   0AEC             ; SEND AN ASCII STRING OUT LCD
1608   0AEC             ;-----------------------------------------
1609   0AEC             ; 
1610   0AEC             ; SENDS A ZERO TERMINATED STRING OR 
1611   0AEC             ; 128 CHARACTERS MAX. OUT LCD
1612   0AEC             ;
1613   0AEC             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
1614   0AEC             ;      EXIT  : NONE
1615   0AEC             ;
1616   0AEC             ;       MODIFIES : A,B,C
1617   0AEC             ;          
1618   0AEC 06 80       SNDLCDMSG: LD    B,128         ;128 CHARS MAX
1619   0AEE 7E          SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
1620   0AEF FE 00              CP    00H          ;ZERO TERMINATOR?
1621   0AF1 28 06              JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
1622   0AF3 CD C0 06           CALL PRINTCHAR         ;TRANSMIT THE CHAR
1623   0AF6 23                 INC   HL
1624   0AF7 10 F5              DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
1625   0AF9 C9          SDLCDMSG2: RET
1626   0AFA             
1627   0AFA             
1628   0AFA             ;-----------------------------------------
1629   0AFA             ; SEND AN ASCII STRING OUT THE SERIAL PORT
1630   0AFA             ;-----------------------------------------
1631   0AFA             ; 
1632   0AFA             ; SENDS A ZERO TERMINATED STRING OR 
1633   0AFA             ; 128 CHARACTERS MAX. OUT THE SERIAL PORT
1634   0AFA             ;
1635   0AFA             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
1636   0AFA             ;      EXIT  : NONE
1637   0AFA             ;
1638   0AFA             ;       MODIFIES : A,B,C
1639   0AFA             ;          
1640   0AFA 06 80       SNDMSG: LD    B,128         ;128 CHARS MAX
1641   0AFC 7E          SDMSG1: LD    A,(HL)        ;GET THE CHAR
1642   0AFD FE 00              CP    00H          ;ZERO TERMINATOR?
1643   0AFF 28 06              JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
1644   0B01 CD 08 0B           CALL  OUTCH         ;TRANSMIT THE CHAR
1645   0B04 23                 INC   HL
1646   0B05 10 F5              DJNZ  SDMSG1        ;128 CHARS MAX!    
1647   0B07 C9          SDMSG2: RET
1648   0B08             
1649   0B08             
1650   0B08             
1651   0B08             ;-----------------------------------
1652   0B08             ; OUTPUT A CHARACTER TO THE TERMINAL
1653   0B08             ;-----------------------------------       
1654   0B08 DD 2A AA FF OUTCH:  LD   IX,(PUTCH)
1655   0B0C DD E9              JP   (IX)
1656   0B0E             ;------------------------------------
1657   0B0E             ; INPUT A CHARACTER FROM THE TERMINAL
1658   0B0E             ;------------------------------------
1659   0B0E DD 2A AC FF INCH:  LD   IX,(GETCH)
1660   0B12 DD E9             JP   (IX)
1661   0B14             
1662   0B14             
1663   0B14             
1664   0B14             ;------------------------
1665   0B14             ; SERIAL TRANSMIT ROUTINE
1666   0B14             ;------------------------
1667   0B14             ;TRANSMIT BYTE SERIALLY ON DOUT
1668   0B14             ;
1669   0B14             ; ENTRY : A = BYTE TO TRANSMIT
1670   0B14             ;  EXIT : NO REGISTERS MODIFIED
1671   0B14             ;
1672   0B14 F5          TXDATA:	PUSH	AF
1673   0B15 C5          	PUSH	BC
1674   0B16 E5          	PUSH	HL
1675   0B17 2A C0 FF    	LD	HL,(BAUD)
1676   0B1A 4F          	LD	C,A
1677   0B1B             ;
1678   0B1B             ; TRANSMIT START BIT
1679   0B1B             ;
1680   0B1B AF          	XOR	A
1681   0B1C D3 C0       	OUT	(SERIAL_TX_PORT),A
1682   0B1E CD 6C 0B    	CALL	BITIME
1683   0B21             ;
1684   0B21             ; TRANSMIT DATA
1685   0B21             ;
1686   0B21 06 08       	LD	B,08H
1687   0B23 CB 09       	RRC	C
1688   0B25 CB 09       NXTBIT:	RRC	C	;SHIFT BITS TO D6,
1689   0B27 79          	LD	A,C	;LSB FIRST AND OUTPUT
1690   0B28 E6 40       	AND	40H	;THEM FOR ONE BIT TIME.
1691   0B2A D3 C0       	OUT	(SERIAL_TX_PORT),A
1692   0B2C CD 6C 0B    	CALL	BITIME
1693   0B2F 10 F4       	DJNZ	NXTBIT
1694   0B31             ;
1695   0B31             ; SEND STOP BITS
1696   0B31             ;
1697   0B31 3E 40       	LD	A,40H
1698   0B33 D3 C0       	OUT	(SERIAL_TX_PORT),A
1699   0B35 CD 6C 0B    	CALL	BITIME
1700   0B38 CD 6C 0B    	CALL	BITIME
1701   0B3B E1          	POP	HL
1702   0B3C C1          	POP	BC
1703   0B3D F1          	POP	AF
1704   0B3E C9          	RET
1705   0B3F             ;-----------------------
1706   0B3F             ; SERIAL RECEIVE ROUTINE
1707   0B3F             ;-----------------------
1708   0B3F             ;RECEIVE SERIAL BYTE FROM DIN
1709   0B3F             ;
1710   0B3F             ; ENTRY : NONE
1711   0B3F             ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
1712   0B3F             ;
1713   0B3F             ; REGISTERS MODIFIED A AND F
1714   0B3F             ;
1715   0B3F C5          RXDATA:	PUSH	BC
1716   0B40 E5          	PUSH	HL
1717   0B41             ;
1718   0B41             ; WAIT FOR START BIT 
1719   0B41             ;
1720   0B41 DB C0       RXDAT1: IN	A,(SERIAL_RX_PORT)
1721   0B43 CB 7F       	    BIT	7,A
1722   0B45 20 FA       	    JR	NZ,RXDAT1	;NO START BIT
1723   0B47             ;
1724   0B47             ; DETECTED START BIT
1725   0B47             ;
1726   0B47 2A C0 FF    	LD	HL,(BAUD)
1727   0B4A CB 3C       	SRL	H
1728   0B4C CB 1D       	RR	L 	;DELAY FOR HALF BIT TIME
1729   0B4E CD 6C 0B    	CALL 	BITIME
1730   0B51 DB C0       	IN	A,(SERIAL_RX_PORT)
1731   0B53 CB 7F       	BIT	7,A
1732   0B55 20 EA       	JR	NZ,RXDAT1	;START BIT NOT VALID
1733   0B57             ;
1734   0B57             ; DETECTED VALID START BIT,READ IN DATA
1735   0B57             ;
1736   0B57 06 08       	LD	B,08H
1737   0B59 2A C0 FF    RXDAT2:	LD	HL,(BAUD)
1738   0B5C CD 6C 0B    	CALL	BITIME	;DELAY ONE BIT TIME
1739   0B5F DB C0       	IN	A,(SERIAL_RX_PORT)
1740   0B61 CB 17       	RL	A
1741   0B63 CB 19       	RR	C	;SHIFT BIT INTO DATA REG
1742   0B65 10 F2       	DJNZ	RXDAT2
1743   0B67 79          	LD	A,C
1744   0B68 B7          	OR	A	;CLEAR CARRY FLAG
1745   0B69 E1              POP	HL
1746   0B6A C1          	POP	BC
1747   0B6B C9          	RET
1748   0B6C             ;---------------
1749   0B6C             ; BIT TIME DELAY
1750   0B6C             ;---------------
1751   0B6C             ;DELAY FOR ONE SERIAL BIT TIME
1752   0B6C             ;ENTRY : HL = DELAY TIME
1753   0B6C             ; NO REGISTERS MODIFIED
1754   0B6C             ;
1755   0B6C E5          BITIME:	PUSH	HL
1756   0B6D D5          	PUSH	DE
1757   0B6E 11 01 00    	LD	DE,0001H
1758   0B71 ED 52       BITIM1:	SBC	HL,DE
1759   0B73 D2 71 0B    	JP	NC,BITIM1
1760   0B76 D1          	POP	DE
1761   0B77 E1          	POP	HL
1762   0B78 C9          	RET
1763   0B79             
1764   0B79             
1765   0B79             ;-----------------
1766   0B79             ; ONE SECOND DELAY
1767   0B79             ;-----------------
1768   0B79             ;
1769   0B79             ; ENTRY : NONE
1770   0B79             ; EXIT : FLAG REGISTER MODIFIED
1771   0B79             ;
1772   0B79 C5          DELONE:	PUSH	BC
1773   0B7A D5          	PUSH	DE
1774   0B7B E5          	PUSH	HL
1775   0B7C 11 01 00    	LD	DE,0001H
1776   0B7F 21 70 08    	LD	HL,0870H
1777   0B82 06 92       DELON1:	LD	B,92H
1778   0B84 10 FE       DELON2:	DJNZ	DELON2	;INNER LOOP
1779   0B86 ED 52       	SBC	HL,DE
1780   0B88 D2 82 0B    	JP	NC,DELON1	;OUTER LOOP
1781   0B8B E1          	POP	HL
1782   0B8C D1          	POP	DE
1783   0B8D C1          	POP	BC
1784   0B8E C9          	RET
1785   0B8F             
1786   0B8F             
1787   0B8F             
1788   0B8F             
1789   0B8F             
1790   0B8F             
1791   0B8F             
1792   0B8F             ; **********************************************************************
1793   0B8F             ; List devices found on the I2C bus
1794   0B8F             ;
1795   0B8F             ; Test each I2C device address and reports any that acknowledge
1796   0B8F             
1797   0B8F 11 B9 0B    I2CLIST:       LD   DE,LISTMsg        ;Address of message string
1798   0B92 CD DD 0B                CALL StrOut         ;Output string
1799   0B95 16 00                   LD   D,0            ;First I2C device address to test
1800   0B97 D5          LISTLOOP:      PUSH DE             ;Preserve DE
1801   0B98 7A                      LD   A,D            ;Get device address to be tested
1802   0B99 CD B0 0B                CALL LISTTEST          ;Test if device is present
1803   0B9C D1                      POP  DE             ;Restore DE
1804   0B9D 20 07                   JR   NZ,LISTNEXT       ;Skip if no acknowledge
1805   0B9F 7A                      LD   A,D            ;Get address of device tested
1806   0BA0 CD 0C 0C                CALL HexOut         ;Output as two character hex 
1807   0BA3 CD D8 0B                CALL SpaceOut       ;Output space character
1808   0BA6 14          LISTNEXT:      INC  D              ;Get next write address
1809   0BA7 14                      INC  D
1810   0BA8 7A                      LD   A,D            ;Address of next device to test
1811   0BA9 B7                      OR   A              ;Have we tested all addresses?
1812   0BAA 20 EB                   JR   NZ,LISTLOOP       ;No, so loop again
1813   0BAC CD D5 0B                CALL LineOut        ;Output new line
1814   0BAF C9                      RET
1815   0BB0             
1816   0BB0             ; Test if device at I2C address A acknowledges
1817   0BB0             ;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
1818   0BB0             ;   On exit:  Z flagged if device acknowledges
1819   0BB0             ;             NZ flagged if devices does not acknowledge
1820   0BB0 CD 4D 0C    LISTTEST:      CALL I2C_Open       ;Open I2C device for write
1821   0BB3 C0                      RET  NZ             ;Abort if failed to open
1822   0BB4 CD 54 0C                CALL I2C_Close      ;Close I2C device 
1823   0BB7 AF                      XOR  A              ;Return with Z flagged
1824   0BB8 C9                      RET
1825   0BB9             
1826   0BB9 493243206465LISTMsg:       .DB  "I2C device found at:",CR,0
1826   0BBF 7669636520666F756E642061743A0D00
1827   0BCF             
1828   0BCF             
1829   0BCF             
1830   0BCF             
1831   0BCF             
1832   0BCF             
1833   0BCF             
1834   0BCF             
1835   0BCF             
1836   0BCF             
1837   0BCF             
1838   0BCF             
1839   0BCF             
1840   0BCF             ; Display test result
1841   0BCF             ;   On entry: DE = Address of null terminated string
1842   0BCF             ;             H = First value ($H)
1843   0BCF             ;             L = Second value ($L)
1844   0BCF             ;   On exit:  HL IX IY preserved
1845   0BCF             Result:     
1846   0BCF C3 24 0C                JP   String         ;Output result string to console
1847   0BD2             
1848   0BD2             
1849   0BD2             ; Character output to console
1850   0BD2             ;   On entry: A = Character to be output
1851   0BD2             ;   On exit:  BC DE HL IX IY preserved
1852   0BD2 C3 EA 0B    CharOut:    JP   API_Cout
1853   0BD5             
1854   0BD5             ; New line output to console
1855   0BD5             ;   On entry: No parameters required
1856   0BD5             ;   On exit:  BC DE HL IX IY preserved
1857   0BD5 C3 F4 0B    LineOut:    JP   API_Lout
1858   0BD8             
1859   0BD8             ; Space character ouput to console
1860   0BD8             ;   On entry: No parameters required
1861   0BD8             ;   On exit:  BC DE HL IX IY preserved
1862   0BD8 3E 20       SpaceOut:   LD   A,$20
1863   0BDA C3 EA 0B                JP   API_Cout
1864   0BDD             
1865   0BDD             ; String output to console
1866   0BDD             ;   On entry: DE = Address of string
1867   0BDD             ;   On exit:  BC DE HL IX IY preserved
1868   0BDD C3 00 0C    StrOut:     JP   API_Sout
1869   0BE0             
1870   0BE0             
1871   0BE0             ; Delay by DE milliseconds (approx)
1872   0BE0             ;   On entry: DE = Delay time in milliseconds
1873   0BE0             ;   On exit:  BC DE HL IX IY preserved
1874   0BE0 C5          API_Delay:  PUSH BC             ;Preserve registers
1875   0BE1 D5                      PUSH DE
1876   0BE2 E5                      PUSH HL
1877   0BE3 CD C1 09                CALL delay
1878   0BE6 E1                      POP  HL             ;Restore registers
1879   0BE7 D1                      POP  DE
1880   0BE8 C1                      POP  BC
1881   0BE9 C9                      RET
1882   0BEA             
1883   0BEA             
1884   0BEA             ; Character output to console device
1885   0BEA             ;   On entry: A = Character to be output
1886   0BEA             ;   On exit:  BC DE HL IX IY preserved
1887   0BEA C5          API_Cout:   PUSH BC             ;Preserve registers
1888   0BEB D5                      PUSH DE
1889   0BEC E5                      PUSH HL
1890   0BED CD 08 00                CALL $0008
1891   0BF0 E1                      POP  HL             ;Restore registers
1892   0BF1 D1                      POP  DE
1893   0BF2 C1                      POP  BC
1894   0BF3 C9                      RET
1895   0BF4             
1896   0BF4             
1897   0BF4             ; New line output to console device
1898   0BF4             ;   On entry: No parameters required
1899   0BF4             ;   On exit:  BC DE HL IX IY preserved
1900   0BF4 C5          API_Lout:   PUSH BC             ;Preserve registers
1901   0BF5 D5                      PUSH DE
1902   0BF6 E5                      PUSH HL
1903   0BF7 3E 0D                   LD A, CR ; enter char
1904   0BF9 CD 08 00                CALL $0008
1905   0BFC E1                      POP  HL             ;Restore registers
1906   0BFD D1                      POP  DE
1907   0BFE C1                      POP  BC
1908   0BFF C9                      RET
1909   0C00             
1910   0C00             
1911   0C00             ; String output to console device
1912   0C00             ;   On entry: DE = Address of string
1913   0C00             ;   On exit:  BC DE HL IX IY preserved
1914   0C00 C5          API_Sout:   PUSH BC             ;Preserve registers
1915   0C01 D5                      PUSH DE
1916   0C02 E5                      PUSH HL
1917   0C03 62                      LD H, D
1918   0C04 6B                      LD L, E
1919   0C05 CD EC 0A                CALL SNDLCDMSG
1920   0C08 E1                      POP  HL             ;Restore registers
1921   0C09 D1                      POP  DE
1922   0C0A C1                      POP  BC
1923   0C0B C9                      RET
1924   0C0C             
1925   0C0C             
1926   0C0C             ; Hex byte output to console
1927   0C0C             ;   On entry: A = Byte to be output in hex
1928   0C0C             ;   On exit:  BC DE HL IX IY preserved
1929   0C0C F5          HexOut:     PUSH AF             ;Preserve byte to be output
1930   0C0D 1F                      RRA                 ;Shift top nibble to
1931   0C0E 1F                      RRA                 ;  botom four bits..
1932   0C0F 1F                      RRA
1933   0C10 1F                      RRA
1934   0C11 E6 0F                   AND  $0F           ;Mask off unwanted bits
1935   0C13 CD 19 0C                CALL HexOutHex           ;Output hi nibble
1936   0C16 F1                      POP  AF             ;Restore byte to be output
1937   0C17 E6 0F                   AND  $0F           ;Mask off unwanted bits
1938   0C19             ; Output nibble as ascii character
1939   0C19 FE 0A       HexOutHex:       CP   $0A           ;Nibble > 10 ?
1940   0C1B 38 02                   JR   C,HexOutSkip        ;No, so skip
1941   0C1D C6 07                   ADD  A,7            ;Yes, so add 7
1942   0C1F C6 30       HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
1943   0C21 C3 EA 0B                JP   API_Cout       ;Write character
1944   0C24             
1945   0C24             
1946   0C24             ; Output string at DE with substitutions
1947   0C24             ;   On entry: A = Address of device on I2C bus (write address)
1948   0C24             ;             DE = Address of null terminated string
1949   0C24             ;             H = Value to substitute for $H
1950   0C24             ;             L = Value to substitute for $L
1951   0C24             ;             B = Value to substitute for $B
1952   0C24             ;   On exit:  DE = Address of next location after this string
1953   0C24             ;             IX IY preserved
1954   0C24 1A          String:     LD   A,(DE)         ;Get character from string
1955   0C25 13                      INC  DE             ;Point to next character in string
1956   0C26 B7                      OR   A              ;Null ?
1957   0C27 C8                      RET  Z              ;Yes, so we're done
1958   0C28 FE 24                   CP   '$'            ;Substitue value?
1959   0C2A 28 05                   JR   Z,StringSubst       ;Yes, so go handle substitution
1960   0C2C CD D2 0B                CALL CharOut        ;Output character to console
1961   0C2F 18 F3                   JR   String         ;Go get next character from string
1962   0C31 1A          StringSubst:     LD   A,(DE)         ;Get character from string
1963   0C32 13                      INC  DE             ;Point to next character in string
1964   0C33 B7                      OR   A              ;Null ?
1965   0C34 C8                      RET  Z              ;Yes, so we're done
1966   0C35 FE 48                   CP   'H'            ;Register H
1967   0C37 20 03                   JR   NZ,StringNotH       ;No, so skip
1968   0C39 7C                      LD   A,H            ;Get value 'H'
1969   0C3A 18 0C                   JR   StringGotIt         ;Go output it in hex
1970   0C3C FE 4C       StringNotH:      CP   'L'            ;Register L
1971   0C3E 20 03                   JR   NZ,StringNotL       ;No, so skip
1972   0C40 7D                      LD   A,L            ;Get value 'L'
1973   0C41 18 05                   JR   StringGotIt         ;Go output it in hex
1974   0C43 FE 42       StringNotL:      CP   'B'            ;Register B
1975   0C45 20 04                   JR   NZ,StringNotB       ;No, so skip
1976   0C47 78                      LD   A,B            ;Get value 'L'
1977   0C48                         ;JR   @GotIt        ;Go output it in hex
1978   0C48 CD 0C 0C    StringGotIt:     CALL HexOut         ;Output write address in hex
1979   0C4B 18 D7       StringNotB:      JR   String         ;Go get next character from string
1980   0C4D             
1981   0C4D             
1982   0C4D             ; **********************************************************************
1983   0C4D             ; I2C support functions
1984   0C4D             
1985   0C4D             ; I2C bus open device
1986   0C4D             ;   On entry: A = Device address (bit zero is read flag)
1987   0C4D             ;             SCL = unknown, SDA = unknown
1988   0C4D             ;   On exit:  If successfully A = 0 and Z flagged
1989   0C4D             ;             If unsuccessfully A = Error and NZ flagged
1990   0C4D             ;             BC DE HL IX IY preserved
1991   0C4D F5          I2C_Open:   PUSH AF
1992   0C4E CD C1 0C                CALL I2C_Start      ;Output start condition
1993   0C51 F1                      POP  AF
1994   0C52 18 03                   JR   I2C_Write      ;Write data byte
1995   0C54             
1996   0C54             
1997   0C54             ; I2C bus close device
1998   0C54             ;   On entry: SCL = unknown, SDA = unknown
1999   0C54             ;   On exit:  If successfully A=0 and Z flagged
2000   0C54             ;             If unsuccessfully A=Error and NZ flagged
2001   0C54             ;             SCL = hi, SDA = hi
2002   0C54             ;             BC DE HL IX IY preserved
2003   0C54 C3 CC 0C    I2C_Close:  JP   I2C_Stop       ;Output stop condition
2004   0C57             
2005   0C57             
2006   0C57             ; **********************************************************************
2007   0C57             ; **********************************************************************
2008   0C57             ; I2C bus master driver
2009   0C57             ; **********************************************************************
2010   0C57             ; **********************************************************************
2011   0C57             
2012   0C57             ; Functions provided are:
2013   0C57             ;     I2C_Start
2014   0C57             ;     I2C_Stop
2015   0C57             ;     I2C_Read
2016   0C57             ;     I2C_Write
2017   0C57             ;
2018   0C57             ; This code has delays between all I/O operations to ensure it works
2019   0C57             ; with the slowest I2C devices
2020   0C57             ;
2021   0C57             ; I2C transfer sequence
2022   0C57             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2023   0C57             ;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
2024   0C57             ;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
2025   0C57             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2026   0C57             ;
2027   0C57             ;
2028   0C57             ; Start condition                     Stop condition
2029   0C57             ; Output by master device             Output by master device
2030   0C57             ;       ----+                                      +----
2031   0C57             ; SDA       |                         SDA          |
2032   0C57             ;           +-------                        -------+
2033   0C57             ;       -------+                                +-------
2034   0C57             ; SCL          |                      SCL       |
2035   0C57             ;              +----                        ----+
2036   0C57             ;
2037   0C57             ;
2038   0C57             ; Address frame
2039   0C57             ; Clock and data output from master device
2040   0C57             ; Receiving device outputs acknowledge 
2041   0C57             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2042   0C57             ; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
2043   0C57             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2044   0C57             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2045   0C57             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2046   0C57             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2047   0C57             ;
2048   0C57             ;
2049   0C57             ; Data frame 
2050   0C57             ; Clock output by master device
2051   0C57             ; Data output by transmitting device
2052   0C57             ; Receiving device outputs acknowledge 
2053   0C57             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2054   0C57             ; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
2055   0C57             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2056   0C57             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2057   0C57             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2058   0C57             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2059   0C57             ;
2060   0C57             
2061   0C57             
2062   0C57             ; **********************************************************************
2063   0C57             ; I2C constants
2064   0C57             
2065   0C57             
2066   0C57             ; I2C bus master interface
2067   0C57             ; The default device option is for SC126 or compatible
2068   0C57             
2069   0C57             I2C_PORT:   .EQU $20           ;Host I2C port address
2070   0C57             I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
2071   0C57             I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
2072   0C57             I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
2073   0C57             I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
2074   0C57             I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
2075   0C57             
2076   0C57             
2077   0C57             ; I2C support constants
2078   0C57             ERR_NONE:   .EQU 0              ;Error = None
2079   0C57             ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
2080   0C57             ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
2081   0C57             ERR_TOUT:   .EQU 3              ;Error = Timeout
2082   0C57             
2083   0C57             
2084   0C57             ; **********************************************************************
2085   0C57             ; Hardware dependent I2C bus functions
2086   0C57             
2087   0C57             
2088   0C57             ; I2C bus transmit frame (address or data)
2089   0C57             ;   On entry: A = Data byte, or
2090   0C57             ;                 Address byte (bit zero is read flag)
2091   0C57             ;             SCL = low, SDA = low
2092   0C57             ;   On exit:  If successful A=0 and Z flagged
2093   0C57             ;                SCL = lo, SDA = lo
2094   0C57             ;             If unsuccessful A=Error and NZ flagged
2095   0C57             ;                SCL = high, SDA = high, I2C closed
2096   0C57             ;             BC DE HL IX IY preserved
2097   0C57 C5          I2C_Write:  PUSH BC             ;Preserve registers
2098   0C58 D5                      PUSH DE
2099   0C59 57                      LD   D,A            ;Store byte to be written
2100   0C5A 06 08                   LD   B,8            ;8 data bits, bit 7 first
2101   0C5C CB 12       I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
2102   0C5E 38 05                   JR   C,I2C_WriteBit_Hi      ;High, so skip
2103   0C60 CD F3 0C                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
2104   0C63 18 03                   JR   I2C_WriteBit_Clk
2105   0C65 CD EC 0C    I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
2106   0C68 CD DE 0C    I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
2107   0C6B CD E5 0C                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
2108   0C6E 10 EC                   DJNZ I2C_WriteWr_Loop
2109   0C70             ; Test for acknowledge from slave (receiver)
2110   0C70             ; On arriving here, SCL = lo, SDA = data bit
2111   0C70 CD EC 0C                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
2112   0C73 CD DE 0C                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
2113   0C76 CD 04 0D                CALL I2C_RdPort     ;Read SDA input
2114   0C79 47                      LD   B,A
2115   0C7A CD E5 0C                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
2116   0C7D CB 78                   BIT  I2C_SDA_RD,B
2117   0C7F 20 04                   JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
2118   0C81 D1                      POP  DE             ;Restore registers
2119   0C82 C1                      POP  BC
2120   0C83 AF                      XOR  A              ;Return success A=0 and Z flagged
2121   0C84 C9                      RET
2122   0C85             ; I2C STOP required as no acknowledge
2123   0C85             ; On arriving here, SCL = lo, SDA = hi
2124   0C85 CD F3 0C    I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
2125   0C88 CD DE 0C                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
2126   0C8B CD EC 0C                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
2127   0C8E D1                      POP  DE             ;Restore registers
2128   0C8F C1                      POP  BC
2129   0C90 3E 02                   LD   A,ERR_NOACK    ;Return error = No Acknowledge
2130   0C92 B7                      OR   A              ;  and NZ flagged
2131   0C93 C9                      RET
2132   0C94             
2133   0C94             
2134   0C94             ; I2C bus receive frame (data)
2135   0C94             ;   On entry: A = Acknowledge flag
2136   0C94             ;               If A != 0 the read is acknowledged
2137   0C94             ;             SCL low, SDA low
2138   0C94             ;   On exit:  If successful A = data byte and Z flagged
2139   0C94             ;               SCL = low, SDA = low
2140   0C94             ;             If unsuccessul* A = Error and NZ flagged
2141   0C94             ;               SCL = low, SDA = low
2142   0C94             ;             BC DE HL IX IY preserved
2143   0C94             ; *This function always returns successful
2144   0C94 C5          I2C_Read:   PUSH BC             ;Preserve registers
2145   0C95 D5                      PUSH DE
2146   0C96 5F                      LD   E,A            ;Store acknowledge flag
2147   0C97 06 08                   LD   B,8            ;8 data bits, 7 first
2148   0C99 CD EC 0C                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
2149   0C9C CD DE 0C    I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
2150   0C9F CD 04 0D                CALL I2C_RdPort     ;Read SDA input bit
2151   0CA2 37                      SCF                 ;Set carry flag
2152   0CA3 CB 7F                   BIT  I2C_SDA_RD,A   ;SDA input high?
2153   0CA5 20 01                   JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
2154   0CA7 3F                      CCF                 ;Clear carry flag
2155   0CA8 CB 12       I2C_ReadRotate:    RL   D              ;Rotate result into D
2156   0CAA CD E5 0C                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
2157   0CAD 10 ED                   DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
2158   0CAF             ; Acknowledge input byte
2159   0CAF             ; On arriving here, SCL = lo, SDA = hi/input
2160   0CAF 7B                      LD   A,E            ;Get acknowledge flag
2161   0CB0 B7                      OR   A              ;A = 0? (indicates no acknowledge)
2162   0CB1 28 03                   JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
2163   0CB3 CD F3 0C                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
2164   0CB6 CD DE 0C    I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
2165   0CB9 CD E5 0C                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2166   0CBC 7A                      LD   A,D            ;Get data byte received
2167   0CBD D1                      POP  DE             ;Restore registers
2168   0CBE C1                      POP  BC
2169   0CBF BF                      CP   A              ;Return success Z flagged
2170   0CC0 C9                      RET
2171   0CC1             
2172   0CC1             
2173   0CC1             ; I2C bus start
2174   0CC1             ;   On entry: SCL = unknown, SDA = unknown
2175   0CC1             ;   On exit:  SCL = low, SDA = low
2176   0CC1             ;             A = 0 and Z flagged as we always succeed
2177   0CC1             ;             BC DE HL IX IY preserved
2178   0CC1             ; First ensure SDA and SCL are high
2179   0CC1 CD DA 0C    I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
2180   0CC4             ;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
2181   0CC4             ;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
2182   0CC4             ; Generate I2C start condition
2183   0CC4 CD F3 0C                CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2184   0CC7 CD E5 0C                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2185   0CCA AF                      XOR  A              ;Return success A=0 and Z flagged
2186   0CCB C9                      RET
2187   0CCC             
2188   0CCC             
2189   0CCC             ; I2C bus stop 
2190   0CCC             ;   On entry: SCL = unknown, SDA = unknown
2191   0CCC             ;   On exit:  SCL = high, SDA = high
2192   0CCC             ;             A = 0 and Z flagged as we always succeed
2193   0CCC             ;             BC DE HL IX IY preserved
2194   0CCC             ; First ensure SDA and SCL are low
2195   0CCC CD F3 0C    I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2196   0CCF CD E5 0C                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2197   0CD2             ; Generate stop condition
2198   0CD2 CD DE 0C                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
2199   0CD5 CD EC 0C                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
2200   0CD8 AF                      XOR  A              ;Return success A=0 and Z flagged
2201   0CD9 C9                      RET
2202   0CDA             
2203   0CDA             
2204   0CDA             ; **********************************************************************
2205   0CDA             ; I2C bus simple I/O functions
2206   0CDA             ;   On entry: No parameters required
2207   0CDA             ;   On exit:  BC DE HL IX IY preserved
2208   0CDA             
2209   0CDA 3E 81       I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
2210   0CDC 18 1A                   JR   I2C_WrPort
2211   0CDE             
2212   0CDE 3A 00 D0    I2C_SCL_HI: LD   A,(I2C_RAMCPY)
2213   0CE1 CB C7                   SET  I2C_SCL_WR,A
2214   0CE3 18 13                   JR   I2C_WrPort
2215   0CE5             
2216   0CE5 3A 00 D0    I2C_SCL_LO: LD   A,(I2C_RAMCPY)
2217   0CE8 CB 87                   RES  I2C_SCL_WR,A
2218   0CEA 18 0C                   JR   I2C_WrPort
2219   0CEC             
2220   0CEC 3A 00 D0    I2C_SDA_HI: LD   A,(I2C_RAMCPY)
2221   0CEF CB FF                   SET  I2C_SDA_WR,A
2222   0CF1 18 05                   JR   I2C_WrPort
2223   0CF3             
2224   0CF3 3A 00 D0    I2C_SDA_LO: LD   A,(I2C_RAMCPY)
2225   0CF6 CB BF                   RES  I2C_SDA_WR,A
2226   0CF8                         ;JR   I2C_WrPort
2227   0CF8             
2228   0CF8 C5          I2C_WrPort: PUSH BC             ;Preserve registers
2229   0CF9 06 00                   LD   B,0            ;Set up BC for 16-bit
2230   0CFB 0E 20                   LD   C,I2C_PORT     ;  I/O address of I2C port
2231   0CFD ED 79                   OUT  (C),A          ;Write A to I2C I/O port
2232   0CFF 32 00 D0                LD   (I2C_RAMCPY),A ;Write A to RAM copy
2233   0D02 C1                      POP  BC             ;Restore registers
2234   0D03 C9                      RET
2235   0D04             
2236   0D04 C5          I2C_RdPort: PUSH BC             ;Preserve registers
2237   0D05 06 00                   LD   B,0            ;Set up BC for 16-bit
2238   0D07 0E 20                   LD   C,I2C_PORT     ;  I/O address of I2C port
2239   0D09 ED 78                   IN   A,(C)          ;Read A from I/O port
2240   0D0B C1                      POP  BC             ;Restore registers
2241   0D0C C9                      RET
2242   0D0D             
2243   0D0D             
2244   0D0D             
2245   0D0D 0C0D0D0A5A38WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
2245   0D13 30204D696E6920496E69636961646F0D0A00
2246   0D25 5A3830204D49MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H
2246   0D2B 4E492C204820544F2048454C500D00
2247   0D3A 42202D204261MSG_MENU1 .db "B - Basic",CR, 00H
2247   0D40 7369630D00
2248   0D45 49202D20496EMSG_MENU2 .db "I - Intel hex loader",CR, 00H
2248   0D4B 74656C20686578206C6F616465720D00
2249   0D5B 52202D205255MSG_MENU3 .db "R - RUN (JP $8000)",CR, 00H
2249   0D61 4E20284A50202438303030290D00
2250   0D6F 31202D204932MSG_MENU4 .db "1 - I2C Scan",CR, 00H
2250   0D75 43205363616E0D00
2251   0D7D 472041414141MSG_MENU5 .db "G AAAA - GO TO ADDR",CR, 00H
2251   0D83 202D20474F20544F20414444520D00
2252   0D92 4D2041414141MSG_MENU6 .db "M AAAA - MODIFY ADDR",CR,00H
2252   0D98 202D204D4F4449465920414444520D00
2253   0DA8             
2254   0DA8 0C496E74656CMSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
2254   0DAE 20484558206C6F616465722E2E2E0D00
2255   0DBE 46494C452052FILEOK    .DB      "FILE RECEIVED OK",CR,00H
2255   0DC4 45434549564544204F4B0D00
2256   0DD0 434845434B53CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
2256   0DD6 554D204552524F520D00
2257   0DE0             
2258   0DE0             
2259   0DE0             
2260   0DE0             ; **********************************************************************
2261   0DE0             ; I2C workspace / variables in RAM
2262   0DE0             
2263   D000                         .ORG  I2CDATA
2264   D000             
2265   D000 00          I2C_RAMCPY: .DB  0              ;RAM copy of output port
2266   D001             
2267   D001 00          RESULTS:    .DB  0              ;Large block of results can start here
2268   D002             
2269   D002             .end
tasm: Number of errors = 0
