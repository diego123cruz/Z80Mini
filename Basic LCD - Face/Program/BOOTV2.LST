0001   0000             ; Diego Cruz - Nov 2022
0002   0000             ; 
0003   0000             ; bootV2: 
0004   0000             ;         - CPU Z80@4Mhz
0005   0000             ;         - Lcd Grafico 128x64
0006   0000             ;         - Keyboard 40 keys + Shift
0007   0000             ;         - Rom 32k 0000h - 7FFFh
0008   0000             ;         - Ram 32k 8000h - FFFFh
0009   0000             ;         
0010   0000             ;
0011   0000             ;         - Ports:
0012   0000             ;               - Keyboard: 40H
0013   0000             ;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
0014   0000             ;               - User IN/OUT: C0H
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------
0017   0000             LCDCTRL	    .EQU    70H
0018   0000             LCDDATA     .EQU    71H
0019   0000             KEY_IN      .EQU    40H
0020   0000             KEY_OUT     .EQU    40H
0021   0000             
0022   0000             CTRLC       .EQU    03H             ; Control "C"
0023   0000             CTRLG       .EQU    07H             ; Control "G"
0024   0000             BKSP        .EQU    08H             ; Back space
0025   0000             LF          .EQU    0AH             ; Line feed
0026   0000             VT          .equ    0BH             ; 
0027   0000             CS          .EQU    0CH             ; Clear screen
0028   0000             CR          .EQU    0DH             ; Carriage return [Enter]
0029   0000             CTRLO       .EQU    0FH             ; Control "O"
0030   0000             CTRLQ	    .EQU	11H		        ; Control "Q"
0031   0000             CTRLR       .EQU    12H             ; Control "R"
0032   0000             CTRLS       .EQU    13H             ; Control "S"
0033   0000             CTRLU       .EQU    15H             ; Control "U"
0034   0000             ESC         .EQU    1BH             ; Escape
0035   0000             DEL         .EQU    7FH             ; Delete
0036   0000             
0037   0000             kCPUClock:  .EQU 4000000       ;CPU clock speed in Hz
0038   0000             kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
0039   0000             kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
0040   0000             kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
0041   0000             kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
0042   0000             kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop
0043   0000             
0044   0000             BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
0045   0000             ;
0046   0000             ; BAUD RATE CONSTANTS
0047   0000             ;
0048   0000             B300:	.EQU	0220H	;300 BAUD
0049   0000             B1200:	.EQU	0080H	;1200 BAUD
0050   0000             B2400:	.EQU	003FH	;2400 BAUD
0051   0000             B4800:	.EQU	001BH	;4800 BAUD
0052   0000             B9600:	.EQU	000BH	;9600 BAUD
0053   0000             
0054   0000             SYSTEM:	.EQU 	0FD00H	;INITIAL STACK POINTER
0055   0000             I2CDATA .EQU    0D000H 
0056   0000             
0057   0000             I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
0058   0000             TIMEOUT:    .EQU 10000          ;Timeout loop counter
0059   0000             
0060   0000             ADDR:       .EQU 0FEB0H   ;THE ADDRESS  2 bytes
0061   0000             ADDR_FROM   .EQU 0FEB2H   ;THE ADDRESS FROM  2 bytes
0062   0000             ADDR_TO     .EQU 0FEB4H   ;THE ADDRESS TO 2 bytes
0063   0000             ADDR_SIZE   .EQU 0FEB6H   ;THE ADDRESS SIZE 2 bytes
0064   0000             DATA:       .EQU 0FEB8H   ;THE DATA
0065   0000             MSGBUF:     .EQU 0FE00H   ;STRING HANDLING AREA
0066   0000             
0067   0000             PORT_SET    .EQU 0FFB0H ; 1 byte - Define port (input/output) Default 0xC0(onboard)
0068   0000             PORT_OUT_VAL    .EQU 0FFB1H ; 1 byte - save value out port
0069   0000             LCD_DATA        .EQU 0FFB2H ; 1byte
0070   0000             
0071   0000             
0072   0000             BAUD:	 .EQU	0FFC0H	 ;BAUD RATE
0073   0000             PUTCH:   .EQU   0FFAAH   ;OUTPUT A CHARACTER TO SERIAL
0074   0000             GETCH:   .EQU   0FFACH   ;WAIT FOR A CHARACTER FROM SERIAL
0075   0000             
0076   0000             SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
0077   0000             SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
0078   0000             
0079   0000             
0080   0000             ; LCD TEXT MODE
0081   0000             LCD_LINE1   .EQU    80H
0082   0000             LCD_LINE2   .EQU    90H
0083   0000             LCD_LINE3   .EQU    88H
0084   0000             LCD_LINE4   .EQU    98H
0085   0000             
0086   0000             
0087   0000             ; RAM MAP
0088   0000             
0089   0000             
0090   0000             
0091   0000             LCD_CHAR            .EQU    $E000   ; 1 byte char ex: 'A'
0092   0000             LCD_CHAR_POINT      .EQU    $E001   ; 2 bytes ponteiro para o mapa de caracteres
0093   0000             LCD_TXT_X           .EQU    $E003   ; 1 byte  0-20 (21 col)
0094   0000             LCD_TXT_Y           .EQU    $E004   ; 1 byte  0-7  (8 row)
0095   0000             LCD_BYTE_INDEX      .EQU    $E005   ; 2 bytes pointer pixel(8)
0096   0000             LCD_BIT_INDEX       .EQU    $E007   ; 1 byte pointer pixel(1)
0097   0000             LCD_TXT_X_TMP       .EQU    $E008   ; 2 bytes = LCD_TXT_X * 6
0098   0000             LCD_TXT_Y_TMP       .EQU    $E00A   ; 2 bytes = LCD_TXT_Y * 128
0099   0000             LCD_CHAR_H          .EQU    $E00C   ; 1 byte altura do char
0100   0000             LCD_CHAR_W          .EQU    $E00D   ; 1 byte largura do char
0101   0000             LCD_TMP_POINT       .EQU    $E00E   ; 2 bytes ponteiro do pixel altural do print
0102   0000             LCD_DELETE_CHAR     .EQU    $E00F   ; 1 byte, 0 n√£o, ff delete proximo char
0103   0000             LCD_AUTO_X          .EQU    $E010   ; 1 byte, 0 sim, ff nao
0104   0000             
0105   0000             DISPLAY             .EQU    $E500
0106   0000             
0107   0000             LCD_TEMP        .EQU    $E110
0108   0000             LCD_COOX        .EQU    $E102 ; 1 byte, local onde vai printar
0109   0000             LCD_COOY        .EQU    $E103 ; 1 byte
0110   0000             LCD_PRINT_H     .EQU    $E104 ; 1 byte, tamanho do que vai printar
0111   0000             LCD_PRINT_W     .EQU    $E105 ; 1 byte
0112   0000             LCD_PRINT_IMAGE .EQU    $E106 ; 2 bytes
0113   0000             
0114   0000             
0115   0000                     .ORG 0
0116   0000 F3          RST00	DI
0117   0001 C3 83 04            JP  INICIO
0118   0004             						
0119   0008                     .ORG     0008H
0120   0008 C3 BE 08    RST08   JP  PRINTCHAR
0121   000B             
0122   0010                     .ORG 0010H
0123   0010 C3 EF 0B    RST10   JP KEYREADINIT
0124   0013             
0125   0018                     .ORG 0018H ; check break
0126   0018 C3 DA 0B    RST18   JP CHKKEY
0127   001B             
0128   0030                     .ORG 0030H
0129   0030 C3 1E 05    RST30   JP APIHandler
0130   0033             
0131   0033             KEYMAP:
0132   0033 313233343536.BYTE   "1234567890"
0132   0039 37383930
0133   003D 515745525459.BYTE   "QWERTYUIOP"
0133   0043 55494F50
0134   0047 415344464748.BYTE   "ASDFGHJKL", CR
0134   004D 4A4B4C0D
0135   0051 035A58435642.BYTE   CTRLC, "ZXCVBNM ", DEL
0135   0057 4E4D207F
0136   005B             
0137   005B             SHIFTKEYMAP:
0138   005B 21402324255E.BYTE   "!@#$%^&*()"
0138   0061 262A2829
0139   0065 607E2D5F3D2B.BYTE   "`~-_=+;:'"
0139   006B 3B3A27
0140   006E 22          .BYTE   22h
0141   006F 7B7D5B5D7C5C.BYTE   "{}[]|",$5C,"<>?/"
0141   0075 3C3E3F2F
0142   0079 032C2E1B2020.BYTE   CTRLC,",.",ESC,"    ", VT, LF
0142   007F 20200B0A
0143   0083             
0144   0083             
0145   0083             
0146   0083             TABLE:
0147   0083 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
0147   0089 0000
0148   008B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
0148   0091 0000
0149   0093 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
0149   0099 0000
0150   009B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
0150   00A1 0000
0151   00A3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
0151   00A9 0000
0152   00AB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
0152   00B1 0000
0153   00B3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
0153   00B9 0000
0154   00BB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
0154   00C1 0000
0155   00C3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
0155   00C9 0000
0156   00CB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
0156   00D1 0000
0157   00D3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0157   00D9 0000
0158   00DB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
0158   00E1 0000
0159   00E3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0159   00E9 0000
0160   00EB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
0160   00F1 0000
0161   00F3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0161   00F9 0000
0162   00FB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
0162   0101 0000
0163   0103 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0163   0109 0000
0164   010B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
0164   0111 0000
0165   0113 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0165   0119 0000
0166   011B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
0166   0121 0000
0167   0123 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0167   0129 0000
0168   012B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
0168   0131 0000
0169   0133 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0169   0139 0000
0170   013B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
0170   0141 0000
0171   0143 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0171   0149 0000
0172   014B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
0172   0151 0000
0173   0153 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0173   0159 0000
0174   015B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
0174   0161 0000
0175   0163 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0175   0169 0000
0176   016B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
0176   0171 0000
0177   0173 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
0177   0179 0000
0178   017B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
0178   0181 0000
0179   0183             
0180   0183             ; DEC 32
0181   0183 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
0181   0189 0000
0182   018B 202020202000.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
0182   0191 2000
0183   0193 505050000000.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
0183   0199 0000
0184   019B 5050F850F850.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
0184   01A1 5000
0185   01A3 2078A07028F0.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
0185   01A9 2000
0186   01AB C0C810204098.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
0186   01B1 1800
0187   01B3 6090A040A890.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
0187   01B9 6800
0188   01BB 202020000000.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
0188   01C1 0000
0189   01C3 102040404020.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
0189   01C9 1000
0190   01CB 402010101020.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
0190   01D1 4000
0191   01D3 0020A870A820.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0191   01D9 0000
0192   01DB 002020F82020.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
0192   01E1 0000
0193   01E3 000000006020.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0193   01E9 4000
0194   01EB 000000F80000.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
0194   01F1 0000
0195   01F3 000000000060.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0195   01F9 6000
0196   01FB 000008102040.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
0196   0201 8000
0197   0203 708898A8C888.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0197   0209 7000
0198   020B 206020202020.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
0198   0211 7000
0199   0213 708808102040.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0199   0219 F800
0200   021B F81020100888.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
0200   0221 7000
0201   0223 10305090F810.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0201   0229 1000
0202   022B F880F0080888.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
0202   0231 7000
0203   0233 304080F08888.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0203   0239 7000
0204   023B F80810204040.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
0204   0241 4000
0205   0243 708888708888.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0205   0249 7000
0206   024B 708888780810.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
0206   0251 6000
0207   0253 000030300030.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0207   0259 3000
0208   025B 003030003010.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
0208   0261 2000
0209   0263 102040804020.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0209   0269 1000
0210   026B 0000F800F800.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
0210   0271 0000
0211   0273 402010081020.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
0211   0279 4000
0212   027B 304808102000.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
0212   0281 2000
0213   0283 70880868A8A8.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
0213   0289 7000
0214   028B             
0215   028B             ; DEC 65 Maiusculas
0216   028B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0216   0291 8800
0217   0293 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0217   0299 F000
0218   029B 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0218   02A1 7000
0219   02A3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0219   02A9 E000
0220   02AB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0220   02B1 F800
0221   02B3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0221   02B9 8000
0222   02BB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0222   02C1 7000
0223   02C3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0223   02C9 8800
0224   02CB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0224   02D1 7000
0225   02D3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0225   02D9 7000
0226   02DB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0226   02E1 8800
0227   02E3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0227   02E9 F800
0228   02EB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0228   02F1 8800
0229   02F3 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0229   02F9 8800
0230   02FB 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0230   0301 7000
0231   0303 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0231   0309 8000
0232   030B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0232   0311 7000
0233   0313 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0233   0319 8800
0234   031B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0234   0321 7000
0235   0323 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0235   0329 2000
0236   032B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0236   0331 7000
0237   0333 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0237   0339 2000
0238   033B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0238   0341 8800
0239   0343 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0239   0349 8800
0240   034B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0240   0351 2000
0241   0353 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0241   0359 F800
0242   035B             
0243   035B             ; DEC 91
0244   035B 302020202020.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
0244   0361 3000
0245   0363 008040201008.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0245   0369 0000
0246   036B 602020202020.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
0246   0371 6000
0247   0373 205088000000.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
0247   0379 0000
0248   037B 000000000000.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
0248   0381 F800
0249   0383 402010000000.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
0249   0389 0000
0250   038B             
0251   038B             ; DEC 97 "Minusculas"
0252   038B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0252   0391 8800
0253   0393 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0253   0399 F000
0254   039B 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0254   03A1 7000
0255   03A3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0255   03A9 E000
0256   03AB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0256   03B1 F800
0257   03B3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0257   03B9 8000
0258   03BB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0258   03C1 7000
0259   03C3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0259   03C9 8800
0260   03CB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0260   03D1 7000
0261   03D3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0261   03D9 7000
0262   03DB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0262   03E1 8800
0263   03E3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0263   03E9 F800
0264   03EB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0264   03F1 8800
0265   03F3 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0265   03F9 8800
0266   03FB 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0266   0401 7000
0267   0403 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0267   0409 8000
0268   040B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0268   0411 7000
0269   0413 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0269   0419 8800
0270   041B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0270   0421 7000
0271   0423 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0271   0429 2000
0272   042B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0272   0431 7000
0273   0433 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0273   0439 2000
0274   043B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0274   0441 8800
0275   0443 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0275   0449 8800
0276   044B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0276   0451 2000
0277   0453 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0277   0459 F800
0278   045B             
0279   045B             ; DEC 123
0280   045B 102020402020.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0280   0461 1000
0281   0463 202020202020.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0281   0469 2000
0282   046B 402020102020.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0282   0471 4000
0283   0473 000050A00000.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0283   0479 0000
0284   047B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0284   0481 0000
0285   0483             
0286   0483             
0287   0483             
0288   0483             
0289   0483             
0290   0483             ; -----------------------------------------------------------------------------
0291   0483             ;   INICIO
0292   0483             ; -----------------------------------------------------------------------------
0293   0483             INICIO:
0294   0483 31 00 FD        LD  SP, SYSTEM
0295   0486             
0296   0486 3E 00           LD A, 0
0297   0488 32 B1 FF        LD (PORT_OUT_VAL), A
0298   048B             
0299   048B 3E C0           LD A, $c0
0300   048D 32 B0 FF        LD (PORT_SET), A
0301   0490             
0302   0490                 ; init serial
0303   0490 CD 88 0D        CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0304   0493 21 23 0D        LD    HL,TXDATA
0305   0496 22 AA FF        LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0306   0499 21 4E 0D        LD    HL,RXDATA
0307   049C 22 AC FF        LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
0308   049F                 
0309   049F 21 1B 00        LD	HL,B4800
0310   04A2 22 C0 FF    	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
0311   04A5             
0312   04A5 3E FF           LD A, $FF
0313   04A7 D3 C0           OUT (SERIAL_TX_PORT), A
0314   04A9             
0315   04A9 21 71 0F        LD HL, WELLCOME
0316   04AC CD 09 0D        CALL SNDMSG
0317   04AF             
0318   04AF                 ; CALL INCH
0319   04AF                 ; CALL OUTCH
0320   04AF             
0321   04AF                 ; Init LCD hardware
0322   04AF CD 3C 0A        CALL INIT_LCD
0323   04B2 CD CB 0B        call delay
0324   04B5             
0325   04B5 CD 54 0B        call cls_TXT
0326   04B8 CD CB 0B        call delay
0327   04BB             
0328   04BB CD DE 0A        CALL enable_grafic
0329   04BE CD CB 0B        call delay
0330   04C1             
0331   04C1 CD 5A 0B        call cls_GRAPHIC
0332   04C4 CD CB 0B        call delay
0333   04C7             
0334   04C7 CD D0 0A        call lcd_clear
0335   04CA             
0336   04CA 21 00 E5        ld hl, DISPLAY
0337   04CD CD F7 0A        call print_image
0338   04D0             
0339   04D0 CD CB 0B        call delay
0340   04D3             
0341   04D3                 ; Init LCD logical
0342   04D3 CD 2F 08        call INIT_TXT_LCD ; set cursor X Y to 0
0343   04D6             
0344   04D6 21 89 0F        LD HL, MSG_MONITOR
0345   04D9 CD F6 0C        CALL SNDLCDMSG
0346   04DC             
0347   04DC 3E 3E           LD A, '>'
0348   04DE CD BE 08        CALL PRINTCHAR
0349   04E1             
0350   04E1             KEY:
0351   04E1 CD EF 0B        CALL KEYREADINIT
0352   04E4             
0353   04E4 FE 48           CP 'H'
0354   04E6 CC F3 06        CALL Z, SHOWHELP
0355   04E9             
0356   04E9 FE 42           CP 'B'
0357   04EB CA 00 60        JP Z, BASIC
0358   04EE             
0359   04EE FE 49           CP 'I'
0360   04F0 CA E7 06        JP Z, INTEL_HEX
0361   04F3             
0362   04F3 FE 31           CP '1'
0363   04F5 CC 9E 0D        CALL Z, I2CLIST
0364   04F8             
0365   04F8 FE 32           CP '2'
0366   04FA CC 5C 06        CALL Z, I2CCPUTOMEM
0367   04FD             
0368   04FD FE 33           CP '3'
0369   04FF CC 34 06        CALL Z, I2CMEMTOCPU
0370   0502             
0371   0502 FE 47           CP 'G'
0372   0504 CC 8B 07        CALL Z, GOJUMP
0373   0507             
0374   0507 FE 4D           CP 'M'
0375   0509 CC 29 07        CALL Z, MODIFY
0376   050C             
0377   050C FE 44           CP 'D'
0378   050E CC B6 05        CALL Z, DSPLAY
0379   0511             
0380   0511 3E 0D           LD A, CR 
0381   0513 CD BE 08        CALL PRINTCHAR
0382   0516             
0383   0516 3E 3E           LD A, '>' 
0384   0518 CD BE 08        CALL PRINTCHAR
0385   051B             
0386   051B C3 E1 04        JP  KEY
0387   051E             
0388   051E             
0389   051E             ; **********************************************************************
0390   051E             ; **  Public functions                                                **
0391   051E             ; **********************************************************************
0392   051E             ; API: Main entry point
0393   051E             ;   On entry: C = Function number
0394   051E             ;             A, DE = Parameters (as specified by function)
0395   051E             ;   On exit:  AF,BC,DE,HL = Return values (as specified by function)
0396   051E             ;             IX IY I AF' BC' DE' HL' preserved
0397   051E             ; This handler modifies: F, B, HL but preserves A, C, DE
0398   051E             ; Other registers depend on API function called
0399   051E 21 30 05    APIHandler: LD   HL,APITable    ;Start of function address table
0400   0521 47                      LD   B,A            ;Preserve A
0401   0522 79                      LD   A,C            ;Get function number
0402   0523 FE 14                   CP   kAPILast+1     ;Supported function?
0403   0525 D0                      RET  NC             ;No, so abort
0404   0526 78                      LD   A,B            ;Restore A
0405   0527 06 00                   LD   B,0
0406   0529 09                      ADD  HL,BC          ;Calculate table pointer..
0407   052A 09                      ADD  HL,BC
0408   052B 46                      LD   B,(HL)         ;Read function address from table..
0409   052C 23                      INC  HL
0410   052D 66                      LD   H,(HL)
0411   052E 68                      LD   L,B
0412   052F E9                      JP   (HL)           ;Jump to function address
0413   0530             
0414   0530             
0415   0530             ; API: Function address table
0416   0530             ; This table contains a list of addresses, one for each API function. 
0417   0530             ; Each is the address of the subroutine for the relevant function.
0418   0530 58 05       APITable:   .DW  SysReset           ; 0x00 = System reset
0419   0532 5B 05                   .DW  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
0420   0534 5E 05                   .DW  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
0421   0536 61 05                   .DW  OutLcdNewLine      ; 0x03 = Output new line LCD
0422   0538 A1 05                   .DW  H_Delay            ; 0x04 = Delay in milliseconds
0423   053A 66 05                   .DW  PrtSet             ; 0x05 = Set Port (Default C0)
0424   053C 6A 05                   .DW  PrtOWr             ; 0x06 = Write to output port
0425   053E 76 05                   .DW  PrtORd             ; 0x07 = Read from output port
0426   0540 7A 05                   .DW  PrtIRd             ; 0x08 = Read from input port
0427   0542 D0 08                   .DW  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
0428   0544 81 05                   .DW  DisplayImage128x64 ; 0x0A = Print image (Pointer in DE), 128x64, 1024 bytes
0429   0546 86 05                   .DW  ClearDisplayBuffer ; 0x0B = Clear display buffer and show to lcd
0430   0548 8F 05                   .DW  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
0431   054A 58 05                   .DW  SysReset           ; 0x0D = Reserved
0432   054C 58 05                   .DW  SysReset           ; 0x0E = Reserved
0433   054E 58 05                   .DW  SysReset           ; 0x0F = Reserved
0434   0550 95 05                   .DW  I2COpen            ; 0x10 = Start i2c (Device address in A)
0435   0552 98 05                   .DW  I2CClose           ; 0x11 = Close i2c 
0436   0554 9B 05                   .DW  I2CRead            ; 0x12 = I2C Read
0437   0556 9E 05                   .DW  I2CWrite           ; 0x13 = I2C Write
0438   0558             kAPILast:   .EQU $13                ;Last API function number
0439   0558             
0440   0558             
0441   0558             
0442   0558             
0443   0558             
0444   0558             
0445   0558             
0446   0558             SysReset:
0447   0558 C3 83 04        JP INICIO
0448   055B             
0449   055B             InputCharKey:
0450   055B C3 EF 0B        JP KEYREADINIT
0451   055E             
0452   055E             OutLcdChar:
0453   055E C3 BE 08        JP PRINTCHAR
0454   0561             
0455   0561             OutLcdNewLine:
0456   0561 3E 0D           LD A, CR
0457   0563 C3 BE 08        JP PRINTCHAR
0458   0566             
0459   0566             PrtSet:
0460   0566 32 B0 FF        LD (PORT_SET), A ; define a porta padr√£o de entrada e saida
0461   0569 C9              RET
0462   056A             
0463   056A             PrtOWr:
0464   056A 47              LD B, A
0465   056B 3A B0 FF        LD A, (PORT_SET)
0466   056E 4F              LD C, A
0467   056F 78              LD A, B
0468   0570 32 B1 FF        LD (PORT_OUT_VAL), A
0469   0573 ED 79           out (C), A
0470   0575 C9              RET
0471   0576             
0472   0576             PrtORd: ; Return value from output port
0473   0576 3A B1 FF        LD A, (PORT_OUT_VAL)
0474   0579 C9              RET
0475   057A             
0476   057A             PrtIRd: ; Return value from input
0477   057A 3A B0 FF        LD A, (PORT_SET)
0478   057D 4F              LD C, A
0479   057E ED 78           in A, (C)
0480   0580 C9              RET
0481   0581             
0482   0581             DisplayImage128x64:
0483   0581 62              LD H, D
0484   0582 6B              LD L, E
0485   0583 C3 F7 0A        JP print_image
0486   0586             
0487   0586             ClearDisplayBuffer:
0488   0586 CD D0 0A        CALL lcd_clear
0489   0589 21 00 E5        LD HL, DISPLAY
0490   058C C3 F7 0A        JP print_image
0491   058F             
0492   058F             ShowBufferDisplay:
0493   058F 21 00 E5        LD HL, DISPLAY
0494   0592 C3 F7 0A        JP print_image
0495   0595             
0496   0595             I2COpen:
0497   0595 C3 B1 0E        JP I2C_Open
0498   0598             
0499   0598             I2CClose:
0500   0598 C3 B8 0E        JP I2C_Close
0501   059B             
0502   059B             I2CRead:
0503   059B C3 F8 0E        JP I2C_Read
0504   059E             
0505   059E             I2CWrite:
0506   059E C3 BB 0E        JP I2C_Write
0507   05A1             
0508   05A1             
0509   05A1             ; **********************************************************************
0510   05A1             ; Delay by DE milliseconds
0511   05A1             ;   On entry: DE = Delay time in milliseconds
0512   05A1             ;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
0513   05A1 F5          H_Delay:    PUSH AF
0514   05A2 C5                      PUSH BC
0515   05A3 D5                      PUSH DE
0516   05A4             ; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
0517   05A4 01 98 00    LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
0518   05A7             ; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
0519   05A7 0B          LoopBC:    DEC  BC             ;[6]     [4]
0520   05A8 79                      LD   A,C            ;[4]     [4]
0521   05A9 B0                      OR   B              ;[4]     [4]
0522   05AA C2 A7 05                JP   NZ,LoopBC     ;[12/7]  [8/6] 
0523   05AD             ; Have we looped once for each millisecond requested?
0524   05AD 1B                      DEC  DE             ;[6]     [4]
0525   05AE 7B                      LD   A,E            ;[4]     [4]
0526   05AF B2                      OR   D              ;[4]     [4]
0527   05B0 20 F2                   JR   NZ, LoopDE     ;[12/7]  [8/6]
0528   05B2 D1                      POP  DE
0529   05B3 C1                      POP  BC
0530   05B4 F1                      POP  AF
0531   05B5 C9                      RET
0532   05B6             
0533   05B6             ;--------------------------
0534   05B6             ; D DISPLAY MEMORY LOCATION
0535   05B6             ;--------------------------
0536   05B6 3E 44       DSPLAY: LD A, 'D'
0537   05B8 CD BE 08            CALL PRINTCHAR
0538   05BB CD B3 07            CALL  OUTSP       ;A SPACE
0539   05BE CD BF 07           CALL  GETCHR
0540   05C1 D8                 RET   C         
0541   05C2 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0542   05C5 CD BF 07           CALL  GETCHR
0543   05C8 D8                 RET   C
0544   05C9 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0545   05CC             ;
0546   05CC             ; WAIT FOR CR OR ESC
0547   05CC             ;
0548   05CC CD EF 0B    DPLAY1: CALL  KEYREADINIT
0549   05CF FE 1B              CP    ESC
0550   05D1 C8                 RET   Z
0551   05D2 FE 0D              CP    CR
0552   05D4 20 F6              JR    NZ,DPLAY1          
0553   05D6 CD B9 07           CALL  TXCRLF      ;NEWLINE
0554   05D9             ;
0555   05D9             ; DISPLAY THE LINE
0556   05D9             ;
0557   05D9 CD EE 05    DPLAY2: CALL  DPLINE
0558   05DC ED 53 B0 FE        LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
0559   05E0             ;
0560   05E0             ; DISPLAY MORE LINES OR EXIT
0561   05E0             ;       
0562   05E0 CD EF 0B    DPLAY3: CALL  KEYREADINIT
0563   05E3 38 FB              JR    C,DPLAY3   
0564   05E5 FE 0D              CP    CR        ;ENTER DISPLAYS THE NEXT LINE
0565   05E7 28 F0              JR    Z,DPLAY2
0566   05E9 FE 1B              CP    ESC         ;ESC EXITS (SHIFT + C)
0567   05EB 20 F3              JR    NZ,DPLAY3     
0568   05ED C9                 RET   
0569   05EE             ;-------------------------
0570   05EE             ; DISPLAY A LINE OF MEMORY
0571   05EE             ;-------------------------      
0572   05EE ED 5B B0 FE DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
0573   05F2 21 00 FE           LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
0574   05F5             ;
0575   05F5             ; DISPLAY THE ADDRESS
0576   05F5             ;         
0577   05F5 CD 16 08           CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
0578   05F8 CD 2E 06           CALL  SPCBUF        
0579   05FB             ;
0580   05FB             ; DISPLAY 4 BYTES
0581   05FB             ;
0582   05FB 06 04              LD    B,4 ;16
0583   05FD 1A          DLINE1: LD    A,(DE)
0584   05FE CD 1B 08           CALL  BYTASC
0585   0601 CD 2E 06           CALL  SPCBUF
0586   0604 13                 INC   DE        
0587   0605 10 F6              DJNZ  DLINE1
0588   0607                    ;CALL  SPCBUF
0589   0607             ;
0590   0607             ; NOW DISPLAY THE ASCII CHARACTER
0591   0607             ; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
0592   0607             ; BE DIFFERENT BETWEEN THE TWO PASSES!
0593   0607             ;
0594   0607 ED 5B B0 FE        LD    DE,(ADDR)    
0595   060B 06 04              LD    B,4 ;16
0596   060D 1A          DLINE2: LD    A,(DE)   
0597   060E FE 20              CP    20H
0598   0610 38 07              JR    C,DOT
0599   0612 FE 7F              CP    7FH
0600   0614 30 03              JR    NC,DOT
0601   0616 C3 1B 06           JP    NDOT
0602   0619 3E 2E       DOT:    LD    A,'.'
0603   061B CD 30 06    NDOT:   CALL  INBUF
0604   061E 13                 INC   DE       
0605   061F 10 EC              DJNZ  DLINE2
0606   0621             ;         
0607   0621             ;TERMINATE AND DISPLAY STRING
0608   0621             ;       
0609   0621 CD 33 06           CALL  BCRLF
0610   0624 3E 00              LD    A,00H
0611   0626 77                 LD    (HL),A
0612   0627 21 00 FE           LD    HL,MSGBUF
0613   062A CD F6 0C           CALL  SNDLCDMSG
0614   062D C9                 RET
0615   062E             
0616   062E             
0617   062E             ;
0618   062E             ; PUT A SPACE IN THE BUFFER
0619   062E             ;
0620   062E 3E 08       SPCBUF: LD    A, 8 ;20H(32dec)
0621   0630 77          INBUF:  LD    (HL),A
0622   0631 23                 INC   HL
0623   0632 C9                 RET
0624   0633             ;
0625   0633             ; PUT A CR LF IN THE BUFFER
0626   0633             ;        
0627   0633             BCRLF:  ;LD    A,CR  
0628   0633                    ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
0629   0633 C9                 RET
0630   0634             
0631   0634             
0632   0634             
0633   0634             
0634   0634             
0635   0634             
0636   0634             I2CMEMTOCPU:
0637   0634                 ; Get parameters to copy a block from I2C memory to CPU memory
0638   0634             ;   On entry: DE = First address in I2C memory
0639   0634             ;             HL = First address in CPU memory
0640   0634             ;             BC = Number of bytes to be copied
0641   0634             ;             SCL = unknown, SDA = unknown
0642   0634             ;   On exit:  If successfully A = 0 and Z flagged
0643   0634             ;             If unsuccessfully A = Error and NZ flagged
0644   0634             ;             IX IY preserved
0645   0634             
0646   0634 21 3C 10        LD HL, MSG_MEM2CPU
0647   0637 CD F6 0C        CALL SNDLCDMSG
0648   063A             
0649   063A CD 84 06        CALL GET_FROM_TO_SIZE
0650   063D             
0651   063D             ;    DE = First address in I2C memory
0652   063D             ;    HL = First address in CPU memory
0653   063D             ;    BC = Number of bytes to be copied
0654   063D             
0655   063D ED 5B B2 FE     LD DE, (ADDR_FROM)
0656   0641 2A B4 FE        LD HL, (ADDR_TO)
0657   0644 ED 4B B6 FE     LD BC, (ADDR_SIZE)
0658   0648 CD C8 0D        CALL I2C_MemRd  
0659   064B             
0660   064B CA 55 06        JP Z, I2CMEMTOCPU_OK
0661   064E 21 8D 10        LD HL, MSG_COPYFAIL
0662   0651 CD F6 0C        CALL SNDLCDMSG
0663   0654 C9              RET
0664   0655             I2CMEMTOCPU_OK:
0665   0655 21 84 10        LD HL, MSG_COPYOK
0666   0658 CD F6 0C        CALL SNDLCDMSG
0667   065B C9              RET
0668   065C             
0669   065C             
0670   065C             I2CCPUTOMEM:
0671   065C             ; Get parameters to copy a block from CPU memory to I2C memory
0672   065C             ;   On entry: DE = First address in I2C memory
0673   065C             ;             HL = First address in CPU memory
0674   065C             ;             BC = Number of bytes to be copied
0675   065C             ;             SCL = unknown, SDA = unknown
0676   065C             ;   On exit:  If successfully A = 0 and Z flagged
0677   065C             ;             If unsuccessfully A = Error and NZ flagged
0678   065C             ;             IX IY preserved
0679   065C             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
0680   065C             ; pages.
0681   065C 21 52 10        LD HL, MSG_CPU2MEM
0682   065F CD F6 0C        CALL SNDLCDMSG
0683   0662             
0684   0662 CD 84 06        CALL GET_FROM_TO_SIZE
0685   0665             
0686   0665             ;    DE = First address in I2C memory
0687   0665             ;    HL = First address in CPU memory
0688   0665             ;    BC = Number of bytes to be copied
0689   0665             
0690   0665 2A B2 FE        LD HL, (ADDR_FROM)
0691   0668 ED 5B B4 FE     LD DE, (ADDR_TO)
0692   066C ED 4B B6 FE     LD BC, (ADDR_SIZE)
0693   0670 CD FD 0D        CALL I2C_MemWr
0694   0673                 
0695   0673 CA 7D 06        JP Z, I2CCPUTOMEM_OK
0696   0676 21 8D 10        LD HL, MSG_COPYFAIL
0697   0679 CD F6 0C        CALL SNDLCDMSG
0698   067C C9              RET
0699   067D             I2CCPUTOMEM_OK:
0700   067D 21 84 10        LD HL, MSG_COPYOK
0701   0680 CD F6 0C        CALL SNDLCDMSG
0702   0683 C9              RET
0703   0684             
0704   0684             
0705   0684             
0706   0684             
0707   0684             
0708   0684             
0709   0684             GET_FROM_TO_SIZE:
0710   0684                 ; FROM
0711   0684 21 68 10        LD HL, MSG_FROM
0712   0687 CD F6 0C        CALL SNDLCDMSG
0713   068A                 ;
0714   068A                 ;GET THE ADDRESS  FROM
0715   068A                 ;
0716   068A CD BF 07        CALL  GETCHR 
0717   068D D8              RET   C        
0718   068E 32 B3 FE        LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
0719   0691 CD BF 07        CALL  GETCHR
0720   0694 D8              RET   C
0721   0695 32 B2 FE        LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW
0722   0698             
0723   0698 CD EF 0B        CALL  KEYREADINIT
0724   069B FE 1B           CP    ESC         ;ESC KEY?
0725   069D C8              RET   Z
0726   069E FE 0D           CP    CR
0727   06A0 28 08           JR Z, GET_FROM_TO_SIZE_TO
0728   06A2 3E 0D           LD A, CR
0729   06A4 CD BE 08        CALL PRINTCHAR
0730   06A7 C3 84 06        JP GET_FROM_TO_SIZE
0731   06AA             
0732   06AA             GET_FROM_TO_SIZE_TO:
0733   06AA                 ; TO
0734   06AA 21 6F 10        LD HL, MSG_TO
0735   06AD CD F6 0C        CALL SNDLCDMSG
0736   06B0                 ;
0737   06B0                 ;GET THE ADDRESS  TO
0738   06B0                 ;
0739   06B0 CD BF 07        CALL  GETCHR 
0740   06B3 D8              RET   C        
0741   06B4 32 B5 FE        LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
0742   06B7 CD BF 07        CALL  GETCHR
0743   06BA D8              RET   C
0744   06BB 32 B4 FE        LD    (ADDR_TO),A    ;SAVE ADDRESS LOW
0745   06BE             
0746   06BE CD EF 0B        CALL  KEYREADINIT
0747   06C1 FE 1B           CP    ESC         ;ESC KEY?
0748   06C3 C8              RET   Z
0749   06C4 FE 0D           CP    CR
0750   06C6 20 E2           JR NZ, GET_FROM_TO_SIZE_TO
0751   06C8             
0752   06C8             GET_FROM_TO_SIZE_SIZE:
0753   06C8                 ; SIZE
0754   06C8 21 75 10        LD HL, MSG_SIZE
0755   06CB CD F6 0C        CALL SNDLCDMSG
0756   06CE                 ;
0757   06CE                 ;GET THE SIZE
0758   06CE                 ;
0759   06CE CD BF 07        CALL  GETCHR 
0760   06D1 D8              RET   C        
0761   06D2 32 B7 FE        LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
0762   06D5 CD BF 07        CALL  GETCHR
0763   06D8 D8              RET   C
0764   06D9 32 B6 FE        LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW
0765   06DC             
0766   06DC CD EF 0B        CALL  KEYREADINIT
0767   06DF FE 1B           CP    ESC         ;ESC KEY?
0768   06E1 C8              RET   Z
0769   06E2 FE 0D           CP    CR
0770   06E4 20 E2           JR NZ, GET_FROM_TO_SIZE_SIZE
0771   06E6 C9              RET
0772   06E7             
0773   06E7             
0774   06E7             INTEL_HEX:
0775   06E7 CD 43 0C        CALL INTHEX
0776   06EA CD CB 0B        CALL delay
0777   06ED CD CB 0B        CALL delay
0778   06F0 C3 83 04        JP INICIO
0779   06F3             
0780   06F3             SHOWHELP:
0781   06F3 3E 0C           LD A, $0C ; limpar tela
0782   06F5 CD BE 08        CALL PRINTCHAR
0783   06F8             
0784   06F8 21 9E 0F        LD HL, MSG_MENU1
0785   06FB CD F6 0C        CALL SNDLCDMSG
0786   06FE             
0787   06FE 21 B4 0F        LD HL, MSG_MENU2
0788   0701 CD F6 0C        CALL SNDLCDMSG
0789   0704             
0790   0704 21 BF 0F        LD HL, MSG_MENU3
0791   0707 CD F6 0C        CALL SNDLCDMSG
0792   070A             
0793   070A 21 D1 0F        LD HL, MSG_MENU4
0794   070D CD F6 0C        CALL SNDLCDMSG
0795   0710             
0796   0710 21 E2 0F        LD HL, MSG_MENU5
0797   0713 CD F6 0C        CALL SNDLCDMSG
0798   0716             
0799   0716 21 F2 0F        LD HL, MSG_MENU6
0800   0719 CD F6 0C        CALL SNDLCDMSG
0801   071C             
0802   071C 21 00 10        LD HL, MSG_MENU7
0803   071F CD F6 0C        CALL SNDLCDMSG
0804   0722             
0805   0722 21 13 10        LD HL, MSG_MENU8
0806   0725 CD F6 0C        CALL SNDLCDMSG
0807   0728             
0808   0728 C9              RET
0809   0729             
0810   0729             
0811   0729             ;----------------------------
0812   0729             ; M DISPLAY AND MODIFY MEMORY
0813   0729             ;----------------------------
0814   0729 3E 4D       MODIFY: LD A, 'M'
0815   072B CD BE 08            CALL PRINTCHAR
0816   072E CD B3 07         CALL  OUTSP
0817   0731             ;
0818   0731             ;GET THE ADDRESS        
0819   0731             ;
0820   0731 CD BF 07           CALL  GETCHR 
0821   0734 D8                 RET   C        
0822   0735 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0823   0738 CD BF 07           CALL  GETCHR
0824   073B D8                 RET   C
0825   073C 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0826   073F             ;
0827   073F             ; DISPLAY ON A NEW LINE
0828   073F             ;       
0829   073F CD B9 07    MDIFY1: CALL  TXCRLF       
0830   0742 ED 5B B0 FE        LD    DE,(ADDR)    
0831   0746 21 00 FE           LD    HL,MSGBUF   
0832   0749 CD 16 08           CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
0833   074C 21 00 FE           LD    HL,MSGBUF
0834   074F CD 0A 08           CALL  WRDOUT      ;OUTPUT THE ADDRESS
0835   0752 CD B3 07           CALL  OUTSP    
0836   0755             ;      
0837   0755             ;GET THE DATA AT THE ADDRESS        
0838   0755             ;
0839   0755 2A B0 FE            LD   HL,(ADDR)       
0840   0758 7E                  LD   A,(HL)
0841   0759             ;
0842   0759             ; DISPLAY THE DATA
0843   0759             ;        
0844   0759 21 00 FE           LD    HL,MSGBUF
0845   075C CD 1B 08           CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
0846   075F 21 00 FE           LD    HL,MSGBUF
0847   0762 CD 0D 08           CALL  BYTOUT      ;OUTPUT THE BYTE
0848   0765 CD B3 07           CALL  OUTSP
0849   0768             ;
0850   0768             ; GET NEW DATA,EXIT OR CONTINUE
0851   0768             ;
0852   0768 CD BF 07           CALL  GETCHR
0853   076B D8                 RET   C
0854   076C 47                 LD    B,A         ;SAVE IT FOR LATER
0855   076D 2A B0 FE           LD    HL,(ADDR)
0856   0770 77                 LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
0857   0771 78                 LD    A,B
0858   0772 BE                 CP    (HL)
0859   0773 28 05              JR    Z,MDIFY2
0860   0775 3E 3F              LD    A,'?'
0861   0777 CD BE 08           CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
0862   077A             ;
0863   077A             ; INCREMENT THE ADDRESS
0864   077A             ;
0865   077A 23          MDIFY2: INC   HL
0866   077B 22 B0 FE           LD    (ADDR),HL
0867   077E C3 3F 07           JP    MDIFY1
0868   0781             
0869   0781             
0870   0781             
0871   0781             ;------------------------------
0872   0781             ; GO <ADDR>
0873   0781             ; TRANSFERS EXECUTION TO <ADDR>
0874   0781             ;------------------------------
0875   0781             GOJUMP_new:
0876   0781 3E 0D           LD A, CR
0877   0783 CD BE 08        CALL PRINTCHAR
0878   0786             
0879   0786 3E 3E           LD A, '>'
0880   0788 CD BE 08        CALL PRINTCHAR
0881   078B             
0882   078B 3E 47       GOJUMP: LD A, 'G'
0883   078D CD BE 08            CALL PRINTCHAR
0884   0790 CD B3 07           CALL  OUTSP       
0885   0793 CD BF 07           CALL  GETCHR      ;GET ADDRESS HIGH BYTE
0886   0796 D8                 RET   C
0887   0797 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0888   079A CD BF 07           CALL  GETCHR      ;GET ADDRESS LOW BYTE
0889   079D D8                 RET   C
0890   079E 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0891   07A1             ;
0892   07A1             ; WAIT FOR A CR OR ESC
0893   07A1             ;       
0894   07A1 CD EF 0B    GOJMP1: CALL  KEYREADINIT
0895   07A4 FE 1B              CP    ESC         ;ESC KEY?
0896   07A6 C8                 RET   Z
0897   07A7 FE 0D              CP    CR
0898   07A9                    ;JR    NZ,GOJMP1
0899   07A9 20 D6              JR NZ, GOJUMP_new
0900   07AB CD B9 07           CALL  TXCRLF
0901   07AE E1                 POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
0902   07AF 2A B0 FE           LD    HL,(ADDR)
0903   07B2 E9                 JP    (HL)        ;GOOD LUCK WITH THAT!
0904   07B3             
0905   07B3             
0906   07B3             ;---------------
0907   07B3             ; OUTPUT A SPACE
0908   07B3             ;---------------
0909   07B3 3E 20       OUTSP:  LD    A, ' '
0910   07B5 CD BE 08           CALL  PRINTCHAR
0911   07B8 C9                 RET
0912   07B9             
0913   07B9             ;-------------      
0914   07B9             ; OUTPUT CRLF
0915   07B9             ;------------
0916   07B9 3E 0D       TXCRLF: LD   A,CR
0917   07BB CD BE 08           CALL PRINTCHAR   
0918   07BE C9                 RET
0919   07BF             
0920   07BF             ;-----------------------------
0921   07BF             ; GET A BYTE FROM THE TERMINAL
0922   07BF             ;-----------------------------
0923   07BF CD EF 0B    GETCHR: CALL KEYREADINIT ; read key
0924   07C2 FE 1B              CP    ESC
0925   07C4 28 27              JR    Z,GETOUT
0926   07C6 47                 LD    B,A                ;SAVE TO ECHO      
0927   07C7 CD EF 07           CALL  ASC2HEX
0928   07CA 30 F3              JR    NC,GETCHR          ;REJECT NON HEX CHARS    
0929   07CC 21 B8 FE           LD    HL,DATA
0930   07CF 77                 LD    (HL),A 
0931   07D0 78                 LD    A,B         
0932   07D1 CD BE 08           CALL  PRINTCHAR             ;ECHO VALID HEX
0933   07D4                    
0934   07D4 CD EF 0B    GETNYB: CALL  KEYREADINIT
0935   07D7 FE 1B              CP    ESC
0936   07D9 28 12              JR    Z,GETOUT
0937   07DB 47                 LD    B,A               ;SAVE TO ECHO
0938   07DC CD EF 07           CALL  ASC2HEX
0939   07DF 30 F3              JR    NC,GETNYB         ;REJECT NON HEX CHARS
0940   07E1 ED 6F              RLD
0941   07E3 78                 LD    A,B
0942   07E4 CD BE 08           CALL  PRINTCHAR             ;ECHO VALID HEX
0943   07E7 7E                 LD    A,(HL)
0944   07E8 CD ED 07           CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
0945   07EB 3F                 CCF                    ;AND THEN COMPLEMENTING IT
0946   07EC C9                 RET   
0947   07ED 37          GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
0948   07EE C9                 RET
0949   07EF             
0950   07EF             
0951   07EF             ;----------------------------------------
0952   07EF             ; CONVERT ASCII CHARACTER INTO HEX NYBBLE
0953   07EF             ;----------------------------------------
0954   07EF             ; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
0955   07EF             ; ENTRY OTHER THAN HEXADECIMAL KEYS
0956   07EF             ;
0957   07EF             ;CONVERTS ASCII 0-9,A-F INTO HEX LSN
0958   07EF             ;ENTRY : A= ASCII 0-9,A-F
0959   07EF             ;EXIT  : CARRY =  1
0960   07EF             ;          A= HEX 0-F IN LSN    
0961   07EF             ;      : CARRY = 0
0962   07EF             ;          A= OUT OF RANGE CHARACTER & 7FH
0963   07EF             ; A AND F REGISTERS MODIFIED
0964   07EF             ;
0965   07EF E6 7F       ASC2HEX: AND   7FH        ;STRIP OUT PARITY
0966   07F1 FE 30              CP    30H
0967   07F3 38 12              JR    C,AC2HEX3    ;LESS THAN 0
0968   07F5 FE 3A              CP    3AH
0969   07F7 30 02              JR    NC,AC2HEX2   ;MORE THAN 9
0970   07F9 37          AC2HEX1: SCF               ;SET THE CARRY - IS HEX
0971   07FA C9                 RET
0972   07FB             ;     
0973   07FB FE 41       AC2HEX2: CP    41H
0974   07FD 38 08              JR    C,AC2HEX3    ;LESS THAN A
0975   07FF FE 47              CP    47H
0976   0801 30 04              JR    NC,AC2HEX3   ;MORE THAN F
0977   0803 D6 07              SUB   07H        ;CONVERT TO NYBBLE
0978   0805 18 F2              JR    AC2HEX1  
0979   0807 E6 FF       AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
0980   0809 C9                 RET
0981   080A             
0982   080A             
0983   080A             ;----------------------     
0984   080A             ; SEND ASCII HEX VALUES        
0985   080A             ;----------------------
0986   080A             ;
0987   080A             ; OUTPUT THE 4 BYTE, WRDOUT
0988   080A             ; THE 2 BYTE, BYTOUT
0989   080A             ; OR THE SINGLE BYTE, NYBOUT
0990   080A             ; ASCII STRING AT HL TO THE SERIAL PORT
0991   080A             ;
0992   080A CD 0D 08    WRDOUT: CALL  BYTOUT
0993   080D CD 10 08    BYTOUT: CALL  NYBOUT
0994   0810 7E          NYBOUT: LD    A,(HL)
0995   0811 CD BE 08           CALL  PRINTCHAR
0996   0814 23                 INC   HL
0997   0815 C9                 RET       
0998   0816             ;----------------
0999   0816             ;CONVERT TO ASCII 
1000   0816             ;----------------
1001   0816             ;
1002   0816             ; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
1003   0816             ;
1004   0816             ;         ENTRY :  A = BINARY TO CONVERT
1005   0816             ;                  HL = CHARACTER BUFFER ADDRESS   
1006   0816             ;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
1007   0816             ;   
1008   0816             ;        MODIFIES : DE
1009   0816             
1010   0816 7A          WRDASC: LD    A,D         ;CONVERT AND
1011   0817 CD 1B 08           CALL  BYTASC      ;OUTPUT D
1012   081A 7B                 LD    A,E         ;THEN E
1013   081B             ;
1014   081B             ;CONVERT A BYTE TO ASCII 
1015   081B             ;
1016   081B F5          BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
1017   081C 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
1018   081D 0F                 RRCA
1019   081E 0F                 RRCA
1020   081F 0F                 RRCA
1021   0820 CD 24 08           CALL NYBASC       ;CALL NYBBLE CONVERTER 
1022   0823 F1                 POP AF            ;RESTORE LOW NYBBLE
1023   0824             
1024   0824             ;           
1025   0824             ; CONVERT A NYBBLE TO ASCII
1026   0824             ;
1027   0824 E6 0F       NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
1028   0826 C6 90              ADD   A,90H       ;CONVERT TO
1029   0828 27                 DAA               ;ASCII
1030   0829 CE 40              ADC   A,40H
1031   082B 27                 DAA
1032   082C             ;            
1033   082C             ; SAVE IN STRING
1034   082C             ;
1035   082C 77          INSBUF: LD    (HL),A
1036   082D 23                 INC   HL 
1037   082E C9                 RET 
1038   082F             
1039   082F             
1040   082F             
1041   082F             INIT_TXT_LCD:
1042   082F 3E 00           ld a, 0
1043   0831 32 03 E0        ld (LCD_TXT_X), a
1044   0834 32 04 E0        ld (LCD_TXT_Y), a
1045   0837 32 0F E0        ld (LCD_DELETE_CHAR), a
1046   083A 32 10 E0        ld (LCD_AUTO_X), a
1047   083D 21 00 00        ld hl, 0
1048   0840 22 08 E0        ld (LCD_TXT_X_TMP), hl
1049   0843 23              inc hl
1050   0844 22 0A E0        ld (LCD_TXT_Y_TMP), hl
1051   0847 C9              RET
1052   0848             
1053   0848             
1054   0848             DISPLAY_SCROLL_UP:
1055   0848                 ; cada linha tem 128 bytes
1056   0848                 ; temos 8 linhas
1057   0848                 ; total 1024 bytes
1058   0848             
1059   0848                 ; display lines 0 to 7
1060   0848                 ; move line 1 to 0
1061   0848 21 80 E5        ld hl, DISPLAY+128
1062   084B 11 00 E5        ld de, DISPLAY
1063   084E 01 7F 00        ld bc, 127
1064   0851 ED B0           ldir
1065   0853             
1066   0853                 ; move line 2 to 1
1067   0853 21 00 E6        ld hl, DISPLAY+256
1068   0856 11 80 E5        ld de, DISPLAY+128
1069   0859 01 7F 00        ld bc, 127
1070   085C ED B0           ldir
1071   085E             
1072   085E                 ; move line 3 to 2
1073   085E 21 80 E6        ld hl, DISPLAY+384
1074   0861 11 00 E6        ld de, DISPLAY+256
1075   0864 01 7F 00        ld bc, 127
1076   0867 ED B0           ldir
1077   0869             
1078   0869                 ; move line 4 to 3
1079   0869 21 00 E7        ld hl, DISPLAY+512
1080   086C 11 80 E6        ld de, DISPLAY+384
1081   086F 01 7F 00        ld bc, 127
1082   0872 ED B0           ldir
1083   0874             
1084   0874                 ; move line 5 to 4
1085   0874 21 80 E7        ld hl, DISPLAY+640
1086   0877 11 00 E7        ld de, DISPLAY+512
1087   087A 01 7F 00        ld bc, 127
1088   087D ED B0           ldir
1089   087F             
1090   087F                 ; move line 6 to 5
1091   087F 21 00 E8        ld hl, DISPLAY+768
1092   0882 11 80 E7        ld de, DISPLAY+640
1093   0885 01 7F 00        ld bc, 127
1094   0888 ED B0           ldir
1095   088A             
1096   088A                 ; move line 7 to 6
1097   088A 21 80 E8        ld hl, DISPLAY+896
1098   088D 11 00 E8        ld de, DISPLAY+768
1099   0890 01 7F 00        ld bc, 127
1100   0893 ED B0           ldir
1101   0895             
1102   0895                 ; clear line 7
1103   0895                 ; 896 to 1024
1104   0895 21 80 E8        ld hl, DISPLAY+896
1105   0898 5D              ld e,l
1106   0899 54              ld d,h
1107   089A 13              inc de
1108   089B 36 00           ld (hl), 0
1109   089D 01 7F 00        ld bc, 127
1110   08A0 ED B0           ldir
1111   08A2             
1112   08A2 C9              RET
1113   08A3             
1114   08A3             DELETE_CHAR:
1115   08A3 E1              POP HL ; retorno do call
1116   08A4 3E 00           LD A, 0
1117   08A6 32 0F E0        LD (LCD_DELETE_CHAR), A
1118   08A9 3A 03 E0        LD A, (LCD_TXT_X)
1119   08AC 3D              DEC A
1120   08AD 32 03 E0        LD (LCD_TXT_X), A
1121   08B0             
1122   08B0 3E FF           LD A, $FF
1123   08B2 32 10 E0        LD (LCD_AUTO_X), A
1124   08B5             
1125   08B5 F1              POP AF
1126   08B6 3E 20           LD A, ' '
1127   08B8 32 00 E0        LD (LCD_CHAR), A
1128   08BB F5              PUSH AF
1129   08BC E5              PUSH HL ; call
1130   08BD C9              RET
1131   08BE             
1132   08BE             
1133   08BE             ; Print char in buffer and show to lcd
1134   08BE             ; char in A
1135   08BE             PRINTCHAR:
1136   08BE F5              PUSH AF
1137   08BF C5              PUSH BC
1138   08C0 D5              PUSH DE
1139   08C1 E5              PUSH HL
1140   08C2 CD D0 08        CALL PrintBufferChar
1141   08C5 21 00 E5        LD HL, DISPLAY
1142   08C8 CD F7 0A        CALL print_image
1143   08CB E1              POP HL
1144   08CC D1              POP DE
1145   08CD C1              POP BC
1146   08CE F1              POP AF
1147   08CF C9              RET
1148   08D0             
1149   08D0             
1150   08D0             ; Print char in buffer lcd (without show to lcd)
1151   08D0             ; char in A
1152   08D0             PrintBufferChar:
1153   08D0 32 00 E0        LD (LCD_CHAR), A ; save char to print
1154   08D3             
1155   08D3 F5              PUSH AF
1156   08D4 C5              PUSH BC
1157   08D5 D5              PUSH DE
1158   08D6 E5              PUSH HL
1159   08D7             
1160   08D7 F5              PUSH AF
1161   08D8 3E 00           LD A, $0
1162   08DA 32 10 E0        LD (LCD_AUTO_X), A
1163   08DD F1              POP AF
1164   08DE             
1165   08DE             
1166   08DE             ver_delete:
1167   08DE F5              PUSH AF
1168   08DF 3A 0F E0        LD A, (LCD_DELETE_CHAR)
1169   08E2 B7              or a
1170   08E3 FE FF           CP $FF
1171   08E5 CC A3 08        call z, DELETE_CHAR
1172   08E8 F1              POP AF
1173   08E9 B7              or a
1174   08EA FE 00           CP $0
1175   08EC 20 08           jr nz, ver_enter
1176   08EE 3E FF           LD A, $FF ; delete proximo char
1177   08F0 32 0F E0        LD (LCD_DELETE_CHAR), A
1178   08F3 C3 1B 0A        jp print_char_fim
1179   08F6             
1180   08F6                 ; Verificar Enter, clear, etc... SEM PERDER O reg. A
1181   08F6             ver_enter:       
1182   08F6             
1183   08F6                             ; trata dados para o lcd
1184   08F6 FE 0D                       CP      CR                     ; compara com ENTER
1185   08F8 20 1A                       jr      nz, ver_limpa
1186   08FA             
1187   08FA 3E 00                       LD A,0
1188   08FC 32 03 E0                    LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
1189   08FF             
1190   08FF 3A 04 E0                    LD A, (LCD_TXT_Y)
1191   0902 3C                          inc a
1192   0903 FE 08                       cp 8
1193   0905 C2 0E 09                    jp nz, ver_enter_incYOK
1194   0908                             
1195   0908 CD 48 08                    CALL DISPLAY_SCROLL_UP
1196   090B                             ;ld hl, DISPLAY
1197   090B                             ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1198   090B                             
1199   090B C3 1B 0A                    jp print_char_fim
1200   090E             
1201   090E             ver_enter_incYOK:
1202   090E 32 04 E0                    ld (LCD_TXT_Y), a
1203   0911 C3 1B 0A                    jp print_char_fim
1204   0914             
1205   0914             
1206   0914             ver_limpa:
1207   0914 FE 0C                       CP      $0C                     ; compara com limpar tela
1208   0916 20 0E                       jr      NZ, ver_line
1209   0918                             
1210   0918                             ;call    clear_lcd_screen
1211   0918                             ;call    show_lcd_screen
1212   0918 CD D0 0A                    call lcd_clear
1213   091B                             ;ld hl, DISPLAY
1214   091B                             ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1215   091B 3E 00                       LD A, 0
1216   091D 32 03 E0                    LD (LCD_TXT_X), A
1217   0920 32 04 E0                    LD (LCD_TXT_Y), A
1218   0923             
1219   0923 C3 1B 0A                    JP print_char_fim
1220   0926             
1221   0926             ver_line:
1222   0926 FE 0A                       CP      LF                     ; retorna come√ßo da linha
1223   0928 20 03                       jr      NZ, print_lcd      
1224   092A             
1225   092A                                 ;----- verificar se precisa add algo aqui
1226   092A                             ;call    shift_lcd_up
1227   092A                             ;call    show_lcd_screen
1228   092A C3 1B 0A                    JP print_char_fim
1229   092D             
1230   092D             print_lcd:
1231   092D                 ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
1232   092D 26 00           ld H, 0
1233   092F 6F              ld L, A
1234   0930 29              ADD HL, HL ; hl x 8
1235   0931 29              ADD HL, HL
1236   0932 29              ADD HL, HL
1237   0933             
1238   0933 54              LD D, H
1239   0934 5D              LD E, L
1240   0935 21 83 00        ld hl, TABLE
1241   0938 19              add hl, de
1242   0939 22 01 E0        ld (LCD_CHAR_POINT), HL ; table
1243   093C             
1244   093C             
1245   093C                 ; ajusta X
1246   093C 06 06           ld b, 6
1247   093E 3A 03 E0        ld a, (LCD_TXT_X)
1248   0941 B7              or A
1249   0942 CA 4C 09        jp z, ajustX
1250   0945 4F              ld c, a
1251   0946 CD 20 0A        call multiplication
1252   0949 C3 4F 09        jp ajustXOK
1253   094C                 
1254   094C             ajustX:
1255   094C 21 00 00        ld hl, 0
1256   094F             ajustXOK:
1257   094F 22 08 E0        ld (LCD_TXT_X_TMP), HL 
1258   0952             
1259   0952             
1260   0952             
1261   0952                 ; ajuste Y
1262   0952 16 04           ld d, 4
1263   0954 1E 00           ld e, 0 ; = 128x8 proxima linha
1264   0956 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1265   0959 3A 04 E0        ld a, (LCD_TXT_Y)
1266   095C B7              or a
1267   095D CA 6D 09        JP Z, multYfim
1268   0960 21 00 00        ld hl, 0
1269   0963 47              ld b, a
1270   0964             multY:
1271   0964 19              add hl, de
1272   0965 10 FD           DJNZ multY
1273   0967             
1274   0967 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1275   096A C3 73 09        jp multYfimok
1276   096D             
1277   096D             multYfim:
1278   096D 21 00 00        ld hl, 0
1279   0970 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1280   0973             
1281   0973             multYfimok:
1282   0973             
1283   0973 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1284   0976 ED 5B 08 E0     ld de, (LCD_TXT_X_TMP)
1285   097A             
1286   097A 19              add hl, de  ; hl tem pos do pix 0-8191
1287   097B             
1288   097B 22 0E E0        ld (LCD_TMP_POINT), hl
1289   097E             
1290   097E             
1291   097E 3E 08           ld a, 8 ; altura do caracter
1292   0980 32 0C E0        ld (LCD_CHAR_H), a
1293   0983             printchar_loopH:
1294   0983 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1295   0986 7E              ld a, (HL)
1296   0987 32 10 E1        ld (LCD_TEMP), a
1297   098A             
1298   098A 3E 06           ld a, 6 ; largura do caracter
1299   098C 32 0D E0        ld (LCD_CHAR_W), a
1300   098F             printchar_loopW:
1301   098F 3A 10 E1        ld a, (LCD_TEMP)
1302   0992 E6 80           and 128
1303   0994 FE 00           cp 0
1304   0996 CA A2 09        jp z, printchar_loopWC
1305   0999 2A 0E E0        ld hl, (LCD_TMP_POINT)
1306   099C CD 5B 0A        call lcd_setPixel
1307   099F C3 A8 09        JP printchar_loopWE
1308   09A2             
1309   09A2             printchar_loopWC:
1310   09A2 2A 0E E0        ld hl, (LCD_TMP_POINT)
1311   09A5 CD 94 0A        call lcd_clearPixel
1312   09A8             
1313   09A8             printchar_loopWE:
1314   09A8 3A 10 E1        ld a, (LCD_TEMP)
1315   09AB CB 27           sla a
1316   09AD 32 10 E1        ld (LCD_TEMP), a
1317   09B0                 
1318   09B0 2A 0E E0        ld hl, (LCD_TMP_POINT)
1319   09B3 23              inc hl
1320   09B4 22 0E E0        ld (LCD_TMP_POINT), hl
1321   09B7             
1322   09B7 3A 0D E0        ld a, (LCD_CHAR_W)
1323   09BA 3D              dec A
1324   09BB 32 0D E0        ld (LCD_CHAR_W), a
1325   09BE FE 00           cp 0
1326   09C0 C2 8F 09        JP NZ, printchar_loopW
1327   09C3             
1328   09C3             
1329   09C3 2A 0E E0        ld hl, (LCD_TMP_POINT)
1330   09C6 2B              dec hl
1331   09C7 2B              dec hl
1332   09C8 2B              dec hl
1333   09C9 2B              dec hl
1334   09CA 2B              dec hl
1335   09CB 2B              dec hl
1336   09CC             
1337   09CC 16 00           ld d, 0
1338   09CE 1E 80           ld e, 128
1339   09D0 19              add hl, de
1340   09D1 22 0E E0        ld (LCD_TMP_POINT), HL
1341   09D4             
1342   09D4 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1343   09D7 23              inc hl
1344   09D8 22 01 E0        ld (LCD_CHAR_POINT), hl
1345   09DB             
1346   09DB             
1347   09DB 3A 0C E0        ld a, (LCD_CHAR_H)
1348   09DE 3D              dec A
1349   09DF 32 0C E0        ld (LCD_CHAR_H), a
1350   09E2 FE 00           cp 0
1351   09E4 C2 83 09        jp NZ, printchar_loopH
1352   09E7             
1353   09E7                 ;ld hl, DISPLAY
1354   09E7                 ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1355   09E7             
1356   09E7             
1357   09E7                 ; check auto x
1358   09E7 3A 10 E0        LD A, (LCD_AUTO_X)
1359   09EA B7              OR A
1360   09EB FE FF           CP $FF
1361   09ED CA 1B 0A        JP Z, print_char_fim
1362   09F0             
1363   09F0                 ; increment X, Y
1364   09F0 3A 03 E0        ld a, (LCD_TXT_X)
1365   09F3 3C              inc a
1366   09F4 FE 15           cp 21
1367   09F6 C2 18 0A        jp nz, incXOK
1368   09F9 3E 00           ld a, 0
1369   09FB 32 03 E0        ld (LCD_TXT_X), a
1370   09FE 3A 04 E0        ld a, (LCD_TXT_Y)
1371   0A01 3C              inc a
1372   0A02 FE 08           cp 8
1373   0A04 C2 12 0A        jp nz, incYOK
1374   0A07 CD 48 08        CALL DISPLAY_SCROLL_UP
1375   0A0A                 ;ld hl, DISPLAY
1376   0A0A                 ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1377   0A0A 3E 00           ld a, 0
1378   0A0C 32 03 E0        ld (LCD_TXT_X), a
1379   0A0F C3 1B 0A        jp print_char_fim
1380   0A12             
1381   0A12             incYOK:
1382   0A12 32 04 E0        ld (LCD_TXT_Y), a
1383   0A15 C3 1B 0A        jp print_char_fim
1384   0A18             
1385   0A18             incXOK:
1386   0A18 32 03 E0        ld (LCD_TXT_X), a
1387   0A1B             
1388   0A1B             print_char_fim:
1389   0A1B                 ;ld hl, DISPLAY
1390   0A1B                 ;CALL print_image
1391   0A1B E1              POP HL
1392   0A1C D1              POP DE
1393   0A1D C1              POP BC
1394   0A1E F1              POP AF
1395   0A1F C9              RET
1396   0A20             ;-------- FIM PRINTCHAR ------------------
1397   0A20             
1398   0A20             
1399   0A20             
1400   0A20             ; ----------------------------------
1401   0A20             
1402   0A20             ; INPUT: THE VALUES IN REGISTER B EN C
1403   0A20             ; OUTPUT: HL = B * C
1404   0A20             ; CHANGES: AF,DE,HL,B
1405   0A20             ;
1406   0A20             multiplication:
1407   0A20 21 00 00    	LD HL,0
1408   0A23 78          	LD A,B
1409   0A24 B7          	OR A
1410   0A25 C8          	RET Z
1411   0A26 16 00       	LD D,0
1412   0A28 59          	LD E,C
1413   0A29 19          multiplicationLOOP:	ADD HL,DE
1414   0A2A 10 FD       	DJNZ multiplicationLOOP
1415   0A2C C9          	RET 
1416   0A2D             
1417   0A2D             ;-----------------------------------
1418   0A2D             
1419   0A2D             Div_HL_D:
1420   0A2D             ;Inputs:
1421   0A2D             ;   HL and D
1422   0A2D             ;Outputs:
1423   0A2D             ;   HL is the quotient (HL/D)
1424   0A2D             ;   A is the remainder
1425   0A2D             ;   B is 0
1426   0A2D             ;   C,D,E are preserved
1427   0A2D AF              xor a         ; Clear upper eight bits of AHL
1428   0A2E 06 10           ld b,16       ; Sixteen bits in dividend
1429   0A30             _loop:
1430   0A30 29              add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
1431   0A31 17              rla           ; This moves the upper bits of the dividend into A
1432   0A32 38 03           jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
1433   0A34 BA              cp d          ; Check if we can subtract the divisor
1434   0A35 38 02           jr c,_skip    ; Carry means A < D
1435   0A37             _overflow:
1436   0A37 92              sub d         ; Do subtraction for real this time
1437   0A38 2C              inc l         ; Set the next bit of the quotient (currently bit 0)
1438   0A39             _skip:
1439   0A39 10 F5           djnz _loop
1440   0A3B C9              ret
1441   0A3C             
1442   0A3C             
1443   0A3C             ; -----------------------------------------------------------------------------
1444   0A3C             ;   LCD DRIVER
1445   0A3C             ; -----------------------------------------------------------------------------
1446   0A3C             ; INIT_LCD - Inicia o lcd em mode texto
1447   0A3C             ; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
1448   0A3C             ; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
1449   0A3C             ; lcd_clear - Limpa buffer do lcd
1450   0A3C             ; enable_grafic - Coloca o LCD em modo grafico
1451   0A3C             ; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
1452   0A3C             ; cls_TXT - Limpa LCD mode text
1453   0A3C             ; cls_GRAPHIC - Limpa LCD modo grafico
1454   0A3C             
1455   0A3C             INIT_LCD:
1456   0A3C                 ;Initialisation
1457   0A3C 3E 30       	ld a, 30H
1458   0A3E CD 80 0B    	call lcd_send_command
1459   0A41             
1460   0A41 3E A0       	ld a, 0b00100000
1461   0A43 CD 80 0B    	call lcd_send_command
1462   0A46             
1463   0A46 3E 30       	ld a, 30H
1464   0A48 CD 80 0B    	call lcd_send_command
1465   0A4B             
1466   0A4B 3E 0C       	ld a, 0CH
1467   0A4D CD 80 0B    	call lcd_send_command
1468   0A50             
1469   0A50 3E 01       	ld a, 01H
1470   0A52 CD 8A 0B    	call lcd_send_command_clear ;; clear
1471   0A55             
1472   0A55 3E 02       	ld a, 02H
1473   0A57 CD 80 0B    	call lcd_send_command
1474   0A5A C9              RET
1475   0A5B             
1476   0A5B             
1477   0A5B             ; pixel index in HL
1478   0A5B             lcd_setPixel:
1479   0A5B E5              push hl
1480   0A5C C5              push bc
1481   0A5D D5              push de
1482   0A5E F5              push af
1483   0A5F AF              xor A
1484   0A60 32 07 E0        ld (LCD_BIT_INDEX), A
1485   0A63 32 05 E0        ld (LCD_BYTE_INDEX), A
1486   0A66             
1487   0A66 16 08           ld d, 8
1488   0A68 CD 2D 0A        call Div_HL_D
1489   0A6B 32 07 E0        ld (LCD_BIT_INDEX), A
1490   0A6E 22 05 E0        ld (LCD_BYTE_INDEX), HL
1491   0A71 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1492   0A75 21 00 E5        ld hl, DISPLAY
1493   0A78 09              add hl, bc
1494   0A79                 
1495   0A79 06 80           ld b, 128 ; 1000 0000
1496   0A7B 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1497   0A7E FE 00           cp 0
1498   0A80 CA 8C 0A        jp z, lcd_setPixel_fim
1499   0A83             lcd_setPixel_bit:
1500   0A83 CB 38           srl B
1501   0A85 3D              dec A
1502   0A86 CA 8C 0A        jp z, lcd_setPixel_fim
1503   0A89                 
1504   0A89 C3 83 0A        jp lcd_setPixel_bit
1505   0A8C             lcd_setPixel_fim
1506   0A8C 7E              ld a, (hl)
1507   0A8D B0              or b
1508   0A8E 77              ld (hl), a
1509   0A8F             
1510   0A8F F1              pop af
1511   0A90 C1              pop bc
1512   0A91 D1              pop de
1513   0A92 E1              pop hl
1514   0A93 C9              ret
1515   0A94             
1516   0A94             ;===============================
1517   0A94             ; pixel index in HL
1518   0A94             lcd_clearPixel:
1519   0A94 E5              push hl
1520   0A95 C5              push bc
1521   0A96 D5              push de
1522   0A97 F5              push af
1523   0A98 AF              xor A
1524   0A99 32 07 E0        ld (LCD_BIT_INDEX), A
1525   0A9C 32 05 E0        ld (LCD_BYTE_INDEX), A
1526   0A9F 16 08           ld d, 8
1527   0AA1 CD 2D 0A        call Div_HL_D
1528   0AA4 32 07 E0        ld (LCD_BIT_INDEX), A
1529   0AA7 22 05 E0        ld (LCD_BYTE_INDEX), HL
1530   0AAA ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1531   0AAE 21 00 E5        ld hl, DISPLAY
1532   0AB1 09              add hl, bc
1533   0AB2                 
1534   0AB2 06 80           ld b, 128 ; 1000 0000
1535   0AB4 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1536   0AB7 FE 00           cp 0
1537   0AB9 CA C5 0A        jp z, lcd_clearPixel_fim
1538   0ABC             lcd_clearPixel_bit:
1539   0ABC CB 38           srl B
1540   0ABE 3D              dec A
1541   0ABF CA C5 0A        jp z, lcd_clearPixel_fim
1542   0AC2                 
1543   0AC2 C3 BC 0A        jp lcd_clearPixel_bit
1544   0AC5             lcd_clearPixel_fim
1545   0AC5 78              ld a, b
1546   0AC6 2F              cpl     ; NOT B
1547   0AC7 47              ld b, a
1548   0AC8             
1549   0AC8 7E              ld a, (hl)
1550   0AC9 A0              and b
1551   0ACA 77              ld (hl), a
1552   0ACB             
1553   0ACB F1              pop af
1554   0ACC C1              pop bc
1555   0ACD D1              pop de
1556   0ACE E1              pop hl
1557   0ACF C9              ret
1558   0AD0             
1559   0AD0             
1560   0AD0             ;;--------------------------------------------------
1561   0AD0             lcd_clear:
1562   0AD0                 ;; HL = start address of block
1563   0AD0 21 00 E5        ld hl, DISPLAY
1564   0AD3             
1565   0AD3                 ;; DE = HL + 1
1566   0AD3 5D              ld e,l
1567   0AD4 54              ld d,h
1568   0AD5 13              inc de
1569   0AD6             
1570   0AD6                 ;; initialise first byte of block
1571   0AD6                 ;; with data byte (&00)
1572   0AD6 36 00           ld (hl), 0
1573   0AD8                     
1574   0AD8                 ;; BC = length of block in bytes
1575   0AD8                 ;; HL+BC-1 = end address of block
1576   0AD8             
1577   0AD8 01 00 04        ld bc, 1024
1578   0ADB             
1579   0ADB                 ;; fill memory
1580   0ADB ED B0           ldir
1581   0ADD C9              ret
1582   0ADE             
1583   0ADE             
1584   0ADE             ;===================
1585   0ADE             
1586   0ADE             ; grafic mode - enable
1587   0ADE             enable_grafic:
1588   0ADE 3E 30       	ld a, 30H
1589   0AE0 CD 80 0B    	call lcd_send_command
1590   0AE3 CD B3 0B    	call delayLCD
1591   0AE6             	
1592   0AE6 3E 34       	ld a, 34H
1593   0AE8 CD 80 0B    	call lcd_send_command
1594   0AEB CD B3 0B    	call delayLCD
1595   0AEE             	
1596   0AEE 3E 36       	ld a, 36H
1597   0AF0 CD 80 0B    	call lcd_send_command
1598   0AF3 CD B3 0B    	call delayLCD
1599   0AF6 C9              ret
1600   0AF7             
1601   0AF7             
1602   0AF7             ;==========================
1603   0AF7             
1604   0AF7             print_image:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
1605   0AF7             									; HL content the data address
1606   0AF7 F5              push af
1607   0AF8 D5          	push de
1608   0AF9 C5          	push bc
1609   0AFA             
1610   0AFA             
1611   0AFA             ; premiere partie : X de 0 √† 127 / Y de 0 √† 32
1612   0AFA             
1613   0AFA 3E 20       	ld a,32
1614   0AFC 57          	ld d,a							; boucle Y
1615   0AFD 3E 00       	ld a,0
1616   0AFF 5F          	ld e,a
1617   0B00             	
1618   0B00             boucle_colonne:
1619   0B00 3E 80       		ld a,$80					; coordonn√©e Y (0)
1620   0B02 83          		add a,e
1621   0B03 CD 80 0B    		call lcd_send_command
1622   0B06             		
1623   0B06 3E 80       		ld a,$80					; coordonn√©e X (0)		
1624   0B08 CD 80 0B    		call lcd_send_command
1625   0B0B             		
1626   0B0B 3E 08       		ld a,8
1627   0B0D 47          		ld b,a						; boucle X
1628   0B0E             		
1629   0B0E             boucle_ligne:	
1630   0B0E 7E          			ld a,(hl)
1631   0B0F CD 94 0B    			call lcd_send_data
1632   0B12 23          			inc hl
1633   0B13 7E          			ld a,(hl)
1634   0B14 CD 94 0B    			call lcd_send_data		; auto-increment on screen address
1635   0B17 23          			inc hl
1636   0B18 05          			dec b
1637   0B19 AF          			XOR a
1638   0B1A B0          			OR b
1639   0B1B C2 0E 0B    			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
1640   0B1E             		
1641   0B1E 15          		dec d
1642   0B1F 1C          		inc e
1643   0B20 AF          		XOR a
1644   0B21 B2          		OR d
1645   0B22 C2 00 0B    		jp nz,boucle_colonne
1646   0B25             		
1647   0B25             
1648   0B25             ; seconde partie : X de 128 √† 255 / Y de 0 √† 32
1649   0B25             
1650   0B25 3E 20       	ld a,32
1651   0B27 57          	ld d,a							; boucle Y
1652   0B28 3E 00       	ld a,0
1653   0B2A 5F          	ld e,a
1654   0B2B             	
1655   0B2B             boucle_colonne2:
1656   0B2B 3E 80       		ld a,$80					; coordonn√©e Y (0)
1657   0B2D 83          		add a, e
1658   0B2E CD 80 0B    		call lcd_send_command
1659   0B31             		
1660   0B31 3E 88       		ld a,$88					; coordonn√©e X (8)		
1661   0B33 CD 80 0B    		call lcd_send_command
1662   0B36             		
1663   0B36 3E 08       		ld a,8
1664   0B38 47          		ld b,a						; boucle X
1665   0B39             		
1666   0B39             boucle_ligne2:	
1667   0B39 7E          			ld a,(hl)
1668   0B3A CD 94 0B    			call lcd_send_data
1669   0B3D 23          			inc hl
1670   0B3E 7E          			ld a,(hl)
1671   0B3F CD 94 0B    			call lcd_send_data		; auto-increment on screen address
1672   0B42 23          			inc hl
1673   0B43 05          			dec b
1674   0B44 AF          			XOR a
1675   0B45 B0          			OR b
1676   0B46 C2 39 0B    			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
1677   0B49             		
1678   0B49 15          		dec d
1679   0B4A 1C          		inc e
1680   0B4B AF          		XOR a
1681   0B4C B2          		OR d
1682   0B4D C2 2B 0B    		jp nz,boucle_colonne2
1683   0B50             
1684   0B50 C1          	pop bc
1685   0B51 D1          	pop de
1686   0B52 F1              pop af
1687   0B53             
1688   0B53 C9              ret
1689   0B54             
1690   0B54             
1691   0B54             
1692   0B54             ; ======================
1693   0B54             cls_TXT:
1694   0B54             	; # CLEAR DISPLAY IN TEXT MODE # 
1695   0B54 3E 01       	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
1696   0B56 CD 8A 0B    	call lcd_send_command_clear		; CLEAR DISPLAY	
1697   0B59 C9              ret
1698   0B5A             
1699   0B5A             ; ========================
1700   0B5A             
1701   0B5A             cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
1702   0B5A             					;	Graphic RAM (GDRAM) use :
1703   0B5A             					;	1. Set vertical address (Y) for GDRAM
1704   0B5A             					;	2. Set horizontal address (X) for GDRAM
1705   0B5A             					;	3. Write D15~D8 to GDRAM (first byte)
1706   0B5A             					;	4. Write D7~D0 to GDRAM (second byte)
1707   0B5A C5          	push bc
1708   0B5B D5          	push de
1709   0B5C             
1710   0B5C 1E 20       	ld e,$20						; e = 32 
1711   0B5E 16 00       	ld d,$0							; d = 0
1712   0B60             Boucle32X:
1713   0B60 7A          		ld a,d
1714   0B61 F6 80       		OR $80
1715   0B63 CD 80 0B    		call lcd_send_command
1716   0B66             		
1717   0B66 3E 80       		ld a,$80					; Set horizontal addressÔºàXÔºâ for GDRAM = 0 ($80)
1718   0B68 CD 80 0B    		call lcd_send_command
1719   0B6B             		
1720   0B6B AF          		xor a							 	
1721   0B6C 06 10       		ld b,$10							; b = 17
1722   0B6E             		
1723   0B6E             Boucle16X:	 
1724   0B6E CD 94 0B    			call lcd_send_data 			; Write D15„ÄúD8 to GDRAM (first byte)
1725   0B71 CD 94 0B    			call lcd_send_data 			; Write D7„ÄúD0 to GDRAM (second byte)
1726   0B74             											; Address counter will automatically increase by one for the next two-byte data												
1727   0B74 10 F8       			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
1728   0B76             		
1729   0B76 1D          		dec e 
1730   0B77 14          		inc d
1731   0B78 AF          		xor a							; a = 0
1732   0B79 B3          		or e
1733   0B7A C2 60 0B    		jp nz,Boucle32X
1734   0B7D             
1735   0B7D D1          	pop de
1736   0B7E C1          	pop bc
1737   0B7F             	
1738   0B7F C9              ret
1739   0B80             
1740   0B80             
1741   0B80             
1742   0B80             ;******************
1743   0B80             ;Send a command byte to the LCD
1744   0B80             ;Entry: A= command byte
1745   0B80             ;Exit: All preserved
1746   0B80             ;******************
1747   0B80             lcd_send_command:
1748   0B80 C5          	push bc				;Preserve
1749   0B81 0E 70       	ld c, LCDCTRL   	;Command port
1750   0B83             	
1751   0B83 CD B3 0B    	call delayLCD
1752   0B86             	
1753   0B86 ED 79       	out (c),a			;Send command
1754   0B88 C1          	pop bc				;Restore
1755   0B89 C9          	ret
1756   0B8A             
1757   0B8A             
1758   0B8A             ;******************
1759   0B8A             ;Send a command byte to the LCD
1760   0B8A             ;Entry: A= command byte
1761   0B8A             ;Exit: All preserved
1762   0B8A             ;******************
1763   0B8A             lcd_send_command_clear:
1764   0B8A C5          	push bc				;Preserve
1765   0B8B             	
1766   0B8B CD BD 0B    	call delayLCDclear
1767   0B8E             	
1768   0B8E 0E 70           ld c, LCDCTRL   	;Command port
1769   0B90 ED 79       	out (c),a			;Send command
1770   0B92 C1          	pop bc				;Restore
1771   0B93 C9          	ret
1772   0B94             	
1773   0B94             ;******************
1774   0B94             ;Send a data byte to the LCD
1775   0B94             ;Entry: A= data byte
1776   0B94             ;Exit: All preserved
1777   0B94             ;******************
1778   0B94             lcd_send_data:
1779   0B94 C5          	push bc				;Preserve
1780   0B95             	
1781   0B95                 ;Busy wait
1782   0B95 CD B3 0B    	call delayLCD
1783   0B98             
1784   0B98 0E 71       	ld c, LCDDATA	;Data port $71
1785   0B9A ED 79       	out (c),a			;Send data
1786   0B9C C1          	pop bc				;Restore
1787   0B9D C9          	ret
1788   0B9E             
1789   0B9E             
1790   0B9E             
1791   0B9E             
1792   0B9E             ;******************
1793   0B9E             ;Send an asciiz string to the LCD
1794   0B9E             ;Entry: HL=address of string
1795   0B9E             ;Exit: HL=address of ending zero of the string. All others preserved
1796   0B9E             ;******************
1797   0B9E             lcd_send_asciiz:
1798   0B9E F5          	push af
1799   0B9F C5          	push bc				;Preserve
1800   0BA0             lcd_asciiz_char_loop:
1801   0BA0 0E 70       	ld c, LCDCTRL   	;Command port
1802   0BA2             	
1803   0BA2             lcd_asciiz_wait_loop:	;Busy wait
1804   0BA2 CD B3 0B    	call delayLCD
1805   0BA5             	
1806   0BA5 7E          	ld a,(hl)			;Get character
1807   0BA6 A7          	and a				;Is it zero?
1808   0BA7 28 07       	jr z,lcd_asciiz_done	;If so, we're done
1809   0BA9             	
1810   0BA9 0E 71       	ld c, LCDDATA	;Data port
1811   0BAB ED 79       	out (c),a			;Send data
1812   0BAD 23          	inc hl				;Next char
1813   0BAE 18 F0       	jr lcd_asciiz_char_loop
1814   0BB0             	
1815   0BB0             lcd_asciiz_done:
1816   0BB0 C1          	pop bc				;Restore
1817   0BB1 F1          	pop af
1818   0BB2 C9          	ret
1819   0BB3             
1820   0BB3             ; =========================================================
1821   0BB3             ; Delay LCD
1822   0BB3             ; =========================================================
1823   0BB3             delayLCD:
1824   0BB3 00          	NOP
1825   0BB4 00          	NOP
1826   0BB5 00          	NOP
1827   0BB6 00          	NOP
1828   0BB7 00          	NOP
1829   0BB8 00          	NOP
1830   0BB9 00          	NOP
1831   0BBA 00          	NOP
1832   0BBB 00              NOP
1833   0BBC C9              ret
1834   0BBD             
1835   0BBD             delayLCDclear:
1836   0BBD 00          	NOP
1837   0BBE 00          	NOP
1838   0BBF 00          	NOP
1839   0BC0 00          	NOP
1840   0BC1 00          	NOP
1841   0BC2 00          	NOP
1842   0BC3 00          	NOP
1843   0BC4 00          	NOP
1844   0BC5 00          	NOP
1845   0BC6 00          	NOP
1846   0BC7 00          	NOP
1847   0BC8 00          	NOP
1848   0BC9 00              NOP
1849   0BCA C9              ret
1850   0BCB             
1851   0BCB             	
1852   0BCB             ; =========================================================
1853   0BCB             ; Delay
1854   0BCB             ; =========================================================
1855   0BCB             delay:
1856   0BCB C5          	push bc                       ; 2.75 us
1857   0BCC 06 01           ld b, 1                     ; 1.75 us
1858   0BCE             delay_loop_b:
1859   0BCE 0E FF       	ld c, 255                     ; 1.75 us
1860   0BD0             delay_loop:
1861   0BD0 0D          	dec c                         ; 1 us
1862   0BD1 C2 D0 0B        jp nz, delay_loop             ; true = 3 us, false 1.75 us
1863   0BD4 05              dec b                         ; 1 us
1864   0BD5 C2 CE 0B        jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
1865   0BD8 C1              pop bc                        ; 2.50 us
1866   0BD9 C9              ret   
1867   0BDA             
1868   0BDA             
1869   0BDA             ; Check break key
1870   0BDA 3E 40       CHKKEY: LD  A, $40
1871   0BDC D3 40       	OUT (KEY_OUT), A ; line 4
1872   0BDE DB 40       	IN  A, (KEY_IN)
1873   0BE0 FE 01       	CP  1
1874   0BE2 C2 EA 0B    	JP  NZ, GRET
1875   0BE5 3E 03       	LD  A, CTRLC
1876   0BE7 FE 00       	CP	0
1877   0BE9 C9          	RET
1878   0BEA             GRET:
1879   0BEA 3E 00       	LD  A, 0
1880   0BEC FE 00       	CP 0
1881   0BEE C9          	RET
1882   0BEF             
1883   0BEF             
1884   0BEF             
1885   0BEF             
1886   0BEF             ; -----------------------------------------------------------------------------
1887   0BEF             ;   KEYREAD - KEY In A
1888   0BEF             ; -----------------------------------------------------------------------------
1889   0BEF             KEYREADINIT:
1890   0BEF C5              PUSH    BC
1891   0BF0 D5          	PUSH	DE
1892   0BF1 E5          	PUSH    HL
1893   0BF2 1E 00       	LD      E, 0                    ; E will be the last pressed key
1894   0BF4             READKEY:        
1895   0BF4 26 01           LD      H, 1                    ; H is the line register, start with second
1896   0BF6 06 00       	LD      B, 0                    ; Count lines for later multiplication	
1897   0BF8 16 00       	LD      D, 0                    ; DE will be the adress for mask
1898   0BFA             						
1899   0BFA             NEXTKEY:        
1900   0BFA 7C              LD      A, H						
1901   0BFB FE 00           CP      0                       ; All lines tried? 
1902   0BFD CA 38 0C        JP      Z, KEYOUT               ; Then check if there was a key pressed
1903   0C00 D3 40       	OUT     (KEY_OUT), A		    ; Put current line to register
1904   0C02 DB 40       	IN      A, (KEY_IN)		        ; Input Keys
1905   0C04 E6 1F       	AND     $1F                     ; only 5 bits
1906   0C06 CB 24       	SLA     H                       ; Next line
1907   0C08 04              INC     B
1908   0C09 FE 00           CP      0                       ; Was key zero?
1909   0C0B CA FA 0B        JP      Z, NEXTKEY              ; Then try again with next lines
1910   0C0E 16 00           LD      D, 0                    ; In D will be the number of the key
1911   0C10             LOGARITHM:      
1912   0C10 14              INC     D	                    ; Add one per shift
1913   0C11 CB 3F           SRL     A                       ; Shift key right
1914   0C13 C2 10 0C        JP      NZ, LOGARITHM		    ; If not zero shift again
1915   0C16 15              DEC     D                       ; Was too much
1916   0C17 DB 40       	IN      A, (KEY_IN)
1917   0C19 E6 80           AND     $80                     ; Check if first bit set (shift key pressed)
1918   0C1B C2 24 0C        JP      NZ, LOADSHIFT		    ; Then jump to read with shift
1919   0C1E 7A              LD      A, D                    ; Put read key into accu
1920   0C1F C6 33           ADD     A, KEYMAP               ; Add base of key map array
1921   0C21 C3 27 0C        JP      ADDOFFSET               ; Jump to load key
1922   0C24             LOADSHIFT:
1923   0C24 7A              LD      A, D
1924   0C25 C6 5B           ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
1925   0C27             ADDOFFSET:
1926   0C27 C6 05           ADD     A, 5                    ; Add 5 for every line
1927   0C29 10 FC           DJNZ    ADDOFFSET               ; Jump back (do while loop)
1928   0C2B D6 05       	SUB     5                       ; Since do while is one too much
1929   0C2D             TRANSKEY:
1930   0C2D A8              XOR     B                       ; Empty B
1931   0C2E 4F          	LD      C, A                    ; A will be address in BC
1932   0C2F 0A          	LD      A, (BC)	                ; Load key
1933   0C30 BB          	CP      E                       ; Same key?
1934   0C31 CA F4 0B    	JP      Z, READKEY              ; Then from beginning
1935   0C34 5F          	LD      E, A                    ; Otherwise save new key
1936   0C35 C3 F4 0B    	JP      READKEY	                ; And restart
1937   0C38             KEYOUT:
1938   0C38 7B              LD      A, E
1939   0C39 1E 00           LD      E, 0                    ; empty it
1940   0C3B B7              OR      A	                    ; Was a key read?
1941   0C3C CA F4 0B        JP      Z, READKEY              ; If not restart
1942   0C3F E1              POP     HL
1943   0C40 D1              POP     DE
1944   0C41 C1              POP     BC
1945   0C42 C9              RET
1946   0C43             
1947   0C43             
1948   0C43             ;-----------------------
1949   0C43             ; RECEIVE INTEL HEX FILE
1950   0C43             ;-----------------------       
1951   0C43             INTHEX: 
1952   0C43 21 98 10           LD HL, MSG_ILOAD
1953   0C46 CD F6 0C           CALL  SNDLCDMSG
1954   0C49             
1955   0C49 21 98 10           LD HL, MSG_ILOAD
1956   0C4C CD 09 0D           CALL  SNDMSG
1957   0C4F                    
1958   0C4F             
1959   0C4F CD 6E 0C           CALL  INTELH
1960   0C52 20 0D              JR    NZ,ITHEX1      
1961   0C54             
1962   0C54 21 AE 10           LD    HL,FILEOK
1963   0C57 CD F6 0C           CALL  SNDLCDMSG   ;GOT FILE OK LCD
1964   0C5A 21 AE 10           LD    HL,FILEOK
1965   0C5D CD 09 0D           CALL  SNDMSG      ;GOT FILE OK Serial
1966   0C60                    
1967   0C60 C9                 RET
1968   0C61 21 C0 10    ITHEX1: LD    HL,CSUMERR
1969   0C64 CD F6 0C           CALL  SNDLCDMSG
1970   0C67             
1971   0C67 21 C0 10           LD    HL,CSUMERR
1972   0C6A CD 09 0D           CALL  SNDMSG      ;CHECKSUM ERROR
1973   0C6D                    
1974   0C6D C9                 RET  
1975   0C6E             
1976   0C6E             
1977   0C6E             
1978   0C6E             
1979   0C6E             
1980   0C6E             ;-----------------------
1981   0C6E             ; RECEIVE INTEL HEX FILE
1982   0C6E             ;-----------------------
1983   0C6E DD 21 00 FD INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
1984   0C72             ;
1985   0C72             ; WAIT FOR RECORD MARK
1986   0C72             ;
1987   0C72 AF          INTEL1:	XOR	A
1988   0C73 DD 77 03    	LD	(IX+3),A	;CLEAR CHECKSUM
1989   0C76 CD 4E 0D    	CALL	RXDATA	;WAIT FOR THE RECORD MARK
1990   0C79 FE 3A       	CP	':'	;TO BE TRANSMITTED
1991   0C7B 20 F5       	JR	NZ,INTEL1	;NOT RECORD MARK
1992   0C7D             ;
1993   0C7D             ; GET RECORD LENGTH
1994   0C7D             ;
1995   0C7D CD CA 0C    	CALL	GETBYT
1996   0C80 DD 77 00    	LD	(IX+0),A	;NUMBER OF DATA BYTES
1997   0C83             ;
1998   0C83             ; GET ADDRESS FIELD
1999   0C83             ;
2000   0C83 CD CA 0C    	CALL	GETBYT
2001   0C86 DD 77 02    	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
2002   0C89 CD CA 0C    	CALL	GETBYT
2003   0C8C DD 77 01    	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
2004   0C8F             ;
2005   0C8F             ; GET RECORD TYPE
2006   0C8F             ;
2007   0C8F CD CA 0C    	CALL	GETBYT
2008   0C92 20 24       	JR	NZ,INTEL4	;END OF FILE RECORD
2009   0C94             ;
2010   0C94             ; READ IN THE DATA
2011   0C94             ;
2012   0C94 DD 46 00    	LD	B,(IX+0)	;NUMBER OF DATA BYTES
2013   0C97 DD 66 02    	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
2014   0C9A DD 6E 01    	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
2015   0C9D             
2016   0C9D CD CA 0C    INTEL2:	CALL	GETBYT	;GET DATA BYTE
2017   0CA0 77          	LD	(HL),A	;STORE DATA BYTE
2018   0CA1 23          	INC	HL
2019   0CA2 10 F9       	DJNZ	INTEL2	;LOAD MORE BYTES
2020   0CA4             ;
2021   0CA4             ; GET CHECKSUM AND COMPARE
2022   0CA4             ;
2023   0CA4 DD 7E 03    	LD	A,(IX+3)	;CONVERT CHECKSUM TO
2024   0CA7 ED 44       	NEG		;TWO'S COMPLEMENT
2025   0CA9 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
2026   0CAC CD CA 0C    	CALL	GETBYT
2027   0CAF DD 77 03    	LD	(IX+3),A	;SAVE RECORD CHECKSUM
2028   0CB2 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
2029   0CB5 28 BB       	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
2030   0CB7 C9              RET             ;NZ=CHECKSUM ERROR
2031   0CB8             ;
2032   0CB8             ; END OF FILE RECORD
2033   0CB8             ;
2034   0CB8 DD 7E 03    INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
2035   0CBB ED 44       	NEG		;TWO'S COMPLEMENT
2036   0CBD DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
2037   0CC0 CD CA 0C    	CALL	GETBYT
2038   0CC3 DD 77 03    	LD	(IX+3),A	;SAVE EOF CHECKSUM
2039   0CC6 DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
2040   0CC9 C9          	RET  	    ;NZ=CHECKSUM ERROR
2041   0CCA             ;--------------------------
2042   0CCA             ; GET BYTE FROM SERIAL PORT
2043   0CCA             ;--------------------------
2044   0CCA C5          GETBYT:	PUSH	BC
2045   0CCB CD 4E 0D    	CALL	RXDATA
2046   0CCE CB 77       	BIT	6,A
2047   0CD0 28 02       	JR	Z,GETBT1
2048   0CD2 C6 09       	ADD	A,09H
2049   0CD4 E6 0F       GETBT1:	AND	0FH
2050   0CD6 CB 27       	SLA 	A
2051   0CD8 CB 27       	SLA	A
2052   0CDA CB 27       	SLA	A
2053   0CDC CB 27       	SLA	A
2054   0CDE 4F          	LD	C,A
2055   0CDF             ;
2056   0CDF             ; GET LOW NYBBLE
2057   0CDF             ;
2058   0CDF CD 4E 0D    	CALL	RXDATA
2059   0CE2 CB 77       	BIT	6,A
2060   0CE4 28 02       	JR	Z,GETBT2
2061   0CE6 C6 09       	ADD	A,09H
2062   0CE8 E6 0F       GETBT2:	AND	0FH
2063   0CEA B1          	OR	C
2064   0CEB 47          	LD	B,A
2065   0CEC DD 86 03    	ADD	A,(IX+3)
2066   0CEF DD 77 03    	LD	(IX+3),A	;ADD TO CHECKSUM
2067   0CF2 78          	LD	A,B
2068   0CF3 A7          	AND	A	;CLEAR CARRY
2069   0CF4 C1              POP	BC
2070   0CF5 C9          	RET
2071   0CF6             
2072   0CF6             ;-----------------------------------------
2073   0CF6             ; SEND AN ASCII STRING OUT LCD
2074   0CF6             ;-----------------------------------------
2075   0CF6             ; 
2076   0CF6             ; SENDS A ZERO TERMINATED STRING OR 
2077   0CF6             ; 128 CHARACTERS MAX. OUT LCD
2078   0CF6             ;
2079   0CF6             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2080   0CF6             ;      EXIT  : NONE
2081   0CF6             ;
2082   0CF6             ;       MODIFIES : A,B,C
2083   0CF6             ;          
2084   0CF6 06 80       SNDLCDMSG: LD    B,128         ;128 CHARS MAX
2085   0CF8 7E          SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
2086   0CF9 FE 00              CP    00H          ;ZERO TERMINATOR?
2087   0CFB 28 06              JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2088   0CFD CD D0 08           CALL PrintBufferChar         ;TRANSMIT THE CHAR
2089   0D00 23                 INC   HL
2090   0D01 10 F5              DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
2091   0D03             SDLCDMSG2: 
2092   0D03 21 00 E5        LD HL, DISPLAY
2093   0D06 CD F7 0A        CALL print_image
2094   0D09             RET
2095   0D09             
2096   0D09             ;-----------------------------------------
2097   0D09             ; SEND AN ASCII STRING OUT THE SERIAL PORT
2098   0D09             ;-----------------------------------------
2099   0D09             ; 
2100   0D09             ; SENDS A ZERO TERMINATED STRING OR 
2101   0D09             ; 128 CHARACTERS MAX. OUT THE SERIAL PORT
2102   0D09             ;
2103   0D09             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2104   0D09             ;      EXIT  : NONE
2105   0D09             ;
2106   0D09             ;       MODIFIES : A,B,C
2107   0D09             ;          
2108   0D09 06 80       SNDMSG: LD    B,128         ;128 CHARS MAX
2109   0D0B 7E          SDMSG1: LD    A,(HL)        ;GET THE CHAR
2110   0D0C FE 00              CP    00H          ;ZERO TERMINATOR?
2111   0D0E 28 06              JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2112   0D10 CD 17 0D           CALL  OUTCH         ;TRANSMIT THE CHAR
2113   0D13 23                 INC   HL
2114   0D14 10 F5              DJNZ  SDMSG1        ;128 CHARS MAX!    
2115   0D16 C9          SDMSG2: RET
2116   0D17             
2117   0D17             
2118   0D17             
2119   0D17             ;-----------------------------------
2120   0D17             ; OUTPUT A CHARACTER TO THE TERMINAL
2121   0D17             ;-----------------------------------       
2122   0D17 DD 2A AA FF OUTCH:  LD   IX,(PUTCH)
2123   0D1B DD E9              JP   (IX)
2124   0D1D             ;------------------------------------
2125   0D1D             ; INPUT A CHARACTER FROM THE TERMINAL
2126   0D1D             ;------------------------------------
2127   0D1D DD 2A AC FF INCH:  LD   IX,(GETCH)
2128   0D21 DD E9             JP   (IX)
2129   0D23             
2130   0D23             
2131   0D23             
2132   0D23             ;------------------------
2133   0D23             ; SERIAL TRANSMIT ROUTINE
2134   0D23             ;------------------------
2135   0D23             ;TRANSMIT BYTE SERIALLY ON DOUT
2136   0D23             ;
2137   0D23             ; ENTRY : A = BYTE TO TRANSMIT
2138   0D23             ;  EXIT : NO REGISTERS MODIFIED
2139   0D23             ;
2140   0D23 F5          TXDATA:	PUSH	AF
2141   0D24 C5          	PUSH	BC
2142   0D25 E5          	PUSH	HL
2143   0D26 2A C0 FF    	LD	HL,(BAUD)
2144   0D29 4F          	LD	C,A
2145   0D2A             ;
2146   0D2A             ; TRANSMIT START BIT
2147   0D2A             ;
2148   0D2A AF          	XOR	A
2149   0D2B D3 C0       	OUT	(SERIAL_TX_PORT),A
2150   0D2D CD 7B 0D    	CALL	BITIME
2151   0D30             ;
2152   0D30             ; TRANSMIT DATA
2153   0D30             ;
2154   0D30 06 08       	LD	B,08H
2155   0D32 CB 09       	RRC	C
2156   0D34 CB 09       NXTBIT:	RRC	C	;SHIFT BITS TO D6,
2157   0D36 79          	LD	A,C	;LSB FIRST AND OUTPUT
2158   0D37 E6 40       	AND	40H	;THEM FOR ONE BIT TIME.
2159   0D39 D3 C0       	OUT	(SERIAL_TX_PORT),A
2160   0D3B CD 7B 0D    	CALL	BITIME
2161   0D3E 10 F4       	DJNZ	NXTBIT
2162   0D40             ;
2163   0D40             ; SEND STOP BITS
2164   0D40             ;
2165   0D40 3E 40       	LD	A,40H
2166   0D42 D3 C0       	OUT	(SERIAL_TX_PORT),A
2167   0D44 CD 7B 0D    	CALL	BITIME
2168   0D47 CD 7B 0D    	CALL	BITIME
2169   0D4A E1          	POP	HL
2170   0D4B C1          	POP	BC
2171   0D4C F1          	POP	AF
2172   0D4D C9          	RET
2173   0D4E             ;-----------------------
2174   0D4E             ; SERIAL RECEIVE ROUTINE
2175   0D4E             ;-----------------------
2176   0D4E             ;RECEIVE SERIAL BYTE FROM DIN
2177   0D4E             ;
2178   0D4E             ; ENTRY : NONE
2179   0D4E             ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
2180   0D4E             ;
2181   0D4E             ; REGISTERS MODIFIED A AND F
2182   0D4E             ;
2183   0D4E C5          RXDATA:	PUSH	BC
2184   0D4F E5          	PUSH	HL
2185   0D50             ;
2186   0D50             ; WAIT FOR START BIT 
2187   0D50             ;
2188   0D50 DB C0       RXDAT1: IN	A,(SERIAL_RX_PORT)
2189   0D52 CB 7F       	    BIT	7,A
2190   0D54 20 FA       	    JR	NZ,RXDAT1	;NO START BIT
2191   0D56             ;
2192   0D56             ; DETECTED START BIT
2193   0D56             ;
2194   0D56 2A C0 FF    	LD	HL,(BAUD)
2195   0D59 CB 3C       	SRL	H
2196   0D5B CB 1D       	RR	L 	;DELAY FOR HALF BIT TIME
2197   0D5D CD 7B 0D    	CALL 	BITIME
2198   0D60 DB C0       	IN	A,(SERIAL_RX_PORT)
2199   0D62 CB 7F       	BIT	7,A
2200   0D64 20 EA       	JR	NZ,RXDAT1	;START BIT NOT VALID
2201   0D66             ;
2202   0D66             ; DETECTED VALID START BIT,READ IN DATA
2203   0D66             ;
2204   0D66 06 08       	LD	B,08H
2205   0D68 2A C0 FF    RXDAT2:	LD	HL,(BAUD)
2206   0D6B CD 7B 0D    	CALL	BITIME	;DELAY ONE BIT TIME
2207   0D6E DB C0       	IN	A,(SERIAL_RX_PORT)
2208   0D70 CB 17       	RL	A
2209   0D72 CB 19       	RR	C	;SHIFT BIT INTO DATA REG
2210   0D74 10 F2       	DJNZ	RXDAT2
2211   0D76 79          	LD	A,C
2212   0D77 B7          	OR	A	;CLEAR CARRY FLAG
2213   0D78 E1              POP	HL
2214   0D79 C1          	POP	BC
2215   0D7A C9          	RET
2216   0D7B             ;---------------
2217   0D7B             ; BIT TIME DELAY
2218   0D7B             ;---------------
2219   0D7B             ;DELAY FOR ONE SERIAL BIT TIME
2220   0D7B             ;ENTRY : HL = DELAY TIME
2221   0D7B             ; NO REGISTERS MODIFIED
2222   0D7B             ;
2223   0D7B E5          BITIME:	PUSH	HL
2224   0D7C D5          	PUSH	DE
2225   0D7D 11 01 00    	LD	DE,0001H
2226   0D80 ED 52       BITIM1:	SBC	HL,DE
2227   0D82 D2 80 0D    	JP	NC,BITIM1
2228   0D85 D1          	POP	DE
2229   0D86 E1          	POP	HL
2230   0D87 C9          	RET
2231   0D88             
2232   0D88             
2233   0D88             ;-----------------
2234   0D88             ; ONE SECOND DELAY
2235   0D88             ;-----------------
2236   0D88             ;
2237   0D88             ; ENTRY : NONE
2238   0D88             ; EXIT : FLAG REGISTER MODIFIED
2239   0D88             ;
2240   0D88 C5          DELONE:	PUSH	BC
2241   0D89 D5          	PUSH	DE
2242   0D8A E5          	PUSH	HL
2243   0D8B 11 01 00    	LD	DE,0001H
2244   0D8E 21 70 08    	LD	HL,0870H
2245   0D91 06 92       DELON1:	LD	B,92H
2246   0D93 10 FE       DELON2:	DJNZ	DELON2	;INNER LOOP
2247   0D95 ED 52       	SBC	HL,DE
2248   0D97 D2 91 0D    	JP	NC,DELON1	;OUTER LOOP
2249   0D9A E1          	POP	HL
2250   0D9B D1          	POP	DE
2251   0D9C C1          	POP	BC
2252   0D9D C9          	RET
2253   0D9E             
2254   0D9E             
2255   0D9E             
2256   0D9E             
2257   0D9E             
2258   0D9E             
2259   0D9E             
2260   0D9E             ; **********************************************************************
2261   0D9E             ; List devices found on the I2C bus
2262   0D9E             ;
2263   0D9E             ; Test each I2C device address and reports any that acknowledge
2264   0D9E             
2265   0D9E 11 25 10    I2CLIST:       LD   DE,LISTMsg        ;Address of message string
2266   0DA1 CD 41 0E                CALL StrOut         ;Output string
2267   0DA4 16 00                   LD   D,0            ;First I2C device address to test
2268   0DA6 D5          LISTLOOP:      PUSH DE             ;Preserve DE
2269   0DA7 7A                      LD   A,D            ;Get device address to be tested
2270   0DA8 CD BF 0D                CALL LISTTEST          ;Test if device is present
2271   0DAB D1                      POP  DE             ;Restore DE
2272   0DAC 20 07                   JR   NZ,LISTNEXT       ;Skip if no acknowledge
2273   0DAE 7A                      LD   A,D            ;Get address of device tested
2274   0DAF CD 70 0E                CALL HexOut         ;Output as two character hex 
2275   0DB2 CD 3C 0E                CALL SpaceOut       ;Output space character
2276   0DB5 14          LISTNEXT:      INC  D              ;Get next write address
2277   0DB6 14                      INC  D
2278   0DB7 7A                      LD   A,D            ;Address of next device to test
2279   0DB8 B7                      OR   A              ;Have we tested all addresses?
2280   0DB9 20 EB                   JR   NZ,LISTLOOP       ;No, so loop again
2281   0DBB CD 39 0E                CALL LineOut        ;Output new line
2282   0DBE C9                      RET
2283   0DBF             
2284   0DBF             ; Test if device at I2C address A acknowledges
2285   0DBF             ;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
2286   0DBF             ;   On exit:  Z flagged if device acknowledges
2287   0DBF             ;             NZ flagged if devices does not acknowledge
2288   0DBF CD B1 0E    LISTTEST:      CALL I2C_Open       ;Open I2C device for write
2289   0DC2 C0                      RET  NZ             ;Abort if failed to open
2290   0DC3 CD B8 0E                CALL I2C_Close      ;Close I2C device 
2291   0DC6 AF                      XOR  A              ;Return with Z flagged
2292   0DC7 C9                      RET
2293   0DC8             
2294   0DC8             
2295   0DC8             
2296   0DC8             
2297   0DC8             ; Copy a block from I2C memory to CPU memory
2298   0DC8             ;   On entry: DE = First address in I2C memory
2299   0DC8             ;             HL = First address in CPU memory
2300   0DC8             ;             BC = Number of bytes to be copied
2301   0DC8             ;             SCL = unknown, SDA = unknown
2302   0DC8             ;   On exit:  If successfully A = 0 and Z flagged
2303   0DC8             ;             If unsuccessfully A = Error and NZ flagged
2304   0DC8             ;             IX IY preserved
2305   0DC8 C5          I2C_MemRd:  PUSH BC
2306   0DC9 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2307   0DCC 3E AE       I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2308   0DCE CD B1 0E                CALL I2C_Open       ;Open for write
2309   0DD1 28 0A                   JR   Z,I2C_MemRdReady       ;If open okay then skip on
2310   0DD3 0B                      DEC  BC
2311   0DD4 78                      LD   A,B
2312   0DD5 B1                      OR   C              ;Timeout?
2313   0DD6 20 F4                   JR   NZ,I2C_MemRdRepeat     ;No, so go try again
2314   0DD8 C1                      POP  BC
2315   0DD9 3E 03                   LD   A,ERR_TOUT     ;Error code
2316   0DDB B7                      OR   A              ;Error, so NZ flagged
2317   0DDC C9                      RET                 ;Return with error
2318   0DDD             ; Device opened okay
2319   0DDD C1          I2C_MemRdReady:     POP  BC             ;Restore byte counter
2320   0DDE 7A                      LD   A,D            ;Address (hi) in I2C memory
2321   0DDF CD BB 0E                CALL I2C_Write      ;Write address
2322   0DE2 7B                      LD   A,E            ;Address (lo) in I2C memory
2323   0DE3 CD BB 0E                CALL I2C_Write      ;Write address
2324   0DE6 3E AF                   LD   A,I2CA_BLOCK+1 ;I2C device to be read from
2325   0DE8 CD B1 0E                CALL I2C_Open       ;Open for read
2326   0DEB C0                      RET  NZ             ;Abort if error
2327   0DEC 0B          I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
2328   0DED 78                      LD   A,B
2329   0DEE B1                      OR   C              ;Last byte to be read?
2330   0DEF CD F8 0E                CALL I2C_Read       ;Read byte with no ack on last byte
2331   0DF2 77                      LD   (HL),A         ;Write byte in CPU memory
2332   0DF3 23                      INC  HL             ;Increment CPU memory pointer
2333   0DF4 78                      LD   A,B
2334   0DF5 B1                      OR   C              ;Finished?
2335   0DF6 20 F4                   JR   NZ,I2C_MemRdRead       ;No, so go read next byte
2336   0DF8 CD 30 0F                CALL I2C_Stop       ;Generate I2C stop
2337   0DFB AF                      XOR  A              ;Return with success (Z flagged)
2338   0DFC C9                      RET
2339   0DFD             
2340   0DFD             
2341   0DFD             ; Copy a block from CPU memory to I2C memory
2342   0DFD             ;   On entry: DE = First address in I2C memory
2343   0DFD             ;             HL = First address in CPU memory
2344   0DFD             ;             BC = Number of bytes to be copied
2345   0DFD             ;             SCL = unknown, SDA = unknown
2346   0DFD             ;   On exit:  If successfully A = 0 and Z flagged
2347   0DFD             ;             If unsuccessfully A = Error and NZ flagged
2348   0DFD             ;             IX IY preserved
2349   0DFD             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
2350   0DFD             ; pages.
2351   0DFD C5          I2C_MemWr:  PUSH BC
2352   0DFE 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2353   0E01 3E AE       I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2354   0E03 CD B1 0E                CALL I2C_Open       ;Open for write
2355   0E06 28 0A                   JR   Z,I2C_MemWrReady       ;If open okay then skip on
2356   0E08 0B                      DEC  BC
2357   0E09 78                      LD   A,B
2358   0E0A B1                      OR   C              ;Timeout?
2359   0E0B 20 F4                   JR   NZ,I2C_MemWrRepeat     ;No, so go try again
2360   0E0D C1                      POP  BC
2361   0E0E 3E 03                   LD   A,ERR_TOUT     ;Error code
2362   0E10 B7                      OR   A              ;Error, so NZ flagged
2363   0E11 C9                      RET                 ;Return with error
2364   0E12             ; Device opened okay
2365   0E12 C1          I2C_MemWrReady:     POP  BC             ;Restore byte counter
2366   0E13 7A          I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
2367   0E14 CD BB 0E                CALL I2C_Write      ;Write address
2368   0E17 7B                      LD   A,E            ;Address (lo) in I2C memory
2369   0E18 CD BB 0E                CALL I2C_Write      ;Write address
2370   0E1B 7E          I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
2371   0E1C CD BB 0E                CALL I2C_Write      ;Read byte from I2C memory
2372   0E1F 23                      INC  HL             ;Increment CPU memory pointer
2373   0E20 13                      INC  DE             ;Increment I2C memory pointer
2374   0E21 0B                      DEC  BC             ;Decrement byte counter
2375   0E22 78                      LD   A,B
2376   0E23 B1                      OR   C              ;Finished?
2377   0E24 28 05                   JR   Z,I2C_MemWrStore       ;Yes, so go store this page
2378   0E26 7B                      LD   A,E            ;Get address in I2C memory (lo byte)
2379   0E27 E6 3F                   AND  63             ;64 byte page boundary?
2380   0E29 20 F0                   JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
2381   0E2B CD 30 0F    I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
2382   0E2E 78                      LD   A,B
2383   0E2F B1                      OR   C              ;Finished?
2384   0E30 20 CB                   JR   NZ,I2C_MemWr   ;No, so go write some more
2385   0E32 C9                      RET   
2386   0E33             
2387   0E33             
2388   0E33             
2389   0E33             
2390   0E33             
2391   0E33             
2392   0E33             
2393   0E33             
2394   0E33             
2395   0E33             
2396   0E33             ; Display test result
2397   0E33             ;   On entry: DE = Address of null terminated string
2398   0E33             ;             H = First value ($H)
2399   0E33             ;             L = Second value ($L)
2400   0E33             ;   On exit:  HL IX IY preserved
2401   0E33             Result:     
2402   0E33 C3 88 0E                JP   String         ;Output result string to console
2403   0E36             
2404   0E36             
2405   0E36             ; Character output to console
2406   0E36             ;   On entry: A = Character to be output
2407   0E36             ;   On exit:  BC DE HL IX IY preserved
2408   0E36 C3 4E 0E    CharOut:    JP   API_Cout
2409   0E39             
2410   0E39             ; New line output to console
2411   0E39             ;   On entry: No parameters required
2412   0E39             ;   On exit:  BC DE HL IX IY preserved
2413   0E39 C3 58 0E    LineOut:    JP   API_Lout
2414   0E3C             
2415   0E3C             ; Space character ouput to console
2416   0E3C             ;   On entry: No parameters required
2417   0E3C             ;   On exit:  BC DE HL IX IY preserved
2418   0E3C 3E 20       SpaceOut:   LD   A,$20
2419   0E3E C3 4E 0E                JP   API_Cout
2420   0E41             
2421   0E41             ; String output to console
2422   0E41             ;   On entry: DE = Address of string
2423   0E41             ;   On exit:  BC DE HL IX IY preserved
2424   0E41 C3 64 0E    StrOut:     JP   API_Sout
2425   0E44             
2426   0E44             
2427   0E44             ; Delay by DE milliseconds (approx)
2428   0E44             ;   On entry: DE = Delay time in milliseconds
2429   0E44             ;   On exit:  BC DE HL IX IY preserved
2430   0E44 C5          API_Delay:  PUSH BC             ;Preserve registers
2431   0E45 D5                      PUSH DE
2432   0E46 E5                      PUSH HL
2433   0E47 CD CB 0B                CALL delay
2434   0E4A E1                      POP  HL             ;Restore registers
2435   0E4B D1                      POP  DE
2436   0E4C C1                      POP  BC
2437   0E4D C9                      RET
2438   0E4E             
2439   0E4E             
2440   0E4E             ; Character output to console device
2441   0E4E             ;   On entry: A = Character to be output
2442   0E4E             ;   On exit:  BC DE HL IX IY preserved
2443   0E4E C5          API_Cout:   PUSH BC             ;Preserve registers
2444   0E4F D5                      PUSH DE
2445   0E50 E5                      PUSH HL
2446   0E51 CD 08 00                CALL $0008
2447   0E54 E1                      POP  HL             ;Restore registers
2448   0E55 D1                      POP  DE
2449   0E56 C1                      POP  BC
2450   0E57 C9                      RET
2451   0E58             
2452   0E58             
2453   0E58             ; New line output to console device
2454   0E58             ;   On entry: No parameters required
2455   0E58             ;   On exit:  BC DE HL IX IY preserved
2456   0E58 C5          API_Lout:   PUSH BC             ;Preserve registers
2457   0E59 D5                      PUSH DE
2458   0E5A E5                      PUSH HL
2459   0E5B 3E 0D                   LD A, CR ; enter char
2460   0E5D CD 08 00                CALL $0008
2461   0E60 E1                      POP  HL             ;Restore registers
2462   0E61 D1                      POP  DE
2463   0E62 C1                      POP  BC
2464   0E63 C9                      RET
2465   0E64             
2466   0E64             
2467   0E64             ; String output to console device
2468   0E64             ;   On entry: DE = Address of string
2469   0E64             ;   On exit:  BC DE HL IX IY preserved
2470   0E64 C5          API_Sout:   PUSH BC             ;Preserve registers
2471   0E65 D5                      PUSH DE
2472   0E66 E5                      PUSH HL
2473   0E67 62                      LD H, D
2474   0E68 6B                      LD L, E
2475   0E69 CD F6 0C                CALL SNDLCDMSG
2476   0E6C E1                      POP  HL             ;Restore registers
2477   0E6D D1                      POP  DE
2478   0E6E C1                      POP  BC
2479   0E6F C9                      RET
2480   0E70             
2481   0E70             
2482   0E70             ; Hex byte output to console
2483   0E70             ;   On entry: A = Byte to be output in hex
2484   0E70             ;   On exit:  BC DE HL IX IY preserved
2485   0E70 F5          HexOut:     PUSH AF             ;Preserve byte to be output
2486   0E71 1F                      RRA                 ;Shift top nibble to
2487   0E72 1F                      RRA                 ;  botom four bits..
2488   0E73 1F                      RRA
2489   0E74 1F                      RRA
2490   0E75 E6 0F                   AND  $0F           ;Mask off unwanted bits
2491   0E77 CD 7D 0E                CALL HexOutHex           ;Output hi nibble
2492   0E7A F1                      POP  AF             ;Restore byte to be output
2493   0E7B E6 0F                   AND  $0F           ;Mask off unwanted bits
2494   0E7D             ; Output nibble as ascii character
2495   0E7D FE 0A       HexOutHex:       CP   $0A           ;Nibble > 10 ?
2496   0E7F 38 02                   JR   C,HexOutSkip        ;No, so skip
2497   0E81 C6 07                   ADD  A,7            ;Yes, so add 7
2498   0E83 C6 30       HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
2499   0E85 C3 4E 0E                JP   API_Cout       ;Write character
2500   0E88             
2501   0E88             
2502   0E88             ; Output string at DE with substitutions
2503   0E88             ;   On entry: A = Address of device on I2C bus (write address)
2504   0E88             ;             DE = Address of null terminated string
2505   0E88             ;             H = Value to substitute for $H
2506   0E88             ;             L = Value to substitute for $L
2507   0E88             ;             B = Value to substitute for $B
2508   0E88             ;   On exit:  DE = Address of next location after this string
2509   0E88             ;             IX IY preserved
2510   0E88 1A          String:     LD   A,(DE)         ;Get character from string
2511   0E89 13                      INC  DE             ;Point to next character in string
2512   0E8A B7                      OR   A              ;Null ?
2513   0E8B C8                      RET  Z              ;Yes, so we're done
2514   0E8C FE 24                   CP   '$'            ;Substitue value?
2515   0E8E 28 05                   JR   Z,StringSubst       ;Yes, so go handle substitution
2516   0E90 CD 36 0E                CALL CharOut        ;Output character to console
2517   0E93 18 F3                   JR   String         ;Go get next character from string
2518   0E95 1A          StringSubst:     LD   A,(DE)         ;Get character from string
2519   0E96 13                      INC  DE             ;Point to next character in string
2520   0E97 B7                      OR   A              ;Null ?
2521   0E98 C8                      RET  Z              ;Yes, so we're done
2522   0E99 FE 48                   CP   'H'            ;Register H
2523   0E9B 20 03                   JR   NZ,StringNotH       ;No, so skip
2524   0E9D 7C                      LD   A,H            ;Get value 'H'
2525   0E9E 18 0C                   JR   StringGotIt         ;Go output it in hex
2526   0EA0 FE 4C       StringNotH:      CP   'L'            ;Register L
2527   0EA2 20 03                   JR   NZ,StringNotL       ;No, so skip
2528   0EA4 7D                      LD   A,L            ;Get value 'L'
2529   0EA5 18 05                   JR   StringGotIt         ;Go output it in hex
2530   0EA7 FE 42       StringNotL:      CP   'B'            ;Register B
2531   0EA9 20 04                   JR   NZ,StringNotB       ;No, so skip
2532   0EAB 78                      LD   A,B            ;Get value 'L'
2533   0EAC                         ;JR   @GotIt        ;Go output it in hex
2534   0EAC CD 70 0E    StringGotIt:     CALL HexOut         ;Output write address in hex
2535   0EAF 18 D7       StringNotB:      JR   String         ;Go get next character from string
2536   0EB1             
2537   0EB1             
2538   0EB1             ; **********************************************************************
2539   0EB1             ; I2C support functions
2540   0EB1             
2541   0EB1             ; I2C bus open device
2542   0EB1             ;   On entry: A = Device address (bit zero is read flag)
2543   0EB1             ;             SCL = unknown, SDA = unknown
2544   0EB1             ;   On exit:  If successfully A = 0 and Z flagged
2545   0EB1             ;             If unsuccessfully A = Error and NZ flagged
2546   0EB1             ;             BC DE HL IX IY preserved
2547   0EB1 F5          I2C_Open:   PUSH AF
2548   0EB2 CD 25 0F                CALL I2C_Start      ;Output start condition
2549   0EB5 F1                      POP  AF
2550   0EB6 18 03                   JR   I2C_Write      ;Write data byte
2551   0EB8             
2552   0EB8             
2553   0EB8             ; I2C bus close device
2554   0EB8             ;   On entry: SCL = unknown, SDA = unknown
2555   0EB8             ;   On exit:  If successfully A=0 and Z flagged
2556   0EB8             ;             If unsuccessfully A=Error and NZ flagged
2557   0EB8             ;             SCL = hi, SDA = hi
2558   0EB8             ;             BC DE HL IX IY preserved
2559   0EB8 C3 30 0F    I2C_Close:  JP   I2C_Stop       ;Output stop condition
2560   0EBB             
2561   0EBB             
2562   0EBB             ; **********************************************************************
2563   0EBB             ; **********************************************************************
2564   0EBB             ; I2C bus master driver
2565   0EBB             ; **********************************************************************
2566   0EBB             ; **********************************************************************
2567   0EBB             
2568   0EBB             ; Functions provided are:
2569   0EBB             ;     I2C_Start
2570   0EBB             ;     I2C_Stop
2571   0EBB             ;     I2C_Read
2572   0EBB             ;     I2C_Write
2573   0EBB             ;
2574   0EBB             ; This code has delays between all I/O operations to ensure it works
2575   0EBB             ; with the slowest I2C devices
2576   0EBB             ;
2577   0EBB             ; I2C transfer sequence
2578   0EBB             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2579   0EBB             ;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
2580   0EBB             ;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
2581   0EBB             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2582   0EBB             ;
2583   0EBB             ;
2584   0EBB             ; Start condition                     Stop condition
2585   0EBB             ; Output by master device             Output by master device
2586   0EBB             ;       ----+                                      +----
2587   0EBB             ; SDA       |                         SDA          |
2588   0EBB             ;           +-------                        -------+
2589   0EBB             ;       -------+                                +-------
2590   0EBB             ; SCL          |                      SCL       |
2591   0EBB             ;              +----                        ----+
2592   0EBB             ;
2593   0EBB             ;
2594   0EBB             ; Address frame
2595   0EBB             ; Clock and data output from master device
2596   0EBB             ; Receiving device outputs acknowledge 
2597   0EBB             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2598   0EBB             ; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
2599   0EBB             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2600   0EBB             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2601   0EBB             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2602   0EBB             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2603   0EBB             ;
2604   0EBB             ;
2605   0EBB             ; Data frame 
2606   0EBB             ; Clock output by master device
2607   0EBB             ; Data output by transmitting device
2608   0EBB             ; Receiving device outputs acknowledge 
2609   0EBB             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2610   0EBB             ; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
2611   0EBB             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2612   0EBB             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2613   0EBB             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2614   0EBB             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2615   0EBB             ;
2616   0EBB             
2617   0EBB             
2618   0EBB             ; **********************************************************************
2619   0EBB             ; I2C constants
2620   0EBB             
2621   0EBB             
2622   0EBB             ; I2C bus master interface
2623   0EBB             ; The default device option is for SC126 or compatible
2624   0EBB             
2625   0EBB             I2C_PORT:   .EQU $21           ;Host I2C port address
2626   0EBB             I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
2627   0EBB             I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
2628   0EBB             I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
2629   0EBB             I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
2630   0EBB             I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
2631   0EBB             
2632   0EBB             
2633   0EBB             ; I2C support constants
2634   0EBB             ERR_NONE:   .EQU 0              ;Error = None
2635   0EBB             ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
2636   0EBB             ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
2637   0EBB             ERR_TOUT:   .EQU 3              ;Error = Timeout
2638   0EBB             
2639   0EBB             
2640   0EBB             ; **********************************************************************
2641   0EBB             ; Hardware dependent I2C bus functions
2642   0EBB             
2643   0EBB             
2644   0EBB             ; I2C bus transmit frame (address or data)
2645   0EBB             ;   On entry: A = Data byte, or
2646   0EBB             ;                 Address byte (bit zero is read flag)
2647   0EBB             ;             SCL = low, SDA = low
2648   0EBB             ;   On exit:  If successful A=0 and Z flagged
2649   0EBB             ;                SCL = lo, SDA = lo
2650   0EBB             ;             If unsuccessful A=Error and NZ flagged
2651   0EBB             ;                SCL = high, SDA = high, I2C closed
2652   0EBB             ;             BC DE HL IX IY preserved
2653   0EBB C5          I2C_Write:  PUSH BC             ;Preserve registers
2654   0EBC D5                      PUSH DE
2655   0EBD 57                      LD   D,A            ;Store byte to be written
2656   0EBE 06 08                   LD   B,8            ;8 data bits, bit 7 first
2657   0EC0 CB 12       I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
2658   0EC2 38 05                   JR   C,I2C_WriteBit_Hi      ;High, so skip
2659   0EC4 CD 57 0F                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
2660   0EC7 18 03                   JR   I2C_WriteBit_Clk
2661   0EC9 CD 50 0F    I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
2662   0ECC CD 42 0F    I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
2663   0ECF CD 49 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
2664   0ED2 10 EC                   DJNZ I2C_WriteWr_Loop
2665   0ED4             ; Test for acknowledge from slave (receiver)
2666   0ED4             ; On arriving here, SCL = lo, SDA = data bit
2667   0ED4 CD 50 0F                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
2668   0ED7 CD 42 0F                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
2669   0EDA CD 68 0F                CALL I2C_RdPort     ;Read SDA input
2670   0EDD 47                      LD   B,A
2671   0EDE CD 49 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
2672   0EE1 CB 78                   BIT  I2C_SDA_RD,B
2673   0EE3 20 04                   JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
2674   0EE5 D1                      POP  DE             ;Restore registers
2675   0EE6 C1                      POP  BC
2676   0EE7 AF                      XOR  A              ;Return success A=0 and Z flagged
2677   0EE8 C9                      RET
2678   0EE9             ; I2C STOP required as no acknowledge
2679   0EE9             ; On arriving here, SCL = lo, SDA = hi
2680   0EE9 CD 57 0F    I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
2681   0EEC CD 42 0F                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
2682   0EEF CD 50 0F                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
2683   0EF2 D1                      POP  DE             ;Restore registers
2684   0EF3 C1                      POP  BC
2685   0EF4 3E 02                   LD   A,ERR_NOACK    ;Return error = No Acknowledge
2686   0EF6 B7                      OR   A              ;  and NZ flagged
2687   0EF7 C9                      RET
2688   0EF8             
2689   0EF8             
2690   0EF8             ; I2C bus receive frame (data)
2691   0EF8             ;   On entry: A = Acknowledge flag
2692   0EF8             ;               If A != 0 the read is acknowledged
2693   0EF8             ;             SCL low, SDA low
2694   0EF8             ;   On exit:  If successful A = data byte and Z flagged
2695   0EF8             ;               SCL = low, SDA = low
2696   0EF8             ;             If unsuccessul* A = Error and NZ flagged
2697   0EF8             ;               SCL = low, SDA = low
2698   0EF8             ;             BC DE HL IX IY preserved
2699   0EF8             ; *This function always returns successful
2700   0EF8 C5          I2C_Read:   PUSH BC             ;Preserve registers
2701   0EF9 D5                      PUSH DE
2702   0EFA 5F                      LD   E,A            ;Store acknowledge flag
2703   0EFB 06 08                   LD   B,8            ;8 data bits, 7 first
2704   0EFD CD 50 0F                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
2705   0F00 CD 42 0F    I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
2706   0F03 CD 68 0F                CALL I2C_RdPort     ;Read SDA input bit
2707   0F06 37                      SCF                 ;Set carry flag
2708   0F07 CB 7F                   BIT  I2C_SDA_RD,A   ;SDA input high?
2709   0F09 20 01                   JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
2710   0F0B 3F                      CCF                 ;Clear carry flag
2711   0F0C CB 12       I2C_ReadRotate:    RL   D              ;Rotate result into D
2712   0F0E CD 49 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
2713   0F11 10 ED                   DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
2714   0F13             ; Acknowledge input byte
2715   0F13             ; On arriving here, SCL = lo, SDA = hi/input
2716   0F13 7B                      LD   A,E            ;Get acknowledge flag
2717   0F14 B7                      OR   A              ;A = 0? (indicates no acknowledge)
2718   0F15 28 03                   JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
2719   0F17 CD 57 0F                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
2720   0F1A CD 42 0F    I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
2721   0F1D CD 49 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2722   0F20 7A                      LD   A,D            ;Get data byte received
2723   0F21 D1                      POP  DE             ;Restore registers
2724   0F22 C1                      POP  BC
2725   0F23 BF                      CP   A              ;Return success Z flagged
2726   0F24 C9                      RET
2727   0F25             
2728   0F25             
2729   0F25             ; I2C bus start
2730   0F25             ;   On entry: SCL = unknown, SDA = unknown
2731   0F25             ;   On exit:  SCL = low, SDA = low
2732   0F25             ;             A = 0 and Z flagged as we always succeed
2733   0F25             ;             BC DE HL IX IY preserved
2734   0F25             ; First ensure SDA and SCL are high
2735   0F25 CD 3E 0F    I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
2736   0F28             ;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
2737   0F28             ;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
2738   0F28             ; Generate I2C start condition
2739   0F28 CD 57 0F                CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2740   0F2B CD 49 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2741   0F2E AF                      XOR  A              ;Return success A=0 and Z flagged
2742   0F2F C9                      RET
2743   0F30             
2744   0F30             
2745   0F30             ; I2C bus stop 
2746   0F30             ;   On entry: SCL = unknown, SDA = unknown
2747   0F30             ;   On exit:  SCL = high, SDA = high
2748   0F30             ;             A = 0 and Z flagged as we always succeed
2749   0F30             ;             BC DE HL IX IY preserved
2750   0F30             ; First ensure SDA and SCL are low
2751   0F30 CD 57 0F    I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
2752   0F33 CD 49 0F                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
2753   0F36             ; Generate stop condition
2754   0F36 CD 42 0F                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
2755   0F39 CD 50 0F                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
2756   0F3C AF                      XOR  A              ;Return success A=0 and Z flagged
2757   0F3D C9                      RET
2758   0F3E             
2759   0F3E             
2760   0F3E             ; **********************************************************************
2761   0F3E             ; I2C bus simple I/O functions
2762   0F3E             ;   On entry: No parameters required
2763   0F3E             ;   On exit:  BC DE HL IX IY preserved
2764   0F3E             
2765   0F3E 3E 81       I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
2766   0F40 18 1A                   JR   I2C_WrPort
2767   0F42             
2768   0F42 3A 00 D0    I2C_SCL_HI: LD   A,(I2C_RAMCPY)
2769   0F45 CB C7                   SET  I2C_SCL_WR,A
2770   0F47 18 13                   JR   I2C_WrPort
2771   0F49             
2772   0F49 3A 00 D0    I2C_SCL_LO: LD   A,(I2C_RAMCPY)
2773   0F4C CB 87                   RES  I2C_SCL_WR,A
2774   0F4E 18 0C                   JR   I2C_WrPort
2775   0F50             
2776   0F50 3A 00 D0    I2C_SDA_HI: LD   A,(I2C_RAMCPY)
2777   0F53 CB FF                   SET  I2C_SDA_WR,A
2778   0F55 18 05                   JR   I2C_WrPort
2779   0F57             
2780   0F57 3A 00 D0    I2C_SDA_LO: LD   A,(I2C_RAMCPY)
2781   0F5A CB BF                   RES  I2C_SDA_WR,A
2782   0F5C                         ;JR   I2C_WrPort
2783   0F5C             
2784   0F5C C5          I2C_WrPort: PUSH BC             ;Preserve registers
2785   0F5D 06 00                   LD   B,0            ;Set up BC for 16-bit
2786   0F5F 0E 21                   LD   C,I2C_PORT     ;  I/O address of I2C port
2787   0F61 ED 79                   OUT  (C),A          ;Write A to I2C I/O port
2788   0F63 32 00 D0                LD   (I2C_RAMCPY),A ;Write A to RAM copy
2789   0F66 C1                      POP  BC             ;Restore registers
2790   0F67 C9                      RET
2791   0F68             
2792   0F68 C5          I2C_RdPort: PUSH BC             ;Preserve registers
2793   0F69 06 00                   LD   B,0            ;Set up BC for 16-bit
2794   0F6B 0E 21                   LD   C,I2C_PORT     ;  I/O address of I2C port
2795   0F6D ED 78                   IN   A,(C)          ;Read A from I/O port
2796   0F6F C1                      POP  BC             ;Restore registers
2797   0F70 C9                      RET
2798   0F71             
2799   0F71             
2800   0F71             
2801   0F71 0C0D0D0A5A38WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
2801   0F77 30204D696E6920496E69636961646F0D0A00
2802   0F89 5A3830204D49MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H
2802   0F8F 4E492C204820544F2048454C500D00
2803   0F9E             
2804   0F9E 49202D20496EMSG_MENU1 .db "I - Intel hex loader",CR, 00H
2804   0FA4 74656C20686578206C6F616465720D00
2805   0FB4 42202D204261MSG_MENU2 .db "B - Basic",CR, 00H
2805   0FBA 7369630D00
2806   0FBF 442041414141MSG_MENU3 .db "D AAAA - DISPLAY",CR,00H
2806   0FC5 202D20444953504C41590D00
2807   0FD1 4D2041414141MSG_MENU4 .db "M AAAA - MODIFY",CR,00H
2807   0FD7 202D204D4F444946590D00
2808   0FE2 472041414141MSG_MENU5 .db "G AAAA - GO TO",CR, 00H
2808   0FE8 202D20474F20544F0D00
2809   0FF2 31202D204932MSG_MENU6 .db "1 - I2C Scan",CR, 00H
2809   0FF8 43205363616E0D00
2810   1000 32202D204932MSG_MENU7 .db "2 - I2C PC -> MEM",CR, 00H
2810   1006 43205043202D3E204D454D0D00
2811   1013 33202D204932MSG_MENU8 .db "3 - I2C MEM -> PC", 00H
2811   1019 43204D454D202D3E20504300
2812   1025             
2813   1025 0C4932432064LISTMsg:    .DB  CS,"I2C device found at:",CR,0
2813   102B 657669636520666F756E642061743A0D00
2814   103C 0C434F505920MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
2814   1042 493243204D454D20544F204350550D00
2815   1052 0C434F505920MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H
2815   1058 43505520544F20493243204D454D0D00
2816   1068 46524F4D3A20MSG_FROM    .db "FROM: ", 00H
2816   106E 00
2817   106F 0D544F3A2000MSG_TO      .db CR,"TO: ", 00H
2818   1075 0D53495A4528MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
2818   107B 4259544553293A2000
2819   1084 0D434F505920MSG_COPYOK  .db CR,"COPY OK", 00H
2819   108A 4F4B00
2820   108D 0D434F505920MSG_COPYFAIL  .db CR,"COPY FAIL", 00H
2820   1093 4641494C00
2821   1098             
2822   1098             
2823   1098 0C496E74656CMSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
2823   109E 20484558206C6F616465722E2E2E0D00
2824   10AE 46494C452052FILEOK    .DB      "FILE RECEIVED OK",CR,00H
2824   10B4 45434549564544204F4B0D00
2825   10C0 434845434B53CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
2825   10C6 554D204552524F520D00
2826   10D0             
2827   10D0             
2828   10D0             
2829   10D0             ; **********************************************************************
2830   10D0             ; I2C workspace / variables in RAM
2831   10D0             
2832   D000                         .ORG  I2CDATA
2833   D000             
2834   D000 00          I2C_RAMCPY: .DB  0              ;RAM copy of output port
2835   D001             
2836   D001 00          RESULTS:    .DB  0              ;Large block of results can start here
2837   D002             
2838   D002             .end
tasm: Number of errors = 0
