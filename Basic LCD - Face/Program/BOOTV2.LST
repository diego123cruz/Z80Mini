0001   0000             ; Diego Cruz - Nov 2022
0002   0000             ; 
0003   0000             ; bootV2: 
0004   0000             ;         - CPU Z80@4Mhz
0005   0000             ;         - Lcd Grafico 128x64
0006   0000             ;         - Keyboard 40 keys + Shift
0007   0000             ;         - Rom 32k 0000h - 7FFFh
0008   0000             ;         - Ram 32k 8000h - FFFFh
0009   0000             ;         
0010   0000             ;
0011   0000             ;         - Ports:
0012   0000             ;               - Keyboard: 40H
0013   0000             ;               - Display:  70H (LCDCTRL), 71H (LCDDATA)
0014   0000             ;               - User IN/OUT: C0H
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------
0017   0000             LCDCTRL	    .EQU    70H
0018   0000             LCDDATA     .EQU    71H
0019   0000             KEY_IN      .EQU    40H
0020   0000             KEY_OUT     .EQU    40H
0021   0000             
0022   0000             CTRLC       .EQU    03H             ; Control "C"
0023   0000             CTRLG       .EQU    07H             ; Control "G"
0024   0000             BKSP        .EQU    08H             ; Back space
0025   0000             LF          .EQU    0AH             ; Line feed
0026   0000             VT          .equ    0BH             ; 
0027   0000             CS          .EQU    0CH             ; Clear screen
0028   0000             CR          .EQU    0DH             ; Carriage return [Enter]
0029   0000             CTRLO       .EQU    0FH             ; Control "O"
0030   0000             CTRLQ	    .EQU	11H		        ; Control "Q"
0031   0000             CTRLR       .EQU    12H             ; Control "R"
0032   0000             CTRLS       .EQU    13H             ; Control "S"
0033   0000             CTRLU       .EQU    15H             ; Control "U"
0034   0000             ESC         .EQU    1BH             ; Escape
0035   0000             DEL         .EQU    7FH             ; Delete
0036   0000             
0037   0000             KLEFT       .EQU    $B4             ; Key Left
0038   0000             KRIGHT      .EQU    $B7             ; Key Right
0039   0000             KUP         .EQU    $B5             ; Key Up
0040   0000             KDOWN       .EQU    $B6             ; Key Down
0041   0000             KF1         .EQU    $80             ; Key F1
0042   0000             KF2         .EQU    $81             ; Key F2
0043   0000             KF3         .EQU    $82             ; Key F3
0044   0000             KF4         .EQU    $83             ; Key F4
0045   0000             KF5         .EQU    $84             ; Key F5 (SHIFT)
0046   0000             KF6         .EQU    $85             ; Key F6 (SHIFT)
0047   0000             KF7         .EQU    $86             ; Key F7 (SHIFT)
0048   0000             KF8         .EQU    $87             ; Key F8 (SHIFT)
0049   0000             
0050   0000             kCPUClock:  .EQU 4000000       ;CPU clock speed in Hz
0051   0000             kDelayOH:   .EQU 36             ;Overhead for each 1ms in Tcycles
0052   0000             kDelayLP:   .EQU 26             ;Inner loop time in Tcycles
0053   0000             kDelayTA:   .EQU kCPUClock / 1000 ;CPU clock cycles per millisecond
0054   0000             kDelayTB:   .EQU kDelayTA - kDelayOH  ;Cycles required for inner loop
0055   0000             kDelayCnt:  .EQU kDelayTB / kDelayLP  ;Loop counter for inner loop
0056   0000             
0057   0000             BASIC       .EQU    $6000           ; inicio basic 6000H, workspace 9000H
0058   0000             ;
0059   0000             ; BAUD RATE CONSTANTS
0060   0000             ;
0061   0000             B300:	.EQU	0220H	;300 BAUD
0062   0000             B1200:	.EQU	0080H	;1200 BAUD
0063   0000             B2400:	.EQU	003FH	;2400 BAUD
0064   0000             B4800:	.EQU	001BH	;4800 BAUD
0065   0000             B9600:	.EQU	000BH	;9600 BAUD
0066   0000             
0067   0000             SYSTEM:	.EQU 	0F000H	;INITIAL STACK POINTER
0068   0000             I2CDATA .EQU    0D000H 
0069   0000             
0070   0000             I2CA_BLOCK: .EQU $AE            ;I2C device addess: 24LC256 (Copy from/to Mem)
0071   0000             TIMEOUT:    .EQU 10000          ;Timeout loop counter
0072   0000             
0073   0000             ADDR:       .EQU 0FEB0H   ;THE ADDRESS  2 bytes
0074   0000             ADDR_FROM   .EQU 0FEB2H   ;THE ADDRESS FROM  2 bytes
0075   0000             ADDR_TO     .EQU 0FEB4H   ;THE ADDRESS TO 2 bytes
0076   0000             ADDR_SIZE   .EQU 0FEB6H   ;THE ADDRESS SIZE 2 bytes
0077   0000             DATA:       .EQU 0FEB8H   ;THE DATA
0078   0000             MSGBUF:     .EQU 0FE00H   ;STRING HANDLING AREA
0079   0000             
0080   0000             PORT_SET        .EQU 0FFB0H ; 1 byte - Define port (input/output) Default 0xC0(onboard)
0081   0000             PORT_OUT_VAL    .EQU 0FFB1H ; 1 byte - save value out port
0082   0000             LCD_DATA        .EQU 0FFB2H ; 1byte
0083   0000             
0084   0000             I2C_ADDR        .EQU $FFC0 ; 1 byte - device address
0085   0000             I2C_RR          .EQU $FFC1 ; 1 byte - register
0086   0000             I2C_DD          .EQU $FFC2 ; 1 byte - data
0087   0000             
0088   0000             
0089   0000             BAUD:	 .EQU	0FFC0H	 ;BAUD RATE
0090   0000             PUTCH:   .EQU   0FFAAH   ;OUTPUT A CHARACTER TO SERIAL
0091   0000             GETCH:   .EQU   0FFACH   ;WAIT FOR A CHARACTER FROM SERIAL
0092   0000             
0093   0000             SERIAL_RX_PORT:          .EQU $C0             ; Serial RX port - bit7
0094   0000             SERIAL_TX_PORT:          .EQU $C0             ; Serial TX Port - bit6
0095   0000             
0096   0000             
0097   0000             ; LCD TEXT MODE
0098   0000             LCD_LINE1   .EQU    80H
0099   0000             LCD_LINE2   .EQU    90H
0100   0000             LCD_LINE3   .EQU    88H
0101   0000             LCD_LINE4   .EQU    98H
0102   0000             
0103   0000             
0104   0000             ; RAM MAP
0105   0000             
0106   0000             
0107   0000             
0108   0000             LCD_CHAR            .EQU    $E000   ; 1 byte char ex: 'A'
0109   0000             LCD_CHAR_POINT      .EQU    $E001   ; 2 bytes ponteiro para o mapa de caracteres
0110   0000             LCD_TXT_X           .EQU    $E003   ; 1 byte  0-20 (21 col)
0111   0000             LCD_TXT_Y           .EQU    $E004   ; 1 byte  0-7  (8 row)
0112   0000             LCD_BYTE_INDEX      .EQU    $E005   ; 2 bytes pointer pixel(8)
0113   0000             LCD_BIT_INDEX       .EQU    $E007   ; 1 byte pointer pixel(1)
0114   0000             LCD_TXT_X_TMP       .EQU    $E008   ; 2 bytes = LCD_TXT_X * 6
0115   0000             LCD_TXT_Y_TMP       .EQU    $E00A   ; 2 bytes = LCD_TXT_Y * 128
0116   0000             LCD_CHAR_H          .EQU    $E00C   ; 1 byte altura do char
0117   0000             LCD_CHAR_W          .EQU    $E00D   ; 1 byte largura do char
0118   0000             LCD_TMP_POINT       .EQU    $E00E   ; 2 bytes ponteiro do pixel altural do print
0119   0000             LCD_DELETE_CHAR     .EQU    $E00F   ; 1 byte, 0 não, ff delete proximo char
0120   0000             LCD_AUTO_X          .EQU    $E010   ; 1 byte, 0 sim, ff nao
0121   0000             
0122   0000             DISPLAY             .EQU    $E500
0123   0000             
0124   0000             LCD_TEMP        .EQU    $E110
0125   0000             LCD_COOX        .EQU    $E102 ; 1 byte, local onde vai printar
0126   0000             LCD_COOY        .EQU    $E103 ; 1 byte
0127   0000             LCD_PRINT_H     .EQU    $E104 ; 1 byte, tamanho do que vai printar
0128   0000             LCD_PRINT_W     .EQU    $E105 ; 1 byte
0129   0000             LCD_PRINT_IMAGE .EQU    $E106 ; 2 bytes
0130   0000             
0131   0000             
0132   0000                     .ORG 0
0133   0000 F3          RST00	DI
0134   0001 C3 93 04            JP  INICIO
0135   0004             						
0136   0008                     .ORG     0008H
0137   0008 C3 57 0A    RST08   JP  PRINTCHAR
0138   000B             
0139   0010                     .ORG 0010H
0140   0010 C3 88 0D    RST10   JP KEYREADINIT
0141   0013             
0142   0018                     .ORG 0018H ; check break
0143   0018 C3 73 0D    RST18   JP CHKKEY
0144   001B             
0145   0030                     .ORG 0030H
0146   0030 C3 48 05    RST30   JP APIHandler
0147   0033             
0148   0033             
0149   0033             KEYMAP:
0150   0033 313233343580.BYTE   "12345",KF1,"67890"
0150   0039 3637383930
0151   003E 815157455254.BYTE   KF2,"QWERT",KF3,"YUIOP"
0151   0044 825955494F50
0152   004A 834153444647.BYTE   KF4,"ASDFG",KLEFT,"HJKL", CR
0152   0050 B4484A4B4C0D
0153   0056 B6035A584356.BYTE   KDOWN,CTRLC, "ZXCV",KRIGHT,"BNM ", DEL, KUP
0153   005C B7424E4D207FB5
0154   0063             
0155   0063             SHIFTKEYMAP:
0156   0063 214023242584.BYTE   "!@#$%",KF5,"^&*()"
0156   0069 5E262A2829
0157   006E 85607E2D5F3D.BYTE   KF6,"`~-_=",KF7,"+;:'" 
0157   0074 862B3B3A27
0158   0079 22          .BYTE 22h,
0159   007A 877B7D5B5D7C.BYTE   KF8,"{}[]|",KLEFT,$5C,"<>?", CR
0159   0080 B45C3C3E3F0D
0160   0086 B61B2F2C2E20.BYTE   KDOWN,ESC,"/,. ",KRIGHT,"    ", DEL, KUP
0160   008C B7202020207FB5
0161   0093             
0162   0093             
0163   0093             
0164   0093             
0165   0093             TABLE:
0166   0093 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NUL
0166   0099 0000
0167   009B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SOH
0167   00A1 0000
0168   00A3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; STX
0168   00A9 0000
0169   00AB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETX
0169   00B1 0000
0170   00B3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EOT
0170   00B9 0000
0171   00BB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ENQ
0171   00C1 0000
0172   00C3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ACK
0172   00C9 0000
0173   00CB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BEL
0173   00D1 0000
0174   00D3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; BS
0174   00D9 0000
0175   00DB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; TAB
0175   00E1 0000
0176   00E3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; LF
0176   00E9 0000
0177   00EB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; VT
0177   00F1 0000
0178   00F3 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FF
0178   00F9 0000
0179   00FB 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CR
0179   0101 0000
0180   0103 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SO
0180   0109 0000
0181   010B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SI
0181   0111 0000
0182   0113 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DLE
0182   0119 0000
0183   011B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC1
0183   0121 0000
0184   0123 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC2
0184   0129 0000
0185   012B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC3
0185   0131 0000
0186   0133 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DC4
0186   0139 0000
0187   013B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; NAK
0187   0141 0000
0188   0143 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SYN
0188   0149 0000
0189   014B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ETB
0189   0151 0000
0190   0153 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; CAN
0190   0159 0000
0191   015B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; EM
0191   0161 0000
0192   0163 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SUB
0192   0169 0000
0193   016B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; ESC
0193   0171 0000
0194   0173 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; FS
0194   0179 0000
0195   017B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; GS
0195   0181 0000
0196   0183 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; RS
0196   0189 0000
0197   018B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; US
0197   0191 0000
0198   0193             
0199   0193             ; DEC 32
0200   0193 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; SPACE
0200   0199 0000
0201   019B 202020202000.db $20, $20, $20, $20, $20, $00, $20, $00 ; !
0201   01A1 2000
0202   01A3 505050000000.db $50, $50, $50, $00, $00, $00, $00, $00 ; "
0202   01A9 0000
0203   01AB 5050F850F850.db $50, $50, $F8, $50, $F8, $50, $50, $00 ; #
0203   01B1 5000
0204   01B3 2078A07028F0.db $20, $78, $A0, $70, $28, $F0, $20, $00 ; $
0204   01B9 2000
0205   01BB C0C810204098.db $C0, $C8, $10, $20, $40, $98, $18, $00 ; %
0205   01C1 1800
0206   01C3 6090A040A890.db $60, $90, $A0, $40, $A8, $90, $68, $00 ; &
0206   01C9 6800
0207   01CB 202020000000.db $20, $20, $20, $00, $00, $00, $00, $00 ; '
0207   01D1 0000
0208   01D3 102040404020.db $10, $20, $40, $40, $40, $20, $10, $00 ; (
0208   01D9 1000
0209   01DB 402010101020.db $40, $20, $10, $10, $10, $20, $40, $00 ; )
0209   01E1 4000
0210   01E3 0020A870A820.db $00, $20, $A8, $70, $A8, $20, $00, $00 ; *
0210   01E9 0000
0211   01EB 002020F82020.db $00, $20, $20, $F8, $20, $20, $00, $00 ; +
0211   01F1 0000
0212   01F3 000000006020.db $00, $00, $00, $00, $60, $20, $40, $00 ; ,
0212   01F9 4000
0213   01FB 000000F80000.db $00, $00, $00, $F8, $00, $00, $00, $00 ; -
0213   0201 0000
0214   0203 000000000060.db $00, $00, $00, $00, $00, $60, $60, $00 ; .
0214   0209 6000
0215   020B 000008102040.db $00, $00, $08, $10, $20, $40, $80, $00 ; /
0215   0211 8000
0216   0213 708898A8C888.db $70, $88, $98, $A8, $C8, $88, $70, $00 ; 0
0216   0219 7000
0217   021B 206020202020.db $20, $60, $20, $20, $20, $20, $70, $00 ; 1
0217   0221 7000
0218   0223 708808102040.db $70, $88, $08, $10, $20, $40, $F8, $00 ; 2
0218   0229 F800
0219   022B F81020100888.db $F8, $10, $20, $10, $08, $88, $70, $00 ; 3
0219   0231 7000
0220   0233 10305090F810.db $10, $30, $50, $90, $F8, $10, $10, $00 ; 4
0220   0239 1000
0221   023B F880F0080888.db $F8, $80, $F0, $08, $08, $88, $70, $00 ; 5
0221   0241 7000
0222   0243 304080F08888.db $30, $40, $80, $F0, $88, $88, $70, $00 ; 6
0222   0249 7000
0223   024B F80810204040.db $F8, $08, $10, $20, $40, $40, $40, $00 ; 7
0223   0251 4000
0224   0253 708888708888.db $70, $88, $88, $70, $88, $88, $70, $00 ; 8
0224   0259 7000
0225   025B 708888780810.db $70, $88, $88, $78, $08, $10, $60, $00 ; 9
0225   0261 6000
0226   0263 000030300030.db $00, $00, $30, $30, $00, $30, $30, $00 ; :
0226   0269 3000
0227   026B 003030003010.db $00, $30, $30, $00, $30, $10, $20, $00 ; ;
0227   0271 2000
0228   0273 102040804020.db $10, $20, $40, $80, $40, $20, $10, $00 ; <
0228   0279 1000
0229   027B 0000F800F800.db $00, $00, $F8, $00, $F8, $00, $00, $00 ; =
0229   0281 0000
0230   0283 402010081020.db $40, $20, $10, $08, $10, $20, $40, $00 ; >
0230   0289 4000
0231   028B 304808102000.db $30, $48, $08, $10, $20, $00, $20, $00 ; ?
0231   0291 2000
0232   0293 70880868A8A8.db $70, $88, $08, $68, $A8, $A8, $70, $00 ; @
0232   0299 7000
0233   029B             
0234   029B             ; DEC 65 Maiusculas
0235   029B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0235   02A1 8800
0236   02A3 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0236   02A9 F000
0237   02AB 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0237   02B1 7000
0238   02B3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0238   02B9 E000
0239   02BB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0239   02C1 F800
0240   02C3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0240   02C9 8000
0241   02CB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0241   02D1 7000
0242   02D3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0242   02D9 8800
0243   02DB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0243   02E1 7000
0244   02E3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0244   02E9 7000
0245   02EB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0245   02F1 8800
0246   02F3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0246   02F9 F800
0247   02FB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0247   0301 8800
0248   0303 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0248   0309 8800
0249   030B 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0249   0311 7000
0250   0313 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0250   0319 8000
0251   031B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0251   0321 7000
0252   0323 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0252   0329 8800
0253   032B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0253   0331 7000
0254   0333 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0254   0339 2000
0255   033B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0255   0341 7000
0256   0343 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0256   0349 2000
0257   034B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0257   0351 8800
0258   0353 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0258   0359 8800
0259   035B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0259   0361 2000
0260   0363 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0260   0369 F800
0261   036B             
0262   036B             ; DEC 91
0263   036B 302020202020.db $30, $20, $20, $20, $20, $20, $30, $00 ; [
0263   0371 3000
0264   0373 008040201008.db $00, $80, $40, $20, $10, $08, $00, $00 ; \
0264   0379 0000
0265   037B 602020202020.db $60, $20, $20, $20, $20, $20, $60, $00 ; ]
0265   0381 6000
0266   0383 205088000000.db $20, $50, $88, $00, $00, $00, $00, $00 ; ^
0266   0389 0000
0267   038B 000000000000.db $00, $00, $00, $00, $00, $00, $F8, $00 ; _
0267   0391 F800
0268   0393 402010000000.db $40, $20, $10, $00, $00, $00, $00, $00 ; `
0268   0399 0000
0269   039B             
0270   039B             ; DEC 97 "Minusculas"
0271   039B 20508888F888.db $20, $50, $88, $88, $F8, $88, $88, $00 ; A
0271   03A1 8800
0272   03A3 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $F0, $00 ; B
0272   03A9 F000
0273   03AB 708880808088.db $70, $88, $80, $80, $80, $88, $70, $00 ; C
0273   03B1 7000
0274   03B3 E09088888890.db $E0, $90, $88, $88, $88, $90, $E0, $00 ; D
0274   03B9 E000
0275   03BB F88080F08080.db $F8, $80, $80, $F0, $80, $80, $F8, $00 ; E
0275   03C1 F800
0276   03C3 F88080F08080.db $F8, $80, $80, $F0, $80, $80, $80, $00 ; F
0276   03C9 8000
0277   03CB 70888080B888.db $70, $88, $80, $80, $B8, $88, $70, $00 ; G
0277   03D1 7000
0278   03D3 888888F88888.db $88, $88, $88, $F8, $88, $88, $88, $00 ; H
0278   03D9 8800
0279   03DB 702020202020.db $70, $20, $20, $20, $20, $20, $70, $00 ; I
0279   03E1 7000
0280   03E3 080808088888.db $08, $08, $08, $08, $88, $88, $70, $00 ; J
0280   03E9 7000
0281   03EB 8890A0C0A090.db $88, $90, $A0, $C0, $A0, $90, $88, $00 ; K
0281   03F1 8800
0282   03F3 808080808080.db $80, $80, $80, $80, $80, $80, $F8, $00 ; L
0282   03F9 F800
0283   03FB 88D8A8888888.db $88, $D8, $A8, $88, $88, $88, $88, $00 ; M
0283   0401 8800
0284   0403 8888C8A89888.db $88, $88, $C8, $A8, $98, $88, $88, $00 ; N
0284   0409 8800
0285   040B 708888888888.db $70, $88, $88, $88, $88, $88, $70, $00 ; O
0285   0411 7000
0286   0413 F08888F08080.db $F0, $88, $88, $F0, $80, $80, $80, $00 ; P
0286   0419 8000
0287   041B 70888888A898.db $70, $88, $88, $88, $A8, $98, $70, $00 ; Q
0287   0421 7000
0288   0423 F08888F08888.db $F0, $88, $88, $F0, $88, $88, $88, $00 ; R
0288   0429 8800
0289   042B 708880700888.db $70, $88, $80, $70, $08, $88, $70, $00 ; S
0289   0431 7000
0290   0433 F82020202020.db $F8, $20, $20, $20, $20, $20, $20, $00 ; T
0290   0439 2000
0291   043B 888888888888.db $88, $88, $88, $88, $88, $88, $70, $00 ; U
0291   0441 7000
0292   0443 888888888850.db $88, $88, $88, $88, $88, $50, $20, $00 ; V
0292   0449 2000
0293   044B 88888888A8D8.db $88, $88, $88, $88, $A8, $D8, $88, $00 ; W
0293   0451 8800
0294   0453 888850205088.db $88, $88, $50, $20, $50, $88, $88, $00 ; X
0294   0459 8800
0295   045B 888850202020.db $88, $88, $50, $20, $20, $20, $20, $00 ; Y
0295   0461 2000
0296   0463 F80810204080.db $F8, $08, $10, $20, $40, $80, $F8, $00 ; Z
0296   0469 F800
0297   046B             
0298   046B             ; DEC 123
0299   046B 102020402020.db $10, $20, $20, $40, $20, $20, $10, $00 ; {
0299   0471 1000
0300   0473 202020202020.db $20, $20, $20, $20, $20, $20, $20, $00 ; |
0300   0479 2000
0301   047B 402020102020.db $40, $20, $20, $10, $20, $20, $40, $00 ; }
0301   0481 4000
0302   0483 000050A00000.db $00, $00, $50, $A0, $00, $00, $00, $00 ; ~
0302   0489 0000
0303   048B 000000000000.db $00, $00, $00, $00, $00, $00, $00, $00 ; DEL
0303   0491 0000
0304   0493             
0305   0493             
0306   0493             
0307   0493             
0308   0493             
0309   0493             ; -----------------------------------------------------------------------------
0310   0493             ;   INICIO
0311   0493             ; -----------------------------------------------------------------------------
0312   0493             INICIO:
0313   0493 31 00 F0        LD  SP, SYSTEM
0314   0496             
0315   0496 3E 00           LD A, 0
0316   0498 32 B1 FF        LD (PORT_OUT_VAL), A
0317   049B             
0318   049B 3E C0           LD A, $c0
0319   049D 32 B0 FF        LD (PORT_SET), A
0320   04A0             
0321   04A0                 ; init serial
0322   04A0 CD 21 0F        CALL  DELONE     ;WAIT A SEC SO THE HOST SEES TX HIGH  
0323   04A3 21 BC 0E        LD    HL,TXDATA
0324   04A6 22 AA FF        LD    (PUTCH),HL ;USE THE BITBANG SERIAL TRANSMIT
0325   04A9 21 E7 0E        LD    HL,RXDATA
0326   04AC 22 AC FF        LD    (GETCH),HL  ;USE THE BITBANG SERIAL RECEIVE
0327   04AF                 
0328   04AF 21 1B 00        LD	HL,B4800
0329   04B2 22 C0 FF    	LD	(BAUD),HL	;DEFAULT SERIAL=9600 BAUD
0330   04B5             
0331   04B5 3E FF           LD A, $FF
0332   04B7 D3 C0           OUT (SERIAL_TX_PORT), A
0333   04B9             
0334   04B9 21 0A 11        LD HL, WELLCOME
0335   04BC CD A2 0E        CALL SNDMSG
0336   04BF             
0337   04BF                 ; CALL INCH
0338   04BF                 ; CALL OUTCH
0339   04BF             
0340   04BF                 ; Init LCD hardware
0341   04BF CD D5 0B        CALL INIT_LCD
0342   04C2 CD 64 0D        call delay
0343   04C5             
0344   04C5 CD ED 0C        call cls_TXT
0345   04C8 CD 64 0D        call delay
0346   04CB             
0347   04CB CD 77 0C        CALL enable_grafic
0348   04CE CD 64 0D        call delay
0349   04D1             
0350   04D1 CD F3 0C        call cls_GRAPHIC
0351   04D4 CD 64 0D        call delay
0352   04D7             
0353   04D7                 ;call lcd_clear
0354   04D7             
0355   04D7                 ;ld hl, DISPLAY
0356   04D7                 ;call print_image
0357   04D7             
0358   04D7                 ;call delay
0359   04D7             RESET_WARM:
0360   04D7 CD 69 0C        call lcd_clear
0361   04DA             
0362   04DA                 ; Init LCD logical
0363   04DA CD C8 09        call INIT_TXT_LCD ; set cursor X Y to 0
0364   04DD             
0365   04DD 21 22 11        LD HL, MSG_MONITOR
0366   04E0 CD 8F 0E        CALL SNDLCDMSG
0367   04E3             
0368   04E3 3E 3E           LD A, '>'
0369   04E5 CD 57 0A        CALL PRINTCHAR
0370   04E8             
0371   04E8             KEY:
0372   04E8 CD 88 0D        CALL KEYREADINIT
0373   04EB             
0374   04EB FE 48           CP 'H'
0375   04ED CC 58 08        CALL Z, SHOWHELP
0376   04F0             
0377   04F0 FE 80           CP KF1
0378   04F2 CA 00 80        JP Z, $8000
0379   04F5             
0380   04F5 FE 81           CP KF2
0381   04F7 CA 4C 08        JP Z, INTEL_HEX
0382   04FA             
0383   04FA FE 42           CP 'B'
0384   04FC CA 00 60        JP Z, BASIC
0385   04FF             
0386   04FF FE 47           CP 'G'
0387   0501 CC 1A 09        CALL Z, GOJUMP
0388   0504             
0389   0504 FE 4D           CP 'M'
0390   0506 CC B8 08        CALL Z, MODIFY
0391   0509             
0392   0509 FE 44           CP 'D'
0393   050B CC 3C 06        CALL Z, DSPLAY
0394   050E             
0395   050E FE 4F           CP 'O'
0396   0510 CC DF 05        CALL Z, OUTPORT
0397   0513             
0398   0513 FE 49           CP 'I'
0399   0515 CC F6 05        CALL Z, INPORT
0400   0518             
0401   0518 FE 31           CP '1'
0402   051A CC 37 0F        CALL Z, I2CLIST
0403   051D             
0404   051D FE 32           CP '2'
0405   051F CC C1 07        CALL Z, I2CCPUTOMEM
0406   0522             
0407   0522 FE 33           CP '3'
0408   0524 CC 99 07        CALL Z, I2CMEMTOCPU
0409   0527             
0410   0527 FE 34           CP '4'
0411   0529 CC BA 06        CALL Z, I2C_WR_DD
0412   052C             
0413   052C FE 35           CP '5'
0414   052E CC DD 06        CALL Z, I2C_WR_RR_DD
0415   0531             
0416   0531 FE 36           CP '6'
0417   0533 CC 09 07        CALL Z, I2C_RD
0418   0536             
0419   0536 FE 37           CP '7'
0420   0538 CC 3A 07        CALL Z, I2C_RD_RR
0421   053B             
0422   053B                 
0423   053B             
0424   053B             
0425   053B             
0426   053B             
0427   053B             
0428   053B             
0429   053B             
0430   053B 3E 0D           LD A, CR 
0431   053D CD 57 0A        CALL PRINTCHAR
0432   0540 3E 3E           LD A, '>' 
0433   0542 CD 57 0A        CALL PRINTCHAR
0434   0545             
0435   0545 C3 E8 04        JP  KEY
0436   0548             
0437   0548             
0438   0548             ; **********************************************************************
0439   0548             ; **  Public functions                                                **
0440   0548             ; **********************************************************************
0441   0548             ; API: Main entry point
0442   0548             ;   On entry: C = Function number
0443   0548             ;             A, DE = Parameters (as specified by function)
0444   0548             ;   On exit:  AF,BC,DE,HL = Return values (as specified by function)
0445   0548             ;             IX IY I AF' BC' DE' HL' preserved
0446   0548             ; This handler modifies: F, B, HL but preserves A, C, DE
0447   0548             ; Other registers depend on API function called
0448   0548 21 5A 05    APIHandler: LD   HL,APITable    ;Start of function address table
0449   054B 47                      LD   B,A            ;Preserve A
0450   054C 79                      LD   A,C            ;Get function number
0451   054D FE 14                   CP   kAPILast+1     ;Supported function?
0452   054F D0                      RET  NC             ;No, so abort
0453   0550 78                      LD   A,B            ;Restore A
0454   0551 06 00                   LD   B,0
0455   0553 09                      ADD  HL,BC          ;Calculate table pointer..
0456   0554 09                      ADD  HL,BC
0457   0555 46                      LD   B,(HL)         ;Read function address from table..
0458   0556 23                      INC  HL
0459   0557 66                      LD   H,(HL)
0460   0558 68                      LD   L,B
0461   0559 E9                      JP   (HL)           ;Jump to function address
0462   055A             
0463   055A             
0464   055A             ; API: Function address table (function in C)
0465   055A             ; This table contains a list of addresses, one for each API function. 
0466   055A             ; Each is the address of the subroutine for the relevant function.
0467   055A 82 05       APITable:   .DW  SysReset           ; 0x00 = System reset
0468   055C 85 05                   .DW  InputCharKey       ; 0x01 = Input character KeyboardOnboard (Char in A)
0469   055E 88 05                   .DW  OutLcdChar         ; 0x02 = Output character LCD (Char in A)
0470   0560 8B 05                   .DW  OutLcdNewLine      ; 0x03 = Output new line LCD
0471   0562 27 06                   .DW  H_Delay            ; 0x04 = Delay in milliseconds
0472   0564 90 05                   .DW  PrtSet             ; 0x05 = Set Port (Default C0)
0473   0566 94 05                   .DW  PrtOWr             ; 0x06 = Write to output port
0474   0568 A0 05                   .DW  PrtORd             ; 0x07 = Read from output port
0475   056A A4 05                   .DW  PrtIRd             ; 0x08 = Read from input port
0476   056C 69 0A                   .DW  PrintBufferChar    ; 0x09 = Print char to display buffer, with out show LCD (Chat in A)
0477   056E AB 05                   .DW  DisplayImage128x64 ; 0x0A = Print image (Pointer in DE), 128x64, 1024 bytes
0478   0570 B0 05                   .DW  ClearDisplayBuffer ; 0x0B = Clear display buffer (A=$00 without show LCD, A > $00 show to LCD)
0479   0572 C2 05                   .DW  ShowBufferDisplay  ; 0x0C = Show DISPLAY buffer to LCD
0480   0574 D4 05                   .DW  LcdSetCXY          ; 0x0D = LCD Cursor X (0-20), Y (0-7) value in D(X) E(Y)
0481   0576 82 05                   .DW  SysReset           ; 0x0E = Reserved
0482   0578 82 05                   .DW  SysReset           ; 0x0F = Reserved
0483   057A C8 05                   .DW  I2COpen            ; 0x10 = Start i2c (Device address in A)
0484   057C CB 05                   .DW  I2CClose           ; 0x11 = Close i2c 
0485   057E CE 05                   .DW  I2CRead            ; 0x12 = I2C Read
0486   0580 D1 05                   .DW  I2CWrite           ; 0x13 = I2C Write
0487   0582             kAPILast:   .EQU $13                ;Last API function number
0488   0582             
0489   0582             
0490   0582             
0491   0582             
0492   0582             
0493   0582             
0494   0582             
0495   0582             SysReset:
0496   0582 C3 93 04        JP INICIO
0497   0585             
0498   0585             InputCharKey:
0499   0585 C3 88 0D        JP KEYREADINIT
0500   0588             
0501   0588             OutLcdChar:
0502   0588 C3 57 0A        JP PRINTCHAR
0503   058B             
0504   058B             OutLcdNewLine:
0505   058B 3E 0D           LD A, CR
0506   058D C3 57 0A        JP PRINTCHAR
0507   0590             
0508   0590             PrtSet:
0509   0590 32 B0 FF        LD (PORT_SET), A ; define a porta padrão de entrada e saida
0510   0593 C9              RET
0511   0594             
0512   0594             PrtOWr:
0513   0594 47              LD B, A
0514   0595 3A B0 FF        LD A, (PORT_SET)
0515   0598 4F              LD C, A
0516   0599 78              LD A, B
0517   059A 32 B1 FF        LD (PORT_OUT_VAL), A
0518   059D ED 79           out (C), A
0519   059F C9              RET
0520   05A0             
0521   05A0             PrtORd: ; Return value from output port
0522   05A0 3A B1 FF        LD A, (PORT_OUT_VAL)
0523   05A3 C9              RET
0524   05A4             
0525   05A4             PrtIRd: ; Return value from input
0526   05A4 3A B0 FF        LD A, (PORT_SET)
0527   05A7 4F              LD C, A
0528   05A8 ED 78           in A, (C)
0529   05AA C9              RET
0530   05AB             
0531   05AB             DisplayImage128x64:
0532   05AB 62              LD H, D
0533   05AC 6B              LD L, E
0534   05AD C3 90 0C        JP print_image
0535   05B0             
0536   05B0             ClearDisplayBuffer:
0537   05B0 F5              PUSH AF
0538   05B1 CD 69 0C        CALL lcd_clear
0539   05B4 F1              POP AF
0540   05B5 B7              OR A
0541   05B6 FE 00           CP $00
0542   05B8 CA C1 05        JP Z, ClearDisplayBufferEnd
0543   05BB 21 00 E5        LD HL, DISPLAY
0544   05BE C3 90 0C        JP print_image
0545   05C1             ClearDisplayBufferEnd:
0546   05C1 C9              RET
0547   05C2             
0548   05C2             ShowBufferDisplay:
0549   05C2 21 00 E5        LD HL, DISPLAY
0550   05C5 C3 90 0C        JP print_image
0551   05C8             
0552   05C8             I2COpen:
0553   05C8 C3 4A 10        JP I2C_Open
0554   05CB             
0555   05CB             I2CClose:
0556   05CB C3 51 10        JP I2C_Close
0557   05CE             
0558   05CE             I2CRead:
0559   05CE C3 91 10        JP I2C_Read
0560   05D1             
0561   05D1             I2CWrite:
0562   05D1 C3 54 10        JP I2C_Write
0563   05D4             
0564   05D4             LcdSetCXY:
0565   05D4 F5              PUSH AF
0566   05D5 7A              LD A, D
0567   05D6 32 03 E0        LD (LCD_TXT_X), A
0568   05D9             
0569   05D9 7B              LD A, E
0570   05DA 32 04 E0        LD (LCD_TXT_Y), A
0571   05DD F1              POP AF
0572   05DE C9              RET
0573   05DF             
0574   05DF             
0575   05DF             
0576   05DF             
0577   05DF             
0578   05DF             
0579   05DF             OUTPORT:
0580   05DF 3E 4F           LD A, 'O'
0581   05E1 CD 69 0A        CALL PrintBufferChar
0582   05E4 CD 42 09        CALL OUTSP ; space and show lcd
0583   05E7             
0584   05E7 CD 4E 09        CALL  GETCHR 
0585   05EA D8              RET   C
0586   05EB 4F              LD C, A
0587   05EC             
0588   05EC CD 42 09        CALL OUTSP
0589   05EF             
0590   05EF CD 4E 09        CALL  GETCHR 
0591   05F2 D8              RET   C
0592   05F3 ED 79           OUT (C), A
0593   05F5 C9              RET
0594   05F6             
0595   05F6             
0596   05F6             INPORT:
0597   05F6 3E 49           LD A, 'I'
0598   05F8 CD 69 0A        CALL PrintBufferChar
0599   05FB CD 42 09        CALL OUTSP ; space and show lcd
0600   05FE             
0601   05FE CD 4E 09        CALL  GETCHR 
0602   0601 D8              RET   C
0603   0602 4F              LD C, A
0604   0603             
0605   0603 ED 78           IN A, (C)
0606   0605             
0607   0605 47              LD B, A
0608   0606 C5              PUSH BC
0609   0607 3E 0D           LD A, CR
0610   0609 CD 57 0A        CALL PRINTCHAR
0611   060C C1              POP BC
0612   060D 78              LD A, B
0613   060E             
0614   060E CD 12 06        CALL CONV_A_HEX
0615   0611 C9              RET
0616   0612             
0617   0612             
0618   0612             
0619   0612             
0620   0612             
0621   0612             
0622   0612             ;----------------
0623   0612             ;CONVERT A TO ASCII (HEX) AND SHOW LCD
0624   0612             ;----------------
0625   0612             ;
0626   0612             ;CONVERT A BYTE TO ASCII 
0627   0612             ;
0628   0612 F5          CONV_A_HEX: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
0629   0613 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
0630   0614 0F                 RRCA
0631   0615 0F                 RRCA
0632   0616 0F                 RRCA
0633   0617 CD 1B 06           CALL CONV_A_HEX_NYBASC       ;CALL NYBBLE CONVERTER 
0634   061A F1                 POP AF            ;RESTORE LOW NYBBLE
0635   061B             ;           
0636   061B             ; CONVERT A NYBBLE TO ASCII
0637   061B             ;
0638   061B E6 0F       CONV_A_HEX_NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
0639   061D C6 90              ADD   A,90H       ;CONVERT TO
0640   061F 27                 DAA               ;ASCII
0641   0620 CE 40              ADC   A,40H
0642   0622 27                 DAA
0643   0623             ;            
0644   0623             ; Print inlcd
0645   0623             ;
0646   0623 CD 57 0A        CALL PRINTCHAR
0647   0626 C9              RET 
0648   0627             
0649   0627             
0650   0627             ; **********************************************************************
0651   0627             ; Delay by DE milliseconds
0652   0627             ;   On entry: DE = Delay time in milliseconds
0653   0627             ;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved
0654   0627 F5          H_Delay:    PUSH AF
0655   0628 C5                      PUSH BC
0656   0629 D5                      PUSH DE
0657   062A             ; 1 ms loop, DE times...        ;[=36]   [=29]    Overhead for each 1ms
0658   062A 01 98 00    LoopDE:    LD   BC, kDelayCnt   ;[10]    [9]
0659   062D             ; Inner loop, BC times...       ;[=26]   [=20]    Loop time in Tcycles
0660   062D 0B          LoopBC:    DEC  BC             ;[6]     [4]
0661   062E 79                      LD   A,C            ;[4]     [4]
0662   062F B0                      OR   B              ;[4]     [4]
0663   0630 C2 2D 06                JP   NZ,LoopBC     ;[12/7]  [8/6] 
0664   0633             ; Have we looped once for each millisecond requested?
0665   0633 1B                      DEC  DE             ;[6]     [4]
0666   0634 7B                      LD   A,E            ;[4]     [4]
0667   0635 B2                      OR   D              ;[4]     [4]
0668   0636 20 F2                   JR   NZ, LoopDE     ;[12/7]  [8/6]
0669   0638 D1                      POP  DE
0670   0639 C1                      POP  BC
0671   063A F1                      POP  AF
0672   063B C9                      RET
0673   063C             
0674   063C             ;--------------------------
0675   063C             ; D DISPLAY MEMORY LOCATION
0676   063C             ;--------------------------
0677   063C 3E 44       DSPLAY: LD A, 'D'
0678   063E CD 57 0A            CALL PRINTCHAR
0679   0641 CD 42 09            CALL  OUTSP       ;A SPACE
0680   0644 CD 4E 09           CALL  GETCHR
0681   0647 D8                 RET   C         
0682   0648 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
0683   064B CD 4E 09           CALL  GETCHR
0684   064E D8                 RET   C
0685   064F 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
0686   0652             ;
0687   0652             ; WAIT FOR CR OR ESC
0688   0652             ;
0689   0652 CD 88 0D    DPLAY1: CALL  KEYREADINIT
0690   0655 FE 1B              CP    ESC
0691   0657 C8                 RET   Z
0692   0658 FE 0D              CP    CR
0693   065A 20 F6              JR    NZ,DPLAY1          
0694   065C CD 48 09           CALL  TXCRLF      ;NEWLINE
0695   065F             ;
0696   065F             ; DISPLAY THE LINE
0697   065F             ;
0698   065F CD 74 06    DPLAY2: CALL  DPLINE
0699   0662 ED 53 B0 FE        LD    (ADDR),DE   ;SAVE THE NEW ADDRESS
0700   0666             ;
0701   0666             ; DISPLAY MORE LINES OR EXIT
0702   0666             ;       
0703   0666 CD 88 0D    DPLAY3: CALL  KEYREADINIT
0704   0669 38 FB              JR    C,DPLAY3   
0705   066B FE 0D              CP    CR        ;ENTER DISPLAYS THE NEXT LINE
0706   066D 28 F0              JR    Z,DPLAY2
0707   066F FE 1B              CP    ESC         ;ESC EXITS (SHIFT + C)
0708   0671 20 F3              JR    NZ,DPLAY3     
0709   0673 C9                 RET   
0710   0674             ;-------------------------
0711   0674             ; DISPLAY A LINE OF MEMORY
0712   0674             ;-------------------------      
0713   0674 ED 5B B0 FE DPLINE: LD    DE,(ADDR)   ;ADDRESS TO BE DISPLAYED
0714   0678 21 00 FE           LD    HL,MSGBUF   ;HL POINTS TO WHERE THE OUTPUT STRING GOES
0715   067B             ;
0716   067B             ; DISPLAY THE ADDRESS
0717   067B             ;         
0718   067B CD AF 09           CALL  WRDASC     ;CONVERT ADDRESS IN DE TO ASCII
0719   067E CD B4 06           CALL  SPCBUF        
0720   0681             ;
0721   0681             ; DISPLAY 4 BYTES
0722   0681             ;
0723   0681 06 04              LD    B,4 ;16
0724   0683 1A          DLINE1: LD    A,(DE)
0725   0684 CD B4 09           CALL  BYTASC
0726   0687 CD B4 06           CALL  SPCBUF
0727   068A 13                 INC   DE        
0728   068B 10 F6              DJNZ  DLINE1
0729   068D                    ;CALL  SPCBUF
0730   068D             ;
0731   068D             ; NOW DISPLAY THE ASCII CHARACTER
0732   068D             ; IF YOU ARE DISPLAYING NON-MEMORY AREAS THE BYTES READ AND THE ASCII COULD
0733   068D             ; BE DIFFERENT BETWEEN THE TWO PASSES!
0734   068D             ;
0735   068D ED 5B B0 FE        LD    DE,(ADDR)    
0736   0691 06 04              LD    B,4 ;16
0737   0693 1A          DLINE2: LD    A,(DE)   
0738   0694 FE 20              CP    20H
0739   0696 38 07              JR    C,DOT
0740   0698 FE 7F              CP    7FH
0741   069A 30 03              JR    NC,DOT
0742   069C C3 A1 06           JP    NDOT
0743   069F 3E 2E       DOT:    LD    A,'.'
0744   06A1 CD B6 06    NDOT:   CALL  INBUF
0745   06A4 13                 INC   DE       
0746   06A5 10 EC              DJNZ  DLINE2
0747   06A7             ;         
0748   06A7             ;TERMINATE AND DISPLAY STRING
0749   06A7             ;       
0750   06A7 CD B9 06           CALL  BCRLF
0751   06AA 3E 00              LD    A,00H
0752   06AC 77                 LD    (HL),A
0753   06AD 21 00 FE           LD    HL,MSGBUF
0754   06B0 CD 8F 0E           CALL  SNDLCDMSG
0755   06B3 C9                 RET
0756   06B4             
0757   06B4             
0758   06B4             ;
0759   06B4             ; PUT A SPACE IN THE BUFFER
0760   06B4             ;
0761   06B4 3E 08       SPCBUF: LD    A, 8 ;20H(32dec)
0762   06B6 77          INBUF:  LD    (HL),A
0763   06B7 23                 INC   HL
0764   06B8 C9                 RET
0765   06B9             ;
0766   06B9             ; PUT A CR LF IN THE BUFFER
0767   06B9             ;        
0768   06B9             BCRLF:  ;LD    A,CR  
0769   06B9                    ;CALL  INBUF  ;Display add CR automaticamente quando chegar na coluna 21
0770   06B9 C9                 RET
0771   06BA             
0772   06BA             
0773   06BA             
0774   06BA             ; --------------------------------------
0775   06BA             ; I2C - Write one byte
0776   06BA             ; --------------------------------------
0777   06BA             I2C_WR_DD:
0778   06BA 3E 0C           LD A, $0C ; limpar tela
0779   06BC CD 57 0A        CALL PRINTCHAR
0780   06BF             
0781   06BF                 ; Show msg func
0782   06BF 21 6F 12        LD HL, MSG_I2C_WR_DD
0783   06C2 CD 8F 0E        CALL SNDLCDMSG
0784   06C5             
0785   06C5                 ; Device Address
0786   06C5 CD 6F 07        CALL GET_DEV_ADDR ; get address
0787   06C8             
0788   06C8             I2C_WR_DD_LOOP:
0789   06C8                 ; Get Data
0790   06C8 CD 7D 07        CALL GET_DEV_DD   ; get data
0791   06CB             
0792   06CB                 ; Send
0793   06CB 3A C0 FF        LD A, (I2C_ADDR) ; Open
0794   06CE CD 4A 10        CALL I2C_Open
0795   06D1             
0796   06D1 3A C2 FF        LD A, (I2C_DD)  ; Data
0797   06D4 CD 54 10        CALL I2C_Write
0798   06D7              
0799   06D7 CD 51 10        CALL I2C_Close  ; Close
0800   06DA             
0801   06DA 18 EC           JR I2C_WR_DD_LOOP
0802   06DC             
0803   06DC C9              RET
0804   06DD             
0805   06DD             
0806   06DD             
0807   06DD             ; --------------------------------------
0808   06DD             ; I2C - Write register one byte
0809   06DD             ; --------------------------------------
0810   06DD             I2C_WR_RR_DD:
0811   06DD 3E 0C           LD A, $0C ; limpar tela
0812   06DF CD 57 0A        CALL PRINTCHAR
0813   06E2             
0814   06E2                 ; Show msg func
0815   06E2 21 80 12        LD HL, MSG_I2C_WR_RR_DD
0816   06E5 CD 8F 0E        CALL SNDLCDMSG
0817   06E8             
0818   06E8                 ; Device Address
0819   06E8 CD 6F 07        CALL GET_DEV_ADDR ; get address
0820   06EB             
0821   06EB             I2C_WR_RR_DD_LOOP:
0822   06EB                 ; Get register
0823   06EB CD 8B 07        CALL GET_DEV_RR ; get address
0824   06EE             
0825   06EE                 ; Get Data
0826   06EE CD 7D 07        CALL GET_DEV_DD   ; get data
0827   06F1             
0828   06F1                 ; Send
0829   06F1 3A C0 FF        LD A, (I2C_ADDR) ; Open
0830   06F4 CD 4A 10        CALL I2C_Open
0831   06F7             
0832   06F7 3A C1 FF        LD A, (I2C_RR)  ; register
0833   06FA CD 54 10        CALL I2C_Write
0834   06FD             
0835   06FD 3A C2 FF        LD A, (I2C_DD)  ; Data
0836   0700 CD 54 10        CALL I2C_Write
0837   0703             
0838   0703 CD 51 10        CALL I2C_Close  ; Close
0839   0706             
0840   0706 18 E3           JR I2C_WR_RR_DD_LOOP
0841   0708             
0842   0708 C9              RET
0843   0709             
0844   0709             
0845   0709             ; --------------------------------------
0846   0709             ; I2C - Read one byte
0847   0709             ; --------------------------------------
0848   0709             I2C_RD:
0849   0709 3E 0C           LD A, $0C ; limpar tela
0850   070B CD 57 0A        CALL PRINTCHAR
0851   070E             
0852   070E                 ; Show msg func
0853   070E 21 95 12        LD HL, MSG_I2C_RD
0854   0711 CD 8F 0E        CALL SNDLCDMSG
0855   0714             
0856   0714                 ; Device Address
0857   0714 CD 6F 07        CALL GET_DEV_ADDR ; get address
0858   0717 CD 48 09        CALL TXCRLF ; new line
0859   071A             
0860   071A             I2C_RD_LOOP:
0861   071A                 ; Send
0862   071A 3A C0 FF        LD A, (I2C_ADDR) ; Open
0863   071D 3C              INC A ; To read address + 1 (flag)
0864   071E CD 4A 10        CALL I2C_Open
0865   0721             
0866   0721 CD 91 10        CALL I2C_Read      ; Read
0867   0724 F5              PUSH AF
0868   0725             
0869   0725 CD 51 10        CALL I2C_Close     ; Close
0870   0728             
0871   0728                 ; Show
0872   0728 F1              POP AF
0873   0729 CD 12 06        CALL CONV_A_HEX ; Show A to (HEX) LCD
0874   072C CD 48 09        CALL TXCRLF ; new line
0875   072F             
0876   072F CD 88 0D        CALL KEYREADINIT
0877   0732 FE 03           CP CTRLC
0878   0734 CA D7 04        JP Z, RESET_WARM
0879   0737             
0880   0737 18 E1           JR I2C_RD_LOOP
0881   0739 C9              RET
0882   073A             
0883   073A             
0884   073A             ; --------------------------------------
0885   073A             ; I2C - Read register one byte
0886   073A             ; --------------------------------------
0887   073A             I2C_RD_RR:
0888   073A 3E 0C           LD A, $0C ; limpar tela
0889   073C CD 57 0A        CALL PRINTCHAR
0890   073F             
0891   073F                 ; Show msg func
0892   073F 21 A5 12        LD HL, MSG_I2C_RD_RR
0893   0742 CD 8F 0E        CALL SNDLCDMSG
0894   0745             
0895   0745                 ; Device Address
0896   0745 CD 6F 07        CALL GET_DEV_ADDR ; get address
0897   0748             
0898   0748             I2C_RD_RR_LOOP:
0899   0748                 ; Get register
0900   0748 CD 8B 07        CALL GET_DEV_RR ; get address
0901   074B CD 48 09        CALL TXCRLF ; new line
0902   074E             
0903   074E                 ; Send
0904   074E 3A C0 FF        LD A, (I2C_ADDR) ; Open
0905   0751 CD 4A 10        CALL I2C_Open
0906   0754             
0907   0754 3A C1 FF        LD A, (I2C_RR)
0908   0757 CD 54 10        CALL I2C_Write ; Register to read
0909   075A             
0910   075A 3A C0 FF        LD A, (I2C_ADDR) ; Open
0911   075D 3C              INC A ; To read address + 1 (flag)
0912   075E CD 4A 10        CALL I2C_Open
0913   0761             
0914   0761 CD 91 10        CALL I2C_Read ; Read register
0915   0764 F5              PUSH AF
0916   0765             
0917   0765 CD 51 10        CALL I2C_Close ; Close
0918   0768             
0919   0768                 ; Show
0920   0768 F1              POP AF
0921   0769 CD 12 06        CALL CONV_A_HEX ; Show A to (HEX) LCD
0922   076C             
0923   076C 18 DA           JR I2C_RD_RR_LOOP
0924   076E C9              RET
0925   076F             
0926   076F             
0927   076F             GET_DEV_ADDR:
0928   076F 21 E9 12        LD HL, MSG_DEV_ADDR
0929   0772 CD 8F 0E        CALL SNDLCDMSG
0930   0775 CD 4E 09        CALL  GETCHR 
0931   0778 D8              RET   C
0932   0779 32 C0 FF        LD (I2C_ADDR), A
0933   077C C9              RET
0934   077D             
0935   077D             GET_DEV_DD:
0936   077D 21 0C 13        LD HL, MSG_DEV_DATA
0937   0780 CD 8F 0E        CALL SNDLCDMSG
0938   0783             
0939   0783 CD 4E 09        CALL  GETCHR 
0940   0786 D8              RET   C
0941   0787 32 C2 FF        LD (I2C_DD), A
0942   078A C9              RET
0943   078B             
0944   078B             GET_DEV_RR:
0945   078B 21 FC 12        LD HL, MSG_DEV_REG
0946   078E CD 8F 0E        CALL SNDLCDMSG
0947   0791             
0948   0791 CD 4E 09        CALL  GETCHR 
0949   0794 D8              RET   C
0950   0795 32 C1 FF        LD (I2C_RR), A
0951   0798 C9              RET
0952   0799             
0953   0799             
0954   0799             
0955   0799             
0956   0799             I2CMEMTOCPU:
0957   0799                 ; Get parameters to copy a block from I2C memory to CPU memory
0958   0799             ;   On entry: DE = First address in I2C memory
0959   0799             ;             HL = First address in CPU memory
0960   0799             ;             BC = Number of bytes to be copied
0961   0799             ;             SCL = unknown, SDA = unknown
0962   0799             ;   On exit:  If successfully A = 0 and Z flagged
0963   0799             ;             If unsuccessfully A = Error and NZ flagged
0964   0799             ;             IX IY preserved
0965   0799             
0966   0799 21 43 12        LD HL, MSG_MEM2CPU
0967   079C CD 8F 0E        CALL SNDLCDMSG
0968   079F             
0969   079F CD E9 07        CALL GET_FROM_TO_SIZE
0970   07A2             
0971   07A2             ;    DE = First address in I2C memory
0972   07A2             ;    HL = First address in CPU memory
0973   07A2             ;    BC = Number of bytes to be copied
0974   07A2             
0975   07A2 ED 5B B2 FE     LD DE, (ADDR_FROM)
0976   07A6 2A B4 FE        LD HL, (ADDR_TO)
0977   07A9 ED 4B B6 FE     LD BC, (ADDR_SIZE)
0978   07AD CD 61 0F        CALL I2C_MemRd  
0979   07B0             
0980   07B0 CA BA 07        JP Z, I2CMEMTOCPU_OK
0981   07B3 21 DE 12        LD HL, MSG_COPYFAIL
0982   07B6 CD 8F 0E        CALL SNDLCDMSG
0983   07B9 C9              RET
0984   07BA             I2CMEMTOCPU_OK:
0985   07BA 21 D5 12        LD HL, MSG_COPYOK
0986   07BD CD 8F 0E        CALL SNDLCDMSG
0987   07C0 C9              RET
0988   07C1             
0989   07C1             
0990   07C1             I2CCPUTOMEM:
0991   07C1             ; Get parameters to copy a block from CPU memory to I2C memory
0992   07C1             ;   On entry: DE = First address in I2C memory
0993   07C1             ;             HL = First address in CPU memory
0994   07C1             ;             BC = Number of bytes to be copied
0995   07C1             ;             SCL = unknown, SDA = unknown
0996   07C1             ;   On exit:  If successfully A = 0 and Z flagged
0997   07C1             ;             If unsuccessfully A = Error and NZ flagged
0998   07C1             ;             IX IY preserved
0999   07C1             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
1000   07C1             ; pages.
1001   07C1 21 59 12        LD HL, MSG_CPU2MEM
1002   07C4 CD 8F 0E        CALL SNDLCDMSG
1003   07C7             
1004   07C7 CD E9 07        CALL GET_FROM_TO_SIZE
1005   07CA             
1006   07CA             ;    DE = First address in I2C memory
1007   07CA             ;    HL = First address in CPU memory
1008   07CA             ;    BC = Number of bytes to be copied
1009   07CA             
1010   07CA 2A B2 FE        LD HL, (ADDR_FROM)
1011   07CD ED 5B B4 FE     LD DE, (ADDR_TO)
1012   07D1 ED 4B B6 FE     LD BC, (ADDR_SIZE)
1013   07D5 CD 96 0F        CALL I2C_MemWr
1014   07D8                 
1015   07D8 CA E2 07        JP Z, I2CCPUTOMEM_OK
1016   07DB 21 DE 12        LD HL, MSG_COPYFAIL
1017   07DE CD 8F 0E        CALL SNDLCDMSG
1018   07E1 C9              RET
1019   07E2             I2CCPUTOMEM_OK:
1020   07E2 21 D5 12        LD HL, MSG_COPYOK
1021   07E5 CD 8F 0E        CALL SNDLCDMSG
1022   07E8 C9              RET
1023   07E9             
1024   07E9             
1025   07E9             
1026   07E9             
1027   07E9             
1028   07E9             
1029   07E9             GET_FROM_TO_SIZE:
1030   07E9                 ; FROM
1031   07E9 21 B9 12        LD HL, MSG_FROM
1032   07EC CD 8F 0E        CALL SNDLCDMSG
1033   07EF                 ;
1034   07EF                 ;GET THE ADDRESS  FROM
1035   07EF                 ;
1036   07EF CD 4E 09        CALL  GETCHR 
1037   07F2 D8              RET   C        
1038   07F3 32 B3 FE        LD    (ADDR_FROM+1),A  ;SAVE ADDRESS HIGH
1039   07F6 CD 4E 09        CALL  GETCHR
1040   07F9 D8              RET   C
1041   07FA 32 B2 FE        LD    (ADDR_FROM),A    ;SAVE ADDRESS LOW
1042   07FD             
1043   07FD CD 88 0D        CALL  KEYREADINIT
1044   0800 FE 1B           CP    ESC         ;ESC KEY?
1045   0802 C8              RET   Z
1046   0803 FE 0D           CP    CR
1047   0805 28 08           JR Z, GET_FROM_TO_SIZE_TO
1048   0807 3E 0D           LD A, CR
1049   0809 CD 57 0A        CALL PRINTCHAR
1050   080C C3 E9 07        JP GET_FROM_TO_SIZE
1051   080F             
1052   080F             GET_FROM_TO_SIZE_TO:
1053   080F                 ; TO
1054   080F 21 C0 12        LD HL, MSG_TO
1055   0812 CD 8F 0E        CALL SNDLCDMSG
1056   0815                 ;
1057   0815                 ;GET THE ADDRESS  TO
1058   0815                 ;
1059   0815 CD 4E 09        CALL  GETCHR 
1060   0818 D8              RET   C        
1061   0819 32 B5 FE        LD    (ADDR_TO+1),A  ;SAVE ADDRESS HIGH
1062   081C CD 4E 09        CALL  GETCHR
1063   081F D8              RET   C
1064   0820 32 B4 FE        LD    (ADDR_TO),A    ;SAVE ADDRESS LOW
1065   0823             
1066   0823 CD 88 0D        CALL  KEYREADINIT
1067   0826 FE 1B           CP    ESC         ;ESC KEY?
1068   0828 C8              RET   Z
1069   0829 FE 0D           CP    CR
1070   082B 20 E2           JR NZ, GET_FROM_TO_SIZE_TO
1071   082D             
1072   082D             GET_FROM_TO_SIZE_SIZE:
1073   082D                 ; SIZE
1074   082D 21 C6 12        LD HL, MSG_SIZE
1075   0830 CD 8F 0E        CALL SNDLCDMSG
1076   0833                 ;
1077   0833                 ;GET THE SIZE
1078   0833                 ;
1079   0833 CD 4E 09        CALL  GETCHR 
1080   0836 D8              RET   C        
1081   0837 32 B7 FE        LD    (ADDR_SIZE+1),A  ;SAVE ADDRESS HIGH
1082   083A CD 4E 09        CALL  GETCHR
1083   083D D8              RET   C
1084   083E 32 B6 FE        LD    (ADDR_SIZE),A    ;SAVE ADDRESS LOW
1085   0841             
1086   0841 CD 88 0D        CALL  KEYREADINIT
1087   0844 FE 1B           CP    ESC         ;ESC KEY?
1088   0846 C8              RET   Z
1089   0847 FE 0D           CP    CR
1090   0849 20 E2           JR NZ, GET_FROM_TO_SIZE_SIZE
1091   084B C9              RET
1092   084C             
1093   084C             
1094   084C             INTEL_HEX:
1095   084C CD DC 0D        CALL INTHEX
1096   084F CD 64 0D        CALL delay
1097   0852 CD 64 0D        CALL delay
1098   0855 C3 93 04        JP INICIO
1099   0858             
1100   0858             SHOWHELP:
1101   0858 3E 0C           LD A, $0C ; limpar tela
1102   085A CD 57 0A        CALL PRINTCHAR
1103   085D             
1104   085D 21 37 11        LD HL, MSG_MENU0
1105   0860 CD 8F 0E        CALL SNDLCDMSG
1106   0863             
1107   0863 21 4A 11        LD HL, MSG_MENU1
1108   0866 CD 8F 0E        CALL SNDLCDMSG
1109   0869             
1110   0869 21 5F 11        LD HL, MSG_MENU2
1111   086C CD 8F 0E        CALL SNDLCDMSG
1112   086F             
1113   086F 21 6A 11        LD HL, MSG_MENU3
1114   0872 CD 8F 0E        CALL SNDLCDMSG
1115   0875             
1116   0875 21 7C 11        LD HL, MSG_MENU4
1117   0878 CD 8F 0E        CALL SNDLCDMSG
1118   087B             
1119   087B 21 8D 11        LD HL, MSG_MENU5
1120   087E CD 8F 0E        CALL SNDLCDMSG
1121   0881             
1122   0881 21 9D 11        LD HL, MSG_MENU6
1123   0884 CD 8F 0E        CALL SNDLCDMSG
1124   0887             
1125   0887 21 AA 11        LD HL, MSG_MENU7
1126   088A CD 8F 0E        CALL SNDLCDMSG
1127   088D             
1128   088D 21 B3 11        LD HL, MSG_MENU8
1129   0890 CD 8F 0E        CALL SNDLCDMSG
1130   0893             
1131   0893 21 BF 11        LD HL, MSG_MENU9
1132   0896 CD 8F 0E        CALL SNDLCDMSG
1133   0899             
1134   0899 21 D0 11        LD HL, MSG_MENU10
1135   089C CD 8F 0E        CALL SNDLCDMSG
1136   089F             
1137   089F 21 E1 11        LD HL, MSG_MENU11
1138   08A2 CD 8F 0E        CALL SNDLCDMSG
1139   08A5             
1140   08A5 21 F1 11        LD HL, MSG_MENU12
1141   08A8 CD 8F 0E        CALL SNDLCDMSG
1142   08AB             
1143   08AB 21 04 12        LD HL, MSG_MENU13
1144   08AE CD 8F 0E        CALL SNDLCDMSG
1145   08B1             
1146   08B1 21 19 12        LD HL, MSG_MENU14
1147   08B4 CD 8F 0E        CALL SNDLCDMSG
1148   08B7             
1149   08B7 C9              RET
1150   08B8             
1151   08B8             
1152   08B8             ;----------------------------
1153   08B8             ; M DISPLAY AND MODIFY MEMORY
1154   08B8             ;----------------------------
1155   08B8 3E 4D       MODIFY: LD A, 'M'
1156   08BA CD 57 0A            CALL PRINTCHAR
1157   08BD CD 42 09         CALL  OUTSP
1158   08C0             ;
1159   08C0             ;GET THE ADDRESS        
1160   08C0             ;
1161   08C0 CD 4E 09           CALL  GETCHR 
1162   08C3 D8                 RET   C        
1163   08C4 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
1164   08C7 CD 4E 09           CALL  GETCHR
1165   08CA D8                 RET   C
1166   08CB 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
1167   08CE             ;
1168   08CE             ; DISPLAY ON A NEW LINE
1169   08CE             ;       
1170   08CE CD 48 09    MDIFY1: CALL  TXCRLF       
1171   08D1 ED 5B B0 FE        LD    DE,(ADDR)    
1172   08D5 21 00 FE           LD    HL,MSGBUF   
1173   08D8 CD AF 09           CALL  WRDASC      ;CONVERT ADDRESS IN DE TO ASCII
1174   08DB 21 00 FE           LD    HL,MSGBUF
1175   08DE CD A3 09           CALL  WRDOUT      ;OUTPUT THE ADDRESS
1176   08E1 CD 42 09           CALL  OUTSP    
1177   08E4             ;      
1178   08E4             ;GET THE DATA AT THE ADDRESS        
1179   08E4             ;
1180   08E4 2A B0 FE            LD   HL,(ADDR)       
1181   08E7 7E                  LD   A,(HL)
1182   08E8             ;
1183   08E8             ; DISPLAY THE DATA
1184   08E8             ;        
1185   08E8 21 00 FE           LD    HL,MSGBUF
1186   08EB CD B4 09           CALL  BYTASC     ;CONVERT THE DATA BYTE IN A TO ASCII
1187   08EE 21 00 FE           LD    HL,MSGBUF
1188   08F1 CD A6 09           CALL  BYTOUT      ;OUTPUT THE BYTE
1189   08F4 CD 42 09           CALL  OUTSP
1190   08F7             ;
1191   08F7             ; GET NEW DATA,EXIT OR CONTINUE
1192   08F7             ;
1193   08F7 CD 4E 09           CALL  GETCHR
1194   08FA D8                 RET   C
1195   08FB 47                 LD    B,A         ;SAVE IT FOR LATER
1196   08FC 2A B0 FE           LD    HL,(ADDR)
1197   08FF 77                 LD    (HL),A      ;PUT THE BYTE AT THE CURRENT ADDRESS
1198   0900 78                 LD    A,B
1199   0901 BE                 CP    (HL)
1200   0902 28 05              JR    Z,MDIFY2
1201   0904 3E 3F              LD    A,'?'
1202   0906 CD 57 0A           CALL  PRINTCHAR       ;NOT THE SAME DATA, PROBABLY NO RAM THERE      
1203   0909             ;
1204   0909             ; INCREMENT THE ADDRESS
1205   0909             ;
1206   0909 23          MDIFY2: INC   HL
1207   090A 22 B0 FE           LD    (ADDR),HL
1208   090D C3 CE 08           JP    MDIFY1
1209   0910             
1210   0910             
1211   0910             
1212   0910             ;------------------------------
1213   0910             ; GO <ADDR>
1214   0910             ; TRANSFERS EXECUTION TO <ADDR>
1215   0910             ;------------------------------
1216   0910             GOJUMP_new:
1217   0910 3E 0D           LD A, CR
1218   0912 CD 57 0A        CALL PRINTCHAR
1219   0915             
1220   0915 3E 3E           LD A, '>'
1221   0917 CD 57 0A        CALL PRINTCHAR
1222   091A             
1223   091A 3E 47       GOJUMP: LD A, 'G'
1224   091C CD 57 0A            CALL PRINTCHAR
1225   091F CD 42 09           CALL  OUTSP       
1226   0922 CD 4E 09           CALL  GETCHR      ;GET ADDRESS HIGH BYTE
1227   0925 D8                 RET   C
1228   0926 32 B1 FE           LD    (ADDR+1),A  ;SAVE ADDRESS HIGH
1229   0929 CD 4E 09           CALL  GETCHR      ;GET ADDRESS LOW BYTE
1230   092C D8                 RET   C
1231   092D 32 B0 FE           LD    (ADDR),A    ;SAVE ADDRESS LOW 
1232   0930             ;
1233   0930             ; WAIT FOR A CR OR ESC
1234   0930             ;       
1235   0930 CD 88 0D    GOJMP1: CALL  KEYREADINIT
1236   0933 FE 1B              CP    ESC         ;ESC KEY?
1237   0935 C8                 RET   Z
1238   0936 FE 0D              CP    CR
1239   0938                    ;JR    NZ,GOJMP1
1240   0938 20 D6              JR NZ, GOJUMP_new
1241   093A CD 48 09           CALL  TXCRLF
1242   093D E1                 POP   HL          ;POP THE UNUSED MENU RETURN ADDRESS FROM THE STACK
1243   093E 2A B0 FE           LD    HL,(ADDR)
1244   0941 E9                 JP    (HL)        ;GOOD LUCK WITH THAT!
1245   0942             
1246   0942             
1247   0942             ;---------------
1248   0942             ; OUTPUT A SPACE
1249   0942             ;---------------
1250   0942 3E 20       OUTSP:  LD    A, ' '
1251   0944 CD 57 0A           CALL  PRINTCHAR
1252   0947 C9                 RET
1253   0948             
1254   0948             ;-------------      
1255   0948             ; OUTPUT CRLF (NEW LINE)
1256   0948             ;------------
1257   0948 3E 0D       TXCRLF: LD   A,CR
1258   094A CD 57 0A           CALL PRINTCHAR   
1259   094D C9                 RET
1260   094E             
1261   094E             ;-----------------------------
1262   094E             ; GET A BYTE FROM THE TERMINAL
1263   094E             ;-----------------------------
1264   094E CD 88 0D    GETCHR: CALL KEYREADINIT ; read key
1265   0951 FE 1B              CP    ESC
1266   0953 28 31              JR    Z,GETOUT
1267   0955 FE 03              CP    CTRLC  ; key BK (reset)
1268   0957 CA D7 04           JP    Z, RESET_WARM
1269   095A 47                 LD    B,A                ;SAVE TO ECHO      
1270   095B CD 88 09           CALL  ASC2HEX
1271   095E 30 EE              JR    NC,GETCHR          ;REJECT NON HEX CHARS    
1272   0960 21 B8 FE           LD    HL,DATA
1273   0963 77                 LD    (HL),A 
1274   0964 78                 LD    A,B         
1275   0965 CD 57 0A           CALL  PRINTCHAR             ;ECHO VALID HEX
1276   0968                    
1277   0968 CD 88 0D    GETNYB: CALL  KEYREADINIT
1278   096B FE 1B              CP    ESC
1279   096D 28 17              JR    Z,GETOUT
1280   096F FE 03              CP    CTRLC  ; key BK (reset)
1281   0971 CA D7 04           JP    Z, RESET_WARM
1282   0974 47                 LD    B,A               ;SAVE TO ECHO
1283   0975 CD 88 09           CALL  ASC2HEX
1284   0978 30 EE              JR    NC,GETNYB         ;REJECT NON HEX CHARS
1285   097A ED 6F              RLD
1286   097C 78                 LD    A,B
1287   097D CD 57 0A           CALL  PRINTCHAR             ;ECHO VALID HEX
1288   0980 7E                 LD    A,(HL)
1289   0981 CD 86 09           CALL  GETOUT            ;MAKE SURE WE CLEAR THE CARRY BY SETTING IT,
1290   0984 3F                 CCF                    ;AND THEN COMPLEMENTING IT
1291   0985 C9                 RET   
1292   0986 37          GETOUT: SCF                    ;SET THE CARRY FLAG TO EXIT BACK TO MENU
1293   0987 C9                 RET
1294   0988             
1295   0988             
1296   0988             ;----------------------------------------
1297   0988             ; CONVERT ASCII CHARACTER INTO HEX NYBBLE
1298   0988             ;----------------------------------------
1299   0988             ; THIS ROUTINE IS FOR MASKING OUT KEYBOARD
1300   0988             ; ENTRY OTHER THAN HEXADECIMAL KEYS
1301   0988             ;
1302   0988             ;CONVERTS ASCII 0-9,A-F INTO HEX LSN
1303   0988             ;ENTRY : A= ASCII 0-9,A-F
1304   0988             ;EXIT  : CARRY =  1
1305   0988             ;          A= HEX 0-F IN LSN    
1306   0988             ;      : CARRY = 0
1307   0988             ;          A= OUT OF RANGE CHARACTER & 7FH
1308   0988             ; A AND F REGISTERS MODIFIED
1309   0988             ;
1310   0988 E6 7F       ASC2HEX: AND   7FH        ;STRIP OUT PARITY
1311   098A FE 30              CP    30H
1312   098C 38 12              JR    C,AC2HEX3    ;LESS THAN 0
1313   098E FE 3A              CP    3AH
1314   0990 30 02              JR    NC,AC2HEX2   ;MORE THAN 9
1315   0992 37          AC2HEX1: SCF               ;SET THE CARRY - IS HEX
1316   0993 C9                 RET
1317   0994             ;     
1318   0994 FE 41       AC2HEX2: CP    41H
1319   0996 38 08              JR    C,AC2HEX3    ;LESS THAN A
1320   0998 FE 47              CP    47H
1321   099A 30 04              JR    NC,AC2HEX3   ;MORE THAN F
1322   099C D6 07              SUB   07H        ;CONVERT TO NYBBLE
1323   099E 18 F2              JR    AC2HEX1  
1324   09A0 E6 FF       AC2HEX3: AND   0FFH        ;RESET THE CARRY - NOT HEX
1325   09A2 C9                 RET
1326   09A3             
1327   09A3             
1328   09A3             ;----------------------     
1329   09A3             ; SEND ASCII HEX VALUES        
1330   09A3             ;----------------------
1331   09A3             ;
1332   09A3             ; OUTPUT THE 4 BYTE, WRDOUT
1333   09A3             ; THE 2 BYTE, BYTOUT
1334   09A3             ; OR THE SINGLE BYTE, NYBOUT
1335   09A3             ; ASCII STRING AT HL TO THE SERIAL PORT
1336   09A3             ;
1337   09A3 CD A6 09    WRDOUT: CALL  BYTOUT
1338   09A6 CD A9 09    BYTOUT: CALL  NYBOUT
1339   09A9 7E          NYBOUT: LD    A,(HL)
1340   09AA CD 57 0A           CALL  PRINTCHAR
1341   09AD 23                 INC   HL
1342   09AE C9                 RET       
1343   09AF             ;----------------
1344   09AF             ;CONVERT TO ASCII 
1345   09AF             ;----------------
1346   09AF             ;
1347   09AF             ; CONVERT A WORD,A BYTE OR A NYBBLE TO ASCII
1348   09AF             ;
1349   09AF             ;         ENTRY :  A = BINARY TO CONVERT
1350   09AF             ;                  HL = CHARACTER BUFFER ADDRESS   
1351   09AF             ;        EXIT   :  HL = POINTS TO LAST CHARACTER+1
1352   09AF             ;   
1353   09AF             ;        MODIFIES : DE
1354   09AF             
1355   09AF 7A          WRDASC: LD    A,D         ;CONVERT AND
1356   09B0 CD B4 09           CALL  BYTASC      ;OUTPUT D
1357   09B3 7B                 LD    A,E         ;THEN E
1358   09B4             ;
1359   09B4             ;CONVERT A BYTE TO ASCII 
1360   09B4             ;
1361   09B4 F5          BYTASC: PUSH  AF          ;SAVE A FOR SECOND NYBBLE 
1362   09B5 0F                 RRCA              ;SHIFT HIGH NYBBLE ACROSS
1363   09B6 0F                 RRCA
1364   09B7 0F                 RRCA
1365   09B8 0F                 RRCA
1366   09B9 CD BD 09           CALL NYBASC       ;CALL NYBBLE CONVERTER 
1367   09BC F1                 POP AF            ;RESTORE LOW NYBBLE
1368   09BD             
1369   09BD             ;           
1370   09BD             ; CONVERT A NYBBLE TO ASCII
1371   09BD             ;
1372   09BD E6 0F       NYBASC: AND   0FH         ;MASK OFF HIGH NYBBLE 
1373   09BF C6 90              ADD   A,90H       ;CONVERT TO
1374   09C1 27                 DAA               ;ASCII
1375   09C2 CE 40              ADC   A,40H
1376   09C4 27                 DAA
1377   09C5             ;            
1378   09C5             ; SAVE IN STRING
1379   09C5             ;
1380   09C5 77          INSBUF: LD    (HL),A
1381   09C6 23                 INC   HL 
1382   09C7 C9                 RET 
1383   09C8             
1384   09C8             
1385   09C8             
1386   09C8             INIT_TXT_LCD:
1387   09C8 3E 00           ld a, 0
1388   09CA 32 03 E0        ld (LCD_TXT_X), a
1389   09CD 32 04 E0        ld (LCD_TXT_Y), a
1390   09D0 32 0F E0        ld (LCD_DELETE_CHAR), a
1391   09D3 32 10 E0        ld (LCD_AUTO_X), a
1392   09D6 21 00 00        ld hl, 0
1393   09D9 22 08 E0        ld (LCD_TXT_X_TMP), hl
1394   09DC 23              inc hl
1395   09DD 22 0A E0        ld (LCD_TXT_Y_TMP), hl
1396   09E0 C9              RET
1397   09E1             
1398   09E1             
1399   09E1             DISPLAY_SCROLL_UP:
1400   09E1                 ; cada linha tem 128 bytes
1401   09E1                 ; temos 8 linhas
1402   09E1                 ; total 1024 bytes
1403   09E1             
1404   09E1                 ; display lines 0 to 7
1405   09E1                 ; move line 1 to 0
1406   09E1 21 80 E5        ld hl, DISPLAY+128
1407   09E4 11 00 E5        ld de, DISPLAY
1408   09E7 01 7F 00        ld bc, 127
1409   09EA ED B0           ldir
1410   09EC             
1411   09EC                 ; move line 2 to 1
1412   09EC 21 00 E6        ld hl, DISPLAY+256
1413   09EF 11 80 E5        ld de, DISPLAY+128
1414   09F2 01 7F 00        ld bc, 127
1415   09F5 ED B0           ldir
1416   09F7             
1417   09F7                 ; move line 3 to 2
1418   09F7 21 80 E6        ld hl, DISPLAY+384
1419   09FA 11 00 E6        ld de, DISPLAY+256
1420   09FD 01 7F 00        ld bc, 127
1421   0A00 ED B0           ldir
1422   0A02             
1423   0A02                 ; move line 4 to 3
1424   0A02 21 00 E7        ld hl, DISPLAY+512
1425   0A05 11 80 E6        ld de, DISPLAY+384
1426   0A08 01 7F 00        ld bc, 127
1427   0A0B ED B0           ldir
1428   0A0D             
1429   0A0D                 ; move line 5 to 4
1430   0A0D 21 80 E7        ld hl, DISPLAY+640
1431   0A10 11 00 E7        ld de, DISPLAY+512
1432   0A13 01 7F 00        ld bc, 127
1433   0A16 ED B0           ldir
1434   0A18             
1435   0A18                 ; move line 6 to 5
1436   0A18 21 00 E8        ld hl, DISPLAY+768
1437   0A1B 11 80 E7        ld de, DISPLAY+640
1438   0A1E 01 7F 00        ld bc, 127
1439   0A21 ED B0           ldir
1440   0A23             
1441   0A23                 ; move line 7 to 6
1442   0A23 21 80 E8        ld hl, DISPLAY+896
1443   0A26 11 00 E8        ld de, DISPLAY+768
1444   0A29 01 7F 00        ld bc, 127
1445   0A2C ED B0           ldir
1446   0A2E             
1447   0A2E                 ; clear line 7
1448   0A2E                 ; 896 to 1024
1449   0A2E 21 80 E8        ld hl, DISPLAY+896
1450   0A31 5D              ld e,l
1451   0A32 54              ld d,h
1452   0A33 13              inc de
1453   0A34 36 00           ld (hl), 0
1454   0A36 01 7F 00        ld bc, 127
1455   0A39 ED B0           ldir
1456   0A3B             
1457   0A3B C9              RET
1458   0A3C             
1459   0A3C             DELETE_CHAR:
1460   0A3C E1              POP HL ; retorno do call
1461   0A3D 3E 00           LD A, 0
1462   0A3F 32 0F E0        LD (LCD_DELETE_CHAR), A
1463   0A42 3A 03 E0        LD A, (LCD_TXT_X)
1464   0A45 3D              DEC A
1465   0A46 32 03 E0        LD (LCD_TXT_X), A
1466   0A49             
1467   0A49 3E FF           LD A, $FF
1468   0A4B 32 10 E0        LD (LCD_AUTO_X), A
1469   0A4E             
1470   0A4E F1              POP AF
1471   0A4F 3E 20           LD A, ' '
1472   0A51 32 00 E0        LD (LCD_CHAR), A
1473   0A54 F5              PUSH AF
1474   0A55 E5              PUSH HL ; call
1475   0A56 C9              RET
1476   0A57             
1477   0A57             
1478   0A57             ; Print char in buffer and show to lcd
1479   0A57             ; char in A
1480   0A57             PRINTCHAR:
1481   0A57 F5              PUSH AF
1482   0A58 C5              PUSH BC
1483   0A59 D5              PUSH DE
1484   0A5A E5              PUSH HL
1485   0A5B CD 69 0A        CALL PrintBufferChar
1486   0A5E 21 00 E5        LD HL, DISPLAY
1487   0A61 CD 90 0C        CALL print_image
1488   0A64 E1              POP HL
1489   0A65 D1              POP DE
1490   0A66 C1              POP BC
1491   0A67 F1              POP AF
1492   0A68 C9              RET
1493   0A69             
1494   0A69             
1495   0A69             ; Print char in buffer lcd (without show to lcd)
1496   0A69             ; char in A
1497   0A69             PrintBufferChar:
1498   0A69 32 00 E0        LD (LCD_CHAR), A ; save char to print
1499   0A6C             
1500   0A6C F5              PUSH AF
1501   0A6D C5              PUSH BC
1502   0A6E D5              PUSH DE
1503   0A6F E5              PUSH HL
1504   0A70             
1505   0A70 F5              PUSH AF
1506   0A71 3E 00           LD A, $0
1507   0A73 32 10 E0        LD (LCD_AUTO_X), A
1508   0A76 F1              POP AF
1509   0A77             
1510   0A77             
1511   0A77             ver_delete:
1512   0A77 F5              PUSH AF
1513   0A78 3A 0F E0        LD A, (LCD_DELETE_CHAR)
1514   0A7B B7              or a
1515   0A7C FE FF           CP $FF
1516   0A7E CC 3C 0A        call z, DELETE_CHAR
1517   0A81 F1              POP AF
1518   0A82 B7              or a
1519   0A83 FE 00           CP $0
1520   0A85 20 08           jr nz, ver_enter
1521   0A87 3E FF           LD A, $FF ; delete proximo char
1522   0A89 32 0F E0        LD (LCD_DELETE_CHAR), A
1523   0A8C C3 B4 0B        jp print_char_fim
1524   0A8F             
1525   0A8F                 ; Verificar Enter, clear, etc... SEM PERDER O reg. A
1526   0A8F             ver_enter:       
1527   0A8F             
1528   0A8F                             ; trata dados para o lcd
1529   0A8F FE 0D                       CP      CR                     ; compara com ENTER
1530   0A91 20 1A                       jr      nz, ver_limpa
1531   0A93             
1532   0A93 3E 00                       LD A,0
1533   0A95 32 03 E0                    LD (LCD_TXT_X), A ; ajusta X para o inicio da linha
1534   0A98             
1535   0A98 3A 04 E0                    LD A, (LCD_TXT_Y)
1536   0A9B 3C                          inc a
1537   0A9C FE 08                       cp 8
1538   0A9E C2 A7 0A                    jp nz, ver_enter_incYOK
1539   0AA1                             
1540   0AA1 CD E1 09                    CALL DISPLAY_SCROLL_UP
1541   0AA4                             ;ld hl, DISPLAY
1542   0AA4                             ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1543   0AA4                             
1544   0AA4 C3 B4 0B                    jp print_char_fim
1545   0AA7             
1546   0AA7             ver_enter_incYOK:
1547   0AA7 32 04 E0                    ld (LCD_TXT_Y), a
1548   0AAA C3 B4 0B                    jp print_char_fim
1549   0AAD             
1550   0AAD             
1551   0AAD             ver_limpa:
1552   0AAD FE 0C                       CP      $0C                     ; compara com limpar tela
1553   0AAF 20 0E                       jr      NZ, ver_line
1554   0AB1                             
1555   0AB1                             ;call    clear_lcd_screen
1556   0AB1                             ;call    show_lcd_screen
1557   0AB1 CD 69 0C                    call lcd_clear
1558   0AB4                             ;ld hl, DISPLAY
1559   0AB4                             ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1560   0AB4 3E 00                       LD A, 0
1561   0AB6 32 03 E0                    LD (LCD_TXT_X), A
1562   0AB9 32 04 E0                    LD (LCD_TXT_Y), A
1563   0ABC             
1564   0ABC C3 B4 0B                    JP print_char_fim
1565   0ABF             
1566   0ABF             ver_line:
1567   0ABF FE 0A                       CP      LF                     ; retorna começo da linha
1568   0AC1 20 03                       jr      NZ, print_lcd      
1569   0AC3             
1570   0AC3                                 ;----- verificar se precisa add algo aqui
1571   0AC3                             ;call    shift_lcd_up
1572   0AC3                             ;call    show_lcd_screen
1573   0AC3 C3 B4 0B                    JP print_char_fim
1574   0AC6             
1575   0AC6             print_lcd:
1576   0AC6                 ; pega o ponteiro para o caracter e salva em LCD_CHAR_POINT
1577   0AC6 26 00           ld H, 0
1578   0AC8 6F              ld L, A
1579   0AC9 29              ADD HL, HL ; hl x 8
1580   0ACA 29              ADD HL, HL
1581   0ACB 29              ADD HL, HL
1582   0ACC             
1583   0ACC 54              LD D, H
1584   0ACD 5D              LD E, L
1585   0ACE 21 93 00        ld hl, TABLE
1586   0AD1 19              add hl, de
1587   0AD2 22 01 E0        ld (LCD_CHAR_POINT), HL ; table
1588   0AD5             
1589   0AD5             
1590   0AD5                 ; ajusta X
1591   0AD5 06 06           ld b, 6
1592   0AD7 3A 03 E0        ld a, (LCD_TXT_X)
1593   0ADA B7              or A
1594   0ADB CA E5 0A        jp z, ajustX
1595   0ADE 4F              ld c, a
1596   0ADF CD B9 0B        call multiplication
1597   0AE2 C3 E8 0A        jp ajustXOK
1598   0AE5                 
1599   0AE5             ajustX:
1600   0AE5 21 00 00        ld hl, 0
1601   0AE8             ajustXOK:
1602   0AE8 22 08 E0        ld (LCD_TXT_X_TMP), HL 
1603   0AEB             
1604   0AEB             
1605   0AEB             
1606   0AEB                 ; ajuste Y
1607   0AEB 16 04           ld d, 4
1608   0AED 1E 00           ld e, 0 ; = 128x8 proxima linha
1609   0AEF 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1610   0AF2 3A 04 E0        ld a, (LCD_TXT_Y)
1611   0AF5 B7              or a
1612   0AF6 CA 06 0B        JP Z, multYfim
1613   0AF9 21 00 00        ld hl, 0
1614   0AFC 47              ld b, a
1615   0AFD             multY:
1616   0AFD 19              add hl, de
1617   0AFE 10 FD           DJNZ multY
1618   0B00             
1619   0B00 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1620   0B03 C3 0C 0B        jp multYfimok
1621   0B06             
1622   0B06             multYfim:
1623   0B06 21 00 00        ld hl, 0
1624   0B09 22 0A E0        ld (LCD_TXT_Y_TMP), HL
1625   0B0C             
1626   0B0C             multYfimok:
1627   0B0C             
1628   0B0C 2A 0A E0        ld hl, (LCD_TXT_Y_TMP)
1629   0B0F ED 5B 08 E0     ld de, (LCD_TXT_X_TMP)
1630   0B13             
1631   0B13 19              add hl, de  ; hl tem pos do pix 0-8191
1632   0B14             
1633   0B14 22 0E E0        ld (LCD_TMP_POINT), hl
1634   0B17             
1635   0B17             
1636   0B17 3E 08           ld a, 8 ; altura do caracter
1637   0B19 32 0C E0        ld (LCD_CHAR_H), a
1638   0B1C             printchar_loopH:
1639   0B1C 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1640   0B1F 7E              ld a, (HL)
1641   0B20 32 10 E1        ld (LCD_TEMP), a
1642   0B23             
1643   0B23 3E 06           ld a, 6 ; largura do caracter
1644   0B25 32 0D E0        ld (LCD_CHAR_W), a
1645   0B28             printchar_loopW:
1646   0B28 3A 10 E1        ld a, (LCD_TEMP)
1647   0B2B E6 80           and 128
1648   0B2D FE 00           cp 0
1649   0B2F CA 3B 0B        jp z, printchar_loopWC
1650   0B32 2A 0E E0        ld hl, (LCD_TMP_POINT)
1651   0B35 CD F4 0B        call lcd_setPixel
1652   0B38 C3 41 0B        JP printchar_loopWE
1653   0B3B             
1654   0B3B             printchar_loopWC:
1655   0B3B 2A 0E E0        ld hl, (LCD_TMP_POINT)
1656   0B3E CD 2D 0C        call lcd_clearPixel
1657   0B41             
1658   0B41             printchar_loopWE:
1659   0B41 3A 10 E1        ld a, (LCD_TEMP)
1660   0B44 CB 27           sla a
1661   0B46 32 10 E1        ld (LCD_TEMP), a
1662   0B49                 
1663   0B49 2A 0E E0        ld hl, (LCD_TMP_POINT)
1664   0B4C 23              inc hl
1665   0B4D 22 0E E0        ld (LCD_TMP_POINT), hl
1666   0B50             
1667   0B50 3A 0D E0        ld a, (LCD_CHAR_W)
1668   0B53 3D              dec A
1669   0B54 32 0D E0        ld (LCD_CHAR_W), a
1670   0B57 FE 00           cp 0
1671   0B59 C2 28 0B        JP NZ, printchar_loopW
1672   0B5C             
1673   0B5C             
1674   0B5C 2A 0E E0        ld hl, (LCD_TMP_POINT)
1675   0B5F 2B              dec hl
1676   0B60 2B              dec hl
1677   0B61 2B              dec hl
1678   0B62 2B              dec hl
1679   0B63 2B              dec hl
1680   0B64 2B              dec hl
1681   0B65             
1682   0B65 16 00           ld d, 0
1683   0B67 1E 80           ld e, 128
1684   0B69 19              add hl, de
1685   0B6A 22 0E E0        ld (LCD_TMP_POINT), HL
1686   0B6D             
1687   0B6D 2A 01 E0        ld hl, (LCD_CHAR_POINT)
1688   0B70 23              inc hl
1689   0B71 22 01 E0        ld (LCD_CHAR_POINT), hl
1690   0B74             
1691   0B74             
1692   0B74 3A 0C E0        ld a, (LCD_CHAR_H)
1693   0B77 3D              dec A
1694   0B78 32 0C E0        ld (LCD_CHAR_H), a
1695   0B7B FE 00           cp 0
1696   0B7D C2 1C 0B        jp NZ, printchar_loopH
1697   0B80             
1698   0B80                 ;ld hl, DISPLAY
1699   0B80                 ;call print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1700   0B80             
1701   0B80             
1702   0B80                 ; check auto x
1703   0B80 3A 10 E0        LD A, (LCD_AUTO_X)
1704   0B83 B7              OR A
1705   0B84 FE FF           CP $FF
1706   0B86 CA B4 0B        JP Z, print_char_fim
1707   0B89             
1708   0B89                 ; increment X, Y
1709   0B89 3A 03 E0        ld a, (LCD_TXT_X)
1710   0B8C 3C              inc a
1711   0B8D FE 15           cp 21
1712   0B8F C2 B1 0B        jp nz, incXOK
1713   0B92 3E 00           ld a, 0
1714   0B94 32 03 E0        ld (LCD_TXT_X), a
1715   0B97 3A 04 E0        ld a, (LCD_TXT_Y)
1716   0B9A 3C              inc a
1717   0B9B FE 08           cp 8
1718   0B9D C2 AB 0B        jp nz, incYOK
1719   0BA0 CD E1 09        CALL DISPLAY_SCROLL_UP
1720   0BA3                 ;ld hl, DISPLAY
1721   0BA3                 ;CALL print_image <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
1722   0BA3 3E 00           ld a, 0
1723   0BA5 32 03 E0        ld (LCD_TXT_X), a
1724   0BA8 C3 B4 0B        jp print_char_fim
1725   0BAB             
1726   0BAB             incYOK:
1727   0BAB 32 04 E0        ld (LCD_TXT_Y), a
1728   0BAE C3 B4 0B        jp print_char_fim
1729   0BB1             
1730   0BB1             incXOK:
1731   0BB1 32 03 E0        ld (LCD_TXT_X), a
1732   0BB4             
1733   0BB4             print_char_fim:
1734   0BB4                 ;ld hl, DISPLAY
1735   0BB4                 ;CALL print_image
1736   0BB4 E1              POP HL
1737   0BB5 D1              POP DE
1738   0BB6 C1              POP BC
1739   0BB7 F1              POP AF
1740   0BB8 C9              RET
1741   0BB9             ;-------- FIM PRINTCHAR ------------------
1742   0BB9             
1743   0BB9             
1744   0BB9             
1745   0BB9             ; ----------------------------------
1746   0BB9             
1747   0BB9             ; INPUT: THE VALUES IN REGISTER B EN C
1748   0BB9             ; OUTPUT: HL = B * C
1749   0BB9             ; CHANGES: AF,DE,HL,B
1750   0BB9             ;
1751   0BB9             multiplication:
1752   0BB9 21 00 00    	LD HL,0
1753   0BBC 78          	LD A,B
1754   0BBD B7          	OR A
1755   0BBE C8          	RET Z
1756   0BBF 16 00       	LD D,0
1757   0BC1 59          	LD E,C
1758   0BC2 19          multiplicationLOOP:	ADD HL,DE
1759   0BC3 10 FD       	DJNZ multiplicationLOOP
1760   0BC5 C9          	RET 
1761   0BC6             
1762   0BC6             ;-----------------------------------
1763   0BC6             
1764   0BC6             Div_HL_D:
1765   0BC6             ;Inputs:
1766   0BC6             ;   HL and D
1767   0BC6             ;Outputs:
1768   0BC6             ;   HL is the quotient (HL/D)
1769   0BC6             ;   A is the remainder
1770   0BC6             ;   B is 0
1771   0BC6             ;   C,D,E are preserved
1772   0BC6 AF              xor a         ; Clear upper eight bits of AHL
1773   0BC7 06 10           ld b,16       ; Sixteen bits in dividend
1774   0BC9             _loop:
1775   0BC9 29              add hl,hl     ; Do a "SLA HL". If the upper bit was 1, the c flag is set
1776   0BCA 17              rla           ; This moves the upper bits of the dividend into A
1777   0BCB 38 03           jr c,_overflow; If D is allowed to be >128, then it is possible for A to overflow here. (Yes future Zeda, 128 is "safe.")
1778   0BCD BA              cp d          ; Check if we can subtract the divisor
1779   0BCE 38 02           jr c,_skip    ; Carry means A < D
1780   0BD0             _overflow:
1781   0BD0 92              sub d         ; Do subtraction for real this time
1782   0BD1 2C              inc l         ; Set the next bit of the quotient (currently bit 0)
1783   0BD2             _skip:
1784   0BD2 10 F5           djnz _loop
1785   0BD4 C9              ret
1786   0BD5             
1787   0BD5             
1788   0BD5             ; -----------------------------------------------------------------------------
1789   0BD5             ;   LCD DRIVER
1790   0BD5             ; -----------------------------------------------------------------------------
1791   0BD5             ; INIT_LCD - Inicia o lcd em mode texto
1792   0BD5             ; lcd_setPixel - Liga um pixel (0 - 8191) pixel address em HL
1793   0BD5             ; lcd_clearPixel - Desliga um pixel (0 - 8191) pixel address em HL
1794   0BD5             ; lcd_clear - Limpa buffer do lcd
1795   0BD5             ; enable_grafic - Coloca o LCD em modo grafico
1796   0BD5             ; print_image - Coloca o conteudo de HL (128x64 bits) no LCD
1797   0BD5             ; cls_TXT - Limpa LCD mode text
1798   0BD5             ; cls_GRAPHIC - Limpa LCD modo grafico
1799   0BD5             
1800   0BD5             INIT_LCD:
1801   0BD5                 ;Initialisation
1802   0BD5 3E 30       	ld a, 30H
1803   0BD7 CD 19 0D    	call lcd_send_command
1804   0BDA             
1805   0BDA 3E A0       	ld a, 0b00100000
1806   0BDC CD 19 0D    	call lcd_send_command
1807   0BDF             
1808   0BDF 3E 30       	ld a, 30H
1809   0BE1 CD 19 0D    	call lcd_send_command
1810   0BE4             
1811   0BE4 3E 0C       	ld a, 0CH
1812   0BE6 CD 19 0D    	call lcd_send_command
1813   0BE9             
1814   0BE9 3E 01       	ld a, 01H
1815   0BEB CD 23 0D    	call lcd_send_command_clear ;; clear
1816   0BEE             
1817   0BEE 3E 02       	ld a, 02H
1818   0BF0 CD 19 0D    	call lcd_send_command
1819   0BF3 C9              RET
1820   0BF4             
1821   0BF4             
1822   0BF4             ; pixel index in HL
1823   0BF4             lcd_setPixel:
1824   0BF4 E5              push hl
1825   0BF5 C5              push bc
1826   0BF6 D5              push de
1827   0BF7 F5              push af
1828   0BF8 AF              xor A
1829   0BF9 32 07 E0        ld (LCD_BIT_INDEX), A
1830   0BFC 32 05 E0        ld (LCD_BYTE_INDEX), A
1831   0BFF             
1832   0BFF 16 08           ld d, 8
1833   0C01 CD C6 0B        call Div_HL_D
1834   0C04 32 07 E0        ld (LCD_BIT_INDEX), A
1835   0C07 22 05 E0        ld (LCD_BYTE_INDEX), HL
1836   0C0A ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1837   0C0E 21 00 E5        ld hl, DISPLAY
1838   0C11 09              add hl, bc
1839   0C12                 
1840   0C12 06 80           ld b, 128 ; 1000 0000
1841   0C14 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1842   0C17 FE 00           cp 0
1843   0C19 CA 25 0C        jp z, lcd_setPixel_fim
1844   0C1C             lcd_setPixel_bit:
1845   0C1C CB 38           srl B
1846   0C1E 3D              dec A
1847   0C1F CA 25 0C        jp z, lcd_setPixel_fim
1848   0C22                 
1849   0C22 C3 1C 0C        jp lcd_setPixel_bit
1850   0C25             lcd_setPixel_fim
1851   0C25 7E              ld a, (hl)
1852   0C26 B0              or b
1853   0C27 77              ld (hl), a
1854   0C28             
1855   0C28 F1              pop af
1856   0C29 C1              pop bc
1857   0C2A D1              pop de
1858   0C2B E1              pop hl
1859   0C2C C9              ret
1860   0C2D             
1861   0C2D             ;===============================
1862   0C2D             ; pixel index in HL
1863   0C2D             lcd_clearPixel:
1864   0C2D E5              push hl
1865   0C2E C5              push bc
1866   0C2F D5              push de
1867   0C30 F5              push af
1868   0C31 AF              xor A
1869   0C32 32 07 E0        ld (LCD_BIT_INDEX), A
1870   0C35 32 05 E0        ld (LCD_BYTE_INDEX), A
1871   0C38 16 08           ld d, 8
1872   0C3A CD C6 0B        call Div_HL_D
1873   0C3D 32 07 E0        ld (LCD_BIT_INDEX), A
1874   0C40 22 05 E0        ld (LCD_BYTE_INDEX), HL
1875   0C43 ED 4B 05 E0     ld BC, (LCD_BYTE_INDEX)
1876   0C47 21 00 E5        ld hl, DISPLAY
1877   0C4A 09              add hl, bc
1878   0C4B                 
1879   0C4B 06 80           ld b, 128 ; 1000 0000
1880   0C4D 3A 07 E0        ld a, (LCD_BIT_INDEX) ;
1881   0C50 FE 00           cp 0
1882   0C52 CA 5E 0C        jp z, lcd_clearPixel_fim
1883   0C55             lcd_clearPixel_bit:
1884   0C55 CB 38           srl B
1885   0C57 3D              dec A
1886   0C58 CA 5E 0C        jp z, lcd_clearPixel_fim
1887   0C5B                 
1888   0C5B C3 55 0C        jp lcd_clearPixel_bit
1889   0C5E             lcd_clearPixel_fim
1890   0C5E 78              ld a, b
1891   0C5F 2F              cpl     ; NOT B
1892   0C60 47              ld b, a
1893   0C61             
1894   0C61 7E              ld a, (hl)
1895   0C62 A0              and b
1896   0C63 77              ld (hl), a
1897   0C64             
1898   0C64 F1              pop af
1899   0C65 C1              pop bc
1900   0C66 D1              pop de
1901   0C67 E1              pop hl
1902   0C68 C9              ret
1903   0C69             
1904   0C69             
1905   0C69             ;;--------------------------------------------------
1906   0C69             lcd_clear:
1907   0C69                 ;; HL = start address of block
1908   0C69 21 00 E5        ld hl, DISPLAY
1909   0C6C             
1910   0C6C                 ;; DE = HL + 1
1911   0C6C 5D              ld e,l
1912   0C6D 54              ld d,h
1913   0C6E 13              inc de
1914   0C6F             
1915   0C6F                 ;; initialise first byte of block
1916   0C6F                 ;; with data byte (&00)
1917   0C6F 36 00           ld (hl), 0
1918   0C71                     
1919   0C71                 ;; BC = length of block in bytes
1920   0C71                 ;; HL+BC-1 = end address of block
1921   0C71             
1922   0C71 01 00 04        ld bc, 1024
1923   0C74             
1924   0C74                 ;; fill memory
1925   0C74 ED B0           ldir
1926   0C76 C9              ret
1927   0C77             
1928   0C77             
1929   0C77             ;===================
1930   0C77             
1931   0C77             ; grafic mode - enable
1932   0C77             enable_grafic:
1933   0C77 3E 30       	ld a, 30H
1934   0C79 CD 19 0D    	call lcd_send_command
1935   0C7C CD 4C 0D    	call delayLCD
1936   0C7F             	
1937   0C7F 3E 34       	ld a, 34H
1938   0C81 CD 19 0D    	call lcd_send_command
1939   0C84 CD 4C 0D    	call delayLCD
1940   0C87             	
1941   0C87 3E 36       	ld a, 36H
1942   0C89 CD 19 0D    	call lcd_send_command
1943   0C8C CD 4C 0D    	call delayLCD
1944   0C8F C9              ret
1945   0C90             
1946   0C90             
1947   0C90             ;==========================
1948   0C90             
1949   0C90             print_image:						; LOAD 128*64 bits (16*8 Byte) of data into the LCD screen
1950   0C90             									; HL content the data address
1951   0C90 F5              push af
1952   0C91 D5          	push de
1953   0C92 C5          	push bc
1954   0C93             
1955   0C93             
1956   0C93             ; premiere partie : X de 0 à 127 / Y de 0 à 32
1957   0C93             
1958   0C93 3E 20       	ld a,32
1959   0C95 57          	ld d,a							; boucle Y
1960   0C96 3E 00       	ld a,0
1961   0C98 5F          	ld e,a
1962   0C99             	
1963   0C99             boucle_colonne:
1964   0C99 3E 80       		ld a,$80					; coordonnée Y (0)
1965   0C9B 83          		add a,e
1966   0C9C CD 19 0D    		call lcd_send_command
1967   0C9F             		
1968   0C9F 3E 80       		ld a,$80					; coordonnée X (0)		
1969   0CA1 CD 19 0D    		call lcd_send_command
1970   0CA4             		
1971   0CA4 3E 08       		ld a,8
1972   0CA6 47          		ld b,a						; boucle X
1973   0CA7             		
1974   0CA7             boucle_ligne:	
1975   0CA7 7E          			ld a,(hl)
1976   0CA8 CD 2D 0D    			call lcd_send_data
1977   0CAB 23          			inc hl
1978   0CAC 7E          			ld a,(hl)
1979   0CAD CD 2D 0D    			call lcd_send_data		; auto-increment on screen address
1980   0CB0 23          			inc hl
1981   0CB1 05          			dec b
1982   0CB2 AF          			XOR a
1983   0CB3 B0          			OR b
1984   0CB4 C2 A7 0C    			jp nz,boucle_ligne		; tant qu'on a pas fait 7 
1985   0CB7             		
1986   0CB7 15          		dec d
1987   0CB8 1C          		inc e
1988   0CB9 AF          		XOR a
1989   0CBA B2          		OR d
1990   0CBB C2 99 0C    		jp nz,boucle_colonne
1991   0CBE             		
1992   0CBE             
1993   0CBE             ; seconde partie : X de 128 à 255 / Y de 0 à 32
1994   0CBE             
1995   0CBE 3E 20       	ld a,32
1996   0CC0 57          	ld d,a							; boucle Y
1997   0CC1 3E 00       	ld a,0
1998   0CC3 5F          	ld e,a
1999   0CC4             	
2000   0CC4             boucle_colonne2:
2001   0CC4 3E 80       		ld a,$80					; coordonnée Y (0)
2002   0CC6 83          		add a, e
2003   0CC7 CD 19 0D    		call lcd_send_command
2004   0CCA             		
2005   0CCA 3E 88       		ld a,$88					; coordonnée X (8)		
2006   0CCC CD 19 0D    		call lcd_send_command
2007   0CCF             		
2008   0CCF 3E 08       		ld a,8
2009   0CD1 47          		ld b,a						; boucle X
2010   0CD2             		
2011   0CD2             boucle_ligne2:	
2012   0CD2 7E          			ld a,(hl)
2013   0CD3 CD 2D 0D    			call lcd_send_data
2014   0CD6 23          			inc hl
2015   0CD7 7E          			ld a,(hl)
2016   0CD8 CD 2D 0D    			call lcd_send_data		; auto-increment on screen address
2017   0CDB 23          			inc hl
2018   0CDC 05          			dec b
2019   0CDD AF          			XOR a
2020   0CDE B0          			OR b
2021   0CDF C2 D2 0C    			jp nz,boucle_ligne2		; tant qu'on a pas fait 7 
2022   0CE2             		
2023   0CE2 15          		dec d
2024   0CE3 1C          		inc e
2025   0CE4 AF          		XOR a
2026   0CE5 B2          		OR d
2027   0CE6 C2 C4 0C    		jp nz,boucle_colonne2
2028   0CE9             
2029   0CE9 C1          	pop bc
2030   0CEA D1          	pop de
2031   0CEB F1              pop af
2032   0CEC             
2033   0CEC C9              ret
2034   0CED             
2035   0CED             
2036   0CED             
2037   0CED             ; ======================
2038   0CED             cls_TXT:
2039   0CED             	; # CLEAR DISPLAY IN TEXT MODE # 
2040   0CED 3E 01       	ld a,%00000001 					; CLEAR DISPLAY -> " $01 "
2041   0CEF CD 23 0D    	call lcd_send_command_clear		; CLEAR DISPLAY	
2042   0CF2 C9              ret
2043   0CF3             
2044   0CF3             ; ========================
2045   0CF3             
2046   0CF3             cls_GRAPHIC:		;   Fill entire Graphical screen with value 0
2047   0CF3             					;	Graphic RAM (GDRAM) use :
2048   0CF3             					;	1. Set vertical address (Y) for GDRAM
2049   0CF3             					;	2. Set horizontal address (X) for GDRAM
2050   0CF3             					;	3. Write D15~D8 to GDRAM (first byte)
2051   0CF3             					;	4. Write D7~D0 to GDRAM (second byte)
2052   0CF3 C5          	push bc
2053   0CF4 D5          	push de
2054   0CF5             
2055   0CF5 1E 20       	ld e,$20						; e = 32 
2056   0CF7 16 00       	ld d,$0							; d = 0
2057   0CF9             Boucle32X:
2058   0CF9 7A          		ld a,d
2059   0CFA F6 80       		OR $80
2060   0CFC CD 19 0D    		call lcd_send_command
2061   0CFF             		
2062   0CFF 3E 80       		ld a,$80					; Set horizontal address（X） for GDRAM = 0 ($80)
2063   0D01 CD 19 0D    		call lcd_send_command
2064   0D04             		
2065   0D04 AF          		xor a							 	
2066   0D05 06 10       		ld b,$10							; b = 17
2067   0D07             		
2068   0D07             Boucle16X:	 
2069   0D07 CD 2D 0D    			call lcd_send_data 			; Write D15〜D8 to GDRAM (first byte)
2070   0D0A CD 2D 0D    			call lcd_send_data 			; Write D7〜D0 to GDRAM (second byte)
2071   0D0D             											; Address counter will automatically increase by one for the next two-byte data												
2072   0D0D 10 F8       			djnz Boucle16X					; b = b -1 ; jump to label if b not 0
2073   0D0F             		
2074   0D0F 1D          		dec e 
2075   0D10 14          		inc d
2076   0D11 AF          		xor a							; a = 0
2077   0D12 B3          		or e
2078   0D13 C2 F9 0C    		jp nz,Boucle32X
2079   0D16             
2080   0D16 D1          	pop de
2081   0D17 C1          	pop bc
2082   0D18             	
2083   0D18 C9              ret
2084   0D19             
2085   0D19             
2086   0D19             
2087   0D19             ;******************
2088   0D19             ;Send a command byte to the LCD
2089   0D19             ;Entry: A= command byte
2090   0D19             ;Exit: All preserved
2091   0D19             ;******************
2092   0D19             lcd_send_command:
2093   0D19 C5          	push bc				;Preserve
2094   0D1A 0E 70       	ld c, LCDCTRL   	;Command port
2095   0D1C             	
2096   0D1C CD 4C 0D    	call delayLCD
2097   0D1F             	
2098   0D1F ED 79       	out (c),a			;Send command
2099   0D21 C1          	pop bc				;Restore
2100   0D22 C9          	ret
2101   0D23             
2102   0D23             
2103   0D23             ;******************
2104   0D23             ;Send a command byte to the LCD
2105   0D23             ;Entry: A= command byte
2106   0D23             ;Exit: All preserved
2107   0D23             ;******************
2108   0D23             lcd_send_command_clear:
2109   0D23 C5          	push bc				;Preserve
2110   0D24             	
2111   0D24 CD 56 0D    	call delayLCDclear
2112   0D27             	
2113   0D27 0E 70           ld c, LCDCTRL   	;Command port
2114   0D29 ED 79       	out (c),a			;Send command
2115   0D2B C1          	pop bc				;Restore
2116   0D2C C9          	ret
2117   0D2D             	
2118   0D2D             ;******************
2119   0D2D             ;Send a data byte to the LCD
2120   0D2D             ;Entry: A= data byte
2121   0D2D             ;Exit: All preserved
2122   0D2D             ;******************
2123   0D2D             lcd_send_data:
2124   0D2D C5          	push bc				;Preserve
2125   0D2E             	
2126   0D2E                 ;Busy wait
2127   0D2E CD 4C 0D    	call delayLCD
2128   0D31             
2129   0D31 0E 71       	ld c, LCDDATA	;Data port $71
2130   0D33 ED 79       	out (c),a			;Send data
2131   0D35 C1          	pop bc				;Restore
2132   0D36 C9          	ret
2133   0D37             
2134   0D37             
2135   0D37             
2136   0D37             
2137   0D37             ;******************
2138   0D37             ;Send an asciiz string to the LCD
2139   0D37             ;Entry: HL=address of string
2140   0D37             ;Exit: HL=address of ending zero of the string. All others preserved
2141   0D37             ;******************
2142   0D37             lcd_send_asciiz:
2143   0D37 F5          	push af
2144   0D38 C5          	push bc				;Preserve
2145   0D39             lcd_asciiz_char_loop:
2146   0D39 0E 70       	ld c, LCDCTRL   	;Command port
2147   0D3B             	
2148   0D3B             lcd_asciiz_wait_loop:	;Busy wait
2149   0D3B CD 4C 0D    	call delayLCD
2150   0D3E             	
2151   0D3E 7E          	ld a,(hl)			;Get character
2152   0D3F A7          	and a				;Is it zero?
2153   0D40 28 07       	jr z,lcd_asciiz_done	;If so, we're done
2154   0D42             	
2155   0D42 0E 71       	ld c, LCDDATA	;Data port
2156   0D44 ED 79       	out (c),a			;Send data
2157   0D46 23          	inc hl				;Next char
2158   0D47 18 F0       	jr lcd_asciiz_char_loop
2159   0D49             	
2160   0D49             lcd_asciiz_done:
2161   0D49 C1          	pop bc				;Restore
2162   0D4A F1          	pop af
2163   0D4B C9          	ret
2164   0D4C             
2165   0D4C             ; =========================================================
2166   0D4C             ; Delay LCD
2167   0D4C             ; =========================================================
2168   0D4C             delayLCD:
2169   0D4C 00          	NOP
2170   0D4D 00          	NOP
2171   0D4E 00          	NOP
2172   0D4F 00          	NOP
2173   0D50 00          	NOP
2174   0D51 00          	NOP
2175   0D52 00          	NOP
2176   0D53 00          	NOP
2177   0D54 00              NOP
2178   0D55 C9              ret
2179   0D56             
2180   0D56             delayLCDclear:
2181   0D56 00          	NOP
2182   0D57 00          	NOP
2183   0D58 00          	NOP
2184   0D59 00          	NOP
2185   0D5A 00          	NOP
2186   0D5B 00          	NOP
2187   0D5C 00          	NOP
2188   0D5D 00          	NOP
2189   0D5E 00          	NOP
2190   0D5F 00          	NOP
2191   0D60 00          	NOP
2192   0D61 00          	NOP
2193   0D62 00              NOP
2194   0D63 C9              ret
2195   0D64             
2196   0D64             	
2197   0D64             ; =========================================================
2198   0D64             ; Delay
2199   0D64             ; =========================================================
2200   0D64             delay:
2201   0D64 C5          	push bc                       ; 2.75 us
2202   0D65 06 01           ld b, 1                     ; 1.75 us
2203   0D67             delay_loop_b:
2204   0D67 0E FF       	ld c, 255                     ; 1.75 us
2205   0D69             delay_loop:
2206   0D69 0D          	dec c                         ; 1 us
2207   0D6A C2 69 0D        jp nz, delay_loop             ; true = 3 us, false 1.75 us
2208   0D6D 05              dec b                         ; 1 us
2209   0D6E C2 67 0D        jp nz, delay_loop_b           ; true = 3 us, false 1.75 us
2210   0D71 C1              pop bc                        ; 2.50 us
2211   0D72 C9              ret   
2212   0D73             
2213   0D73             
2214   0D73             ; Check break key
2215   0D73 3E 40       CHKKEY: LD  A, $40
2216   0D75 D3 40       	OUT (KEY_OUT), A ; line 4
2217   0D77 DB 40       	IN  A, (KEY_IN)
2218   0D79 FE 01       	CP  1
2219   0D7B C2 83 0D    	JP  NZ, GRET
2220   0D7E 3E 03       	LD  A, CTRLC
2221   0D80 FE 00       	CP	0
2222   0D82 C9          	RET
2223   0D83             GRET:
2224   0D83 3E 00       	LD  A, 0
2225   0D85 FE 00       	CP 0
2226   0D87 C9          	RET
2227   0D88             
2228   0D88             
2229   0D88             
2230   0D88             
2231   0D88             ; -----------------------------------------------------------------------------
2232   0D88             ;   KEYREAD - KEY In A
2233   0D88             ; -----------------------------------------------------------------------------
2234   0D88             KEYREADINIT:
2235   0D88 C5              PUSH    BC
2236   0D89 D5          	PUSH	DE
2237   0D8A E5          	PUSH    HL
2238   0D8B 1E 00       	LD      E, 0                    ; E will be the last pressed key
2239   0D8D             READKEY:        
2240   0D8D 26 01           LD      H, 1                    ; H is the line register, start with second
2241   0D8F 06 00       	LD      B, 0                    ; Count lines for later multiplication	
2242   0D91 16 00       	LD      D, 0                    ; DE will be the adress for mask
2243   0D93             						
2244   0D93             NEXTKEY:        
2245   0D93 7C              LD      A, H						
2246   0D94 FE 00           CP      0                       ; All lines tried? 
2247   0D96 CA D1 0D        JP      Z, KEYOUT               ; Then check if there was a key pressed
2248   0D99 D3 40       	OUT     (KEY_OUT), A		    ; Put current line to register
2249   0D9B DB 40       	IN      A, (KEY_IN)		        ; Input Keys
2250   0D9D E6 3F       	AND     $3F                     ; only 6 bits
2251   0D9F CB 24       	SLA     H                       ; Next line
2252   0DA1 04              INC     B
2253   0DA2 FE 00           CP      0                       ; Was key zero?
2254   0DA4 CA 93 0D        JP      Z, NEXTKEY              ; Then try again with next lines
2255   0DA7 16 00           LD      D, 0                    ; In D will be the number of the key
2256   0DA9             LOGARITHM:      
2257   0DA9 14              INC     D	                    ; Add one per shift
2258   0DAA CB 3F           SRL     A                       ; Shift key right
2259   0DAC C2 A9 0D        JP      NZ, LOGARITHM		    ; If not zero shift again
2260   0DAF 15              DEC     D                       ; Was too much
2261   0DB0 DB 40       	IN      A, (KEY_IN)
2262   0DB2 E6 80           AND     $80                     ; Check if first bit set (shift key pressed)
2263   0DB4 C2 BD 0D        JP      NZ, LOADSHIFT		    ; Then jump to read with shift
2264   0DB7 7A              LD      A, D                    ; Put read key into accu
2265   0DB8 C6 33           ADD     A, KEYMAP               ; Add base of key map array
2266   0DBA C3 C0 0D        JP      ADDOFFSET               ; Jump to load key
2267   0DBD             LOADSHIFT:
2268   0DBD 7A              LD      A, D
2269   0DBE C6 63           ADD     A, SHIFTKEYMAP          ; In this case add the base for shift		
2270   0DC0             ADDOFFSET:
2271   0DC0 C6 06           ADD     A, 6                    ; Add 6 for every line
2272   0DC2 10 FC           DJNZ    ADDOFFSET               ; Jump back (do while loop)
2273   0DC4 D6 06       	SUB     6                       ; Since do while is one too much
2274   0DC6             TRANSKEY:
2275   0DC6 A8              XOR     B                       ; Empty B
2276   0DC7 4F          	LD      C, A                    ; A will be address in BC
2277   0DC8 0A          	LD      A, (BC)	                ; Load key
2278   0DC9 BB          	CP      E                       ; Same key?
2279   0DCA CA 8D 0D    	JP      Z, READKEY              ; Then from beginning
2280   0DCD 5F          	LD      E, A                    ; Otherwise save new key
2281   0DCE C3 8D 0D    	JP      READKEY	                ; And restart
2282   0DD1             KEYOUT:
2283   0DD1 7B              LD      A, E
2284   0DD2 1E 00           LD      E, 0                    ; empty it
2285   0DD4 B7              OR      A	                    ; Was a key read?
2286   0DD5 CA 8D 0D        JP      Z, READKEY              ; If not restart
2287   0DD8 E1              POP     HL
2288   0DD9 D1              POP     DE
2289   0DDA C1              POP     BC
2290   0DDB C9              RET
2291   0DDC             
2292   0DDC             
2293   0DDC             ;-----------------------
2294   0DDC             ; RECEIVE INTEL HEX FILE
2295   0DDC             ;-----------------------       
2296   0DDC             INTHEX: 
2297   0DDC 21 18 13           LD HL, MSG_ILOAD
2298   0DDF CD 8F 0E           CALL  SNDLCDMSG
2299   0DE2             
2300   0DE2 21 18 13           LD HL, MSG_ILOAD
2301   0DE5 CD A2 0E           CALL  SNDMSG
2302   0DE8                    
2303   0DE8             
2304   0DE8 CD 07 0E           CALL  INTELH
2305   0DEB 20 0D              JR    NZ,ITHEX1      
2306   0DED             
2307   0DED 21 2E 13           LD    HL,FILEOK
2308   0DF0 CD 8F 0E           CALL  SNDLCDMSG   ;GOT FILE OK LCD
2309   0DF3 21 2E 13           LD    HL,FILEOK
2310   0DF6 CD A2 0E           CALL  SNDMSG      ;GOT FILE OK Serial
2311   0DF9                    
2312   0DF9 C9                 RET
2313   0DFA 21 40 13    ITHEX1: LD    HL,CSUMERR
2314   0DFD CD 8F 0E           CALL  SNDLCDMSG
2315   0E00             
2316   0E00 21 40 13           LD    HL,CSUMERR
2317   0E03 CD A2 0E           CALL  SNDMSG      ;CHECKSUM ERROR
2318   0E06                    
2319   0E06 C9                 RET  
2320   0E07             
2321   0E07             
2322   0E07             
2323   0E07             
2324   0E07             
2325   0E07             ;-----------------------
2326   0E07             ; RECEIVE INTEL HEX FILE
2327   0E07             ;-----------------------
2328   0E07 DD 21 00 F0 INTELH:	LD	IX,SYSTEM	;POINT TO SYSTEM VARIABLES
2329   0E0B             ;
2330   0E0B             ; WAIT FOR RECORD MARK
2331   0E0B             ;
2332   0E0B AF          INTEL1:	XOR	A
2333   0E0C DD 77 03    	LD	(IX+3),A	;CLEAR CHECKSUM
2334   0E0F CD E7 0E    	CALL	RXDATA	;WAIT FOR THE RECORD MARK
2335   0E12 FE 3A       	CP	':'	;TO BE TRANSMITTED
2336   0E14 20 F5       	JR	NZ,INTEL1	;NOT RECORD MARK
2337   0E16             ;
2338   0E16             ; GET RECORD LENGTH
2339   0E16             ;
2340   0E16 CD 63 0E    	CALL	GETBYT
2341   0E19 DD 77 00    	LD	(IX+0),A	;NUMBER OF DATA BYTES
2342   0E1C             ;
2343   0E1C             ; GET ADDRESS FIELD
2344   0E1C             ;
2345   0E1C CD 63 0E    	CALL	GETBYT
2346   0E1F DD 77 02    	LD	(IX+2),A	;LOAD ADDRESS HIGH BYTE
2347   0E22 CD 63 0E    	CALL	GETBYT
2348   0E25 DD 77 01    	LD	(IX+1),A	;LOAD ADDRESS LOW BYTE
2349   0E28             ;
2350   0E28             ; GET RECORD TYPE
2351   0E28             ;
2352   0E28 CD 63 0E    	CALL	GETBYT
2353   0E2B 20 24       	JR	NZ,INTEL4	;END OF FILE RECORD
2354   0E2D             ;
2355   0E2D             ; READ IN THE DATA
2356   0E2D             ;
2357   0E2D DD 46 00    	LD	B,(IX+0)	;NUMBER OF DATA BYTES
2358   0E30 DD 66 02    	LD	H,(IX+2)	;LOAD ADDRESS HIGH BYTE
2359   0E33 DD 6E 01    	LD	L,(IX+1)	;LOAD ADDRESS LOW BYTE
2360   0E36             
2361   0E36 CD 63 0E    INTEL2:	CALL	GETBYT	;GET DATA BYTE
2362   0E39 77          	LD	(HL),A	;STORE DATA BYTE
2363   0E3A 23          	INC	HL
2364   0E3B 10 F9       	DJNZ	INTEL2	;LOAD MORE BYTES
2365   0E3D             ;
2366   0E3D             ; GET CHECKSUM AND COMPARE
2367   0E3D             ;
2368   0E3D DD 7E 03    	LD	A,(IX+3)	;CONVERT CHECKSUM TO
2369   0E40 ED 44       	NEG		;TWO'S COMPLEMENT
2370   0E42 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
2371   0E45 CD 63 0E    	CALL	GETBYT
2372   0E48 DD 77 03    	LD	(IX+3),A	;SAVE RECORD CHECKSUM
2373   0E4B DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
2374   0E4E 28 BB       	JR	Z,INTEL1	;CHECKSUM OK,NEXT RECORD
2375   0E50 C9              RET             ;NZ=CHECKSUM ERROR
2376   0E51             ;
2377   0E51             ; END OF FILE RECORD
2378   0E51             ;
2379   0E51 DD 7E 03    INTEL4:	LD	A,(IX+3)	;CONVERT CHECKSUM TO
2380   0E54 ED 44       	NEG		;TWO'S COMPLEMENT
2381   0E56 DD 77 04    	LD	(IX+4),A	;SAVE COMPUTED CHECKSUM
2382   0E59 CD 63 0E    	CALL	GETBYT
2383   0E5C DD 77 03    	LD	(IX+3),A	;SAVE EOF CHECKSUM
2384   0E5F DD BE 04    	CP	(IX+4)	;COMPARE CHECKSUM
2385   0E62 C9          	RET  	    ;NZ=CHECKSUM ERROR
2386   0E63             ;--------------------------
2387   0E63             ; GET BYTE FROM SERIAL PORT
2388   0E63             ;--------------------------
2389   0E63 C5          GETBYT:	PUSH	BC
2390   0E64 CD E7 0E    	CALL	RXDATA
2391   0E67 CB 77       	BIT	6,A
2392   0E69 28 02       	JR	Z,GETBT1
2393   0E6B C6 09       	ADD	A,09H
2394   0E6D E6 0F       GETBT1:	AND	0FH
2395   0E6F CB 27       	SLA 	A
2396   0E71 CB 27       	SLA	A
2397   0E73 CB 27       	SLA	A
2398   0E75 CB 27       	SLA	A
2399   0E77 4F          	LD	C,A
2400   0E78             ;
2401   0E78             ; GET LOW NYBBLE
2402   0E78             ;
2403   0E78 CD E7 0E    	CALL	RXDATA
2404   0E7B CB 77       	BIT	6,A
2405   0E7D 28 02       	JR	Z,GETBT2
2406   0E7F C6 09       	ADD	A,09H
2407   0E81 E6 0F       GETBT2:	AND	0FH
2408   0E83 B1          	OR	C
2409   0E84 47          	LD	B,A
2410   0E85 DD 86 03    	ADD	A,(IX+3)
2411   0E88 DD 77 03    	LD	(IX+3),A	;ADD TO CHECKSUM
2412   0E8B 78          	LD	A,B
2413   0E8C A7          	AND	A	;CLEAR CARRY
2414   0E8D C1              POP	BC
2415   0E8E C9          	RET
2416   0E8F             
2417   0E8F             ;-----------------------------------------
2418   0E8F             ; SEND AN ASCII STRING OUT LCD
2419   0E8F             ;-----------------------------------------
2420   0E8F             ; 
2421   0E8F             ; SENDS A ZERO TERMINATED STRING OR 
2422   0E8F             ; 128 CHARACTERS MAX. OUT LCD
2423   0E8F             ;
2424   0E8F             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2425   0E8F             ;      EXIT  : NONE
2426   0E8F             ;
2427   0E8F             ;       MODIFIES : A,B,C
2428   0E8F             ;          
2429   0E8F 06 80       SNDLCDMSG: LD    B,128         ;128 CHARS MAX
2430   0E91 7E          SDLCDMSG1: LD    A,(HL)        ;GET THE CHAR
2431   0E92 FE 00              CP    00H          ;ZERO TERMINATOR?
2432   0E94 28 06              JR    Z,SDLCDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2433   0E96 CD 69 0A           CALL PrintBufferChar         ;TRANSMIT THE CHAR
2434   0E99 23                 INC   HL
2435   0E9A 10 F5              DJNZ  SDLCDMSG1        ;128 CHARS MAX!    
2436   0E9C             SDLCDMSG2: 
2437   0E9C 21 00 E5        LD HL, DISPLAY
2438   0E9F CD 90 0C        CALL print_image
2439   0EA2             RET
2440   0EA2             
2441   0EA2             ;-----------------------------------------
2442   0EA2             ; SEND AN ASCII STRING OUT THE SERIAL PORT
2443   0EA2             ;-----------------------------------------
2444   0EA2             ; 
2445   0EA2             ; SENDS A ZERO TERMINATED STRING OR 
2446   0EA2             ; 128 CHARACTERS MAX. OUT THE SERIAL PORT
2447   0EA2             ;
2448   0EA2             ;      ENTRY : HL = POINTER TO 00H TERMINATED STRING
2449   0EA2             ;      EXIT  : NONE
2450   0EA2             ;
2451   0EA2             ;       MODIFIES : A,B,C
2452   0EA2             ;          
2453   0EA2 06 80       SNDMSG: LD    B,128         ;128 CHARS MAX
2454   0EA4 7E          SDMSG1: LD    A,(HL)        ;GET THE CHAR
2455   0EA5 FE 00              CP    00H          ;ZERO TERMINATOR?
2456   0EA7 28 06              JR    Z,SDMSG2      ;FOUND A ZERO TERMINATOR, EXIT  
2457   0EA9 CD B0 0E           CALL  OUTCH         ;TRANSMIT THE CHAR
2458   0EAC 23                 INC   HL
2459   0EAD 10 F5              DJNZ  SDMSG1        ;128 CHARS MAX!    
2460   0EAF C9          SDMSG2: RET
2461   0EB0             
2462   0EB0             
2463   0EB0             
2464   0EB0             ;-----------------------------------
2465   0EB0             ; OUTPUT A CHARACTER TO THE TERMINAL
2466   0EB0             ;-----------------------------------       
2467   0EB0 DD 2A AA FF OUTCH:  LD   IX,(PUTCH)
2468   0EB4 DD E9              JP   (IX)
2469   0EB6             ;------------------------------------
2470   0EB6             ; INPUT A CHARACTER FROM THE TERMINAL
2471   0EB6             ;------------------------------------
2472   0EB6 DD 2A AC FF INCH:  LD   IX,(GETCH)
2473   0EBA DD E9             JP   (IX)
2474   0EBC             
2475   0EBC             
2476   0EBC             
2477   0EBC             ;------------------------
2478   0EBC             ; SERIAL TRANSMIT ROUTINE
2479   0EBC             ;------------------------
2480   0EBC             ;TRANSMIT BYTE SERIALLY ON DOUT
2481   0EBC             ;
2482   0EBC             ; ENTRY : A = BYTE TO TRANSMIT
2483   0EBC             ;  EXIT : NO REGISTERS MODIFIED
2484   0EBC             ;
2485   0EBC F5          TXDATA:	PUSH	AF
2486   0EBD C5          	PUSH	BC
2487   0EBE E5          	PUSH	HL
2488   0EBF 2A C0 FF    	LD	HL,(BAUD)
2489   0EC2 4F          	LD	C,A
2490   0EC3             ;
2491   0EC3             ; TRANSMIT START BIT
2492   0EC3             ;
2493   0EC3 AF          	XOR	A
2494   0EC4 D3 C0       	OUT	(SERIAL_TX_PORT),A
2495   0EC6 CD 14 0F    	CALL	BITIME
2496   0EC9             ;
2497   0EC9             ; TRANSMIT DATA
2498   0EC9             ;
2499   0EC9 06 08       	LD	B,08H
2500   0ECB CB 09       	RRC	C
2501   0ECD CB 09       NXTBIT:	RRC	C	;SHIFT BITS TO D6,
2502   0ECF 79          	LD	A,C	;LSB FIRST AND OUTPUT
2503   0ED0 E6 40       	AND	40H	;THEM FOR ONE BIT TIME.
2504   0ED2 D3 C0       	OUT	(SERIAL_TX_PORT),A
2505   0ED4 CD 14 0F    	CALL	BITIME
2506   0ED7 10 F4       	DJNZ	NXTBIT
2507   0ED9             ;
2508   0ED9             ; SEND STOP BITS
2509   0ED9             ;
2510   0ED9 3E 40       	LD	A,40H
2511   0EDB D3 C0       	OUT	(SERIAL_TX_PORT),A
2512   0EDD CD 14 0F    	CALL	BITIME
2513   0EE0 CD 14 0F    	CALL	BITIME
2514   0EE3 E1          	POP	HL
2515   0EE4 C1          	POP	BC
2516   0EE5 F1          	POP	AF
2517   0EE6 C9          	RET
2518   0EE7             ;-----------------------
2519   0EE7             ; SERIAL RECEIVE ROUTINE
2520   0EE7             ;-----------------------
2521   0EE7             ;RECEIVE SERIAL BYTE FROM DIN
2522   0EE7             ;
2523   0EE7             ; ENTRY : NONE
2524   0EE7             ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
2525   0EE7             ;
2526   0EE7             ; REGISTERS MODIFIED A AND F
2527   0EE7             ;
2528   0EE7 C5          RXDATA:	PUSH	BC
2529   0EE8 E5          	PUSH	HL
2530   0EE9             ;
2531   0EE9             ; WAIT FOR START BIT 
2532   0EE9             ;
2533   0EE9 DB C0       RXDAT1: IN	A,(SERIAL_RX_PORT)
2534   0EEB CB 7F       	    BIT	7,A
2535   0EED 20 FA       	    JR	NZ,RXDAT1	;NO START BIT
2536   0EEF             ;
2537   0EEF             ; DETECTED START BIT
2538   0EEF             ;
2539   0EEF 2A C0 FF    	LD	HL,(BAUD)
2540   0EF2 CB 3C       	SRL	H
2541   0EF4 CB 1D       	RR	L 	;DELAY FOR HALF BIT TIME
2542   0EF6 CD 14 0F    	CALL 	BITIME
2543   0EF9 DB C0       	IN	A,(SERIAL_RX_PORT)
2544   0EFB CB 7F       	BIT	7,A
2545   0EFD 20 EA       	JR	NZ,RXDAT1	;START BIT NOT VALID
2546   0EFF             ;
2547   0EFF             ; DETECTED VALID START BIT,READ IN DATA
2548   0EFF             ;
2549   0EFF 06 08       	LD	B,08H
2550   0F01 2A C0 FF    RXDAT2:	LD	HL,(BAUD)
2551   0F04 CD 14 0F    	CALL	BITIME	;DELAY ONE BIT TIME
2552   0F07 DB C0       	IN	A,(SERIAL_RX_PORT)
2553   0F09 CB 17       	RL	A
2554   0F0B CB 19       	RR	C	;SHIFT BIT INTO DATA REG
2555   0F0D 10 F2       	DJNZ	RXDAT2
2556   0F0F 79          	LD	A,C
2557   0F10 B7          	OR	A	;CLEAR CARRY FLAG
2558   0F11 E1              POP	HL
2559   0F12 C1          	POP	BC
2560   0F13 C9          	RET
2561   0F14             ;---------------
2562   0F14             ; BIT TIME DELAY
2563   0F14             ;---------------
2564   0F14             ;DELAY FOR ONE SERIAL BIT TIME
2565   0F14             ;ENTRY : HL = DELAY TIME
2566   0F14             ; NO REGISTERS MODIFIED
2567   0F14             ;
2568   0F14 E5          BITIME:	PUSH	HL
2569   0F15 D5          	PUSH	DE
2570   0F16 11 01 00    	LD	DE,0001H
2571   0F19 ED 52       BITIM1:	SBC	HL,DE
2572   0F1B D2 19 0F    	JP	NC,BITIM1
2573   0F1E D1          	POP	DE
2574   0F1F E1          	POP	HL
2575   0F20 C9          	RET
2576   0F21             
2577   0F21             
2578   0F21             ;-----------------
2579   0F21             ; ONE SECOND DELAY
2580   0F21             ;-----------------
2581   0F21             ;
2582   0F21             ; ENTRY : NONE
2583   0F21             ; EXIT : FLAG REGISTER MODIFIED
2584   0F21             ;
2585   0F21 C5          DELONE:	PUSH	BC
2586   0F22 D5          	PUSH	DE
2587   0F23 E5          	PUSH	HL
2588   0F24 11 01 00    	LD	DE,0001H
2589   0F27 21 70 08    	LD	HL,0870H
2590   0F2A 06 92       DELON1:	LD	B,92H
2591   0F2C 10 FE       DELON2:	DJNZ	DELON2	;INNER LOOP
2592   0F2E ED 52       	SBC	HL,DE
2593   0F30 D2 2A 0F    	JP	NC,DELON1	;OUTER LOOP
2594   0F33 E1          	POP	HL
2595   0F34 D1          	POP	DE
2596   0F35 C1          	POP	BC
2597   0F36 C9          	RET
2598   0F37             
2599   0F37             
2600   0F37             
2601   0F37             
2602   0F37             
2603   0F37             
2604   0F37             
2605   0F37             ; **********************************************************************
2606   0F37             ; List devices found on the I2C bus
2607   0F37             ;
2608   0F37             ; Test each I2C device address and reports any that acknowledge
2609   0F37             
2610   0F37 11 2C 12    I2CLIST:       LD   DE,LISTMsg        ;Address of message string
2611   0F3A CD DA 0F                CALL StrOut         ;Output string
2612   0F3D 16 00                   LD   D,0            ;First I2C device address to test
2613   0F3F D5          LISTLOOP:      PUSH DE             ;Preserve DE
2614   0F40 7A                      LD   A,D            ;Get device address to be tested
2615   0F41 CD 58 0F                CALL LISTTEST          ;Test if device is present
2616   0F44 D1                      POP  DE             ;Restore DE
2617   0F45 20 07                   JR   NZ,LISTNEXT       ;Skip if no acknowledge
2618   0F47 7A                      LD   A,D            ;Get address of device tested
2619   0F48 CD 09 10                CALL HexOut         ;Output as two character hex 
2620   0F4B CD D5 0F                CALL SpaceOut       ;Output space character
2621   0F4E 14          LISTNEXT:      INC  D              ;Get next write address
2622   0F4F 14                      INC  D
2623   0F50 7A                      LD   A,D            ;Address of next device to test
2624   0F51 B7                      OR   A              ;Have we tested all addresses?
2625   0F52 20 EB                   JR   NZ,LISTLOOP       ;No, so loop again
2626   0F54 CD D2 0F                CALL LineOut        ;Output new line
2627   0F57 C9                      RET
2628   0F58             
2629   0F58             ; Test if device at I2C address A acknowledges
2630   0F58             ;   On entry: A = I2C device address (8-bit, bit 0 = lo for write)
2631   0F58             ;   On exit:  Z flagged if device acknowledges
2632   0F58             ;             NZ flagged if devices does not acknowledge
2633   0F58 CD 4A 10    LISTTEST:      CALL I2C_Open       ;Open I2C device for write
2634   0F5B C0                      RET  NZ             ;Abort if failed to open
2635   0F5C CD 51 10                CALL I2C_Close      ;Close I2C device 
2636   0F5F AF                      XOR  A              ;Return with Z flagged
2637   0F60 C9                      RET
2638   0F61             
2639   0F61             
2640   0F61             
2641   0F61             
2642   0F61             ; Copy a block from I2C memory to CPU memory
2643   0F61             ;   On entry: DE = First address in I2C memory
2644   0F61             ;             HL = First address in CPU memory
2645   0F61             ;             BC = Number of bytes to be copied
2646   0F61             ;             SCL = unknown, SDA = unknown
2647   0F61             ;   On exit:  If successfully A = 0 and Z flagged
2648   0F61             ;             If unsuccessfully A = Error and NZ flagged
2649   0F61             ;             IX IY preserved
2650   0F61 C5          I2C_MemRd:  PUSH BC
2651   0F62 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2652   0F65 3E AE       I2C_MemRdRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2653   0F67 CD 4A 10                CALL I2C_Open       ;Open for write
2654   0F6A 28 0A                   JR   Z,I2C_MemRdReady       ;If open okay then skip on
2655   0F6C 0B                      DEC  BC
2656   0F6D 78                      LD   A,B
2657   0F6E B1                      OR   C              ;Timeout?
2658   0F6F 20 F4                   JR   NZ,I2C_MemRdRepeat     ;No, so go try again
2659   0F71 C1                      POP  BC
2660   0F72 3E 03                   LD   A,ERR_TOUT     ;Error code
2661   0F74 B7                      OR   A              ;Error, so NZ flagged
2662   0F75 C9                      RET                 ;Return with error
2663   0F76             ; Device opened okay
2664   0F76 C1          I2C_MemRdReady:     POP  BC             ;Restore byte counter
2665   0F77 7A                      LD   A,D            ;Address (hi) in I2C memory
2666   0F78 CD 54 10                CALL I2C_Write      ;Write address
2667   0F7B 7B                      LD   A,E            ;Address (lo) in I2C memory
2668   0F7C CD 54 10                CALL I2C_Write      ;Write address
2669   0F7F 3E AF                   LD   A,I2CA_BLOCK+1 ;I2C device to be read from
2670   0F81 CD 4A 10                CALL I2C_Open       ;Open for read
2671   0F84 C0                      RET  NZ             ;Abort if error
2672   0F85 0B          I2C_MemRdRead:      DEC  BC             ;Decrement byte counter
2673   0F86 78                      LD   A,B
2674   0F87 B1                      OR   C              ;Last byte to be read?
2675   0F88 CD 91 10                CALL I2C_Read       ;Read byte with no ack on last byte
2676   0F8B 77                      LD   (HL),A         ;Write byte in CPU memory
2677   0F8C 23                      INC  HL             ;Increment CPU memory pointer
2678   0F8D 78                      LD   A,B
2679   0F8E B1                      OR   C              ;Finished?
2680   0F8F 20 F4                   JR   NZ,I2C_MemRdRead       ;No, so go read next byte
2681   0F91 CD C9 10                CALL I2C_Stop       ;Generate I2C stop
2682   0F94 AF                      XOR  A              ;Return with success (Z flagged)
2683   0F95 C9                      RET
2684   0F96             
2685   0F96             
2686   0F96             ; Copy a block from CPU memory to I2C memory
2687   0F96             ;   On entry: DE = First address in I2C memory
2688   0F96             ;             HL = First address in CPU memory
2689   0F96             ;             BC = Number of bytes to be copied
2690   0F96             ;             SCL = unknown, SDA = unknown
2691   0F96             ;   On exit:  If successfully A = 0 and Z flagged
2692   0F96             ;             If unsuccessfully A = Error and NZ flagged
2693   0F96             ;             IX IY preserved
2694   0F96             ; The 24LC64 requires blocks of data to be written in 64 byte (or less)
2695   0F96             ; pages.
2696   0F96 C5          I2C_MemWr:  PUSH BC
2697   0F97 01 10 27                LD   BC,TIMEOUT     ;Timeout loop counter
2698   0F9A 3E AE       I2C_MemWrRepeat:    LD   A,I2CA_BLOCK   ;I2C address to write to
2699   0F9C CD 4A 10                CALL I2C_Open       ;Open for write
2700   0F9F 28 0A                   JR   Z,I2C_MemWrReady       ;If open okay then skip on
2701   0FA1 0B                      DEC  BC
2702   0FA2 78                      LD   A,B
2703   0FA3 B1                      OR   C              ;Timeout?
2704   0FA4 20 F4                   JR   NZ,I2C_MemWrRepeat     ;No, so go try again
2705   0FA6 C1                      POP  BC
2706   0FA7 3E 03                   LD   A,ERR_TOUT     ;Error code
2707   0FA9 B7                      OR   A              ;Error, so NZ flagged
2708   0FAA C9                      RET                 ;Return with error
2709   0FAB             ; Device opened okay
2710   0FAB C1          I2C_MemWrReady:     POP  BC             ;Restore byte counter
2711   0FAC 7A          I2C_MemWrBlock:     LD   A,D            ;Address (hi) in I2C memory
2712   0FAD CD 54 10                CALL I2C_Write      ;Write address
2713   0FB0 7B                      LD   A,E            ;Address (lo) in I2C memory
2714   0FB1 CD 54 10                CALL I2C_Write      ;Write address
2715   0FB4 7E          I2C_MemWrWrite:     LD   A,(HL)         ;Get data byte from CPU memory
2716   0FB5 CD 54 10                CALL I2C_Write      ;Read byte from I2C memory
2717   0FB8 23                      INC  HL             ;Increment CPU memory pointer
2718   0FB9 13                      INC  DE             ;Increment I2C memory pointer
2719   0FBA 0B                      DEC  BC             ;Decrement byte counter
2720   0FBB 78                      LD   A,B
2721   0FBC B1                      OR   C              ;Finished?
2722   0FBD 28 05                   JR   Z,I2C_MemWrStore       ;Yes, so go store this page
2723   0FBF 7B                      LD   A,E            ;Get address in I2C memory (lo byte)
2724   0FC0 E6 3F                   AND  63             ;64 byte page boundary?
2725   0FC2 20 F0                   JR   NZ,I2C_MemWrWrite      ;No, so go write another byte
2726   0FC4 CD C9 10    I2C_MemWrStore:     CALL I2C_Stop       ;Generate I2C stop
2727   0FC7 78                      LD   A,B
2728   0FC8 B1                      OR   C              ;Finished?
2729   0FC9 20 CB                   JR   NZ,I2C_MemWr   ;No, so go write some more
2730   0FCB C9                      RET   
2731   0FCC             
2732   0FCC             
2733   0FCC             
2734   0FCC             
2735   0FCC             
2736   0FCC             
2737   0FCC             
2738   0FCC             
2739   0FCC             
2740   0FCC             
2741   0FCC             ; Display test result
2742   0FCC             ;   On entry: DE = Address of null terminated string
2743   0FCC             ;             H = First value ($H)
2744   0FCC             ;             L = Second value ($L)
2745   0FCC             ;   On exit:  HL IX IY preserved
2746   0FCC             Result:     
2747   0FCC C3 21 10                JP   String         ;Output result string to console
2748   0FCF             
2749   0FCF             
2750   0FCF             ; Character output to console
2751   0FCF             ;   On entry: A = Character to be output
2752   0FCF             ;   On exit:  BC DE HL IX IY preserved
2753   0FCF C3 E7 0F    CharOut:    JP   API_Cout
2754   0FD2             
2755   0FD2             ; New line output to console
2756   0FD2             ;   On entry: No parameters required
2757   0FD2             ;   On exit:  BC DE HL IX IY preserved
2758   0FD2 C3 F1 0F    LineOut:    JP   API_Lout
2759   0FD5             
2760   0FD5             ; Space character ouput to console
2761   0FD5             ;   On entry: No parameters required
2762   0FD5             ;   On exit:  BC DE HL IX IY preserved
2763   0FD5 3E 20       SpaceOut:   LD   A,$20
2764   0FD7 C3 E7 0F                JP   API_Cout
2765   0FDA             
2766   0FDA             ; String output to console
2767   0FDA             ;   On entry: DE = Address of string
2768   0FDA             ;   On exit:  BC DE HL IX IY preserved
2769   0FDA C3 FD 0F    StrOut:     JP   API_Sout
2770   0FDD             
2771   0FDD             
2772   0FDD             ; Delay by DE milliseconds (approx)
2773   0FDD             ;   On entry: DE = Delay time in milliseconds
2774   0FDD             ;   On exit:  BC DE HL IX IY preserved
2775   0FDD C5          API_Delay:  PUSH BC             ;Preserve registers
2776   0FDE D5                      PUSH DE
2777   0FDF E5                      PUSH HL
2778   0FE0 CD 64 0D                CALL delay
2779   0FE3 E1                      POP  HL             ;Restore registers
2780   0FE4 D1                      POP  DE
2781   0FE5 C1                      POP  BC
2782   0FE6 C9                      RET
2783   0FE7             
2784   0FE7             
2785   0FE7             ; Character output to console device
2786   0FE7             ;   On entry: A = Character to be output
2787   0FE7             ;   On exit:  BC DE HL IX IY preserved
2788   0FE7 C5          API_Cout:   PUSH BC             ;Preserve registers
2789   0FE8 D5                      PUSH DE
2790   0FE9 E5                      PUSH HL
2791   0FEA CD 08 00                CALL $0008
2792   0FED E1                      POP  HL             ;Restore registers
2793   0FEE D1                      POP  DE
2794   0FEF C1                      POP  BC
2795   0FF0 C9                      RET
2796   0FF1             
2797   0FF1             
2798   0FF1             ; New line output to console device
2799   0FF1             ;   On entry: No parameters required
2800   0FF1             ;   On exit:  BC DE HL IX IY preserved
2801   0FF1 C5          API_Lout:   PUSH BC             ;Preserve registers
2802   0FF2 D5                      PUSH DE
2803   0FF3 E5                      PUSH HL
2804   0FF4 3E 0D                   LD A, CR ; enter char
2805   0FF6 CD 08 00                CALL $0008
2806   0FF9 E1                      POP  HL             ;Restore registers
2807   0FFA D1                      POP  DE
2808   0FFB C1                      POP  BC
2809   0FFC C9                      RET
2810   0FFD             
2811   0FFD             
2812   0FFD             ; String output to console device
2813   0FFD             ;   On entry: DE = Address of string
2814   0FFD             ;   On exit:  BC DE HL IX IY preserved
2815   0FFD C5          API_Sout:   PUSH BC             ;Preserve registers
2816   0FFE D5                      PUSH DE
2817   0FFF E5                      PUSH HL
2818   1000 62                      LD H, D
2819   1001 6B                      LD L, E
2820   1002 CD 8F 0E                CALL SNDLCDMSG
2821   1005 E1                      POP  HL             ;Restore registers
2822   1006 D1                      POP  DE
2823   1007 C1                      POP  BC
2824   1008 C9                      RET
2825   1009             
2826   1009             
2827   1009             ; Hex byte output to console
2828   1009             ;   On entry: A = Byte to be output in hex
2829   1009             ;   On exit:  BC DE HL IX IY preserved
2830   1009 F5          HexOut:     PUSH AF             ;Preserve byte to be output
2831   100A 1F                      RRA                 ;Shift top nibble to
2832   100B 1F                      RRA                 ;  botom four bits..
2833   100C 1F                      RRA
2834   100D 1F                      RRA
2835   100E E6 0F                   AND  $0F           ;Mask off unwanted bits
2836   1010 CD 16 10                CALL HexOutHex           ;Output hi nibble
2837   1013 F1                      POP  AF             ;Restore byte to be output
2838   1014 E6 0F                   AND  $0F           ;Mask off unwanted bits
2839   1016             ; Output nibble as ascii character
2840   1016 FE 0A       HexOutHex:       CP   $0A           ;Nibble > 10 ?
2841   1018 38 02                   JR   C,HexOutSkip        ;No, so skip
2842   101A C6 07                   ADD  A,7            ;Yes, so add 7
2843   101C C6 30       HexOutSkip:      ADD  A,$30         ;Add ASCII '0'
2844   101E C3 E7 0F                JP   API_Cout       ;Write character
2845   1021             
2846   1021             
2847   1021             ; Output string at DE with substitutions
2848   1021             ;   On entry: A = Address of device on I2C bus (write address)
2849   1021             ;             DE = Address of null terminated string
2850   1021             ;             H = Value to substitute for $H
2851   1021             ;             L = Value to substitute for $L
2852   1021             ;             B = Value to substitute for $B
2853   1021             ;   On exit:  DE = Address of next location after this string
2854   1021             ;             IX IY preserved
2855   1021 1A          String:     LD   A,(DE)         ;Get character from string
2856   1022 13                      INC  DE             ;Point to next character in string
2857   1023 B7                      OR   A              ;Null ?
2858   1024 C8                      RET  Z              ;Yes, so we're done
2859   1025 FE 24                   CP   '$'            ;Substitue value?
2860   1027 28 05                   JR   Z,StringSubst       ;Yes, so go handle substitution
2861   1029 CD CF 0F                CALL CharOut        ;Output character to console
2862   102C 18 F3                   JR   String         ;Go get next character from string
2863   102E 1A          StringSubst:     LD   A,(DE)         ;Get character from string
2864   102F 13                      INC  DE             ;Point to next character in string
2865   1030 B7                      OR   A              ;Null ?
2866   1031 C8                      RET  Z              ;Yes, so we're done
2867   1032 FE 48                   CP   'H'            ;Register H
2868   1034 20 03                   JR   NZ,StringNotH       ;No, so skip
2869   1036 7C                      LD   A,H            ;Get value 'H'
2870   1037 18 0C                   JR   StringGotIt         ;Go output it in hex
2871   1039 FE 4C       StringNotH:      CP   'L'            ;Register L
2872   103B 20 03                   JR   NZ,StringNotL       ;No, so skip
2873   103D 7D                      LD   A,L            ;Get value 'L'
2874   103E 18 05                   JR   StringGotIt         ;Go output it in hex
2875   1040 FE 42       StringNotL:      CP   'B'            ;Register B
2876   1042 20 04                   JR   NZ,StringNotB       ;No, so skip
2877   1044 78                      LD   A,B            ;Get value 'L'
2878   1045                         ;JR   @GotIt        ;Go output it in hex
2879   1045 CD 09 10    StringGotIt:     CALL HexOut         ;Output write address in hex
2880   1048 18 D7       StringNotB:      JR   String         ;Go get next character from string
2881   104A             
2882   104A             
2883   104A             ; **********************************************************************
2884   104A             ; I2C support functions
2885   104A             
2886   104A             ; I2C bus open device
2887   104A             ;   On entry: A = Device address (bit zero is read flag)
2888   104A             ;             SCL = unknown, SDA = unknown
2889   104A             ;   On exit:  If successfully A = 0 and Z flagged
2890   104A             ;             If unsuccessfully A = Error and NZ flagged
2891   104A             ;             BC DE HL IX IY preserved
2892   104A F5          I2C_Open:   PUSH AF
2893   104B CD BE 10                CALL I2C_Start      ;Output start condition
2894   104E F1                      POP  AF
2895   104F 18 03                   JR   I2C_Write      ;Write data byte
2896   1051             
2897   1051             
2898   1051             ; I2C bus close device
2899   1051             ;   On entry: SCL = unknown, SDA = unknown
2900   1051             ;   On exit:  If successfully A=0 and Z flagged
2901   1051             ;             If unsuccessfully A=Error and NZ flagged
2902   1051             ;             SCL = hi, SDA = hi
2903   1051             ;             BC DE HL IX IY preserved
2904   1051 C3 C9 10    I2C_Close:  JP   I2C_Stop       ;Output stop condition
2905   1054             
2906   1054             
2907   1054             ; **********************************************************************
2908   1054             ; **********************************************************************
2909   1054             ; I2C bus master driver
2910   1054             ; **********************************************************************
2911   1054             ; **********************************************************************
2912   1054             
2913   1054             ; Functions provided are:
2914   1054             ;     I2C_Start
2915   1054             ;     I2C_Stop
2916   1054             ;     I2C_Read
2917   1054             ;     I2C_Write
2918   1054             ;
2919   1054             ; This code has delays between all I/O operations to ensure it works
2920   1054             ; with the slowest I2C devices
2921   1054             ;
2922   1054             ; I2C transfer sequence
2923   1054             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2924   1054             ;   | Start |  | Address |  | Data    | ... | Data    |  | Stop  |
2925   1054             ;   |       |  | frame   |  | frame 1 |     | frame N |  |       |
2926   1054             ;   +-------+  +---------+  +---------+     +---------+  +-------+
2927   1054             ;
2928   1054             ;
2929   1054             ; Start condition                     Stop condition
2930   1054             ; Output by master device             Output by master device
2931   1054             ;       ----+                                      +----
2932   1054             ; SDA       |                         SDA          |
2933   1054             ;           +-------                        -------+
2934   1054             ;       -------+                                +-------
2935   1054             ; SCL          |                      SCL       |
2936   1054             ;              +----                        ----+
2937   1054             ;
2938   1054             ;
2939   1054             ; Address frame
2940   1054             ; Clock and data output from master device
2941   1054             ; Receiving device outputs acknowledge 
2942   1054             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2943   1054             ; SDA    | A 7 | A 6 | A 5 | A 4 | A 3 | A 2 | A 1 | R/W | ACK |   |
2944   1054             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2945   1054             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2946   1054             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2947   1054             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2948   1054             ;
2949   1054             ;
2950   1054             ; Data frame 
2951   1054             ; Clock output by master device
2952   1054             ; Data output by transmitting device
2953   1054             ; Receiving device outputs acknowledge 
2954   1054             ;        +-----+-----+-----+-----+-----+-----+-----+-----+     +---+
2955   1054             ; SDA    | D 7 | D 6 | D 5 | D 4 | D 3 | D 2 | D 1 | D 0 | ACK |   |
2956   1054             ;     ---+-----+-----+-----+-----+-----+-----+-----+-----+-----+   +---
2957   1054             ;          +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+   +-+
2958   1054             ; SCL      | |   | |   | |   | |   | |   | |   | |   | |   | |
2959   1054             ;     -----+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---------
2960   1054             ;
2961   1054             
2962   1054             
2963   1054             ; **********************************************************************
2964   1054             ; I2C constants
2965   1054             
2966   1054             
2967   1054             ; I2C bus master interface
2968   1054             ; The default device option is for SC126 or compatible
2969   1054             
2970   1054             I2C_PORT:   .EQU $21           ;Host I2C port address
2971   1054             I2C_SDA_WR: .EQU 7              ;Host I2C write SDA bit number
2972   1054             I2C_SDA_RD: .EQU 7              ;Host I2C read SDA bit number
2973   1054             I2C_SCL_WR: .EQU 0              ;Host I2C write SCL bit number
2974   1054             I2C_SCL_RD: .EQU 0              ;Host I2C read SCL bit number 
2975   1054             I2C_QUIES:  .EQU 0b10000001     ;Host I2C output port quiescent value
2976   1054             
2977   1054             
2978   1054             ; I2C support constants
2979   1054             ERR_NONE:   .EQU 0              ;Error = None
2980   1054             ERR_JAM:    .EQU 1              ;Error = Bus jammed [not used]
2981   1054             ERR_NOACK:  .EQU 2              ;Error = No ackonowledge
2982   1054             ERR_TOUT:   .EQU 3              ;Error = Timeout
2983   1054             
2984   1054             
2985   1054             ; **********************************************************************
2986   1054             ; Hardware dependent I2C bus functions
2987   1054             
2988   1054             
2989   1054             ; I2C bus transmit frame (address or data)
2990   1054             ;   On entry: A = Data byte, or
2991   1054             ;                 Address byte (bit zero is read flag)
2992   1054             ;             SCL = low, SDA = low
2993   1054             ;   On exit:  If successful A=0 and Z flagged
2994   1054             ;                SCL = lo, SDA = lo
2995   1054             ;             If unsuccessful A=Error and NZ flagged
2996   1054             ;                SCL = high, SDA = high, I2C closed
2997   1054             ;             BC DE HL IX IY preserved
2998   1054 C5          I2C_Write:  PUSH BC             ;Preserve registers
2999   1055 D5                      PUSH DE
3000   1056 57                      LD   D,A            ;Store byte to be written
3001   1057 06 08                   LD   B,8            ;8 data bits, bit 7 first
3002   1059 CB 12       I2C_WriteWr_Loop:   RL   D              ;Test M.S.Bit
3003   105B 38 05                   JR   C,I2C_WriteBit_Hi      ;High, so skip
3004   105D CD F0 10                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = data bit)
3005   1060 18 03                   JR   I2C_WriteBit_Clk
3006   1062 CD E9 10    I2C_WriteBit_Hi:    CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA = data bit)
3007   1065 CD DB 10    I2C_WriteBit_Clk:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = data bit)
3008   1068 CD E2 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = data bit)
3009   106B 10 EC                   DJNZ I2C_WriteWr_Loop
3010   106D             ; Test for acknowledge from slave (receiver)
3011   106D             ; On arriving here, SCL = lo, SDA = data bit
3012   106D CD E9 10                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/ack)
3013   1070 CD DB 10                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/ack)
3014   1073 CD 01 11                CALL I2C_RdPort     ;Read SDA input
3015   1076 47                      LD   B,A
3016   1077 CD E2 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA = hi)
3017   107A CB 78                   BIT  I2C_SDA_RD,B
3018   107C 20 04                   JR   NZ,I2C_WriteNoAck      ;Skip if no acknowledge
3019   107E D1                      POP  DE             ;Restore registers
3020   107F C1                      POP  BC
3021   1080 AF                      XOR  A              ;Return success A=0 and Z flagged
3022   1081 C9                      RET
3023   1082             ; I2C STOP required as no acknowledge
3024   1082             ; On arriving here, SCL = lo, SDA = hi
3025   1082 CD F0 10    I2C_WriteNoAck:     CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA = lo)
3026   1085 CD DB 10                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA = lo)
3027   1088 CD E9 10                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA = hi)
3028   108B D1                      POP  DE             ;Restore registers
3029   108C C1                      POP  BC
3030   108D 3E 02                   LD   A,ERR_NOACK    ;Return error = No Acknowledge
3031   108F B7                      OR   A              ;  and NZ flagged
3032   1090 C9                      RET
3033   1091             
3034   1091             
3035   1091             ; I2C bus receive frame (data)
3036   1091             ;   On entry: A = Acknowledge flag
3037   1091             ;               If A != 0 the read is acknowledged
3038   1091             ;             SCL low, SDA low
3039   1091             ;   On exit:  If successful A = data byte and Z flagged
3040   1091             ;               SCL = low, SDA = low
3041   1091             ;             If unsuccessul* A = Error and NZ flagged
3042   1091             ;               SCL = low, SDA = low
3043   1091             ;             BC DE HL IX IY preserved
3044   1091             ; *This function always returns successful
3045   1091 C5          I2C_Read:   PUSH BC             ;Preserve registers
3046   1092 D5                      PUSH DE
3047   1093 5F                      LD   E,A            ;Store acknowledge flag
3048   1094 06 08                   LD   B,8            ;8 data bits, 7 first
3049   1096 CD E9 10                CALL I2C_SDA_HI     ;SDA high  (SCL lo, SDA hi/input)
3050   1099 CD DB 10    I2C_ReadRd_Loop:   CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA hi/input)
3051   109C CD 01 11                CALL I2C_RdPort     ;Read SDA input bit
3052   109F 37                      SCF                 ;Set carry flag
3053   10A0 CB 7F                   BIT  I2C_SDA_RD,A   ;SDA input high?
3054   10A2 20 01                   JR   NZ, I2C_ReadRotate     ;Yes, skip with carry flag set
3055   10A4 3F                      CCF                 ;Clear carry flag
3056   10A5 CB 12       I2C_ReadRotate:    RL   D              ;Rotate result into D
3057   10A7 CD E2 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA hi/input)
3058   10AA 10 ED                   DJNZ  I2C_ReadRd_Loop       ;Repeat for all 8 bits
3059   10AC             ; Acknowledge input byte
3060   10AC             ; On arriving here, SCL = lo, SDA = hi/input
3061   10AC 7B                      LD   A,E            ;Get acknowledge flag
3062   10AD B7                      OR   A              ;A = 0? (indicates no acknowledge)
3063   10AE 28 03                   JR   Z, I2C_ReadNoAck       ;Yes, so skip acknowledge
3064   10B0 CD F0 10                CALL I2C_SDA_LO     ;SDA low   (SCL lo, SDA lo)
3065   10B3 CD DB 10    I2C_ReadNoAck:     CALL I2C_SCL_HI     ;SCL hi    (SCL hi, SDA lo)
3066   10B6 CD E2 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
3067   10B9 7A                      LD   A,D            ;Get data byte received
3068   10BA D1                      POP  DE             ;Restore registers
3069   10BB C1                      POP  BC
3070   10BC BF                      CP   A              ;Return success Z flagged
3071   10BD C9                      RET
3072   10BE             
3073   10BE             
3074   10BE             ; I2C bus start
3075   10BE             ;   On entry: SCL = unknown, SDA = unknown
3076   10BE             ;   On exit:  SCL = low, SDA = low
3077   10BE             ;             A = 0 and Z flagged as we always succeed
3078   10BE             ;             BC DE HL IX IY preserved
3079   10BE             ; First ensure SDA and SCL are high
3080   10BE CD D7 10    I2C_Start:  CALL I2C_INIT       ;Initialise I2C control port
3081   10C1             ;           CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA ??)
3082   10C1             ;           CALL I2C_SDA_HI     ;SDA high  (SCL hi, SDA hi)
3083   10C1             ; Generate I2C start condition
3084   10C1 CD F0 10                CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
3085   10C4 CD E2 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
3086   10C7 AF                      XOR  A              ;Return success A=0 and Z flagged
3087   10C8 C9                      RET
3088   10C9             
3089   10C9             
3090   10C9             ; I2C bus stop 
3091   10C9             ;   On entry: SCL = unknown, SDA = unknown
3092   10C9             ;   On exit:  SCL = high, SDA = high
3093   10C9             ;             A = 0 and Z flagged as we always succeed
3094   10C9             ;             BC DE HL IX IY preserved
3095   10C9             ; First ensure SDA and SCL are low
3096   10C9 CD F0 10    I2C_Stop:   CALL I2C_SDA_LO     ;SDA low   (SCL hi, SDA lo)
3097   10CC CD E2 10                CALL I2C_SCL_LO     ;SCL low   (SCL lo, SDA lo)
3098   10CF             ; Generate stop condition
3099   10CF CD DB 10                CALL I2C_SCL_HI     ;SCL high  (SCL hi, SDA lo)
3100   10D2 CD E9 10                CALL I2C_SDA_HI     ;SDA low   (SCL hi, SDA hi)
3101   10D5 AF                      XOR  A              ;Return success A=0 and Z flagged
3102   10D6 C9                      RET
3103   10D7             
3104   10D7             
3105   10D7             ; **********************************************************************
3106   10D7             ; I2C bus simple I/O functions
3107   10D7             ;   On entry: No parameters required
3108   10D7             ;   On exit:  BC DE HL IX IY preserved
3109   10D7             
3110   10D7 3E 81       I2C_INIT:   LD   A,I2C_QUIES    ;I2C control port quiescent value
3111   10D9 18 1A                   JR   I2C_WrPort
3112   10DB             
3113   10DB 3A 00 D0    I2C_SCL_HI: LD   A,(I2C_RAMCPY)
3114   10DE CB C7                   SET  I2C_SCL_WR,A
3115   10E0 18 13                   JR   I2C_WrPort
3116   10E2             
3117   10E2 3A 00 D0    I2C_SCL_LO: LD   A,(I2C_RAMCPY)
3118   10E5 CB 87                   RES  I2C_SCL_WR,A
3119   10E7 18 0C                   JR   I2C_WrPort
3120   10E9             
3121   10E9 3A 00 D0    I2C_SDA_HI: LD   A,(I2C_RAMCPY)
3122   10EC CB FF                   SET  I2C_SDA_WR,A
3123   10EE 18 05                   JR   I2C_WrPort
3124   10F0             
3125   10F0 3A 00 D0    I2C_SDA_LO: LD   A,(I2C_RAMCPY)
3126   10F3 CB BF                   RES  I2C_SDA_WR,A
3127   10F5                         ;JR   I2C_WrPort
3128   10F5             
3129   10F5 C5          I2C_WrPort: PUSH BC             ;Preserve registers
3130   10F6 06 00                   LD   B,0            ;Set up BC for 16-bit
3131   10F8 0E 21                   LD   C,I2C_PORT     ;  I/O address of I2C port
3132   10FA ED 79                   OUT  (C),A          ;Write A to I2C I/O port
3133   10FC 32 00 D0                LD   (I2C_RAMCPY),A ;Write A to RAM copy
3134   10FF C1                      POP  BC             ;Restore registers
3135   1100 C9                      RET
3136   1101             
3137   1101 C5          I2C_RdPort: PUSH BC             ;Preserve registers
3138   1102 06 00                   LD   B,0            ;Set up BC for 16-bit
3139   1104 0E 21                   LD   C,I2C_PORT     ;  I/O address of I2C port
3140   1106 ED 78                   IN   A,(C)          ;Read A from I/O port
3141   1108 C1                      POP  BC             ;Restore registers
3142   1109 C9                      RET
3143   110A             
3144   110A             
3145   110A             
3146   110A 0C0D0D0A5A38WELLCOME: .db CS, CR, CR, LF,"Z80 Mini Iniciado", CR, LF, 00H
3146   1110 30204D696E6920496E69636961646F0D0A00
3147   1122 5A3830204D49MSG_MONITOR .db "Z80 MINI, H TO HELP",CR, 00H
3147   1128 4E492C204820544F2048454C500D00
3148   1137             
3149   1137 46312052554EMSG_MENU0  .db "F1 RUN (JP $8000)",CR, 00H
3149   113D 20284A50202438303030290D00
3150   114A 463220496E74MSG_MENU1  .db "F2 Intel hex loader",CR, 00H
3150   1150 656C20686578206C6F616465720D00
3151   115F 42202D204261MSG_MENU2  .db "B - Basic",CR, 00H
3151   1165 7369630D00
3152   116A 442041414141MSG_MENU3  .db "D AAAA - DISPLAY",CR,00H
3152   1170 202D20444953504C41590D00
3153   117C 4D2041414141MSG_MENU4  .db "M AAAA - MODIFY",CR,00H
3153   1182 202D204D4F444946590D00
3154   118D 472041414141MSG_MENU5  .db "G AAAA - GO TO",CR, 00H
3154   1193 202D20474F20544F0D00
3155   119D 4F204F757420MSG_MENU6  .db "O Out AA DD",CR, 00H
3155   11A3 41412044440D00
3156   11AA 4920496E2041MSG_MENU7  .db "I In AA",CR, 00H
3156   11B0 410D00
3157   11B3 312049324320MSG_MENU8  .db "1 I2C Scan",CR, 00H
3157   11B9 5363616E0D00
3158   11BF 322049324320MSG_MENU9  .db "2 I2C PC -> MEM",CR, 00H
3158   11C5 5043202D3E204D454D0D00
3159   11D0 332049324320MSG_MENU10 .db "3 I2C MEM -> PC",CR, 00H
3159   11D6 4D454D202D3E2050430D00
3160   11E1 342049324320MSG_MENU11 .db "4 I2C WRITE DD",CR, 00H
3160   11E7 57524954452044440D00
3161   11F1 352049324320MSG_MENU12 .db "5 I2C WRITE RR DD",CR, 00H
3161   11F7 57524954452052522044440D00
3162   1204 362049324320MSG_MENU13 .db "6 I2C READ ONE BYTE",CR, 00H
3162   120A 52454144204F4E4520425954450D00
3163   1219 372049324320MSG_MENU14 .db "7 I2C READ RR BYTE", 00H ; ultimo não tem CR (nova linha)
3163   121F 52454144205252204259544500
3164   122C             
3165   122C             
3166   122C             
3167   122C 0C4932432064LISTMsg:    .DB  CS,"I2C device found at:",CR,0
3167   1232 657669636520666F756E642061743A0D00
3168   1243 0C434F505920MSG_MEM2CPU .db CS,"COPY I2C MEM TO CPU",CR, 00H
3168   1249 493243204D454D20544F204350550D00
3169   1259 0C434F505920MSG_CPU2MEM .db CS,"COPY CPU TO I2C MEM",CR, 00H
3169   125F 43505520544F20493243204D454D0D00
3170   126F             
3171   126F 0C5752495445MSG_I2C_WR_DD    .db CS,"WRITE ONE BYTE",CR, 00H
3171   1275 204F4E4520425954450D00
3172   1280 0C5752495445MSG_I2C_WR_RR_DD .db CS,"WRITE REG ONE BYTE",CR, 00H
3172   1286 20524547204F4E4520425954450D00
3173   1295 0C5245414420MSG_I2C_RD       .db CS,"READ ONE BYTE",CR, 00H
3173   129B 4F4E4520425954450D00
3174   12A5 0C5245414420MSG_I2C_RD_RR    .db CS,"READ REG ONE BYTE",CR, 00H
3174   12AB 524547204F4E4520425954450D00
3175   12B9             
3176   12B9 46524F4D3A20MSG_FROM    .db "FROM: ", 00H
3176   12BF 00
3177   12C0 0D544F3A2000MSG_TO      .db CR,"TO: ", 00H
3178   12C6 0D53495A4528MSG_SIZE    .db CR,"SIZE(BYTES): ", 00H
3178   12CC 4259544553293A2000
3179   12D5 0D434F505920MSG_COPYOK  .db CR,"COPY OK", 00H
3179   12DB 4F4B00
3180   12DE 0D434F505920MSG_COPYFAIL  .db CR,"COPY FAIL", 00H
3180   12E4 4641494C00
3181   12E9             
3182   12E9 0D4445564943MSG_DEV_ADDR  .db CR,"DEVICE ADDR(AA): ", 00H
3182   12EF 452041444452284141293A2000
3183   12FC 0D5245474953MSG_DEV_REG   .db CR,"REGISTER(RR): ", 00H
3183   1302 544552285252293A2000
3184   130C 0D4441544128MSG_DEV_DATA  .db CR,"DATA(DD): ", 00H
3184   1312 4444293A2000
3185   1318             
3186   1318             
3187   1318 0C496E74656CMSG_ILOAD .db $0C, "Intel HEX loader...", CR, 00H
3187   131E 20484558206C6F616465722E2E2E0D00
3188   132E 46494C452052FILEOK    .DB      "FILE RECEIVED OK",CR,00H
3188   1334 45434549564544204F4B0D00
3189   1340 434845434B53CSUMERR   .DB    "CHECKSUM ERROR",CR,00H
3189   1346 554D204552524F520D00
3190   1350             
3191   1350             
3192   1350             
3193   1350             ; **********************************************************************
3194   1350             ; I2C workspace / variables in RAM
3195   1350             
3196   D000                         .ORG  I2CDATA
3197   D000             
3198   D000 00          I2C_RAMCPY: .DB  0              ;RAM copy of output port
3199   D001             
3200   D001 00          RESULTS:    .DB  0              ;Large block of results can start here
3201   D002             
3202   D002             .end
tasm: Number of errors = 0
